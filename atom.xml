<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>杨宝强的技术笔记</title>
  
  <subtitle>Gopher Watcher</subtitle>
  <link href="https://bqyang.top/atom.xml" rel="self"/>
  
  <link href="https://bqyang.top/"/>
  <updated>2022-07-11T10:41:29.671Z</updated>
  <id>https://bqyang.top/</id>
  
  <author>
    <name>bqyang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>组合模式</title>
    <link href="https://bqyang.top/2022/design-pattern/Structural/composite/"/>
    <id>https://bqyang.top/2022/design-pattern/Structural/composite/</id>
    <published>2022-07-10T16:00:00.000Z</published>
    <updated>2022-07-11T10:41:29.671Z</updated>
    
    <content type="html"><![CDATA[<p>设计模式的学习逐渐变成了一周一次，一次一周。不求一天之内学多少，重要的是真正了解到模式适用的场景，一味的图快，可能有点狗熊掰棒子那味了。那这周的主要内容是<strong>组合模式</strong>。</p><span id="more"></span><h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><p>主要思想：<strong>整体与部分可以被一致对待</strong></p><p>组合模式（Composite），将对象组合成树形结构以表示‘部分-整体’的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。</p><h3 id="透明方式-与-安全方式"><a href="#透明方式-与-安全方式" class="headerlink" title="透明方式 与 安全方式"></a>透明方式 与 安全方式</h3><p><strong>透明方式</strong></p><p><strong>安全方式</strong></p><h3 id="何时使用？"><a href="#何时使用？" class="headerlink" title="何时使用？"></a>何时使用？</h3><p>需求中是体现<strong>部分与整体</strong>层次的结构时，以及希望用户可以忽略组合对象与单个对象的不同，统一地使用组合结构中的所有对象时，就应该考虑用组合模式。形如总部与分部，文件与文件夹这种形式。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3>]]></content>
    
    
    <summary type="html">&lt;p&gt;设计模式的学习逐渐变成了一周一次，一次一周。不求一天之内学多少，重要的是真正了解到模式适用的场景，一味的图快，可能有点狗熊掰棒子那味了。那这周的主要内容是&lt;strong&gt;组合模式&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>简易版 pstree</title>
    <link href="https://bqyang.top/2022/os/pstree/"/>
    <id>https://bqyang.top/2022/os/pstree/</id>
    <published>2022-07-10T12:26:34.198Z</published>
    <updated>2022-07-11T03:57:27.625Z</updated>
    
    <content type="html"><![CDATA[<p>最近在学习 C 语言的相关知识，想通过 C 语言实现一个简易版的 <code>pstree</code> 命令行工具，我认为对 C 新手来说还是有一定难度的，最后只通过 C 实现了一半功能，但是实践的过程让我印象深刻。现代程序员使用着便捷的开发工具，输入几个首字母就能打印出自己想调用的库函数。</p><span id="more"></span><p>我想几十年前的编程，是不是还挺麻烦的，或许跟我使用的环境有关，我在虚机上使用 VIM 写的，没有快捷键，更没有代码自动补全。 想知道一个库函数怎么用、怎么传参都需要通过手册查询，在某些程度上，这个过程也锻炼了自己查阅资料的能力。</p><p>一般，我是通过 <code>tmux</code> 开两个 session，一个用来敲代码，另一个查手册。最后卡在 C 上的原因是：</p><p>N 叉树实现问题，不知道怎么初始化结构体，又不想把每个节点中的子节点数量写死，所以就通过 Go 实现了后半部分。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 子节点硬编码</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> Id;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">Child</span>[10];</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这种在通过 malloc 初始化的时候，存在问题</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> Id;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">Child</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还没有看学到 C struct 中的内容（大学学的早就还给老师了），待我学成归来，一定把这块好好补上。</p><p>另一个在 C 中比较难的是，不知道怎么处理字符串，不知道哪些库函数可以做我想做的事。就比如拆分字符串，如果说每次通过 split 拆分一个太复杂了，它有个 strtok 更方便..不过这些问题还好，是自己对语言的不熟悉。</p><p>实现 <code>pstree</code> 过程中花了较多时间的点：</p><ul><li>如何找到进程的相关信息，父进程ID，当前进程的名称</li><li>如何过滤非进程目录</li><li>如何存储父进程及其子进程</li><li>如何以缩进的方式输出</li></ul><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sort&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;path/filepath&quot;</span></span><br><span class="line">    <span class="string">&quot;strconv&quot;</span></span><br><span class="line">    <span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// init root node</span></span><br><span class="line"><span class="keyword">var</span> Root = &amp;Node&#123;Id: <span class="number">1</span>, Child: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">uint</span>]*Node)&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123;</span><br><span class="line">    Id    <span class="keyword">uint</span></span><br><span class="line">    Name  <span class="keyword">string</span></span><br><span class="line">    Child <span class="keyword">map</span>[<span class="keyword">uint</span>]*Node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n Node)</span> <span class="title">GetName</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> n.Name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *Node)</span> <span class="title">InsertChild</span><span class="params">(id <span class="keyword">uint</span>, childName <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n.Child == <span class="literal">nil</span> &#123;</span><br><span class="line">        n.Child = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">uint</span>]*Node)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    n.Child[id] = &amp;Node&#123;</span><br><span class="line">        Id:    id,</span><br><span class="line">        Name:  childName,</span><br><span class="line">        Child: <span class="literal">nil</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pre-traverse</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TraverseTree</span><span class="params">(root *Node, indent <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%s%d-%s\n&quot;</span>, strings.Repeat(<span class="string">&quot; &quot;</span>, indent), root.Id, root.GetName())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> root.Child == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, child := <span class="keyword">range</span> root.Child &#123;</span><br><span class="line">        TraverseTree(child, indent+<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FindParent</span><span class="params">(parentId <span class="keyword">uint</span>, root *Node)</span> *<span class="title">Node</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> parentId == <span class="number">0</span> || parentId == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Root</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the last node</span></span><br><span class="line">    <span class="keyword">if</span> root.Child == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> parent, ok := root.Child[parentId]; ok &amp;&amp; parent.Id == parentId &#123;</span><br><span class="line">        <span class="keyword">return</span> parent</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, node := <span class="keyword">range</span> root.Child &#123;</span><br><span class="line">        <span class="keyword">if</span> parent := FindParent(parentId, node); parent != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> parent</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetProcs</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fps, err := filepath.Glob(<span class="string">&quot;/proc/[0-9]*&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalln(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort.Slice(fps, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">        one := strings.TrimPrefix(fps[i], <span class="string">&quot;/proc/&quot;</span>)</span><br><span class="line">        two := strings.TrimPrefix(fps[j], <span class="string">&quot;/proc/&quot;</span>)</span><br><span class="line"></span><br><span class="line">        num1, _ := strconv.Atoi(one)</span><br><span class="line">        num2, _ := strconv.Atoi(two)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> num1 &lt; num2 &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, procFile := <span class="keyword">range</span> fps &#123;</span><br><span class="line">        stat, err := os.ReadFile(filepath.Join(procFile, <span class="string">&quot;/stat&quot;</span>))</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Println(err)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pid, parentId, processName := GetInfoFromStat(<span class="keyword">string</span>(stat))</span><br><span class="line">        <span class="keyword">if</span> pid == <span class="number">1</span> &#123;</span><br><span class="line">            Root.Name = processName</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// after find parent, insert to proc tree</span></span><br><span class="line">        <span class="comment">// because the proc dir order by pid</span></span><br><span class="line">        <span class="comment">// so parent always insert to tree before child</span></span><br><span class="line">        parentNode := FindParent(parentId, Root)</span><br><span class="line">        <span class="keyword">if</span> parentNode == <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Fatalln(<span class="string">&quot;parent doesn&#x27;t in tree&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        parentNode.InsertChild(pid, processName)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetInfoFromStat</span><span class="params">(stat <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">uint</span>, <span class="keyword">uint</span>, <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        procName <span class="keyword">string</span></span><br><span class="line">        pid      <span class="keyword">int</span></span><br><span class="line">        ppid     <span class="keyword">int</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    tokens := strings.FieldsFunc(stat, <span class="function"><span class="keyword">func</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">        <span class="keyword">return</span> r == <span class="string">&#x27;(&#x27;</span> || r == <span class="string">&#x27;)&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(tokens) != <span class="number">3</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    procName = tokens[<span class="number">1</span>]</span><br><span class="line">    pid, _ = strconv.Atoi(strings.TrimSuffix(tokens[<span class="number">0</span>], <span class="string">&quot; &quot;</span>))</span><br><span class="line">    ppid, _ = strconv.Atoi(strings.Split(strings.TrimPrefix(tokens[<span class="number">2</span>], <span class="string">&quot; &quot;</span>), <span class="string">&quot; &quot;</span>)[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">uint</span>(pid), <span class="keyword">uint</span>(ppid), procName</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// populate N Tree</span></span><br><span class="line">    GetProcs()</span><br><span class="line">    <span class="comment">// printf tree</span></span><br><span class="line">    TraverseTree(Root, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码如上，用 Go 实现也遇到了与上述一样的问题，过滤目录，处理字符串。</p><p>新学到了 <code>filepath.Glob()</code> 还是比较好用的，直接通过正则的方式就将所有进程相关的目录输出了。</p><p>以及 <code>strings.FieldFunc()</code> 每次可以使用不通过分隔符进行过滤跟 C 中 <code>strtok</code> 类似。</p><p>最难的就是如何输出这棵树，先把当前实现的输出放出来（是不是挺像那么回事）：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> pid-process_name</span></span><br><span class="line"></span><br><span class="line">1-systemd</span><br><span class="line"> 19-systemd-journal</span><br><span class="line"> 29-systemd-udevd</span><br><span class="line">  9405-systemd-udevd</span><br><span class="line">  9402-systemd-udevd</span><br><span class="line">  9403-systemd-udevd</span><br><span class="line">  9404-systemd-udevd</span><br><span class="line"> 76-sshd</span><br><span class="line">  86-sshd</span><br><span class="line">   88-bash</span><br><span class="line">    9406-pstree</span><br><span class="line"> 81-systemd-logind</span><br><span class="line"> 82-dbus-daemon</span><br><span class="line"> 84-agetty</span><br></pre></td></tr></table></figure><p>通过前序遍历的方式就能输出这个方式但是输出内容都是齐刷刷的，难的地方在于如何考虑缩进的长度。</p><p>最后实在是想不出来了，上 Github 看了一下，我的方向没错，需要在前序遍历过程中加上一个缩进长度，每往下遍历一层缩进长度就加一，最后就可以输出上述的样子。</p><p>另外，我们还可以通过命令行的方式，指定一些输出格式，具体可以参考手册中的 <code>pstree</code> 就比如：</p><ul><li>按照特定顺序输出</li></ul><blockquote><p>上述实现方式，每次输出的顺序都是不同的，因为 map 的遍历是无序的。</p></blockquote><p>总的来说，对自己理解进程，任务管理器是有很大帮助的，还是要<strong>敢于动手</strong>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近在学习 C 语言的相关知识，想通过 C 语言实现一个简易版的 &lt;code&gt;pstree&lt;/code&gt; 命令行工具，我认为对 C 新手来说还是有一定难度的，最后只通过 C 实现了一半功能，但是实践的过程让我印象深刻。现代程序员使用着便捷的开发工具，输入几个首字母就能打印出自己想调用的库函数。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>k8s 存储内容</title>
    <link href="https://bqyang.top/2022/k8s/k8s-storage/"/>
    <id>https://bqyang.top/2022/k8s/k8s-storage/</id>
    <published>2022-07-05T10:43:10.520Z</published>
    <updated>2022-07-11T10:50:26.875Z</updated>
    
    <content type="html"><![CDATA[<p>概述 k8s 存储相关知识点。</p><span id="more"></span><h2 id="Volume-概念"><a href="#Volume-概念" class="headerlink" title="Volume 概念"></a>Volume 概念</h2><p>物理机上大家共用同一套文件系统，但是在容器内，每个容器的镜像都提供了一套文件系统，它们之间之相互独立的。容器运行时可以对系统中的文件进行修改，但是当他们运行结束后，container 被销毁了（进程没了，进程中的内容也不会存在了），他修改的东西也就都没了</p><p>想让数据持久存储的方法就是给 POD 挂载卷，绑定到 POD 内的容器中。所以不要再傻傻的以为卷是挂给 POD 的，严格的说是挂载给运行中的容器。</p><img src="https://s2.loli.net/2022/07/04/ybZlBV1AJSiQv7R.png" style="zoom:80%;" /><p>目前为止我们提到的都是容器重启，现有的方案可以解决容器重启后数据丢失的问题，那么如上图中的结构，Pod 进行重启后，数据还可以进行持久化存储吗？</p><p><strong>不能的</strong> ，在上图中，Volume 和 Pod 是共享生命周期的，我们需要一种能够独立于 Pod  生命周期的存储类别。</p><h2 id="External-Storage-Volume"><a href="#External-Storage-Volume" class="headerlink" title="External Storage Volume"></a>External Storage Volume</h2><p>外部存储，独立于 Pod 的生命周期。即使 Pod 被调度到了其他的工作节点，依然可以连接到我们的外部存储卷，相比于 hostpath 的好处。</p><p><img src="https://s2.loli.net/2022/07/04/2a1bxNSVTweWKns.png"></p><p>常见的卷类型：</p><ul><li>hostPath 独立于 Pod 生命周期</li><li>emptyDir 与 Pod 生命周期相同</li><li>gcePersistentDisk Google 的持久卷</li><li>cephfs </li><li>configMap 一般用于挂载文件的，通常是配置文件</li><li>secret 一般用于存储重要信息</li></ul><p>问题： <strong>当以 read/write 模式挂载卷的时候</strong>，这时需要扩展到多个 Pod，新的 Pod 创建不出来的。read/write 模式下的卷只能给一个 Pod 挂载， read-only 可以同事挂载给多个 Pod。</p><h2 id="PV"><a href="#PV" class="headerlink" title="PV"></a>PV</h2><p>顾名思义，PersistentVolume 对象代表一个用于持久化应用程序数据的存储卷。没有讲 PV 对象前，我们挂载外部存储的的时候，需要指定具体的存储类别，比如使用 Google 的存储卷，当我们需要将 Pod 部署到 AWS 中的集群时，就需要重新修改这个 YAML 文件。</p><p><img src="https://s2.loli.net/2022/07/04/DhfS5CRILcmW9se.png"></p><p>PV 是 K8s 提供给我们的抽象，在 Pod 和底层存储技术之间解耦。</p><p><img src="https://s2.loli.net/2022/07/04/71qz5ZdxpjWGIeF.png"></p><h3 id="手动配置的-PV-的生命周期"><a href="#手动配置的-PV-的生命周期" class="headerlink" title="手动配置的 PV 的生命周期"></a>手动配置的 PV 的生命周期</h3><p><img src="https://s2.loli.net/2022/07/05/I8RzS5uBNakKAs3.png"></p><ol><li>现有配置好底层存储</li><li>创建 PV 对象，指向底层存储，PV 状态为 Available</li><li>创建 PVC 指向刚刚创建的 PV, PVC – PV 绑定到一起</li><li>删除 PVC， PVC – PV 之间解绑，PV 状态为 Released</li><li>重新创建 PV 可使 PV 状态变成 Available</li></ol><h2 id="PVC"><a href="#PVC" class="headerlink" title="PVC"></a>PVC</h2><p>Pod 并不会直接引用 PV，而是通过 PVC ，然后 PVC 再对应一个 PV 的方式，正如上图描述的，使用 PV PVC 的最大好处就是将特定于底层存储的细节与 pod 所代表的应用程序分离。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p><img src="https://s2.loli.net/2022/07/04/dMFyi8ncsQLl3o6.png"></p><p>从这张图可以看出，PV 是给集群管理员使用的，PVC 是给用户使用的。如果安装了动态分配的插件，那我们就可以直接通过创建 PVC 的方式。</p><p>卷的访问方式：</p><table><thead><tr><th>Access Mode</th><th>Abbr.</th><th>Description</th></tr></thead><tbody><tr><td><code>ReadWriteOnce </code></td><td><code>RWO </code></td><td>The volume can be mounted by a single worker node in read/write mode. While it’s mounted to the node, other nodes can’t mount the volume.</td></tr><tr><td><code>ReadOnlyMany </code></td><td><code>ROX </code></td><td>The volume can be mounted on multiple worker nodes simultaneously in read-only mode.</td></tr><tr><td><code>ReadWriteMany </code></td><td><code>RWX </code></td><td>The volume can be mounted in read/write mode on multiple worker nodes at the same time.</td></tr></tbody></table><blockquote><p>这里指的是 Node</p></blockquote><p>PV 的回收策略：</p><table><thead><tr><th>Reclaim policy</th><th>Description</th></tr></thead><tbody><tr><td><code>Retain </code></td><td>When the persistent volume is released (this happens when you delete the claim that’s bound to it), Kubernetes <em>retains</em> the volume. The cluster administrator must manually reclaim the volume. This is the default policy for manually created persistent volumes.</td></tr><tr><td><code>Delete </code></td><td>The PersistentVolume object and the underlying storage are automatically deleted upon release. This is the default policy for dynamically provisioned persistent volumes, which are discussed in the next section.</td></tr><tr><td><code>Recycle </code></td><td>This option is deprecated and shouldn’t be used as it may not be supported by the underlying volume plugin. This policy typically causes all files on the volume to be deleted and makes the persistent volume available again without the need to delete and recreate it.</td></tr></tbody></table><p>动态分配默认回收策略是：delete</p><p>手动创建 PV 时默认回收策略是：retain</p><p>我们在任何时候都可以修改 PV 的回收策略，比如使用动态分配时，默认回收策略是 delete ，但是我们中途不想删除PVC的时候删除这个卷，可以将其修改为 retain。</p><blockquote><p>如果是 Released 状态的 PV，我们修改其回收策略为 delete 时，保存退出后，PV 对象和底层的卷都会被删除。</p></blockquote><p><img src="https://s2.loli.net/2022/07/05/TPmMsjYJBEdbHqw.png"></p><p>上图中我将 PVC 删掉了，现在策略是 Retain 这时候 <code>kubectl edit </code> 一下修改为 Delete。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">persistentVolumeReclaimPolicy: Retain --&gt; persistentVolumeReclaimPolicy: Delete</span><br></pre></td></tr></table></figure><p>PV 的删除</p><p>除了上述情况，假如我们想在 PV 是 Bound 状态下删除，PV 可以被删掉吗？</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">[root@k8s]#</span><span class="bash"> kubectl delete pv hostvol</span></span><br><span class="line">persistentvolume &quot;hostvol&quot; deleted</span><br></pre></td></tr></table></figure><p>会一直卡在这里，Ctrl-C 取消这次操作，再次获取 PV 发现已经是 <code>Terminating</code> 状态了。尽管刚刚取消delete命令的执行，但是这个 delete 的操作会被记录在 K8S 中（被释放后仍然会被删除）。</p><p>同样的，我们看看删除某个被 POD 引用的 PVC 是什么情况。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s]<span class="comment"># kubectl delete pvc hostpvc</span></span><br><span class="line">persistentvolumeclaim <span class="string">&quot;hostpvc&quot;</span> deleted</span><br></pre></td></tr></table></figure><p>依然会一直卡在这里，同删除 PV 一样。</p><h2 id="多个-POD-挂载-ReadWriteOnce-卷"><a href="#多个-POD-挂载-ReadWriteOnce-卷" class="headerlink" title="多个 POD 挂载 ReadWriteOnce 卷"></a>多个 POD 挂载 ReadWriteOnce 卷</h2><p>这两天脑子里也一直在想这件事，我们挂载一个可读可写的卷给 POD，如果说这时候需要增加这个 POD  的副本，多个 POD 挂载同一个可读可写的卷，是否可以支持？</p><p><strong>答案是支持的</strong> ，但是有前提，  <strong>扩展出来的POD都必须在同一个 NODE 上</strong> ，Once 指的是挂载到的 Node，只能给 Node 挂载一次，如果扩展的 POD 调度到其他 NODE，POD 是起不来的，会报如下错误：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl describe po data-writer-97t9j</span></span><br><span class="line">...</span><br><span class="line">  Warning  FailedAttachVolume   ...   attachdetach-controller  AttachVolume.Attach failed </span><br><span class="line">for volume &quot;other-data&quot; : googleapi: Error 400: RESOURCE_IN_USE_BY_ANOTHER_RESOURCE -</span><br><span class="line">The disk resource &#x27;projects/.../disks/other-data&#x27; is already being used by</span><br><span class="line">&#x27;projects/.../instances/gkdp-r6j4&#x27;</span><br></pre></td></tr></table></figure><p>由于我这里机器就俩节点，复现不出来，直接把书中内容粘贴出来了。</p><h2 id="动态配置持久卷"><a href="#动态配置持久卷" class="headerlink" title="动态配置持久卷"></a>动态配置持久卷</h2><p>先创建 PV ，再创建 PVC 的方式有些繁琐，我这里遇到过一个问题，在对接 ceph 的过程中，我想创建一个 PV 对象指向这个底层的卷，当时需要填一个 <code>volumeHandle</code> 对应的值，是 ceph 卷的 ID。对于并不知道怎么操作 ceph 的我来说是比较困难的，需要先创建好底层卷，然后在PV中指定才可以。</p><p>但是，通过动态配置的方式就可以解决这个问题，我们不再需要手动准备好存储卷以及PV对象，只需写一个“需求文档”。</p><h3 id="动态配置流程"><a href="#动态配置流程" class="headerlink" title="动态配置流程"></a>动态配置流程</h3><p><img src="https://s2.loli.net/2022/07/05/rkYKoNBRMi3nUjV.png"></p><h3 id="StorageClass-与-PVC-的关系"><a href="#StorageClass-与-PVC-的关系" class="headerlink" title="StorageClass 与 PVC 的关系"></a>StorageClass 与 PVC 的关系</h3><p><img src="https://s2.loli.net/2022/07/11/dQRJFDbnCAuyk5x.png"></p><p>通常来讲，不同卷类型对应的不同的底层存储技术。</p><h3 id="卷绑定模式"><a href="#卷绑定模式" class="headerlink" title="卷绑定模式"></a>卷绑定模式</h3><p>讲的就是我们创建 PVC 对象后，PV  何时被创建。</p><table><thead><tr><th>Volume binding mode</th><th>Description</th></tr></thead><tbody><tr><td><code>Immediate </code></td><td>The provision and binding of the persistent volume takes place immediately after the claim is created. Because the consumer of the claim is unknown at this point, this mode is only applicable to volumes that are can be accessed from any cluster node.</td></tr><tr><td><code>WaitForFirstConsumer </code></td><td>The volume is provisioned and bound to the claim when the first pod that uses this claim is created. This mode is used for topology-constrained volume types.</td></tr></tbody></table><p>需要 <code>WaitForFirstConsumer </code> 的原因是，使用 Local 这种卷类型的时候，不知道 POD 被调度到哪里，所以需要确定好 POD 位置后再创建 PV。</p><h3 id="动态绑定的声明周期"><a href="#动态绑定的声明周期" class="headerlink" title="动态绑定的声明周期"></a>动态绑定的声明周期</h3><p><img src="https://s2.loli.net/2022/07/06/5ABInxbTrwCLl7v.png"></p><h3 id="卷扩容"><a href="#卷扩容" class="headerlink" title="卷扩容"></a>卷扩容</h3><p>需要 POD 配合（重启）来完成。</p><h3 id="Retain-状态的-PV-怎么恢复为-Available"><a href="#Retain-状态的-PV-怎么恢复为-Available" class="headerlink" title="Retain 状态的 PV 怎么恢复为 Available"></a>Retain 状态的 PV 怎么恢复为 Available</h3><p>本来以为 k8s 对接持久化存储已经结束了，突然发现 Rancher 上并不支持，修改 PV 的属性。想要从 Retain 状态修改为 Available 有两种方式：</p><ul><li>重新创建这个 PV 对象</li><li>edit 这个 PV 对象删除 claimref 部分</li></ul><p><img src="https://s2.loli.net/2022/07/11/4JN2AMPanYqQ3bV.png"></p><p> 将 PVC 对象释放后，获取到的 PV 列表，既然 Rancher 不支持，只能另寻他路了。</p><blockquote><p><strong>delete and recreate pv object 会导致底层卷被删除吗？</strong></p><p>先创建 PV 再创建 PVC 的方式并不会删除，底层存储。</p><p>动态创建的情况下，需要根据不同的回收策略区分：</p><ul><li>delete，pvc 被删除后 pv 和底层存储卷都被删除</li><li>retain，pvc 被删除后，pv 是 released 状态 （TODO 需要调研一下）</li></ul></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;概述 k8s 存储相关知识点。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>门面模式（外观模式）</title>
    <link href="https://bqyang.top/2022/design-pattern/Structural/facade/"/>
    <id>https://bqyang.top/2022/design-pattern/Structural/facade/</id>
    <published>2022-07-05T10:42:54.266Z</published>
    <updated>2022-07-05T11:00:54.885Z</updated>
    
    <content type="html"><![CDATA[<p>有两周时间没看设计模式内容了，前边学的都忘记差不多了..今天要学的是外观模式。（总感觉将这个英文翻译过来有点词不达意）</p><span id="more"></span><h2 id="门面模式"><a href="#门面模式" class="headerlink" title="门面模式"></a>门面模式</h2><p>门面模式（Facade），为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。体现了<strong>依赖倒转</strong>与<strong>迪米特法则</strong>，抽象出来一个中间层。</p><p><img src="https://s2.loli.net/2022/07/05/2WPfhFCj6yUpIHV.png"></p><p>最近在学习 K8S 持久化存储的相关内容，这之中也有一个类似的实现。K8S 的 PV 对象对底层实际的存储技术进行封装，再通过 PVC 对 PV 对象进行引用，达到了 K8S 与底层存储技术的解耦。</p><p>用一个用户的登录注册的例子可能比较形象，假设现在如左边一样，登录时候调用登录接口，注册时候调用注册接口。现在要增加一个功能，使用手机号的登录时候检查是否存在，存在直接登录，不存在自动注册再登录，例子来源 [<a href="https://github.com/mohuishou/go-design-pattern/tree/master/09_facade">这里</a>]：</p><p><img src="https://s2.loli.net/2022/07/05/78QuU9nEI6HPFco.png"></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">    username <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *user)</span> <span class="title">Login</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;user login&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *user)</span> <span class="title">Register</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;user register&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> facadeUser <span class="keyword">struct</span> &#123;</span><br><span class="line">    user</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *facadeUser)</span> <span class="title">LoginOrRegister</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// check user exist</span></span><br><span class="line">    <span class="keyword">var</span> exist <span class="keyword">bool</span></span><br><span class="line">    <span class="keyword">if</span> !exist &#123;</span><br><span class="line">        f.user.Register()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    f.user.Login()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里实现与上述链接中的些许不同，区别在于<strong>facade 的职责</strong>， <strong>facade 负责的是中转，他的方法中最好不要有具体实现，通过 facade 调用子类的方法或者是将子类的方法再进行封装使其更容易复用。</strong> 通过结构体内嵌可以实现，也可以将user抽象出来一个接口：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> IUser <span class="keyword">interface</span> &#123;</span><br><span class="line">    Login()</span><br><span class="line">    register</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再将这个接口内嵌到 facade 中：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> facadeUser <span class="keyword">struct</span> &#123;</span><br><span class="line">    user IUser</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一个更详细的例子请看这里 [<a href="https://golangbyexample.com/facade-design-pattern-in-golang/">facade</a>]。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;有两周时间没看设计模式内容了，前边学的都忘记差不多了..今天要学的是外观模式。（总感觉将这个英文翻译过来有点词不达意）&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>内存相关 API</title>
    <link href="https://bqyang.top/2022/os/memory-api/"/>
    <id>https://bqyang.top/2022/os/memory-api/</id>
    <published>2022-06-29T13:19:58.377Z</published>
    <updated>2022-07-02T05:46:13.074Z</updated>
    
    <content type="html"><![CDATA[<p>这两天在学习内存虚拟化的过程中，发现两个查看内存的两个工具 <code>free</code> <code>pmap</code> 关于他们的详细描述可以在手册上查阅，这里举两个小例子玩一玩。</p><span id="more"></span><h2 id="free"><a href="#free" class="headerlink" title="free"></a>free</h2><p>这个比较简单，可以查看当前系统中的内存使用情况：</p><p><img src="https://s2.loli.net/2022/07/01/uCGFEikarR4WAJQ.png"></p><h2 id="pmap"><a href="#pmap" class="headerlink" title="pmap"></a>pmap</h2><p>这个比较有意思，我们可以查看运行中进程的内存布局，<code>CODE HEAP STACK</code> ，暂时将布局简单的分成以上三个部分，运行如下代码（采用静待链接的方式编译）：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 变换这个数组的大小查看有什么不同</span></span><br><span class="line">    <span class="keyword">int</span> *p = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="number">100000</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>, *p);</span><br><span class="line">    sleep(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 变换这个数组的大小查看有什么不同</span></span><br><span class="line">    <span class="keyword">int</span> *p = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="number">100000</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>, *p);</span><br><span class="line">    sleep(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中声明了一个包含<strong>100000</strong>个元素的数组，即使我们现在不知道 <code>malloc</code> 会将这个数组分配到哪里也没关系，通过 <code>pmap</code> 查看：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">~ # pmap 457</span><br><span class="line">457: ./a.out</span><br><span class="line">0000000000400000       4K r--p  /root/a.out</span><br><span class="line">0000000000401000      12K r-xp  /root/a.out</span><br><span class="line">0000000000404000       4K r--p  /root/a.out</span><br><span class="line">0000000000405000       8K rw-p  /root/a.out</span><br><span class="line">0000000000ab4000     392K rw-p  [heap]</span><br><span class="line">00007fff65583000     132K rw-p  [stack]</span><br><span class="line">00007fff655f3000      16K r--p  [vvar]</span><br><span class="line">00007fff655f7000       4K r-xp  [vdso]</span><br><span class="line">mapped: 572K</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">~ # pmap 457</span><br><span class="line">457: ./a.out</span><br><span class="line">0000000000400000       4K r--p  /root/a.out</span><br><span class="line">0000000000401000      12K r-xp  /root/a.out</span><br><span class="line">0000000000404000       4K r--p  /root/a.out</span><br><span class="line">0000000000405000       8K rw-p  /root/a.out</span><br><span class="line">0000000000ab4000     392K rw-p  [heap]</span><br><span class="line">00007fff65583000     132K rw-p  [stack]</span><br><span class="line">00007fff655f3000      16K r--p  [vvar]</span><br><span class="line">00007fff655f7000       4K r-xp  [vdso]</span><br><span class="line">mapped: 572K</span><br></pre></td></tr></table></figure><p>通过观察堆栈的起始地址，可以得出他们的相对位置，看到这个输出就能知道进程内存是如何布局的</p><ul><li>在最开始的位置就是需要执行的指令，<code>CODE</code>，通过前面的 ELF 知识的学习，这里又可以分为 .text .data .bss 段等</li><li>然后是堆，<code>HEAP</code></li><li>其次是栈，<code>STACK</code></li><li><code>VVAR</code> <code>VDSO</code> 放在下面分开讲</li></ul><p>如果说这时候我们还是不清楚数组被分配到了哪里，我们可以尝试减少数组中的元素，然后再查看占用的内存大小。</p><blockquote><p>修改后输出的内容都是相同的话，可以尝试禁用优化，在编译的时候加上 <code>-O0</code>。</p></blockquote><h2 id="VDSO"><a href="#VDSO" class="headerlink" title="VDSO"></a>VDSO</h2><p>VDSO (Virtual dynamic shared object) ，虚拟动态共享对象，名字就给人一种很难理解的假象。手册中一句话就概述了这个特性是用来做什么的：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The &quot;vDSO&quot; (virtual dynamic shared object) is a small shared</span><br><span class="line">library that the kernel automatically maps into the address space</span><br><span class="line">of all user-space applications.</span><br></pre></td></tr></table></figure><p><strong>系统调用一定要陷入内核吗？</strong>  VDSO 告诉你不是的，操作系统内核会将某些共享库自动的映射到进程的地址空间。比如在业务逻辑中，很多情况下是需要获取当前时间戳：</p><p><img src="https://s2.loli.net/2022/07/01/bBUahRS2ZyrwFu3.png"></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1017: /root/a.out</span><br><span class="line">Address           Kbytes     PSS   Dirty    Swap  Mode  Mapping</span><br><span class="line">000055d54f219000       4       4       0       0  r--p  /root/a.out</span><br><span class="line">000055d54f21a000       4       4       4       0  r-xp  /root/a.out</span><br><span class="line">000055d54f21b000       4       0       0       0  r--p  /root/a.out</span><br><span class="line">000055d54f21c000       4       4       4       0  r--p  /root/a.out</span><br><span class="line">000055d54f21d000       4       4       4       0  rw-p  /root/a.out</span><br><span class="line">000055d550af4000       4       0       0       0  ---p  [heap]</span><br><span class="line">000055d550af5000       4       4       4       0  rw-p  [heap]</span><br><span class="line">00007fc662f2e000      84       3       0       0  r--p  /lib/ld-musl-x86_64.so.1</span><br><span class="line">00007fc662f43000     288      18       8       0  r-xp  /lib/ld-musl-x86_64.so.1</span><br><span class="line">00007fc662f8b000     216       3       0       0  r--p  /lib/ld-musl-x86_64.so.1</span><br><span class="line">00007fc662fc1000       4       4       4       0  r--p  /lib/ld-musl-x86_64.so.1</span><br><span class="line">00007fc662fc2000       4       4       4       0  rw-p  /lib/ld-musl-x86_64.so.1</span><br><span class="line">00007fc662fc3000      12       8       8       0  rw-p    [ anon ]</span><br><span class="line">00007ffe9782e000     132      12      12       0  rw-p  [stack]</span><br><span class="line">00007ffe978e5000      16       0       0       0  r--p  [vvar]</span><br><span class="line">00007ffe978e9000       4       0       0       0  r-xp  [vdso]</span><br><span class="line">----------------  ------  ------  ------  ------</span><br><span class="line">total                788      72      52       0</span><br></pre></td></tr></table></figure><p><code>00007ffe978e9733</code> 正好在 VDSO 的地址范围内，说明这里直接访问了 VDSO 的映射，没有通过系统调用。</p><h2 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 映射，addr 进程中地址，length 区间长度，prot 和 flags 与权限有关，fd 文件描述符</span></span><br><span class="line"><span class="comment">// offset 偏移量；意味着可以把文件的某部分内容映射到进程中。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mmap</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> length, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">munmap</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> length)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改映射权限</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mprotect</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> length, <span class="keyword">int</span> prot)</span></span>;</span><br></pre></td></tr></table></figure><p>文档中有个关于 mmap 的例子还挺不错的 <a href="https://man7.org/linux/man-pages/man2/mmap.2.html">code example</a></p><h2 id="malloc-amp-free"><a href="#malloc-amp-free" class="headerlink" title="malloc &amp;free"></a>malloc &amp;free</h2><p><code>malloc</code> 用于在堆空间上分配内存的 API，在 C 中堆上的内存分配和释放有开发者来维护。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *x = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br></pre></td></tr></table></figure><h2 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h2><p>针对 <code>malloc</code> 和 <code>free</code> 的常见问题：</p><p><strong>忘记分配内存</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *src = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> *dst; <span class="comment">// oops! unallocated</span></span><br><span class="line"><span class="built_in">strcpy</span>(dst, src); <span class="comment">// segfault and die</span></span><br></pre></td></tr></table></figure><p>将字符串 <code>hello</code> 赋值给变量 dst 时，由于dst指针为指向任何可用的内存，导致失败，正确的做法如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *src = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> *dst = (<span class="keyword">char</span> *) <span class="built_in">malloc</span>(<span class="built_in">strlen</span>(src)+<span class="number">1</span>); <span class="comment">// +1 是给 \0 准备的</span></span><br><span class="line"><span class="built_in">strcpy</span>(dst, src);</span><br></pre></td></tr></table></figure><p><strong>编译通过并运行不代表是正确的</strong></p><p>虽然我们在控制台看到了正确的输出结果，但也不代表我们的程序是正确的，看下面这个例子：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *src = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> *dst = (<span class="keyword">char</span> *) <span class="built_in">malloc</span>(<span class="built_in">strlen</span>(src)); <span class="comment">// too small!</span></span><br><span class="line"><span class="built_in">strcpy</span>(dst, src); <span class="comment">// work properly</span></span><br></pre></td></tr></table></figure><p>输出 dst 中的内容时，可以看到 hello 被打印出来了。但是我们分配给变量 dst 的内存大小装不下 src 中的内容。这就会导致，它覆盖了不属于它自己部分。</p><p><strong>忘记初始化刚分配的内存</strong></p><p>C 并不会帮你初始化内存，很有可能你声明了一个整型变量没有进行赋值操作，但当你读他的时候发现是一个神奇怪的数字。</p><p><strong>忘记释放内存</strong></p><p>分配和释放应该成对的出现，这就好像 Go 中打开了一个 response.body 要记得关闭一个道理。如果是一个长时间运行的服务，最终可能把所有的内存耗光，导致 OOM。如果是一个一次性运行的服务，不是放也没什么关系，进程退出了自动会把占有的资源释放了。</p><blockquote><p>为什么进程退出了，相关的内存会得到释放？</p></blockquote><p><strong>还没有使用完内存，就提前释放了</strong></p><p>dangling pointer 问题</p><p><strong>释放已经释放的内存</strong></p><p>double free 的结果是未被定义的，不知道会产生什么结果</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这两天在学习内存虚拟化的过程中，发现两个查看内存的两个工具 &lt;code&gt;free&lt;/code&gt; &lt;code&gt;pmap&lt;/code&gt; 关于他们的详细描述可以在手册上查阅，这里举两个小例子玩一玩。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>misuse init func</title>
    <link href="https://bqyang.top/2022/language/golang/100-go-mistaks/2-misuse-init/"/>
    <id>https://bqyang.top/2022/language/golang/100-go-mistaks/2-misuse-init/</id>
    <published>2022-06-29T13:19:32.315Z</published>
    <updated>2022-06-30T13:23:55.896Z</updated>
    
    <content type="html"><![CDATA[<p>今天这篇讲的是 <code>init</code> 函数使用技巧，平时在人家封装好的代码框架中进行开发，很少独立用到 <code>init</code> 函数的地方，其实不小心使用的话坑还是比较多的。</p><ul><li>一个包中能不能拥有多个 <code>init</code> </li><li><code>init</code> 与全局变量的初始化哪个先执行</li><li>一个包被导入多次 <code>init</code> 是否会执行多次</li></ul><span id="more"></span><p>参考如下代码，你能否说出输出的顺序：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;var&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;init&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;main&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">output:</span></span><br><span class="line"><span class="comment">  var</span></span><br><span class="line"><span class="comment">  init</span></span><br><span class="line"><span class="comment">  main</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>我是倒在了这上边，不过还好，借这个机会来好好了解一下。我们先看下不包含全局变量的情况，在 main 包中引用 redis 包：</p><p><img src="https://s2.loli.net/2022/06/29/3BlmuwZKvqONH9s.png"></p><p><code>init </code> 函数的执行顺序如上述标号所示，这时候如果一个 package 中有多个 <code>init</code> 函数需要执行时，他们的顺序是什么呢？</p><p>假设我们有如下的目录结构，每个文件中都有 <code>init</code> 函数：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">hello</span><br><span class="line">|--a.<span class="keyword">go</span></span><br><span class="line">|--b.<span class="keyword">go</span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;a.go&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;b.go&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.go package main</span></span><br><span class="line"><span class="keyword">import</span> _ <span class="string">&quot;hello&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;main.go&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候是先执行 <code>a.go</code> 中的 <code>init</code> 还是 <code>b.go</code> 中的呢？ **答案是文件名称排序，谁在前边就先执行谁的 <code>init</code>**。</p><blockquote><p>所以这里警示我们，务必不能通过文件名称的方式确定 <code>init</code> 函数的执行顺序，在不断迭代的过程中文件名称很有可能会被修改。</p></blockquote><p>另一个有意思的地方是，可以在一个文件中写多个 <code>init</code> 函数：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;first init&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;second init&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure><p> <code>init</code> 会带来什么样的问题呢？</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> db *sql.DB</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    dataSourceName := os.Getenv(<span class="string">&quot;MYSQL_DATA_SOURCE_NAME&quot;</span>)</span><br><span class="line">    d, err := sql.Open(<span class="string">&quot;mysql&quot;</span>, dataSourceName)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Panic(err)</span><br><span class="line">    &#125;</span><br><span class="line">    err = d.Ping()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Panic(err)</span><br><span class="line">    &#125;</span><br><span class="line">    db = d</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 <code>init</code> 进行数据库连接的初始化，这里存在至少三个问题：</p><ul><li>错误处理的局限性，因为 <code>init</code> 是没有参数和返回值的。</li><li>全局变量的可能会在其它的package中被修改。</li><li>单元测试的局限性，针对这种 <code>init</code> 函数，我们想进行单元测试不太可能，在执行用例的时候 <code>init</code> 函数已经执行完成了。</li></ul><p><strong>疑问</strong></p><p>假设我们有 <code>package A</code>，<code>package B</code>，<code>package main</code> 每个包都有自己的  <code>init</code> 函数，那么他们被导入多次的时候  <code>init</code> 会被执行多次吗？</p><p>B 中引用了 A，main 中引用了 B，A；我以为 A 的 <code>init</code> 会被执行两次，又 tm 被打脸了。 不过比较及时，要不面试的时候就尴尬了。</p><h2 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// An initTask represents the set of initializations that need to be done for a package.</span></span><br><span class="line"><span class="comment">// Keep in sync with ../../test/initempty.go:initTask</span></span><br><span class="line"><span class="keyword">type</span> initTask <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> pack the first 3 fields more tightly?</span></span><br><span class="line">    state <span class="keyword">uintptr</span> <span class="comment">// 0 = uninitialized, 1 = in progress, 2 = done</span></span><br><span class="line">    ndeps <span class="keyword">uintptr</span></span><br><span class="line">    nfns  <span class="keyword">uintptr</span></span><br><span class="line">    <span class="comment">// followed by ndeps instances of an *initTask, one per package depended on</span></span><br><span class="line">    <span class="comment">// followed by nfns pcs, one per init function to run</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:linkname runtime_inittask runtime..inittask</span></span><br><span class="line"><span class="keyword">var</span> runtime_inittask initTask</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:linkname main_inittask main..inittask</span></span><br><span class="line"><span class="keyword">var</span> main_inittask initTask</span><br></pre></td></tr></table></figure><p>这里我理解 <code>runtime_inittask</code> <code>main_inittask</code> 一个是 runtime 需要用到的初始化函数，一个是 user program 用到的 init 函数，原因如下：cmd/compile/internal/gc/init.go 文件中有关于 init 的代码（省略了部分代码）：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fninit makes an initialization record for the package.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fninit</span><span class="params">(n []*Node)</span></span> &#123;</span><br><span class="line">    nf := initOrder(n)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> deps []*obj.LSym <span class="comment">// initTask records for packages the current package depends on</span></span><br><span class="line">    <span class="keyword">var</span> fns []*obj.LSym  <span class="comment">// functions to call for package initialization</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find imported packages with init tasks.</span></span><br><span class="line">    <span class="keyword">for</span> _, s := <span class="keyword">range</span> types.InitSyms &#123;</span><br><span class="line">        deps = <span class="built_in">append</span>(deps, s.Linksym())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make a function that contains all the initialization statements.</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nf) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Record user init functions.</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; renameinitgen; i++ &#123;</span><br><span class="line">        s := lookupN(<span class="string">&quot;init.&quot;</span>, i)</span><br><span class="line">        fn := asNode(s.Def).Name.Defn</span><br><span class="line">        <span class="comment">// Skip init functions with empty bodies.</span></span><br><span class="line">        <span class="keyword">if</span> fn.Nbody.Len() == <span class="number">1</span> &amp;&amp; fn.Nbody.First().Op == OEMPTY &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        fns = <span class="built_in">append</span>(fns, s.Linksym())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有 init 函数需要执行</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(deps) == <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(fns) == <span class="number">0</span> &amp;&amp; localpkg.Name != <span class="string">&quot;main&quot;</span> &amp;&amp; localpkg.Name != <span class="string">&quot;runtime&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="comment">// nothing to initialize</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make an .inittask structure.</span></span><br><span class="line">    sym := lookup(<span class="string">&quot;.inittask&quot;</span>)</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    ot := <span class="number">0</span></span><br><span class="line">    <span class="comment">// 最初状态：未初始化</span></span><br><span class="line">    ot = duintptr(lsym, ot, <span class="number">0</span>) <span class="comment">// state: not initialized yet</span></span><br><span class="line">    ot = duintptr(lsym, ot, <span class="keyword">uint64</span>(<span class="built_in">len</span>(deps)))</span><br><span class="line">    ot = duintptr(lsym, ot, <span class="keyword">uint64</span>(<span class="built_in">len</span>(fns)))</span><br><span class="line">    <span class="keyword">for</span> _, d := <span class="keyword">range</span> deps &#123;</span><br><span class="line">        ot = dsymptr(lsym, ot, d, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// An initTask has pointers, but none into the Go heap.</span></span><br><span class="line">    <span class="comment">// It&#x27;s not quite read only, the state field must be modifiable.</span></span><br><span class="line">    ggloblsym(lsym, <span class="keyword">int32</span>(ot), obj.NOPTR)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在初始化的过程中是怎么保证一个包不被执行多次的？</p><p>inittask 中有一个表示 init 函数状态的变量，0 代表<em>未执行</em>， 1 代表<em>执行中</em>， 2代表<em>已完成</em>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天这篇讲的是 &lt;code&gt;init&lt;/code&gt; 函数使用技巧，平时在人家封装好的代码框架中进行开发，很少独立用到 &lt;code&gt;init&lt;/code&gt; 函数的地方，其实不小心使用的话坑还是比较多的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个包中能不能拥有多个 &lt;code&gt;init&lt;/code&gt; &lt;/li&gt;
&lt;li&gt;&lt;code&gt;init&lt;/code&gt; 与全局变量的初始化哪个先执行&lt;/li&gt;
&lt;li&gt;一个包被导入多次 &lt;code&gt;init&lt;/code&gt; 是否会执行多次&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>参数是怎么传给 goroutine 的</title>
    <link href="https://bqyang.top/2022/language/golang/go-params-to-goroutine/"/>
    <id>https://bqyang.top/2022/language/golang/go-params-to-goroutine/</id>
    <published>2022-06-28T11:06:28.302Z</published>
    <updated>2022-06-28T11:05:02.712Z</updated>
    
    <content type="html"><![CDATA[<p><em>go version: 1.16</em></p><p><img src="https://s2.loli.net/2022/06/27/j7xI9vwEdRF8eTB.png"></p><p>文章内容接之前的 <code>variable shadowing</code>  做了一些延伸，在批量创建 <code>goroutine</code> 时，避免不了参数传递，通常的做法如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span> <span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="built_in">println</span>(i)</span><br><span class="line">    &#125;(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// wait all g done</span></span><br></pre></td></tr></table></figure><span id="more"></span><p>其实也可以通过 <code>variable shadowing</code> 来解决，这两种方法达到的效果是一样的，如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">    i := i</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span> <span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">println</span>(i)</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// wait all g done</span></span><br></pre></td></tr></table></figure><h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><p><strong>由此，我产生了一个疑问，参数是如何传递给 <code>goroutine</code> 的</strong>。</p><h2 id="寻找答案"><a href="#寻找答案" class="headerlink" title="寻找答案"></a>寻找答案</h2><p>我们使用上述代码调试，在源码中寻找答案，其实关键的代码就这两行：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newproc</span><span class="params">(siz <span class="keyword">int32</span>, fn *funcval)</span></span> &#123;</span><br><span class="line">    <span class="comment">// fn 地址 再加 8 个字节（跟机器有关，32位4字节），</span></span><br><span class="line">    <span class="comment">// 就是第一个参数的位置，siz 代表字节数，传进来的参数大小</span></span><br><span class="line">    argp := add(unsafe.Pointer(&amp;fn), sys.PtrSize)</span><br><span class="line">    <span class="comment">// ommit</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>栈是由<em>高</em>地址向<em>低</em>地址增长的，有时候不好确定这个增长方向，因为 x86 代码和 go 的汇编存在差异，区分不好应该是从左往右看，还是从右往左，既然这该死的脑子记不住，就找到一个窍门，每次先找 sub 或者 add 指令，通过这种方式来区分从哪边看起。</p><p>还有一点需要我们注意的就是，如何理解 <code>go func()&#123;&#125;()</code> 的这个函数地址与参数位置的关系，是谁把参数放在了与这个函数位置挨着的地方？为什么要挨着放在别的地方行不行？常规情况下，函数的参数传递形式如下图所示：</p><p><img src="https://s2.loli.net/2022/06/27/QgtHDkSq75E9sGJ.png"></p><p>这里涉及到调用规约的内容，可以参考曹大的文章（文末引路），主要讲的就是函数间参数传递的方式以及返回值放在哪里等。</p><p>查看创建 goroutine 的源码，注释中有关于调用规约的描述：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The stack layout of this call is unusual: it assumes that the</span></span><br><span class="line"><span class="comment">// arguments to pass to fn are on the stack sequentially immediately</span></span><br><span class="line"><span class="comment">// after &amp;fn.</span></span><br></pre></td></tr></table></figure><p>首先提到的就是这里的的栈传参形式与平常是不一样的，这里的 <code>fn</code> 指的就是 go 关键字后面的 func，<code>&amp;fn</code> 的意思就是 fn 函数的地址（一开始以为在执行这个取址操作后..）。</p><p>在 <code>fn</code> 函数地址后面，就是传递给它的参数。有意思的地方来了，<strong>goroutine 的参数是借用 newproc 传递给了 fn 函数，但是在 newproc 函数签名中只有两个参数</strong>，如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newproc</span><span class="params">(siz <span class="keyword">int32</span>, fn *funcval)</span></span> &#123;</span><br><span class="line">    <span class="comment">// ommit</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/06/27/VNzjKJUTlZWnf13.png"></p><p>这里通过汇编代码验证下，我们增加传递给 goroutine 参数，加到 3 个：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 第一个参数 siz 代表所有参数占用的字节数</span><br><span class="line">mov dword ptr [rsp], 0x18</span><br><span class="line"># 把 fn 的地址 load 出来</span><br><span class="line">lea rbx, ptr [rip+0x2b572]</span><br><span class="line"># 第二个参数 fn</span><br><span class="line">mov qword ptr [rsp+0x8], rbx</span><br><span class="line"># fn 的第一个参数</span><br><span class="line">mov qword ptr [rsp+0x10], rdx</span><br><span class="line"># fn 的第二个参数</span><br><span class="line">mov qword ptr [rsp+0x18], rax</span><br><span class="line"># fn 的第三个参数</span><br><span class="line">mov qword ptr [rsp+0x20], rcx</span><br><span class="line"># 调用 newproc</span><br><span class="line">call $runtime.newproc</span><br></pre></td></tr></table></figure><blockquote><p>虽然计算机的世界没有 magic，但是感觉是真 tmd 神奇。</p></blockquote><p>最后在创建新 goroutine 的时候，把参数拷贝到当前 goroutine 的栈地址空间。分析的过程没什么难度，死记硬背并不是什么秘诀，掌握寻找答案的方法更重要。</p><p>最后，关于调用规约的相关内容，指路[ <a href="https://www.xargin.com/go1-17-new-calling-convention/">曹大博客</a> ]。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;em&gt;go version: 1.16&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2022/06/27/j7xI9vwEdRF8eTB.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;文章内容接之前的 &lt;code&gt;variable shadowing&lt;/code&gt;  做了一些延伸，在批量创建 &lt;code&gt;goroutine&lt;/code&gt; 时，避免不了参数传递，通常的做法如下：&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i := &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;; i++ &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;(i &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;println&lt;/span&gt;(i)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;(i)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// wait all g done&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Variable shadowing</title>
    <link href="https://bqyang.top/2022/language/golang/100-go-mistaks/1-variable-shadowing/"/>
    <id>https://bqyang.top/2022/language/golang/100-go-mistaks/1-variable-shadowing/</id>
    <published>2022-06-26T08:46:56.077Z</published>
    <updated>2022-06-26T12:15:33.120Z</updated>
    
    <content type="html"><![CDATA[<p>本文中的内容来自《100 Go Mistakes and How to Avoid Them》，作者总结了常见、易犯的错误，比较适合刚学习 Go 的同学。</p><p>这个问题我最开始实习的时候还真遇到过，不过经历一次之后就记住了。主要问题在于对变量作用域以及 <code>:=</code> 的理解：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> client *http.Client</span><br><span class="line"><span class="keyword">if</span> tracing &#123;</span><br><span class="line">    <span class="comment">// 这个 client 是一个新的变量</span></span><br><span class="line">    client, err := createClientWithTracing()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果这里不打印的话，会报 declared but not use 的错误</span></span><br><span class="line">    log.Println(client)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    client, err := createDefaultClient()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    log.Println(client)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Use client</span></span><br></pre></td></tr></table></figure><span id="more"></span><p>解决方案这里一共有两种：</p><ul><li><p>在 if 语句代码块外部声明好（err 也要声明）使用 <code>=</code> 号赋值；</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> client *http.Client</span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> xx &#123;</span><br><span class="line">    client, err = xx()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    client, err = xx1()   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代码更加简洁</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在 if 语句代码块中使用额外的变量接收返回值，然后对 client 进行赋值</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">c, err := createClientWithTracing()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">client = c</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure></li></ul><p>这两种方法都是对的，拿第一种来说，我们减少了额外的变量声明，只执行了一次变量分配，而且在进行错误处理时进行统一。我以前写的代码是第一种，不过针对错误处理，我是在每个代码块中都写了，确实有些啰嗦，这下以后就可以写出更简洁的代码了hh。</p><h2 id="发生场景"><a href="#发生场景" class="headerlink" title="发生场景"></a>发生场景</h2><p>那么我们什么时候会遇到这个问题呢？</p><p><strong>当一个变量的名称，在内部代码块重新声明的时候会发生。</strong>正如我们在上述示例代码中看到的，client 在 if 的代码块又被声明了。</p><h2 id="如何避免"><a href="#如何避免" class="headerlink" title="如何避免"></a>如何避免</h2><p>其实说到这里应该能反应过来，一般这种代码检查工具，go vet 中都应该有，就算没有可能有类似的 linter，通过 <code>go help vet</code> 我们就可以看到这样一句话 <code>For example, the &#39;shadow&#39; analyzer can be built and run using these commands</code></p><p>然后我们可以通过 <code>go install</code> 命令安装到自己的 GOPATH/bin 路径下，通过 <code>go vet -vettool=（可执行文件路径）</code> 就可以检查出来。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">go vet -vettool=C:\Users\bqYang\go\bin\shadow.exe .\main.go</span><br><span class="line"></span><br><span class="line">.\main.go:24:3: declaration of &quot;x&quot; shadows declaration at line 22</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文中的内容来自《100 Go Mistakes and How to Avoid Them》，作者总结了常见、易犯的错误，比较适合刚学习 Go 的同学。&lt;/p&gt;
&lt;p&gt;这个问题我最开始实习的时候还真遇到过，不过经历一次之后就记住了。主要问题在于对变量作用域以及 &lt;code&gt;:=&lt;/code&gt; 的理解：&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; client *http.Client&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; tracing &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 这个 client 是一个新的变量&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    client, err := createClientWithTracing()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; err != &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; err&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 如果这里不打印的话，会报 declared but not use 的错误&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    log.Println(client)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    client, err := createDefaultClient()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; err != &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; err&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    log.Println(client)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Use client&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>操作系统进程</title>
    <link href="https://bqyang.top/2022/os/process/process/"/>
    <id>https://bqyang.top/2022/os/process/process/</id>
    <published>2022-06-24T13:49:47.178Z</published>
    <updated>2022-06-26T05:46:10.078Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2022/06/24/kjNFfKicts1XbDZ.png"></p><p>读了几章关于操作系统进程的相关内容，看几个简单的课后习题，从实际代码中去体会进程的特性。</p><span id="more"></span><p>1.在父进程中声明一个变量，然后创建子进程，两个进程都去修改这个变量会是什么结果？</p><p>哇，不动手实践一下是还真是没搞清楚，虽然在理论部分说到了，fork() 其实就是对父进程进行了拷贝操作。没有实践时以为会像多线程共享变量那样，真正敲过代码后发现，每个进程内的变量都是独立于父进程的，所以对本进程中数据的修改并不会影响父进程中的数据。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> child = fork();</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (child &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fork child err\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (child == <span class="number">0</span>) &#123;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;after exec count++ %d \n&quot;</span>, count);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (child &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        count = <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;the count is %d\n&quot;</span>, count);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.多进程操作同一个文件</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// file.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;i am parent, my pid is %d\n&quot;</span>, (<span class="keyword">int</span>)getpid());</span><br><span class="line">    FILE *fd = fopen(<span class="string">&quot;./info.txt&quot;</span>, <span class="string">&quot;a+&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> rc = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;new process failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rc == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="built_in">fputs</span>(<span class="string">&quot;STFW....\n\n&quot;</span>, fd);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child write finished\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rc &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="built_in">fputs</span>(<span class="string">&quot;hello RTFMMM\n\n&quot;</span>, fd);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent write finished\n&quot;</span>);</span><br><span class="line">        <span class="comment">//int data = wait(NULL);</span></span><br><span class="line">        <span class="comment">//printf(&quot;%d\n&quot;, data);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如程序中看到的，我们在两个进程中操作同一个文件描述符，讲道理这种没加约束的并发写操作都是存在问题的。但是我这里看文件中的内容有点过于正确。。</p><p>3.这题不让我们使用wait实现，子进程先完成某些打印，没明白想具体考察什么..</p><p>4.尝试不同的 <code>exec execl execle execlp execv execvp execvpe</code> 并思考为什么要有这么多的变种？</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rc = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rc == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> *myargs[<span class="number">3</span>];</span><br><span class="line">        myargs[<span class="number">0</span>] = strdup(<span class="string">&quot;ls&quot;</span>);</span><br><span class="line">        myargs[<span class="number">1</span>] = strdup(<span class="string">&quot;-la&quot;</span>);</span><br><span class="line">        myargs[<span class="number">2</span>] = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">int</span> result = execvp(myargs[<span class="number">0</span>], myargs);</span><br><span class="line">        <span class="comment">// can not reach</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, result);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rc &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> childs = wait(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, childs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 execl 时，第一个和第二个参数都是可执行文件的路径，第三个参数开始就是自带的一些参数比如 <code>-la</code>，最后一个参数需要传 NULL 而且要转成 char * 类型的空指针：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *myargs[<span class="number">3</span>];</span><br><span class="line">myargs[<span class="number">0</span>] = strdup(<span class="string">&quot;/bin/ls&quot;</span>);</span><br><span class="line">myargs[<span class="number">1</span>] = strdup(<span class="string">&quot;-la&quot;</span>);</span><br><span class="line">myargs[<span class="number">2</span>] = strdup(<span class="string">&quot;/root&quot;</span>);</span><br><span class="line"><span class="keyword">int</span> result = execl(myargs[<span class="number">0</span>], myargs[<span class="number">0</span>], myargs[<span class="number">1</span>], myargs[<span class="number">2</span>], (<span class="keyword">char</span> *) <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>后续就不一一举例了，具体内容可以参考 [<a href="https://linuxhint.com/exec_linux_system_call_c/">这里</a>]。</p><p>5.double wait 在父进程中执行 wait 函数，在子进程中也执行 wait 函数，这时会发生什么？</p><p>没有实践时，我认为会直接卡死，产生相互等待的情况，正如 go 中 all goroutine asleep.</p><p>但是，神奇的事情又发生了，这个程序不但没卡死，还正确的执行了。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// doubleWait.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rc = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rc == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;start exec child %d proces\n&quot;</span>, (<span class="keyword">int</span>)getpid());</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="number">111</span>);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rc &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;start wait child&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> childs = wait(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, childs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很意外，当这个 <code>111</code> 打印出来后恍然大悟，我们在父进程中执行了 fork 这时候调用 wait 可以得到返回的子进程 pid。但是当你在子进程中执行 wait 时，是没有任何子进程的子进程，所以 wait 会直接返回。（还是要多动手实践呀..自己这个脑子..并不靠谱）</p><h2 id="进程相关-API"><a href="#进程相关-API" class="headerlink" title="进程相关 API"></a>进程相关 API</h2><ul><li>创建进程 – fork()，fork() 执行的是状态机的复制；<strong>状态机的复制</strong><ul><li>fork 的返回值，如果是父进程执行，返回的是子进程的Pid；如果是子进程执行，返回的是 0；</li></ul></li></ul><p>画出下面的状态机：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pid_1 = fork();</span><br><span class="line">    <span class="keyword">int</span> pid_2 = fork();</span><br><span class="line">    <span class="keyword">int</span> pid_3 = fork();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>, pid_1, pid_2, pid_3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>printf 缓冲区与 fork 复制：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">        fork();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Hello\n&quot;</span>);        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">        wait(<span class="literal">NULL</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>fork 会将 printf 的缓冲区也复制</p></blockquote><ul><li>execve()， fork() 只能对父进程执行拷贝，exec 可以启动一个子进程执行另一段代码；<strong>状态机的重置</strong>；</li><li>exit(); 销毁进程；<strong>状态机的销毁</strong>；</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2022/06/24/kjNFfKicts1XbDZ.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;读了几章关于操作系统进程的相关内容，看几个简单的课后习题，从实际代码中去体会进程的特性。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>linker and loader</title>
    <link href="https://bqyang.top/2022/os/linker&amp;loader/"/>
    <id>https://bqyang.top/2022/os/linker&amp;loader/</id>
    <published>2022-06-23T10:30:51.735Z</published>
    <updated>2022-06-24T15:12:45.640Z</updated>
    
    <content type="html"><![CDATA[<p>学习下 linker 和 loader 中的内容，记录一下学习过程遇到的笔记以及知识点。主要的内容来自 csapp。</p><span id="more"></span><h3 id="为什么要学链接"><a href="#为什么要学链接" class="headerlink" title="为什么要学链接"></a>为什么要学链接</h3><ul><li>理解链接器能帮助我构造大型程序</li><li>理解链接器能帮助我避免一些危险的编程错误</li><li>理解链接器能帮助我理解语言中作用域规则的实现</li><li>理解链接器能帮助我理解其他系统概念</li><li>理解链接器能帮助我利用共享库</li></ul><p>这是文中提到的一些关键点，我个人更想了解的是，linker 和 loader 的执行过程，毕竟 Go 是编译类型的语言，还是有必要去了解一下其底层的编译的内容的。</p><p>书中的例子都是 C 语言实现的，只需要你简单了解一下语法即可，很简单。</p><h3 id="编译器驱动程序"><a href="#编译器驱动程序" class="headerlink" title="编译器驱动程序"></a>编译器驱动程序</h3><p>一个编译的过程有以下几个步骤：（一个 gcc 可以拆成以下四步）</p><ul><li>语言预处理器</li><li>编译器</li><li>汇编器</li><li>链接器</li></ul><p>（这个就像 Go 语言中，一个 go build 可以拆分成 compile 和 link 的过程。）</p><p>比如要编译 main.c 和 sum.c 文件， 通过 <code>gcc -Og -o prog main.c sum.c</code> 即可输出 prog 可执行文件。也可以一步一步拆解进行，如下：</p><ul><li>预处理器： <code>cpp main.c ./main.i</code>  翻译成一个 ASCII 码的中间文件</li><li>编译器： <code>cc1 ./main.i -Og -o ./main.s</code>  翻译成一个ASCII 码的<strong>汇编语言文件</strong></li><li>汇编器： <code>as -o ./main.o ./main.s</code>  翻译成一个<strong>可重定位目标文件</strong></li><li>链接器： <code>ld -o prog ./main.o ./sum.o</code> 生成一个<strong>可重定位目标文件</strong></li></ul><p>通过 gcc 的方式</p><ul><li>gcc -E hello.c -o hello.i</li><li>gcc –S hello.i –o hello.s</li><li>gcc –c hello.s –o hello.o</li><li>gcc hello.o –o hello</li></ul><h3 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h3><ul><li>符号解析<ul><li>目的是将每个符号引用正好和一个符号定义关联起来，比如将符号对应到函数、全局变量等。</li></ul></li><li>重定位<ul><li>把每个符号定义与一个内存位置关联起来。</li></ul></li></ul><h3 id="目标文件"><a href="#目标文件" class="headerlink" title="目标文件"></a>目标文件</h3><p><a href="https://www.bqyang.top/2021/elf">点我跳转到 ELF</a></p><h3 id="可重定位目标文件"><a href="#可重定位目标文件" class="headerlink" title="可重定位目标文件"></a>可重定位目标文件</h3><p><a href="https://www.bqyang.top/2021/elf">点我跳转到 ELF</a></p><h3 id="符号和符号表"><a href="#符号和符号表" class="headerlink" title="符号和符号表"></a>符号和符号表</h3><ul><li>由模块 m 定义并能被其他模块引用的<strong>全局符号</strong>。<ul><li>C 语言：全局链接器符号对应于非静态的C函数和全局变量。</li><li>Go语言：可以理解为在 util 包下定义的全局函数或全局变量。</li></ul></li><li>由其他模块定义并被模块 m 引用的<strong>全局符号</strong>。这些符号称为外部符号。<ul><li>C 语言：对应于在其他模块中定义的非静态 C 函数和全局变量。</li><li>Go 语言： 可以理解为在 util 包下引用了  time 包中的内容。</li></ul></li><li>只被模块 m 定义和引用的<strong>局部符号</strong>。<ul><li>C 语言：对应于带 static 属性的 C 函数和全局变量。</li><li>可以理解为在 Go util 包中定义的不可导出的函数或变量。</li></ul></li></ul><p>注意：C 语言中使用 static 关键字，隐藏模块内部的变量和函数声明，就像 Java 中的 private 和 public。在 C 中，任何带有 static 属性声明的全局变量或函数都是模块私有的。类似的，任何不带 static 属性的全局变量和函数都是公共的，可以被其他模块访问。</p><p>符号表是如何记录一个函数的：</p><p><img src="https://s2.loli.net/2022/06/23/D84UqxfTuAZneNS.png"></p><p>如上图中所示，一个函数在符号表中被称为条目，该条目中包括了函数的名称，函数的位置，函数是局部的还是全局的。</p><ul><li>name 表示字符串表中的字节偏移，指向符号的以 null 结尾的字符串名字。<ul><li>可以理解为函数名或者变量名字。</li></ul></li><li>value 表示符号的地址。<ul><li>对于可重定位的模块来说，value 是距定义目标的节的起始位置的偏移。</li><li>对于可执行目标文件来说，该值是一个绝对运行时地址。</li></ul></li><li>size 表示目标的大小。</li><li>type 表示要么是数据，要么是函数。</li><li>binding 表示是局部的，还是全局的。</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.c 文件</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> n)</span></span>;      </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">2</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;       </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;                 </span><br><span class="line">    <span class="keyword">int</span> val = sum(<span class="built_in">array</span>, <span class="number">2</span>); </span><br><span class="line">    <span class="keyword">return</span> val;              </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>乍一看是不是感觉很熟悉，Go 看起来也差不多的哈哈。通过上述的<strong>预处理-编译-汇编-链接</strong>这三步，将 main.c 文件编译成 main.o 文件。然后再查看 main.o 文件的符号表，如下图所示：</p><p><img src="https://s2.loli.net/2022/06/23/SzdTlrF6DXu2aUQ.png"></p><p>可以看到我们在 main.c 中定义的全局变量 array，sum 和 main。</p><p>Ndx 表示所在的 section，.text 索引为 1，以此类推。</p><p>再来看个简单的例子，以下内容来自 csapp 的课后习题。代码如下所示，</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// swap.c</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> buf[];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *bufp0 = &amp;buf[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">int</span> *bufp1;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下过程就是将 buf 中的两个元素进行交换</span></span><br><span class="line">    bufp1 = &amp;buf[<span class="number">1</span>];</span><br><span class="line">    temp = *bufp0;</span><br><span class="line">    *bufp0 = *bufp1;</span><br><span class="line">    *bufp1 = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// m.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> buf[<span class="number">2</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    swap();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样通过<strong>预处理-编译-汇编-链接</strong>的前三步，输出 swap.o 和 m.o 文件。按部就班的来，我们再看看 swap.o 的符号表长什么样。</p><p><img src="https://s2.loli.net/2022/06/23/UQ593ENuTzKrZMk.png"></p><table><thead><tr><th align="center">符号</th><th align="center">.symtab 条目？</th><th align="center">符号类型</th><th align="center">在哪个模块定义</th><th align="center">节</th></tr></thead><tbody><tr><td align="center">buf</td><td align="center">是</td><td align="center">外部</td><td align="center">m.o</td><td align="center">可以自行查看 m.o 确定</td></tr><tr><td align="center">bufp0</td><td align="center">是</td><td align="center">全局</td><td align="center">swap.o</td><td align="center">.data</td></tr><tr><td align="center">bufp1</td><td align="center">是</td><td align="center">全局</td><td align="center">swap.o</td><td align="center">COM</td></tr><tr><td align="center">swap</td><td align="center">是</td><td align="center">全局</td><td align="center">swap.o</td><td align="center">.text</td></tr><tr><td align="center">temp</td><td align="center">否</td><td align="center">-</td><td align="center">-</td><td align="center">都不在（栈分配）</td></tr></tbody></table><ul><li>.symtab 填是否</li><li>符号类型填全局、局部、外部</li><li>在哪个模块定义，即为在哪个文件中定义的</li><li>节，Ndx 对应的 section</li></ul><p>可以简单的做一下，看看你是否真的能够读懂 .symtab（符号表）。笔者一开始理解的符号表，只是其字面意思，以为就是用来存储符号的表，在网上查阅相关资料后，知道他存储的是函数和变量，在阅读 csapp 相关章节后，对于符号表的内容又有了进一步认识。</p><p>注：关于 COM、UND、ABS 的相关内容，请移步到 <a href="https://www.bqyang.top/2021/elf">ELF</a> 中进行查阅。</p><h3 id="符号解析"><a href="#符号解析" class="headerlink" title="符号解析"></a>符号解析</h3><h4 id="链接器如何解析多重定义的全局符号"><a href="#链接器如何解析多重定义的全局符号" class="headerlink" title="链接器如何解析多重定义的全局符号"></a>链接器如何解析多重定义的全局符号</h4><ul><li><p>强符号</p><p>函数和已初始化的全局变量是强符号。</p></li><li><p>弱符号</p><p>未初始化的全局变量是弱符号。</p></li></ul><p>规则如下：</p><ol><li>不允许有多个同名的强符号</li><li>如果有一个强符号和多个弱符号同名，那么选择强符号</li><li>如果有多个弱符号同名，那么从这些弱符号中任意选择一个</li></ol><h4 id="与静态库链接"><a href="#与静态库链接" class="headerlink" title="与静态库链接"></a>与静态库链接</h4><p>将所有相关的目标模块打包成为一个单独的文件，称为静态库（static library）。</p><p>在 linux 系统中，静态库以一种称为存档（archive）的特殊文件格式存放在磁盘中。存档文件是一组连接起来的可重定位目标文件的集合，有一个头部用来描述每个成员目标文件的大小和位置。archive 文件名后缀未 .a 标识。</p><h4 id="链接器如何使用静态库来解析引用"><a href="#链接器如何使用静态库来解析引用" class="headerlink" title="链接器如何使用静态库来解析引用"></a>链接器如何使用静态库来解析引用</h4><p>注：</p><p>​    1.在这里抛出一个问题， Go 语言中，我们在 main 包中调用了一个库函数，比如 <code>math.Max(1, 2)</code> ，请你思考一下，在程序编译过程中是把整个 math 模块都编译了进来，还是说只会将 main 包中用到的库函数编译进来？</p><p>​    2.如题，链接器如何使用静态库解析引用</p><p>在解析过程中要维护三个集合</p><ul><li>一个可重定位目标文件的集合 E，这个集合中的文件会被合并起来形成可执行文件</li><li>一个未解析的符号集合 U</li><li>一个在前面输入文件中已定义的符号集合 D</li></ul><p><img src="https://s2.loli.net/2022/06/23/oTYf4JLwVx3X6KU.png">注意：如果最后集合 U 是不为空的，说明有的符号未能在可执行目标文件或者静态库中找到 <code>symbol not found</code> 。</p><p>小结：至此我们已经学习过了，符号的定义，符号的解析过程。把代码中每个符号的引用和确切的一个符号定义关联了起来。</p><h3 id="重定位"><a href="#重定位" class="headerlink" title="重定位"></a>重定位</h3><p>重定位是由两步组成的：</p><ul><li>重定位 section 和 符号定义。在这一步中，链接器将所有相同类型的节合并为同一类型的新的聚合节。比如讲所有目标文件中的 <code>.data</code> section 合并成一个 <code>.data</code> section 并且这个 section 最后就是可执行目标文件的section。</li><li>重定位 section 中的符号引用。在这一步中，链接器修改 <code>.text</code> 和 <code>.data</code> 中对每个符号的引用，使得它们指向正确的运行时地址。</li></ul><h4 id="重定位条目"><a href="#重定位条目" class="headerlink" title="重定位条目"></a>重定位条目</h4><p>为什么需要重定位条目？</p><ul><li>因为汇编器生成一个目标文件的时候，并不知道该文件中 <code>.data</code> 和 <code>.text</code> section 最终要在内存的什么位置，与此同时，汇编器也不知道这个模块引用的任何外部定义的函数或者全局变量的位置。</li><li>所以汇编器在遇到一个最终位置未知的符号引用，它就会生成一个重定位条目。告诉链接器将目标文件合并成可执行文件时如何修改这个引用。</li></ul><p><strong>代码重定位条目放在 <code>.rel.text</code> 中</strong></p><p><strong>已初始化数据的重定位条目放在 <code>.rel.data</code> 中</strong></p><p>什么是重定位条目？</p><p><img src="https://s2.loli.net/2022/06/23/uZaVLfQmcbBEP9v.png"></p><p>参数解释：</p><ul><li>offset 需要被修改的引用的偏移</li><li>表示被修改引用应该指向的符号，在 symtab 中的位置</li><li>type 告知链接器如何修改引用</li><li>addend 是一个有符号常数，一些类型的重定位要使用它对被修改引用的值做偏移调整。</li></ul><p>注：我们只需要关注两个最基本的重定位条目</p><ul><li><p>R_X86_64_PC32 重定位一个使用 32 位 PC 相对地址的引用。在指令中编码的 32 位值加上 PC 的当前运</p><p>行时值，得到有效地址。</p></li><li><p>R_X86_64_32 重定位一个使用 32 位绝对地址的引用。</p></li></ul><h4 id="重定位符号引用"><a href="#重定位符号引用" class="headerlink" title="重定位符号引用"></a>重定位符号引用</h4><p>1.重定位 PC 相对引用</p><p>2.重定位 PC 绝对引用    </p><p><img src="https://s2.loli.net/2022/06/23/vcVxoFJTnpdyabQ.png"></p><p>这张图主要讲了，针对相对或绝对的不同类型，对应到不同的计算方式。</p><h3 id="加载可执行目标文件"><a href="#加载可执行目标文件" class="headerlink" title="加载可执行目标文件"></a>加载可执行目标文件</h3><p>当我们通过命令行调用我们的可执行文件时 <code>./prog</code> shell 会认为这是一个可执行目标文件，然后通过某个在内存中称为加载器（loader） 的操作系统代码来运行 <code>./prog</code> 。</p><p>加载器将可执行目标文件中的代码和数据从磁盘加载到内存，然后通过跳转到程序的第一条指令或入口来运行该程序。程序被复制到内存并运行的过程称为<strong>加载</strong>。</p><h4 id="加载器实际上是如何工作的："><a href="#加载器实际上是如何工作的：" class="headerlink" title="加载器实际上是如何工作的："></a>加载器实际上是如何工作的：</h4><p>书中提到，这里只是一个简单的概述。</p><p>Linux 系统中的每个程序都运行在一个进程上下文中，有自己的虚拟地址空间。当 shell 运行一个程序时，父 shell 进程生成一个子进程，它是父进程的一个复制。子进程通过 execve 系统调用启动加载器。加栽器删除子进程现有的虚拟内存段，并创建一组新的代码、数据、堆和栈段。新的栈和堆段被初始化为零 通过将虚拟地址空间中的页映射到可执行文件的页大小的片 (chunk), 新的代码和数据段袚初始化为可执行文件的内容。最后，加载器跳转到 _start地址，它最终会调用应用程序的 main 函数。除了一些头部信息，在加栽过程中没有任何从磁盘到内存的数据复制 直到 CPU 引用一个被映射的虚拟页时才会进行复制，此时，操作系统利用它的页面调度机制自动将页面从磁盘传送到内存。</p><h3 id="动态链接共享库"><a href="#动态链接共享库" class="headerlink" title="动态链接共享库"></a>动态链接共享库</h3><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><p><a href="https://stackoverflow.com/questions/6687630/how-to-remove-unused-c-c-symbols-with-gcc-and-ld">https://stackoverflow.com/questions/6687630/how-to-remove-unused-c-c-symbols-with-gcc-and-ld</a></p></li><li><p>简书-图解静态库链接过程-<a href="https://www.jianshu.com/p/4510b47ecd8a">https://www.jianshu.com/p/4510b47ecd8a</a></p></li><li><p>csapp 第七章</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;学习下 linker 和 loader 中的内容，记录一下学习过程遇到的笔记以及知识点。主要的内容来自 csapp。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>git rebase</title>
    <link href="https://bqyang.top/2022/vcs/git/git-rebase/"/>
    <id>https://bqyang.top/2022/vcs/git/git-rebase/</id>
    <published>2022-06-23T10:30:51.732Z</published>
    <updated>2021-12-09T11:07:09.051Z</updated>
    
    <content type="html"><![CDATA[<p>以前合分支，用的都是 git merge 但是发现用 merge 合并总是会出现一条自动添加的 commit 这样导致历史提交记录显得非常乱。</p><span id="more"></span><p>就比如下面这个样子</p><img src="https://gitee.com/yangbaoqiang/images/raw/master/blogpics/image-20211209110709842.png" alt="image-20211209110709842" style="zoom:67%; margin: 0 auto;"/><p>没几个 commit 全都是 Merge branch xxxx into xxxx。有一次我在提交 pr 的时候，当时已经提交完了，但是显示我的分支是落后的，上边有个 merge 按钮，我点了以后就出现了这种“不干净的” commit。</p><p>在了解之后，通过 rebase 命令可以避免这种情况，所以简单看下 git rebase 是怎么玩的。</p><p>rebase  和 merge 都是用来整合一个分支到另一个分支上，但是主要的区别为：rebase 后产生的是一个线性的历史分支。可以结合实际使用场景举个例子：</p><p>假设，当前有一个 main 分支，我要开发一个查询功能，所以基于 main 新建了一个 feature 分支。当你在  feature 分支上开发完成后，与此同时，main 分支已经被更新了，你想在  feature 分支上获取 main 刚刚提交的 commit，这时候有两种方式</p><ul><li>merge</li><li>rebase</li></ul><p>想要以一种最“干净”的方式来合并，就好像你这个 branch 刚刚从 main 分支上新建出来的一样，这时候就要用到 git base。</p><p>（所谓的干净是什么意思呢，我理解的是，它看起来是干净的，并且在需要回滚的时候也是非常清除的。）</p><img src="https://gitee.com/yangbaoqiang/images/raw/master/blogpics/v2-73db63a5abb3cac70f913155a854cf29_1440w.jpg" alt="v2-73db63a5abb3cac70f913155a854cf29_1440w" style="zoom:50%; margin: 0 auto;" /><p>如上图所示，主要的区别就是怎么对待以前的 commit 信息。</p><p>参考：</p><p><a href="https://zhuanlan.zhihu.com/p/75499871">知乎-丁哥开讲</a></p><p><a href="https://www.atlassian.com/git/tutorials/rewriting-history/git-rebase">bitbucket</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;以前合分支，用的都是 git merge 但是发现用 merge 合并总是会出现一条自动添加的 commit 这样导致历史提交记录显得非常乱。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>DDIA 读书笔记</title>
    <link href="https://bqyang.top/2022/DDIA/"/>
    <id>https://bqyang.top/2022/DDIA/</id>
    <published>2022-06-23T10:30:51.729Z</published>
    <updated>2022-07-05T11:01:58.273Z</updated>
    
    <content type="html"><![CDATA[<p>Designing Data-intensive Applications</p><span id="more"></span><h2 id="CH1：-Reliable-Scalable-Maintainable"><a href="#CH1：-Reliable-Scalable-Maintainable" class="headerlink" title="CH1： Reliable, Scalable, Maintainable"></a>CH1： Reliable, Scalable, Maintainable</h2><p>主要解释这三个词是什么意思，以及从哪些角度进行思考。</p><p><strong>影响设计数据系统的多个因素</strong></p><ul><li>遗留系统的依赖问题</li><li>设计这个系统的人的经验和技能</li><li>要交付的时间</li><li>对风险的容忍度</li><li>监管限制？ 这个没搞懂，是权限的意思么？</li></ul><p>在 DDIA 中主要关注三个方面</p><ul><li><p>Reliability 可靠性</p><p>即使遇到硬件或软件的 fault，人为的 error 系统应该正常工作。</p></li><li><p>Scalability 可扩展性</p></li></ul><p>​        随着系统的增长（规模上），能够妥善的处理增长带来的问题。</p><ul><li><p>Maintainablity 可维护性</p><p>人员变动随着时间变化着，不同的人维护着同一套代码。</p></li></ul><p><strong>Reliablity</strong></p><ul><li>应用程序像用户期待的那样执行函数</li><li>可以容忍用户错误的操作或非常规的操作</li><li>性能可以满足日常需求，并且足以应对突发的负载</li><li>能够阻止未授权的请求</li></ul><p>作者给我们总结了，如果上述的这些条件都满足了，意味着正常工作，我们可以粗略的认为可靠性就是，在系统出错的时候，仍然能正常工作。</p><p>这里对错误和失败又进行了区分，有哪些是可以容忍的，哪些是不行的。</p><p>错误通常被定义为系统中的一个组件偏离了最初的规范。比如一个接口本应该返回A，但是返回B了。失败通常表示整个系统宕机了，不能正常提供服务。</p><p>硬件错误</p><ul><li>硬盘故障，RAM 故障，电源被关闭了，插错网口了</li></ul><p>软件错误</p><ul><li>软件失控了，把所有计算资源都消耗了。</li><li>Linux 内核错误，导致程序都 hang 住了。</li><li>系统依赖的服务挂掉了，变成无响应的或者返回错误的响应。</li><li>Cascading failures 这种不知道中文怎么翻译，不过大概意思就是扇面的那种，一个错误导致多个，多个错误导致更多的错误。</li></ul><p>​    没有快捷的方法来解决这些系统性的错误在软件中，只能做好监控，识别差异（未能达到预期）</p><p>人为错误</p><ul><li>在某种程度上，最小化系统犯错的机会。</li><li>在出错最多的地方与引起错误的地方进行解耦。使用与生产环境一样的配置，来探索发现问题。</li><li>详细的测试工作，单元测试，系统测试，手动测试，自动测试等。</li><li>能够从人为制造的错误中快速进行恢复，最小化其带来的影响。比如，具备快速回滚的能力</li><li>配置好详细清晰的监控，比如性能监控和错误比率。当出错的时候，监控数据以及日志对于我们排查问题来说是无价的。</li><li>对员工有一个完整，良好的培训过程。</li></ul><p>总而言之，可靠性会关乎到公司，部门的信誉，和用户的体验也有很大联系。</p><p><strong>可扩展性</strong></p><p>可扩展性是用来描述系统在面对突发负载的能力。当讨论扩展性的使用，其实就是在考虑如下的两个问题：</p><ul><li>如果系统以某种特别的方式进行增长，我们可以采取什么措施来应对？</li><li>我们应该怎么增加计算资源来处理额外的负载？</li></ul><p><em>负载</em></p><p>负载可以用一些参数来表述：数据库的读写比，同一时间在线的用户数量，缓存的命中率..</p><p>作者以 Twitter 为例，具体描述了<em>负载</em>。</p><p><em>性能</em></p><p>在网络应用中，性能更多的意味着响应时间。</p><p>是什么导致了每次响应时间都不相同？</p><ul><li>后台进程的上下文切换</li><li>网络丢包，TCP 重传</li><li>GC pause</li><li>页缺失导致从磁盘重新加载</li><li>等等</li></ul><p><strong>可维护性</strong></p><p>广为人知的是，软件中的主要开销是维护工作，而不是起初开发。比如，修 Bug，保证系统运行，调研失败原因，适应新的平台，偿还技术债务，添加新的特性等。</p><p>三个软件涉及原则：</p><ul><li><p>可操作性，Operability</p><p>能使运维团队很容易操作。</p></li><li><p>简易性，Simplicity</p><p>能让新的工程师很容易明白，尽量设计的简洁。</p></li><li><p>可进行性，Evolvability</p><p>能让工程师在修改的时候很方便，可以应对未被考虑到的需求变化，也可以用这几个词来形容，<em>extensibility</em>, <em>modifiability</em>, or <em>plasticity</em>.</p></li></ul><p>（上述的名词翻译都是我自己凭感觉搞得，不存在普遍性）</p><p>作者简述了一个好的运维团队应该要做的事情..</p><h2 id="CH2：Data-Models-And-Query-Languages"><a href="#CH2：Data-Models-And-Query-Languages" class="headerlink" title="CH2：Data Models And Query Languages"></a>CH2：Data Models And Query Languages</h2><p>数据模型是按照每一层进行分布的，关键的问题在于每一层是如何表示的？</p><ul><li>实际生活中，有组织，商品，现金流，传感器，等。我们以对象或者数据结构的方式对其进行建模。可以理解为数据表达方式</li><li>这些数据是以哪种结构进行存储的，JSON\XML\数据库中的表结构，等等。</li><li>这些数据是存储在哪种物理器件上的，内存，磁盘，网络中。</li><li>在更底层，这些内容以电子，脉冲信号的形式存在。</li></ul><p>万变不离其宗，每一层都是对底层的封装，提供更简洁接口。</p><p><strong>NoSQL 数据库的诞生</strong></p><p>采纳 NoSQL 数据库的几个驱动力：</p><ul><li>需要比关系数据库更容易实现的可扩展性，包括非常大的数据集或非常高的写入吞吐量</li><li>免费开源的软件</li><li>关系型数据模型并不支持的查询</li><li>对关系模式的不看好，渴望一个更加动态和富有表达力的数据模型</li></ul><p><strong>Many-to-One and Many-to-Many</strong></p><p>作者在这里探讨了一个点，在多对一或多对多的关系中，为什么存储另一个字段的 ID，二不是值。</p><p>举个例子，用户对应的地区，职业，一个用户可以对应到多个地区，工作，家庭住址等，也可以对应到多个职业。</p><p>所以，在存储用户对应的这些信息的时候，如果说在页面上需要用户自己输入，那存储用户的具体信息是有意义的。如果在页面上呈现出来的是一个标准的下拉列表，让用户去选择，有很多的好处：</p><ul><li>一致的格式和拼写</li><li>避免歧义，比如重名问题</li><li>利于更新 – 因为名称仅存在了一个地方，其他都是对它 ID 的引用</li><li>本地化支持 – 作者想表达的是国际化时候很方便</li><li>利于搜索</li></ul><p><strong>网络模型</strong>（The network model）</p><p>太复杂不够灵活。</p><p><strong>关系模型</strong></p><p>即使索引改变了，也不需要我们在代码中手动调整指定，查询优化器会自定的帮我们做这些事情。</p><p><strong>文档模型与关系模型</strong></p><p>有利于文档模型的一点就是灵活性，更好的局部性（可以理解为相关的信息都在一起），关系模型中支持连表查询，多对一，多对多的关系。</p><p>文档模型中的限制：</p><ul><li>不能直接引用文档中嵌套的数据，取而代之的是需要说明那个引用在文档中的路径。作者提到只要嵌套不是很深，都不是问题。</li><li>对 Join 这类查询，无法提供良好的支持，但主要取决于应用。作者提到，比如在用于分析的应用中，可能永远用不到多对多的关系，这时采用文档数据库来存储更合适，比如什么时间发生了什么时间。</li></ul><p>文档模型的灵活性</p><p>有一点被误解的是，文档数据库是<em>无模式的</em>。但是，当代码从数据库中读取数据的时候，通常会假设某种结构用于接收读到的数据，这种模式是隐式的，也不是由数据库强迫加上的。</p><p>对于上述情况，有一个更专业的术语 <em>schema-on-read</em> ， 还有一种 <em>schema-on-write</em> 在写入数据库的时候就已经明确了</p><p><em>schema-on-read</em> 像动态类型语言（python），<em>schema-on-write</em> 像强类型的语言。</p><p>这两种模型的区别在应用想要修改数据格式的时候非常明显：</p><p>作者通过修改名称举例，目前采用一个字段进行存储名称，但是现在想通过 <em>first name</em> 和 <em>last name</em> 的模式进行存储。</p><p>文档模型</p><ul><li>直接在代码中做处理即可</li></ul><p>关系模型</p><ul><li>需要在数据库中添加列</li><li>然后更新那一列的值</li></ul><blockquote><p>在数据库中添加列的操作会使数据库停机，大多数数据库执行 Alter 语句通常在几毫秒内就可以完成，但是 MySQL 中会复制整张表，当处理一张拥有很多数据的表时，这可能会执行几分钟甚至几小时</p></blockquote><p>什么时候使用文档模型最合适？作者给出了两点参考</p><ul><li>一个对象有很多种类型，把每种类型的对象放在单独的表中不切合实际。</li><li>外部系统决定数据结构，可能随时改变。</li></ul><p>数据库未来的发展：作者提到的是数据库会结合这两者的优点，让应用从中受益。</p><p><strong>图状数据模型</strong></p><p>关系模型的数据库虽然支持多对多的关系，如果应用中存在大量的多对多映射，应考虑使用图来建模。</p><p>图由两种对象组成： 顶点（也称为结点或实体）和边（也称为关系或弧）。 很多数据</p><p>可以建模为图。 典型的例子包括：</p><ul><li><p>社交网络</p><p>顶点是人，边表示哪些人相互认识</p></li><li><p>网络图</p></li><li><p>公路或铁路网</p><p>顶点是交叉路口，边表示公路或铁路</p></li></ul><p><em>属性图</em> 的几个重要方面</p><ul><li>一个顶点可以通过任意一边连接到其他顶点。没有模式限制哪个类型可以连接哪个类型或者不可以连接。</li><li>给定一个顶点，可以很高效的找出进来的边，和出去的边。因此可以遍历整张图。</li><li>使用不同的标签代表不同的关系，可以存储各种各样的信息在一张图中，并且可以维护一个整洁的数据模型。</li></ul><blockquote><p>选择性跳过一些内容，不是很感兴趣.. 主要是关于图的查询，比如在关系型数据库中如何使用 SQL 等，还介绍了其他几种不同的图查询语言。</p></blockquote><p><strong>总结</strong></p><p>这一节主要学到了，document，graph，relational，三种数据模型，</p><ul><li><p>document 的使用场景主要是，各个数据之间都是独立，一条数据不存在（几乎不）与另一条的关联关系。</p></li><li><p>graph 与 document 相反，在图模型中，任何事物都有可能与其他事物关联到一起。</p></li><li><p>relational 关系模型是我们接触最频繁的..</p></li></ul><p>突然想到一个问题，要设计某些东西的时候，我们好像没有去发散的思考，这个场景下，是否真的适合使用 MySQL，取而代之的是，为了往 MySQL 上套，强行这样思考。</p><p>确实这是一个值得深思的问题，研究问题要从问题的本质出发，而不要被工具束缚。</p><h2 id="CH3：Store-and-Retrieval"><a href="#CH3：Store-and-Retrieval" class="headerlink" title="CH3：Store and Retrieval"></a>CH3：Store and Retrieval</h2><p>通过标题来看应该是讲，数据的存储和检索。</p><p><em>作为一个应用开发者，为什么需要关心数据库是如何存储和检索数据的？</em></p><ul><li>虽然我们不需要从头开始实现一个数据库，但是我们需要知道如何进行选择一种最适合我们的</li></ul><p>作者通过一个文件进行举例，文件中的每一行都是一个 k-v 形式的键值对。当前这种情况也会遇到很多问题，比如控制并发写入，怎样进行错误处理等..</p><p>另外，性能也存在一定的问题，想要寻找某个 Key 对应的 Value 时，只能从头到尾进行遍历，作者由此引出<strong>索引</strong></p><p>不同类型索引之间的共同点：</p><ul><li>都需要额外增加元数据信息来提高搜索速度</li></ul><p>索引的添加和删除并不会影响数据本身的内容，只会影响查询数据的性能。</p><p><strong>Hash Indexes</strong></p><p>作者最开始还是通过文件进行举例，文件还是存储在磁盘上，然后在内存中存储一个 <em>Hash Map</em> ， Map 中存储了 key value 是 真正的 val 在 磁盘中的位置。</p><p><img src="https://s2.loli.net/2022/06/23/sHOQul1pcin5vVW.png">为了防止 log 文件过大的解决办法：</p><ul><li>设定某一个阈值，当 log 文件达到这个值的时候，就把他拆分成几份。</li><li>后续的写操作都在另一个新的文件中进行写入。</li><li>压缩 log 文件，只保留对 key 的最新一次更新，如下。</li></ul><p><img src="https://s2.loli.net/2022/06/23/vlzUqd79fyIbaRo.png"></p><ul><li>通过压缩后，可能会导致某一段的文件过小，这里也可以进行段的合并操作，如下。</li></ul><p><img src="https://s2.loli.net/2022/06/23/Fryci6t4GCm7JIK.png"></p><p>正如之前看到的，所有对 log 文件的操作都基于 append 的，为什么不能直接更新之前的操作呢？使用 append-only 的好处是：</p><ul><li>append 的操作是顺序写，而不是随机写，速度快</li><li>如果 log 文件是 append-only 的，并发和崩溃恢复很容易实现</li><li>合并之前被拆分的 log 文件，有助于防止 log 文件的碎片化</li></ul><p><em>Hash Map</em> 带来的限制：</p><ul><li>hash map 不能太大，必须保证内存可以装下</li><li>范围查询效率不高</li></ul><p><strong>SSTable and LSM-Trees</strong></p><p>SSTable (Sorted String Table) 按照 Key 进行排序，如下。</p><p><img src="https://s2.loli.net/2022/06/23/sJRpG2EBAkNMuqC.png"></p><p>看的过程中我想到一个问题，不同的 key 在不同的 log 文件中都有存在，是怎么在合并后的 log 文件中进行存储的呢？难道是每次读取到同样的 key 的时候都要再进行一次更新操作吗？</p><p>紧接着，作者在下文中就提到了这个问题：</p><p><code>What if the same key appears in several input segments?</code></p><p>在看“答案”的时候，作者提到了一点，当出现这种情况的时候，以最新的 log 文件中的数据为准，忽略旧的（在这之前操作）log 文件。</p><p>作者简述了一个采用 SSTable 和平衡树（红黑，AVL）作为底层数据结构的存储引擎，工作流程大致如下：</p><ul><li>当有写操作时，将写操作的内容加入到内存中的平衡树，这种结构也被称为 <code>memtable</code></li><li>当 <code>memtable</code> 超过某个阈值的时候，将其以 SSTable 的形式写入到磁盘中。如果这个时候有新的写操作，可以在一个新的 memtable 中进行插入。</li><li>当有读操作的时候，会从 memtable 中进行查找，然后在最近的 SSTable 中进行查找，直至找到最后一个</li><li>后台程序会将 log 文件进行合并、压缩操作。</li></ul><p>上述存储引擎存在一个问题，内存作为易失型存储，所以存在 memtable 中的数据是有可能丢失，为了解决这类问题，作者随后提到</p><ul><li>用一个存储在 disk 中的 log 文件用来存储操作日志，比如写操作发生时，不仅仅在 memtable 中进行插入，也在 log 文件中插入</li></ul><blockquote><p>该 log 文件是无序的，因为它只有在宕机等情况发生时才会用到，如果与之对应的 memtable 写入disk后，这个 log 文件也就变成无用的，可以删除掉。</p></blockquote><p><em>LSM-tree</em></p><p>LSM - log structured merge</p><p>当在 LSM-tree 中查找一个不存在的 key 时，需要从 memtable 找到最后一个 log 文件。为了优化这个问题，引入了 <code>Bloom Filter</code>。</p><p>LSM-tree 两种压缩策略</p><ul><li>size-tiered</li><li>leveled</li></ul><blockquote><p>以后有兴趣可以深入了解一下，这种存储的数据的策略，这里只是根据书中内容作为简要了解即可！</p></blockquote><p><em>B 树</em></p><p>学过很多次，看看作者是怎么结合实例进行讲解的。。</p><p>LSM 最后将数据划分到大小不一的 log 文件中（通常是 Mb）<strong>B</strong> 树采用的是，固定的块大小或页大小（通常大小为 4 KB）的方式进行存储。这样能更贴合硬件，因为磁盘也是采用这种固定大小块的方式进行数据的写入和存储。</p><p>B 树中，每一页都是存储在磁盘上，可以通过地址进行索引，并且页与页之间可以相互引用</p><p>分支因子：branch childs ，表示一个父节点拥有多少个子节点，实际使用中，分支因子的数量<em>取决于</em>存储页引用需要的空间大小和范围边界，通常来说是几百个。</p><p>在添加数据到叶子结点的时候，可能会导致页的拆分</p><p><img src="https://s2.loli.net/2022/06/23/nHFL8C3cNpUty5P.png"></p><p>假设当前page已经不能再容纳新的key时，在添加 key 334 后，进行了 page 的拆分。</p><p>平衡二叉树通过自旋算法，能想起来的有 LL，RR，LR，RL…保证了任意两个节点之间的只能有一个节点。我记得是有这么一条定义。。记不清楚了。。</p><p>作者举例，当 page = 4 KB，branching factor = 500 的时候，一个四层的 B 树可以容纳 250 TB 的数据。</p><p>如果在写入数据的时候，数据库崩溃了，会出现什么问题？</p><ul><li>比如，上述发生插入操作的时候，导致了 page 的分裂，这时候需要将当前这个 range 拆分成两个，并修改父节点对他们的引用。如果这时候数据库崩溃了，可能会出现类似<em>悬垂指针</em>的问题。为了解决这个问题，让数据库对崩溃有一定的容错能力，在实现 B-tree 的时候会额外在磁盘上添加一个数据结构，<em>write-ahead logging</em> (WAL, 也被称为 redo log)。</li></ul><blockquote><p>怪不得都说 DDIA 是必读书籍，读起来就是两个字，畅快。循序渐进，对我这种菜鸟来说太棒了！</p></blockquote><p>WAL ，append-only 的文件格式。<strong>在将修改操作实际应用到磁盘中数据的之前，必须将修改写入到这个文件中</strong>，恢复后，可以使用这个文件进行恢复。</p><p><strong>优化 B 树</strong></p><ul><li>copy-on-write</li><li>尽量减少key所占用的空间，可以通过缩写的方式，key 只是用来表明边界的。</li><li>保持相邻的key在磁盘上的位置也是相邻的，如果一个查询要查出一个很大范文的内容并要求是有序的，一页一页查找的效率十分低下。<ul><li>想法时候，但是随着数据的增长，很难维护一个这样的数据结构</li></ul></li><li>添加额外的指针，将兄弟节点连接起来，这样在遍历的时候就不需要回到父节点找到其他的兄弟节点。</li><li>从 B 树优化出来一个叫 <code>fractal tree</code> 听都没听过…</li></ul><p><strong>对比 B 树 和 LSM 树</strong></p><p>当我们评测存储引擎性能的时候有哪些事情是值得考虑的？</p><ul><li><em>write amplification</em>（写放大）<ul><li>在数据库的生命周期中，一次写入数据库的操作导致多次写入磁盘的操作被称为写放大。</li><li>注：SSD 被写入的次数是有限制的</li></ul></li></ul><p>LSM 优缺点：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TODO </span></span><br></pre></td></tr></table></figure><p><strong>索引</strong></p><ul><li>Secondary Index （二级索引）<ul><li>索引中 value 存储的是引用</li></ul></li><li>Clustered Index （聚簇索引）<ul><li>索引中 value 存储的是数据</li></ul></li><li>Covring Index （覆盖索引）<ul><li>是聚簇和非聚簇索引的一种折中方式</li><li>覆盖索引对应的 value 中可以包含多个列</li></ul></li></ul><p>注：MySQL 中，二级索引的 value 存储的是主键 id</p><p><strong>多列索引</strong></p><p>作者给我们做了一个科普吧算是，介绍了一维索引的局限性，已经多维索引可以在哪些场景中用到。</p><p><strong>全文搜索，模糊索引</strong></p><p>同上</p><p><strong>事务处理与分析处理</strong></p><p>作者对事务（transaction）进行了解释，并没有像教科书那种直接给出定义，而是结合历史告诉我们，事务一词的来源。以前在商业数据处理中， 一个往数据库中写入的操作往往意味着背后发生了一笔交易，或者是一笔订单，给员工汇款等操作。随着数据库不仅仅用于商业领域，transaction 这个词仍然延续使用。</p><p>其代表的是，一个逻辑单元中全部的写操作和读操作。</p><blockquote><p>事务并不一定要有 ACID （atomicity, consistency, isolation, durability）</p></blockquote><p>OLTP (online transaction processing)</p><p>OLAP (online analystic processing)</p><p><img src="https://s2.loli.net/2022/06/23/HfGSdbgCRA8rwsX.png"></p><p><em>数据仓库的由来</em></p><p>90 年左右，一些公司开始停止在 OLTP 中进行数据分析，而是在一个单独的数据库中进行分析，这种独立的数据库被称为：data warehouse. 数据仓库。</p><p><strong>数据仓库</strong></p><p>从 OLTP 提取数据到  OLAP 的过程被称为： ETL (extract-transform-load)</p><p><img src="https://gitee.com/yangbaoqiang/images/raw/master/blogpics/image-20220127205128006.png" alt="image-20220127205128006"></p><blockquote><p>作者提到。。小规模的公司可能都没听过数据仓库。。。身在其中啊。。</p></blockquote><p><strong>Stars schema and Snowflakes</strong></p><p>这一小节通读下来，可以学习到的是：</p><p>星模式-一个主表中存储的都是其他表（子表）的主键。比如，订单表中存储的商户id，商户表中存储了商户信息</p><p>雪花模式-星模式的一种变种，子表中存储的其他表的主键。订单表中存储的商户id，商户表中存储了商户信息，还存储了户主信息，户主表中存储了户主的信息。</p><p>可以理解为雪花模式是比星模式表达的更完整，拓展的更多的一种模式。</p><p><strong>面向列的存储</strong></p><p>row-oriented 和 column-oriented 存储方式上的区别</p><p><img src="https://s2.loli.net/2022/06/23/SYNihRLcZBml1gs.png"></p><p><em>采用位图压缩列</em></p><p><img src="https://gitee.com/yangbaoqiang/images/raw/master/blogpics/image-20220128102336567.png" alt="image-20220128102336567"></p><p>这里感觉书中描述的不是那么清晰（也可能是我自己翻译后理解的比较烂哈哈）：</p><ul><li>比如我们有 n 个列，但是经过去重后发现只有 m 个商品，可以通过，建立 m 个 bitmap 然后，每一个 bitmap 的长度是  n 的方式，来压缩列。</li><li>如果 bitmap 中，对应比特位为 1 说明该行有这个值，为 0，说明无。</li></ul><p><em>在 bitmap 中查找数据</em></p><p><img src="https://s2.loli.net/2022/06/23/BaonQTIzSVNw9WU.png"></p><p>这个地方确实是非常巧妙，比如要找 product_sk 的 id 在 30，68，69 这三个数之间的，直接把这三个对应的 bitmap 找出来，进行 OR 运算，bit 位 是 1 的就代表找到了。</p><p>第二个例子中展示了当进行 AND （与）运算的时候，直接将不同的 bitmap 进行 AND，可以这样做的根本原因是，虽然不同的数据在不同的 bitmap 中，但是 bitmap 中的每一位都是彼此对应的。</p><p><em>内存带宽和矢量化处理</em></p><p>内存带宽这里涉及到 SIMD 一个指令，包含多个数据。跟普通的三、四地址的指令好像还不太一样。。</p><p><em>data cube and materialized view</em></p><p><img src="https://s2.loli.net/2022/06/23/3E5U7zJTOHlusQS.png"></p><p>缓存聚合数据。</p><h2 id="CH4：-Encoding-and-Evolution"><a href="#CH4：-Encoding-and-Evolution" class="headerlink" title="CH4： Encoding and Evolution"></a>CH4： Encoding and Evolution</h2><p>Backward compatibility</p><p>​    Newer code can read data that was written by older code.</p><p>Forward compatibility</p><p>​    Older code can read data that was written by newer code.</p><p><strong>数据的编码方式</strong></p><p>程序处理的数据通常由两种（至少）表示方式：</p><ul><li>In memory</li><li>self-contained sequence of bytes （Json）</li></ul><p>encoding ： In memory —&gt; sequence</p><p><em>二进制编码</em></p><p>Facebook - Thirft </p><ul><li>Thrift 有两种压缩方式： <em>BinaryProtocol</em> and <em>CompactProtocol</em></li></ul><p>Google - Protobuf</p><ul><li>Protobuf 只有一种压缩方式，从书中结论来看，比 Thrift 压缩的要小一点，但是差别不大。</li></ul><p>Thrift 采用如下第一种的方式声明 schema</p><p><img src="https://s2.loli.net/2022/06/23/5DMGen3OPgULca9.png"></p><p>Thrift - BinaryProtocol</p><p><img src="https://s2.loli.net/2022/06/23/Xj38cVD1rpgG67z.png"></p><p>有数据类型标识，字段的 tag （表示字段名称），可以在图中看到有很多地方都是 00 ，这些未用到字节，如果可以进一步被压缩，仍然可以节省很多空间。</p><p>由此可以引出 Thrift 的第二种压缩方式：CompactProtocol ，它确实也是这么做的，通过把更多的信息<strong>pack到尽可能少的字节中</strong>，这是不是和 SIMD 的基本思想是相同的？从 59 字节压缩到 34 字节，优化了将近 50 %的size。</p><p>如下图，把数据类型和字段的tag, pack 到了一个字节。</p><p><img src="https://s2.loli.net/2022/06/23/TZsguR4KqAoweaD.png"></p><blockquote><p>这章节后半部分是在手机上阅读的。。没来得及做笔记整理，等我二刷中文版的时候，着重把这块补上。</p></blockquote><h2 id="CH5：Replication"><a href="#CH5：Replication" class="headerlink" title="CH5：Replication"></a>CH5：Replication</h2><p>从单一的数据系统转变为分布式的数据系统。</p><p>分布式系统有两种形式的存在方式</p><ul><li>Replication</li><li>Partitioning</li></ul><p>某些情况下，这两种模式会混合使用，下图中展示了，一个数据库分成了两个分片，又为两个分片搞了两个副本。</p><p><img src="https://s2.loli.net/2022/06/23/AgezPrCvyl1Nd3B.png"></p><p><em>为什么需要 replication</em></p><ul><li>在距离上离用户更近</li><li>当某部分出错时可以保证系统正常工作</li><li>水平扩展机器，增加吞吐量</li></ul><p><strong>Leaders And Followers</strong></p><p><em>如何却确保 master 的数据到达了所有的  slave 上？</em></p><p><img src="https://s2.loli.net/2022/06/23/SHL7jerUyf6pMq2.png"></p><p><em>Synchronous Versus Asynchronous Replication</em></p><p><img src="https://s2.loli.net/2022/06/23/CKQRLSyi1XpAtdU.png"></p><p>同步的优缺点</p><ul><li>slaves 一定是最新的副本，与 master 中保持一致</li></ul><p>缺点</p><ul><li>如果同步过程中 slave 没有响应，如上图 Follower 1 的处理时间会变成不可预测的。这时 master 不会处理任何写操作，直到收到 slave 的响应。</li></ul><p>异步的缺点：</p><ul><li>如果 master 崩溃了，可能会导致数据的丢失，即主从节点存储的数据不一致</li></ul><p><strong>配置新的 slave</strong></p><p>当一个 slave 加入到 cluster 中，slave 如何进行数据的同步。</p><ul><li>打快照</li><li>将快照发送到 slave</li><li>slave 连接到 master ，同步从 <em>打快照时间之后</em> 做的数据变更</li><li>上一步执行完成后，与其他的 slave 同步数据的方式就没有什么不同了</li></ul><p><strong>处理崩溃节点</strong></p><ul><li><p><strong>catch-up recovery</strong></p></li><li><p><strong>Failover</strong> 故障转移</p></li></ul><p><strong>replication logs 的实现</strong></p><p>用于slave同步数据的文件，是怎么存储 master 的操作日志的？</p><ul><li><p>基于语句的实现</p><ul><li>压缩性好</li><li>如果master 中用了 NOW() 这样的函数，这样在 slave 中执行会出问题的<ul><li>解决办法就是，计算出确定的值然后存储的 log 文件中</li></ul></li></ul></li><li><p>WAL</p><p>这里提到了怎样使用这个技术是实现数据库版本的升级，简而言之，先给 slave 节点进行升级，然后执行故障转移，让已经升级的 slave 成为 master 节点。</p><blockquote><p>这种方式的一个缺点就是，slave 和 存储引擎是紧耦合的</p></blockquote></li><li><p>基于行 row 的实现</p><ul><li>MySQL 触发器，逻辑日志</li></ul></li><li><p>基于 trigger 的实现</p><p>就是在执行相应语句时，执行特定的函数</p></li></ul><p><strong>slave 节点同步数据滞后的问题</strong></p><p>似乎每种高可用都有这类问题，如果在主库修改了一个数据，紧接着读取数据，这时候从节点去服务这个读请求，就会出现数据不一致的问题。</p><blockquote><p>第五章，一部分是在手机上读的没来得及做笔记。。二刷一定补上！</p></blockquote><h2 id="CH6：Partitioning"><a href="#CH6：Partitioning" class="headerlink" title="CH6：Partitioning"></a>CH6：Partitioning</h2><p>分布式数据库的另一种存储方式，分片，即每个地方只存储一部分数据，各个分片的内容合并起来才是一个完整的数据。</p><p>如何将一个大的数据库进行分片？</p><p>如何与分片进行交互，即数据的查询？</p><p>如何找到数据所在的正确的分片？</p><p><strong>分片和副本</strong></p><p>这俩通常会结合使用，如下：</p><p><img src="https://s2.loli.net/2022/06/23/5RDAsTzKv1um27e.png"></p><h4 id="Key-Value-类型数据的分片"><a href="#Key-Value-类型数据的分片" class="headerlink" title="Key-Value 类型数据的分片"></a>Key-Value 类型数据的分片</h4><p>学到了几个名词：</p><p>skewed 倾斜，某个分区的数据要多余其他分区，把这种情况称为倾斜。</p><p>hot pot 热点，某个分区的负载比其他分区都要高，把这种情况的分区叫做热点。</p><p>避免热点分区最简单的方法就是，插入记录的时候随机选择分区。</p><p><img src="https://s2.loli.net/2022/06/23/WtIMG4HnEqiV9O7.png"></p><p>图中索引为 12 的范围，包括了 T - Z，这种简单的将一本书包括两个字母索引，会导致其他的卷包含的索引不均匀。<em>为了使数据分布的更均匀，分区的边界需要适应数据。</em></p><h4 id="通过-key-的-hash-值进行分区"><a href="#通过-key-的-hash-值进行分区" class="headerlink" title="通过 key 的 hash 值进行分区"></a>通过 key 的 hash 值进行分区</h4><p><img src="https://s2.loli.net/2022/06/23/MOtpjgGC39NvHi8.png"></p><p>使用key的哈希值作为分区，给我们带来的一个损失就是：没办法执行高效的范围查询。</p><p><strong>Skewed Workloads and Relieving Hot Spots</strong></p><p>倾斜的工作负载指的是，某个分区的负载要明显高于其他分区。比如社交媒体中的明星有很多的粉丝，这种情况下很容易引起，瞬间大量操作同一个 key。</p><p>解决这种问题的办法就叫做：Relieving Hot Spots</p><p>就是让打在同一个分区上的请求，再次分布到别的分区之中。</p><p>作者提到的一个最简单的方法是：在 key 的开头或结尾添加随机数，这两个随机数可以将打在一个分区的请求均匀分布到 100 个 key 上，而不是只操作一个 key。</p><p>但是这又带来了另一个问题，就是读取数据的时候变得更加困难，需要将这100个key 都读取出来，再做汇总。</p><h4 id="Partitioning-and-Secondary-Indexes"><a href="#Partitioning-and-Secondary-Indexes" class="headerlink" title="Partitioning and Secondary Indexes"></a>Partitioning and Secondary Indexes</h4><p><strong>Partitioning Secondary Indexes by Document</strong></p><p>主要讲了分区和二级索引怎么搭配使用。</p><p><img src="https://s2.loli.net/2022/06/23/6ysve8u5AQb3GoZ.png"></p><p>基于文档的二级索引分区，每个分区中的二级索引都是独立的，各自维护各自的索引，也被称为本地索引。</p><p><strong>Partitioning Secondary Indexes by Term</strong></p><p>按术语划分二级索引</p><p><img src="https://s2.loli.net/2022/06/23/1K6k2lfeo5i8jbr.png"></p><p>与基于文档的方式相比，很容易看出，二级索引变成了全局索引。</p><p>但是也不能把索引全部放在一个分区上，会破坏分区的目的，也可能会成为性能的瓶颈。</p><h4 id="Rebalancing-Partitions"><a href="#Rebalancing-Partitions" class="headerlink" title="Rebalancing Partitions"></a>Rebalancing Partitions</h4><p>为什么我们需要对分区进行重平衡？</p><ul><li>查询吞吐量增加，需要添加 CPU 应对高负载。</li><li>数据规模增长，需要添加磁盘和 RAM 存储。</li><li>机器宕机的时候，其他的机器需要接管失败的机器。</li></ul><p><em>rebalancing</em> 的过程就是，将集群中一个节点负载转移到另一个。</p><p>期望 <em>rebalancing</em> 达到什么目的？</p><ul><li>在重平衡之后，负载能够均匀的分布在集群的节点上。</li><li>即发生了 rebalancing，也可以正常处理读、写请求。</li><li>不应该在节点间移动不必要的数据，快速重新平衡并最小化网络和磁盘 I/O 负载。</li></ul><p><strong>重平衡的策略</strong></p><p><em>hash mod N</em></p><p>对 N 取模带来的问题是，如果 node 数量 N 变化了，大多数 key 都需要从原 node 移动到另一个 node。</p><p><em>固定数量的 partitions</em></p><p>这里采用了一种在 node 上创建比 node 数量更多分区的方法，比如 node 数量是 10，一个 node 上创建 100 个分区，这样总数就是 1000 个分区。</p><p>按照上述的分配，如果这是新加入了一个 node ，这个新的 node 从那 10 个 node 上 steal 几个分区过来，如下图。</p><p><img src="https://s2.loli.net/2022/06/23/2NsHbOV91EWfJ38.png"></p><p>分区编号不会改变，分区中的 key 也不会改变。唯一改变的就是分区所在的 node，但是这个改变不是立即发生的，通过网络传输数据到另一个 node 需要花费很多时间。</p><p>这时，旧的分区在这个传输的过程中仍然用于处理读写请求。</p><p>这种模式在 ES 中有使用到。</p><p>一般是怎么确定固定数量的分区的数量呢？</p><ul><li>the number of partitions configured at the outset is the maximum number of nodes you can have</li></ul><blockquote><p>管理分区也是有开销的，所以选择了一个非常高的分区数量时，可能会适得其反。</p></blockquote><p><em>动态 partitions</em></p><p>大的会拆成小的，太小了会合并成一个。</p><p>动态分区的好处</p><ul><li>分区的数量可以适应数据的变化。</li></ul><blockquote><p>空的数据库会以一个唯一的分区开始，这时所有的读写操作只操作一个分区，直到达到了需要拆分的阈值。</p></blockquote><p><strong>Partitioning proportinally to nodes</strong></p><p><strong>自动或手动进行重平衡</strong></p><p>自动会很方便，运维只需要做很少的操作就能达到维护的目的。但是自动重平衡是不可预测的。</p><p>当自动重平衡和故障检测结合使用时会更加危险，比如某个 node 负载比较高，会时不时出现响应慢的问题。这时其他节点要是判定这个 node 崩溃了，开启了自动重平衡，这不是我们期待的结果。</p><p>所以，手动的可能没有自动的那么方便，但是可以阻止一些额外的问题。</p><h4 id="请求路由"><a href="#请求路由" class="headerlink" title="请求路由"></a>请求路由</h4><p>常见的三种方式：</p><ul><li>直接访问一个node 如果有就返回，没有就找下一个node</li><li>通过路由的方式，在 client 和 node 中间套一层。</li><li>第三种需要客户端进行配合，客户端对哪些分区存储了哪些key是有感知的。</li></ul><p><img src="https://s2.loli.net/2022/06/23/FUslPBcKGLAHT2R.png"></p><p>另一种方式为，分布式系统以来一个独立的服务，比如 ZooKeeper 来跟踪集群中的元数据。</p><p><img src="https://s2.loli.net/2022/06/23/WwbyJRN1YHX2eSp.png"></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>这章讲了几种将数据库拆成分区的方法，不过针对的好像都是 key-value 类型的数据库。</p><p>分区的目的：<strong>将数据和查询的负载更均匀的分配到多台机器上</strong></p><p>两种分区的方法：</p><ul><li>key range 的分区方法，将 key 排序后进行存储的一个好处是，支持更高效的范围查询，同时也会带来一种风险，就是 hot spot 的问题。这种分区方式通常结合<strong>动态分区</strong>进行使用，在达到某个阈值的时候进行分区的拆分。</li><li>hash 分区，通过散列函数将数据更均匀的分布在多台机器上。虽然损失了高效的范围查询，但是给我们带来了更均匀的数据分布和负载均衡。hash 分区的方式通常结合<strong>固定数量</strong>的分区进行使用。</li></ul><p><em>分区和二级索引</em>的结合</p><ul><li>基于文档的，也叫 local index</li><li>基于术语的，也叫 global index</li></ul><h2 id="Ch7：Transactions"><a href="#Ch7：Transactions" class="headerlink" title="Ch7：Transactions"></a>Ch7：Transactions</h2><p>循序渐进，介绍了一些会导致数据系统出错的几个问题</p><ul><li>数据库软件或者硬件可能会随时出错，也包括在写操作执行一般的过程中</li><li>应用可能会随时崩溃，包括一些逻辑只执行了一半</li><li>网络的不可靠，切断了应用和数据库之间的关系</li><li>客户端之间的并发操作</li><li>客户端可能读取到了无意义的数据（脏数据）</li></ul><p><strong>事务</strong></p><p>事务是简化上述问题的一种机制。<strong>事务是应用程序将多个读取和写入组合成一个逻辑单元的一种方式。</strong></p><p>概念上，所有的读写操作在一个事务中被看成是一个操作，要么整个事务成功（commit），要么全部失败（abort, rollback）。</p><p>这下我就有点明白了，总说的分布式事务是什么意思，比如一个写请求，需要多个服务进行协调，为了保证数据的可靠性，要么所有的服务都响应成功，要么就都失败。</p><h4 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h4><p>atomicity 原子性</p><p>consistency 一致性</p><p>isolation 隔离性</p><p>durability 持久性</p><p>是数据库中的容错机制建立精确的术语</p><p><strong>Atomicity</strong></p><p>atomic 这个词通常代表的意思是，一个不可再分的操作。</p><p>在计算机中，代表着一些其他的意思，比如多线程环境下，某个线程修改了某个值，由 1 改成 2，这时候其他线程是看不到的，其他线程看到的仍然是 1。</p><p><strong>但是在 ACID 中</strong>，A 代表的意思是和并发没有任何关系的！像上述这种问题，在 ACID 中 I isolation 中覆盖了这样的场景。</p><p>Atomicity 描述了如果客户端想要请求多个写操作，但是在一部分写操作执行完成后发生了错误。如果多个写操作聚合到一个 atomic 事务中，就说明这个事务是由于错误未完成的，然后这个事务就可以进行回滚，数据库必须忽略和恢复写入成功的值。</p><p><strong>发生错误时，有回滚事务的能力，并且这个事务中的所有写操作都应该被忽略。</strong>这是 ACID 中 A 的定义。</p><p>作者提到 abortability（可回滚能力）可能更适合这个 A。</p><p><strong>Consitency</strong></p><p>ACID中的一致性的主要是指对数据有特定的预期状态， 任何数据更改必须满足这些状态约束（或者恒等条件）。</p><blockquote><p>说实话，这句话有点难懂。。原文是这样的 <code>The idea of ACID consistency is that you have certain statements about your data (invariants) that must always be true</code></p></blockquote><p>关于一致性的描述确实很模糊，看完知乎上这个回答清晰了很多。</p><p><img src="E:/resource/myInfo/blogRes/images-master/blogpics/image-20220218100501876.png"></p><p><strong>通常，应用程序会依赖数据库的 A 和 I 来实现 C</strong></p><p><strong>Isolation</strong></p><p><img src="https://s2.loli.net/2022/06/23/P5oRqwhxXcZWnuT.png">这个就有点和一开始说的 atomic 并发访问类似了。</p><p><strong>Durability</strong></p><p>数据库系统的目的就是提供一个安全的地方，可以用来存放数据，并且不需要担心数据的丢失。</p><p>单节点中，持久性意味着数据成功的写入了。master - slave 中，意味着副本中的数据也成功写入了。</p><p>完美的持久性其实并不存在，如果存储数据的磁盘和存储副本数据的磁盘都坏了，这也是一种情况。</p><h4 id="单对象与多对象事务操作"><a href="#单对象与多对象事务操作" class="headerlink" title="单对象与多对象事务操作"></a>单对象与多对象事务操作</h4><p><img src="https://s2.loli.net/2022/06/23/2yncBqfrW1Ie6EU.png"></p><p>如果没有隔离性，user2 会看到一种非常诡异的现象，就是有未读邮件，但是未读邮件的数量显示为 0。</p><p><img src="https://s2.loli.net/2022/06/23/BzUa3sCGQqlfXxk.png"></p><p>如果没有原子性，这时候未读邮件和未读数量的显示就不一致了。这种情况下，第二个更新数量的操作失败了，那么第一个插入未读邮件的操作是需要回滚的。</p><p><strong>多对象事务的需求</strong></p><p>主要还是为了事务的  A 和 I</p><p><strong>错误处理和驳回</strong></p><p>事务一个非常重要的特点：当错误发生的时候，可以进行驳回（忽略已修改的内容）并且安全的重试。</p><p>ACID 的哲学：<strong>如果数据库违背了 AID ，那还不如摒弃 AID，这样也比把数据搞成半截子强。</strong></p><p>重试事务也会有很多问题：</p><ul><li>比如事务执行成功了，但是 commit 未返回给客户端，此时客户端会认为这个事务是失败的，这样就会导致事务执行多次。。除非有一种去重的机制。。</li><li>如果事务执行失败是由于过载导致，那么事务的重试会加重负载。这种情况下可以添加重试次数的限制。</li><li>只有在”可控的“错误发生时，事务重试才有意义。如果这个事务中本身就有错误，那么怎么重试都是无意义的。（这句话是我自己理解的）</li><li>如果事务的执行存在数据库之外的副作用，那么即使事务被驳回了，副作用仍然会发生。作者举了一个例子，特别好！如果这个事务的执行伴随着发送邮件，那么重试的时候仍然会发送邮件。。</li></ul><h4 id="弱隔离级别"><a href="#弱隔离级别" class="headerlink" title="弱隔离级别"></a>弱隔离级别</h4><h5 id="Read-committed"><a href="#Read-committed" class="headerlink" title="Read committed"></a>Read committed</h5><p>读提交是最基础的事务隔离级别，提供了两种保障：</p><ul><li>当从数据库读的时候，只能读到已经被 committed 的内容。<strong>No dirty reads</strong></li><li>当写操作发生时，只有在事务 committed 的时候，才会覆盖原数据。<strong>No dirty writes</strong></li></ul><p><strong>No dirty reads</strong></p><p>dirty reads （脏读）如果一个事务对数据库中的内容进行了修改，但是事务还没提交，这时候另一个事务要是读到了未提交的数据，称这种情况未脏读。</p><p>读提交的事务隔离级别，<strong>必须阻止脏读</strong>，意味着所有的写操作只有在 committed 后才能被看到，如下图：</p><p><img src="https://s2.loli.net/2022/06/23/a6pN7lZYxej2O5c.png"></p><p><strong>No dirty writes</strong></p><p>dirty writes （脏写）如果一个未提交的事务修改的内容，被另一个事务覆盖了，这种情况称为脏写。</p><p><img src="https://s2.loli.net/2022/06/23/8HPdxRcOYFwkts1.png"></p><h4 id="实现读提交隔离级别"><a href="#实现读提交隔离级别" class="headerlink" title="实现读提交隔离级别"></a>实现读提交隔离级别</h4><p>写 ： 大多数情况，数据库实现读提交隔离级别都是通过<strong>行级别</strong>的锁来实现的，如果某个事务想修改某个值，一定要先获取锁。</p><p>读 ： 要是不想脏读，也可以通过行级锁实现，但是可能会出现一个写事务，阻塞非常多的读事务。更普遍的方式是，通过上边的 7-4 图中那样的方法。</p><h4 id="Snapshot-Isolation-and-Repeatable-Read"><a href="#Snapshot-Isolation-and-Repeatable-Read" class="headerlink" title="Snapshot Isolation and Repeatable Read"></a>Snapshot Isolation and Repeatable Read</h4><p>快照隔离和可重复读。</p><p>读提交中存在的问题：</p><p><img src="https://gitee.com/yangbaoqiang/images/raw/master/blogpics/image-20220221151207197.png" alt="image-20220221151207197"></p><p>这个账户有 1000 ，分成两个账户，每个中有 500。这个用户账上发生了一笔交易，从一个账户转移到另一个账户 100。</p><p>两个事务，一个读的，一个写。她查询第一个账户是 500，但是读提交的事务只有在整个事务 commit 后才能被看到，所以在事务提交后，她再次查账户是 400，但是她本来是 1000 块钱，那 100 就莫名其妙消失了。。</p><p><strong>快照隔离的一个关键原则是：读不会阻塞写，写不会阻塞读</strong></p><p><strong>MVCC</strong></p><p>数据库必须保存某个对象的多个不同提交版本，因为不同的进行中事务需要在不同时间看到不同的数据库状态。<em>因为在同一时刻保存了某个对象的多个版本，这个技术被称为 MVCC</em></p><p><strong>快照隔离的实现</strong></p><p>当事务开始的时候，会给每个事务一个唯一且自增的事务 ID。</p><p><img src="https://s2.loli.net/2022/06/23/G2OBu1VwpkaWLNI.png"></p><p>如图所示，一个更新操作在内部被拆分成了删除和插入。事务13 要更新账户 1  的余额，把 created by = 3 的删除，插入了一条新的。</p><p><strong>一致性快照的可见性规则</strong></p><p><em>事务 ID 决定了他可以看到哪些对象，哪些看不到</em></p><ul><li>在事务开始的时候，数据库会创建一个在那个时刻其他正在执行的但是还没有提交或驳回的事务列表。</li><li>被驳回事务的写操作会被忽略。</li><li>事务 ID 更大的写操作会被忽略掉，尽管这些事务被提交了。</li><li><strong>所有其他写入对应用程序的查询都是可见的。</strong></li></ul><p>在快照隔离中，如果一个对象是可见的，必须满足以下两个条件：</p><ul><li>在读事务开启的时候，在另一个事务中创建的对象已经 commit 了。</li><li>对象没有被标记为删除，如果被删除了，当读事务开启的时候，请求删除的事务还没有提交。</li></ul><p><strong>索引在快照隔离中是怎样工作的</strong></p><p>主要是讲了两种建立索引树的方式。</p><ul><li>append-only<ul><li>有写事务的时候，会从某个特定的根创建一颗新的索引树</li></ul></li><li>copy-on-write<ul><li>写时复制，针对当前 page 进行操作的，如果想要更新的话，并不会覆盖当前页的内容，而是创建当前页的一个副本。</li></ul></li></ul><p><strong>可重复读和命名混乱</strong></p><p>MySQL 中把快照隔离称为<strong>可重复读</strong></p><h4 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h4><p>一个事务中的写操作影响了另一个事务中的查询操作。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Designing Data-intensive Applications&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>第一次 pr</title>
    <link href="https://bqyang.top/2022/contributeToYunion/"/>
    <id>https://bqyang.top/2022/contributeToYunion/</id>
    <published>2022-06-23T10:30:51.728Z</published>
    <updated>2022-07-05T10:42:25.928Z</updated>
    
    <content type="html"><![CDATA[<p>所有工作时间加起来也有一年多快两年的时间了，实习了 8 个月，正式工作也有 10 个月了，加起来有一年半的工作经验了。事实一次又一次的证明了去大公司的必要性，就算没有办法去大公司，也要多接触在大厂上班的人，这就有点近朱者赤近墨者黑的意思。</p><span id="more"></span> <p>大厂程序员能接触的面实在是太多了，他们带给我的感受就好像，井底之蛙。每天我所接触到的东西只有那么一点，或者说工作所能涉及到内容，再多也不会多到哪去。久而久之，与人家的差距自然就被拉开了。</p><p>说了点废话，只想和大家共勉，一定要好好学习，曹大说了，混几个你所在工作的领域相关的 commit 哈哈，对自己来说简历上还是能挂得住的，我们公司用的代码是一套开源的云管理平台，据说是买的人家商业版，在人家代码基础上做的二次开发。</p><p>二次开发做的真的是惨不忍睹，没有把人家的代码研究明白就开始在上边迭代，导致现在的代码维护成本非常高，再加上这套代码本身就非常复杂，各种高度抽象，各种回调、异步任务。我入职有快四个月了，还是有很多不明白的地方。</p><p>上个周五，2021-11-19，那天调试一个bug，当时就是跟自己较真，过不去这个坎，觉得今天要是解决不了这个问题，真的是太没用了。。所以周五到家后，又一直研究，trace代码，最后还是找到了问题出现的地方，跟这些异步任务属实是费劲。可能自己对这个bug的偏执，也说明了自己能力不足。</p><p>以前看到过一句话，不要对年轻人讲经验，他该走的弯路一个不会少。我其实是认同的，虽然在某些时候，前辈们的经验可以帮助我们减轻一些心理负担，但是真正需要自己站出来的时候，一个弯路都不会少的。</p><p>这次排查 bug 给我带来的收获，不仅仅是一个提 pr 的机会，更是一次开拓眼界的机会，或许也是迈向开源的一个机会。</p><p>贴上两张提 pr 的图片吧哈哈，相关的 reviewer 还没有 review 代码，希望可以顺利的被 merge！</p><p><img src="https://s2.loli.net/2022/06/23/eDXpEfKIgz3L95O.png"></p><p><img src="https://s2.loli.net/2022/06/23/76oCUmlOBHQJ25y.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;所有工作时间加起来也有一年多快两年的时间了，实习了 8 个月，正式工作也有 10 个月了，加起来有一年半的工作经验了。事实一次又一次的证明了去大公司的必要性，就算没有办法去大公司，也要多接触在大厂上班的人，这就有点近朱者赤近墨者黑的意思。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>2021 年末总结</title>
    <link href="https://bqyang.top/2022/summary/summary2021/"/>
    <id>https://bqyang.top/2022/summary/summary2021/</id>
    <published>2022-06-23T10:30:51.725Z</published>
    <updated>2022-06-04T07:39:22.880Z</updated>
    
    <content type="html"><![CDATA[<p>2021 已经过去半个月的时间了，看了很多前辈的总结，大家进步的都好快.. 突然想起来曹大的 Bio <code>If you don&#39;t keep moving, you&#39;ll quickly fall behind.</code></p><span id="more"></span><h3 id="Golang-深度"><a href="#Golang-深度" class="headerlink" title="Golang 深度"></a>Golang 深度</h3><p>先给大家汇报下这一年从语言深度上的学习：</p><ul><li>GMP</li><li>GC</li><li>内存管理</li><li>汇编</li><li>Golang Contributor</li></ul><p>之前看 csapp 学习到了关于 x86 指令集的一些基础知识，作为一个只写业务的程序员，了解这些内容对我们没什么大的帮助。但是，正是这些不起眼的东西，在我学习 Go 底层原理的时候，发挥了重要作用。</p><p>Go 1.4 采用的是  C 编写的，后来在 1.5 版本开始完全自举了，一些与内核的交互都是采用汇编写的，用的是诞生在 Bell labs 的 plan9 ，和传统的 x86 指令集有不少的差异。所以，不和其他语言一样，Go 的底层是干净，统一的。并不需要过多的掌握 C ，自然也不会给我带来额外的学习成本。</p><p>了解我的人都知道，我并不是一个聪明的人，和女朋友聊天的时候也会和她吐槽，感觉自己太笨了，有很多东西理解起来都很慢，甚至理解不了。悲观一点会觉得这是跟人家生理上的差距，没有那脑子。乐观一点呢，会觉得可能学习的时候并不踏实，是不是缺少相关的基础理论。</p><p>举个例子，在学习内存管理的时候，会涉及到系统调用，抽象的来看，我们调用某个函数就可以获得一块内存空间亦或是归还给操作系统。这个过程就涉及到，什么是系统调用，相关的系统调用函数是干什么的等一系列问题。</p><p>再说说怎么解决问题（正确利用好搜索工具），一下子这么多问题，上哪找答案去啊，这个我从曹大那学到不少东西，Linux 相关的直接上 man7 看下说明，比通过百度，看那些二手信息效率高太多了。这里突然想到以前实习时候，一个大哥说的话，这他妈上个 CSDN 跟去小厕所一样，全xx是小广告。</p><p>也是从这一刻开始，我真正了解到了 Google 的强大，搜索结果的相关性，准确性，是百度完全不可企及的。如果你因为某些原因用不了，我推荐你尝试一下 Microsoft 的 Bing 搜索引擎，也是我在用不了 Google 时的一个替代品。</p><p>在语言深度的学习过程中，掌握了一套非常顺手的工具。</p><p>我说的工具不仅仅如此，也包括 readelf，objdump，go tool 等等。</p><ul><li>readelf 学习到了可执行文件的相关知识</li><li>objdump 学习到了反汇编的内容</li><li>go tool 学习到了 pprof ，compile</li></ul><p>这里还想多说一点！</p><p>阅读源码谁都可以！但是！怎么开始阅读源码是一种能力！</p><p>以前学习 Golang 都是看大佬总结，看人家在底层穿梭，在掌握了相关工具，发现自己也具备了这样的能力，这也是一种进步。</p><hr><h3 id="英语"><a href="#英语" class="headerlink" title="英语"></a>英语</h3><p>英文对程序原来说是十分重要的，我做出过尝试，2021年读了两本英文书</p><ul><li>《Kubernetes in Action》</li><li>《Concurrency in Go》</li></ul><p>一本是讲 Go 并发的，另一本是讲 K8s 的基础知识。<strong>都没读完</strong>一方面是自己动力不够，一方面是自己词汇量薄弱，遇到一些长难句就卡住了。</p><p>不过好在是，自己在路上，坚持下去就好。</p><hr><h3 id="生活方面"><a href="#生活方面" class="headerlink" title="生活方面"></a>生活方面</h3><p>今年入手了一些比较好的产品，对于提升工作、生活效率有很大帮助。</p><blockquote><p>Y9000P 3060</p></blockquote><p>联想的一款游戏本，对打游戏的需求不高的我来说，是这么想的。我可以不玩游戏，但是打游戏的时候，得有打游戏的条件。</p><p>优点：体验不错，165 Hz 的高刷屏幕，就是两个字，丝滑，硬件性能也是无话可说。</p><p>缺点：贵，不加钱买不到。而且游戏本太重了，每天背来背去很是麻烦，不过久而久之也没什么感觉了。为了减少一些负担，又上咸鱼淘了一个适配器，公司和家都放一个，这样每次只带电脑就好了。</p><blockquote><p>niz 三模 35g 68键</p></blockquote><p>职业生涯的第一把静电容，68 键位的组合键比较多，不过也不影响使用，可以自己独立设置键程，而且无线也给我带来了极大的便利，不仅仅是桌面上看起来整洁。</p><p>另外，35 g 使用起来，没什么特别的感觉，后续发现就算长时间打字也不会觉得累。</p><p>以后考虑换回 84 键的，就是这键盘也在涨价…我当初买的时候 800 多，现在涨到 1000+ 了..</p><blockquote><p>logic gpw</p></blockquote><p>狗屁王，自己设置了切换屏幕的侧键，用起来也是十分方便，Dpi 能搞到 2w 多，之前我用的一直是 6400，时间长了手腕会有点疼，需要多用些力气才能精准的控制鼠标，最近搞到 3200 也还不错。</p><blockquote><p>绿源 inno7</p></blockquote><p>这个我感觉就是重中之重了，21 年换工作以后，找了一个离公司不远的地方租房子，每天走路通勤就可以了。有了这个电动车以后，那简直就是飞起，每天早上九点起床，中午还能骑车回家休息一会。</p><p>公司免费给我们提供充电，续航的话基本上就是一周一次，唯一缺点就是太慢了，有时候能被自行车甩开几条街..</p><p>这个可以评为年度最佳哈哈</p><p>总结的差不多了是不是该开始展望了？</p><p>没什么大目标，暂时还是藏在心底好了。</p><p>等等！！！</p><p>写完了才发现，有一个很重要的点给忘记了！</p><p>就是在 2021 年，我搭建了属于自己的博客，可以在百度搜索</p><blockquote><p>杨宝强的技术笔记</p></blockquote><p>广告的下一条应该就是哈哈，laji 百度..</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;2021 已经过去半个月的时间了，看了很多前辈的总结，大家进步的都好快.. 突然想起来曹大的 Bio &lt;code&gt;If you don&amp;#39;t keep moving, you&amp;#39;ll quickly fall behind.&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>根管治疗+全瓷冠</title>
    <link href="https://bqyang.top/2022/summary/about-0602/"/>
    <id>https://bqyang.top/2022/summary/about-0602/</id>
    <published>2022-06-23T10:30:51.724Z</published>
    <updated>2022-06-02T03:46:31.733Z</updated>
    
    <content type="html"><![CDATA[<p>从小就是牙口不好，小时候家里对这方面也没有过多关注过，自己也不注重口腔健康，当时爽了，现在完蛋了。</p><p>不仅钱花得多，还非常的折腾。</p><p>我是清明节回家补了一颗龋齿（蛀牙），那天补牙的时候，突然有一下特别疼（就是那个感觉一瞬间就布遍全身，我感觉不咋疼），医生在那一顿叹气，哎呀，露神经了，这就不好弄了。</p><span id="more"></span><p>就是龋齿太深了，已经到牙神经部分了，当时医生没有做过多的处理，问我是要盖上还是直接补，当时我也不明白啥意思，反正最后是听了医生的建议，直接补上了。</p><p>补上后感觉那个地方一直在跳动，别的感觉就没啥了，直到一个月后，就是四月底吧。那天吃午饭，明显的感觉咬到了像石子一样的东西，照镜子一看，补的那块牙掉了一块渣。</p><p>自打那天开始就一直疼，牙髓发炎了，但是当时上着班，而且也挂不上号，拖了两天没去。</p><blockquote><p>北京这边的医院挂号真的好复杂啊，我当时抢北京大学口腔医院的号，抢了两天都没有。而且就算你挂上了也不是当天的号，都是 N + 1 或者 N + 2 的这种。</p></blockquote><p>然后选了一个二甲的保底，挂到了某个首都医科大学附属的三甲医院。</p><p>去了那天就做了牙髓失活术（先打麻药，然后应该是往里放了点什么药），整个人感觉活过来了一样，完全没感觉了。</p><p>后续就是非常折腾，大概跑了 6 次，期间还因为政策原因推迟了很久。</p><p>这周一是最后一次去，把牙冠戴上了， 医生只给了我两个选项，一个是 5000 的，另一个是 6500 的。因为我这个颗牙参与咀嚼比较多，我选了一个质量更好的一点的。</p><p>现在唯一的感觉就是那个对牙咬合不齐，总感觉这个地方比较高。</p><p>于是又约了医生下周一还得再跑一趟.. 另外把别的蛀牙补一下。</p><p>感谢医保报销，感谢公司的医疗保险。。确确实实感受到了医疗方面的保障..</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;从小就是牙口不好，小时候家里对这方面也没有过多关注过，自己也不注重口腔健康，当时爽了，现在完蛋了。&lt;/p&gt;
&lt;p&gt;不仅钱花得多，还非常的折腾。&lt;/p&gt;
&lt;p&gt;我是清明节回家补了一颗龋齿（蛀牙），那天补牙的时候，突然有一下特别疼（就是那个感觉一瞬间就布遍全身，我感觉不咋疼），医生在那一顿叹气，哎呀，露神经了，这就不好弄了。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>关于 rpc 的那些事（一）</title>
    <link href="https://bqyang.top/2022/rpc/about-rpc-1/"/>
    <id>https://bqyang.top/2022/rpc/about-rpc-1/</id>
    <published>2022-06-23T10:30:51.721Z</published>
    <updated>2022-06-26T08:47:03.882Z</updated>
    
    <content type="html"><![CDATA[<p>该文是我学习 <code>rpc</code> 过程中的总结，初步了解到一个 <code>rpc </code> 框架是做什么的，以及为什么我们要使用 <code>rpc </code> 框架。结合当前工作中遇到的场景，对比思考。</p><p><img src="https://s2.loli.net/2022/06/22/8kZFXOu7yo6nfLJ.png"></p><span id="more"></span><h2 id="我遇到的"><a href="#我遇到的" class="headerlink" title="我遇到的"></a>我遇到的</h2><p>我们现在的后端服务，跑的是一套开源的云管代码 [<a href="https://github.com/yunionio/cloudpods">在这里</a>]，据不可靠消息透露，这套框架的源头是美团搞得，一开始貌似用的 Java 代码，后来用 Go 重写了。</p><p>八卦了一下，言归正传，这套代码主要由 keystone / apigateway / region / scheduler 组成，简单概述下他们的职责。</p><ol><li>keystone 负责认证。</li><li>apigateway 负责路由转发。</li><li>region 负责实际的业务逻辑。</li><li>scheduler 负责调度，根据库里数据选择某个最优解。</li></ol><p><strong>网络请求是怎么进行流转的呢？</strong></p><p>认证我们抛开不说，假设以下内容都是认证完成后的。</p><p>认证完成后，用户需要创建云主机，从页面点击创建后，请求走到 <code>apigateway</code>，<code>apigateway</code> 分析请求路径，找到对应的 <code>model</code>，进行路由转发，请求 <code>region</code>，<code>region</code> 处理完成后，返回给 <code>apigateway</code>，<code>apigateway</code> 拿到响应后返回给客户结果。</p><p><strong>这里是怎么拿到另一个服务的地址呢？</strong></p><p>将所有服务信息存储在 endpoint 表中，然后根据请求的相关信息拿到对应的 url，再把 path 拼上。</p><p>这个其实不重要，我最好奇的就是，新加了一些路由之后，<code>apigateway</code> 怎么感知呢？</p><p>调试代码后发现，<code>region</code> 服务和 <code>apigateway</code> 服务存在着某些程度上的耦合，我们在 <code>region</code> 中添加路由后，必须要“同步”给网关。在网关中添加个文件，如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    Disks modulebase.ResourceManager</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Disks = modules.NewComputeManager(</span><br><span class="line">        <span class="string">&quot;disk&quot;</span>,</span><br><span class="line">        <span class="string">&quot;disks&quot;</span>,</span><br><span class="line">        []<span class="keyword">string</span>&#123;<span class="string">&quot;ID&quot;</span>, <span class="string">&quot;Name&quot;</span>, <span class="string">&quot;Billing_type&quot;</span>,</span><br><span class="line">                 <span class="string">&quot;Guest_id&quot;</span>, <span class="string">&quot;Created_at&quot;</span>&#125;,</span><br><span class="line">        []<span class="keyword">string</span>&#123;<span class="string">&quot;Storage&quot;</span>, <span class="string">&quot;Tenant&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line">    modules.RegisterCompute(&amp;Disks)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这种方式，注册到全局变量中，后续根据请求的路径查询对应的模块。</p><blockquote><p>值得一提的是，<code>apigateway</code> 中使用的是正则路由。这样就可以根据请求方法进行抽象，所有的 Get 请求走的都是同一个 handler，其他也类似。</p></blockquote><p>所以，我们每次写新功能的时候都需要额外重启网关服务，个人感觉不是那么的优雅。</p><p>那么问题来了，rpc 能否解决这个问题？我写这篇文章的时候并不知道答案。</p><h2 id="rpc-是什么呢？"><a href="#rpc-是什么呢？" class="headerlink" title="rpc 是什么呢？"></a>rpc 是什么呢？</h2><p>虽然没用过微服务，但是听的耳朵都要起茧子了。这玩意应该没那么普及吧..</p><p>我认为 rpc 框架主要解决的是服务间调用的问题，如果每个接口都使用注册 handler 的方式实现，这个工作量很大并且很难维护。正如 rpc 名字的意思，调用远程接口和调用本地函数一样，rpc 框架封装了这些细节。</p><p>另一方面，grpc 通信摒弃了常规的序列化方式，《DDIA》 中有讲到几种压缩方式的对比。</p><p>看一个简单的例子就知道这个调用过程大致长什么样了，例子来自 [<a href="https://github.com/grpc/grpc-go/tree/master/examples/helloworld">grpc-go</a> ]</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// client</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    flag.Parse()</span><br><span class="line">    <span class="comment">// Set up a connection to the server.</span></span><br><span class="line">    conn, err := grpc.Dial(*addr, grpc.WithTransportCredentials(insecure.NewCredentials()))</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">&quot;did not connect: %v&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> conn.Close()</span><br><span class="line">    c := pb.NewGreeterClient(conn)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Contact the server and print out its response.</span></span><br><span class="line">    ctx, cancel := context.WithTimeout(context.Background(), time.Second)</span><br><span class="line">    <span class="keyword">defer</span> cancel()</span><br><span class="line">    r, err := c.SayHello(ctx, &amp;pb.HelloRequest&#123;Name: *name&#125;)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">&quot;could not greet: %v&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    log.Printf(<span class="string">&quot;Greeting: %s&quot;</span>, r.GetMessage())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// server</span></span><br><span class="line"><span class="comment">// server is used to implement helloworld.GreeterServer.</span></span><br><span class="line"><span class="keyword">type</span> server <span class="keyword">struct</span> &#123;</span><br><span class="line">    pb.UnimplementedGreeterServer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SayHello implements helloworld.GreeterServer</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *server)</span> <span class="title">SayHello</span><span class="params">(ctx context.Context, in *pb.HelloRequest)</span> <span class="params">(*pb.HelloReply, error)</span></span> &#123;</span><br><span class="line">    log.Printf(<span class="string">&quot;Received: %v&quot;</span>, in.GetName())</span><br><span class="line">    <span class="keyword">return</span> &amp;pb.HelloReply&#123;Message: <span class="string">&quot;Hello &quot;</span> + in.GetName()&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    flag.Parse()</span><br><span class="line">    lis, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, fmt.Sprintf(<span class="string">&quot;:%d&quot;</span>, *port))</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">&quot;failed to listen: %v&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    s := grpc.NewServer()</span><br><span class="line">    pb.RegisterGreeterServer(s, &amp;server&#123;&#125;)</span><br><span class="line">    log.Printf(<span class="string">&quot;server listening at %v&quot;</span>, lis.Addr())</span><br><span class="line">    <span class="keyword">if</span> err := s.Serve(lis); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">&quot;failed to serve: %v&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，我们在客户端通过调用函数的方式就实现了对服务端的调用。但是，重点也不是这些，这些内容大部分是通过 <code>.proto</code> 文件生成的，我们只是实现了相应的接口。</p><h2 id="proto-文件"><a href="#proto-文件" class="headerlink" title=".proto 文件"></a>.proto 文件</h2><p>生成 <code>.pb.go | _grpc.pb.go</code> 命令：</p><p><code> protoc --go_out=. --go_opt=paths=source_relative  --go-grpc_out=.  --go-grpc_opt=paths=source_relative .\forGen.proto</code></p><p>Google 官网的解释 [<a href="https://developers.google.com/protocol-buffers/docs/gotutorial">在这里</a>]，常用的几种数据类型：</p><ul><li>repeated</li><li>map&lt;string, int&gt;</li><li>oneof 结构体里面套了一个接口</li><li>单个结构体类型，<code>message Foo &#123;&#125;</code> </li></ul><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">message FooRepeated &#123;</span><br><span class="line">    <span class="comment">// []string</span></span><br><span class="line">    repeated <span class="keyword">string</span> Address = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message FooMap &#123;</span><br><span class="line">    <span class="comment">// map[string]int32</span></span><br><span class="line">    <span class="keyword">map</span>&lt;<span class="keyword">string</span>, <span class="keyword">int32</span>&gt; info = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message FooOneof &#123;</span><br><span class="line">    <span class="comment">// struct &#123;interface&#123;&#125;&#125;</span></span><br><span class="line">    oneof avatar &#123;</span><br><span class="line">        <span class="keyword">string</span> image_url = <span class="number">1</span>;</span><br><span class="line">        bytes image_data = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="grpc-流"><a href="#grpc-流" class="headerlink" title="grpc 流"></a>grpc 流</h2><p>从文档中不难发现，grpc 支持流式数据传输，流式传输应对的是上传和下载大量数据的场景。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 双向流，stream指定启用流特性</span></span><br><span class="line">service HelloService &#123;</span><br><span class="line">    rpc Channel (stream Foo) returns (stream Foo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和普通的差别也不大，只是从直接接收参数变成了，读取连接里的内容。我们实现的 Channel 方法如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> HelloServiceImpl <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 这就好像，pb 插件给我们提供一个抽象类</span></span><br><span class="line">    <span class="comment">// 我们自己去实现具体的内容</span></span><br><span class="line">    pb.UnimplementedHelloServiceServer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *HelloServiceImpl)</span> <span class="title">Channel</span><span class="params">(stream pb.HelloService_ChannelServer)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// 读取连接中的内容，</span></span><br><span class="line">        <span class="comment">// 读出来的最小单位就是我们在 service 中定义的</span></span><br><span class="line">        args, err := stream.Recv()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 输出从客户端都到的东西</span></span><br><span class="line">        fmt.Println(args.GetName())</span><br><span class="line">        reply := &amp;pb.Foo&#123;Name: args.GetName()&#125;</span><br><span class="line"></span><br><span class="line">        err = stream.Send(reply)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其余 server 端的代码类似，注册函数，启动服务。这里看下 client 实现：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">conn, err := grpc.Dial(<span class="string">&quot;:1234&quot;</span>, grpc.WithTransportCredentials(insecure.NewCredentials()))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br><span class="line"></span><br><span class="line">client := pb.NewHelloServiceClient(conn)</span><br><span class="line">s, err := client.Channel(context.Background())</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="comment">// 每隔一秒给 server 发个消息</span></span><br><span class="line">    err := s.Send(&amp;pb.Foo&#123;Name: <span class="string">&quot;bqyang-test&quot;</span>&#125;)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样既可实现 grpc 以流的方式通信。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>那么我们是否可以通过 rpc 的方式重写那个框架中的内容呢？答案是肯定的，可以通过基于HTTP的 rpc 服务，但是貌似仍然解决不了两个服务都重启的问题，而且维护路由的成本更高了。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AServer</span><span class="params">()</span></span> &#123;</span><br><span class="line">    rpc.RegisterName(<span class="string">&quot;HelloService&quot;</span>, <span class="built_in">new</span>(HelloService))</span><br><span class="line">    http.HandleFunc(<span class="string">&quot;/hello&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span>&#123;</span><br><span class="line">        <span class="keyword">var</span> conn io.ReadWriteCloser = <span class="keyword">struct</span> &#123;</span><br><span class="line">            io.Writer</span><br><span class="line">            io.ReadCloser</span><br><span class="line">        &#125; &#123;</span><br><span class="line">            Writer: w, </span><br><span class="line">            ReadCloser: r.Body,</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        rpc.ServeRequest(jsonrpc.NewServerCodec(conn))</span><br><span class="line">    &#125;)</span><br><span class="line">    http.ListenAndServe(<span class="string">&quot;:1234&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有没有更优解呢？或许可以通过服务发现进行实现，下篇文章的内容有了，了解下服务发现。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;该文是我学习 &lt;code&gt;rpc&lt;/code&gt; 过程中的总结，初步了解到一个 &lt;code&gt;rpc &lt;/code&gt; 框架是做什么的，以及为什么我们要使用 &lt;code&gt;rpc &lt;/code&gt; 框架。结合当前工作中遇到的场景，对比思考。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2022/06/22/8kZFXOu7yo6nfLJ.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>宽松内存模型</title>
    <link href="https://bqyang.top/2022/os/RMO/"/>
    <id>https://bqyang.top/2022/os/RMO/</id>
    <published>2022-06-23T10:30:51.718Z</published>
    <updated>2022-04-19T06:02:45.861Z</updated>
    
    <content type="html"><![CDATA[<hr><p>最近学习到一个关于内存模型的知识点，一开始对内存模型的认识还是以为是描述数据结构实在内存中怎样进行存储的。</p><span id="more"></span><p>后来发现我这种理解完全被这个名字所误导了，宽松内存模型指的是，在多核处理器的情况下，对访问共享内存行为的描述。</p><p>解释下面这个 C 代码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;thread.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局变量 x, y</span></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">atomic_int</span> flag;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FLAG atomic_load(&amp;flag)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FLAG_XOR(val) atomic_fetch_xor(&amp;flag, val)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WAIT_FOR(cond) while (!(cond)) ;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定编译的时候不要进行内联优化</span></span><br><span class="line"> __attribute__((noinline))</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_x_read_y</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> y_val;</span><br><span class="line">  <span class="comment">// 汇编实现变量 +1 的操作</span></span><br><span class="line">  <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="string">&quot;movl $1, %0;&quot;</span> <span class="comment">// x = 1</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="string">&quot;movl %2, %1;&quot;</span> <span class="comment">// y_val = y</span></span></span></span><br><span class="line"><span class="params"><span class="function">    : <span class="string">&quot;=m&quot;</span>(x), <span class="string">&quot;=r&quot;</span>(y_val) : <span class="string">&quot;m&quot;</span>(y)</span></span></span><br><span class="line"><span class="params"><span class="function">  )</span></span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, y_val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代码含义如上</span></span><br><span class="line"> __attribute__((noinline))</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_y_read_x</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> x_val;</span><br><span class="line">  <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="string">&quot;movl $1, %0;&quot;</span> <span class="comment">// y = 1</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="string">&quot;movl %2, %1;&quot;</span> <span class="comment">// x_val = x</span></span></span></span><br><span class="line"><span class="params"><span class="function">    : <span class="string">&quot;=m&quot;</span>(y), <span class="string">&quot;=r&quot;</span>(x_val) : <span class="string">&quot;m&quot;</span>(x)</span></span></span><br><span class="line"><span class="params"><span class="function">  )</span></span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, x_val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">T1</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    WAIT_FOR((FLAG &amp; <span class="number">1</span>));</span><br><span class="line">    write_x_read_y();</span><br><span class="line">    FLAG_XOR(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">T2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    WAIT_FOR((FLAG &amp; <span class="number">2</span>));</span><br><span class="line">    write_y_read_x();</span><br><span class="line">    FLAG_XOR(<span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// thread sync func</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tsync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    x = y = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      No memory operand will be moved across the operation,</span></span><br><span class="line"><span class="comment">      either forward or backward. Further, </span></span><br><span class="line"><span class="comment">      instructions will be issued as necessary to prevent </span></span><br><span class="line"><span class="comment">      the processor from speculating loads across </span></span><br><span class="line"><span class="comment">      the operation and from queuing stores after the operation.</span></span><br><span class="line"><span class="comment">      简言之就是会保证 x=y=0 这条赋值操作执行完成</span></span><br><span class="line"><span class="comment">      或许你会问，我把这个赋值语句写在前边</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    __sync_synchronize(); <span class="comment">// full barrier</span></span><br><span class="line">    assert(FLAG == <span class="number">0</span>);</span><br><span class="line">    FLAG_XOR(<span class="number">3</span>); <span class="comment">// 这里没搞懂，为什么执行 XOR 会使 cache miss</span></span><br><span class="line">    <span class="comment">// T1 and T2 clear 0/1-bit, respectively      </span></span><br><span class="line">    WAIT_FOR(FLAG == <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>); fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 创建线程，线程的起点为 T1</span></span><br><span class="line">  create(T1);</span><br><span class="line">  create(T2);</span><br><span class="line">  create(Tsync);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码执行流程分析：</p><ul><li>T1,T2 函数开始执行就会被卡住，因为 FLAG 变量初始值为 0</li><li>Tsync 函数，初始化全局变量 x,y 然后执行了一个 <code>__sync_synchronize();</code> 函数，详情见注释。</li></ul><p>然后 <code>FLAG_XOR</code> 命令，让 T1, T2 两个在等待中的开始执行。</p><p>write_y_read_x 和 write_x_read_y 两个函数，也比较简单，就是将 x y 分别进行赋值的操作，然后读取另一个变量。写 y 读 x，写 x 读 y。我们看下具体的汇编代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00000000004008f1 &lt;write_x_read_y&gt;:</span><br><span class="line">  ... # 省略无关代码</span><br><span class="line">  # 将 1 赋值 x</span><br><span class="line">  4008f9:       c7 05 89 17 20 00 01    movl   $0x1,0x201789(%rip)        # 60208c &lt;x&gt;</span><br><span class="line">  # 读取 y 变量</span><br><span class="line">  400903:       8b 05 87 17 20 00       mov    0x201787(%rip),%eax        # 602090 &lt;y&gt;</span><br><span class="line">  ...</span><br><span class="line">  400921:       c3                      retq</span><br></pre></td></tr></table></figure><p> 从程序就是状态机的视角去分析的话，如下：</p><p>在开始时，我们有 x,y两个全局变量，T1,T2 两个线程，然后 T1，T2 开始交替执行。</p><p><img src="https://s2.loli.net/2022/04/19/x6KeQ2mMXN9qOJ3.jpg" alt="28d0652f7b48792aeea6c52883045fe.jpg"></p><p>从上图我们不难得出，所有的输出结果无外乎是</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 0 1</span></span><br><span class="line"><span class="comment">// 1 0</span></span><br><span class="line"><span class="comment">// 1 1</span></span><br></pre></td></tr></table></figure><p>我们看一下执行 1000 次的输出结果是什么样</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//   756 0 0 </span></span><br><span class="line"><span class="comment">//   242 0 1</span></span><br><span class="line"><span class="comment">//     2 1 0</span></span><br></pre></td></tr></table></figure><p>很奇怪，根本不存在序列为 <code>1 1</code> 的组合，而且输出占最多次数的是  <code>0 0</code> ，从我们刚才列出的输出结果中，并没有这个序列。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><p>实际上，我们的代码经过编译器优化后生成汇编指令，汇编指令被放到处理器上进行执行。在多核的情况下，为了榨取 CPU 的最高性能，<code>处理器会对待执行的汇编代码进行优化</code> 也就是将汇编代码再执行一次编译优化的过程，即处理器也是编译器。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">movl   $0x1,0x201789(%rip)</span><br><span class="line">mov    0x201787(%rip),%eax</span><br></pre></td></tr></table></figure><p>从我们人类的视角出发，我们更偏向于顺序化执行，但如果从处理器的视角出发，会对这两条指令进行优化。</p><p>他做的优化是：将写操作放入到待执行队列中，如果说队列塞满了，批量进行写操作。所以，第一条 mov 指令会被放入到队列中，然后先进行读操作。</p><p><img src="https://s2.loli.net/2022/04/19/X5LUKbMhiE9JpCt.png" alt="mem-tso.png"></p><p>所以这就是为什么我们没有看到 1 1 的原因。</p><h3 id="如何进行修复"><a href="#如何进行修复" class="headerlink" title="如何进行修复"></a>如何进行修复</h3><p>既然找到了问题的源头，那么就“有从下手了”，我们不让他放入到队列中，直接执行即可。</p><h3 id="Go-中的内存模型是怎样的？"><a href="#Go-中的内存模型是怎样的？" class="headerlink" title="Go 中的内存模型是怎样的？"></a>Go 中的内存模型是怎样的？</h3><p>// TODO</p>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;p&gt;最近学习到一个关于内存模型的知识点，一开始对内存模型的认识还是以为是描述数据结构实在内存中怎样进行存储的。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>perterson 算法学习</title>
    <link href="https://bqyang.top/2022/os/peterson/"/>
    <id>https://bqyang.top/2022/os/peterson/</id>
    <published>2022-06-23T10:30:51.717Z</published>
    <updated>2022-04-19T12:17:15.034Z</updated>
    
    <content type="html"><![CDATA[<p>并发控制算法之-Peterson</p><span id="more"></span><h3 id="Peterson-算法解决了什么问题"><a href="#Peterson-算法解决了什么问题" class="headerlink" title="Peterson 算法解决了什么问题"></a>Peterson 算法解决了什么问题</h3><ul><li>peterson 算法解决的是双线程访问共享变量导致的 data-race 问题。</li></ul><blockquote><p>这里确实是双线程，但是该算法在多线程场景下也适用。</p></blockquote><h3 id="Peterson-算法描述"><a href="#Peterson-算法描述" class="headerlink" title="Peterson 算法描述"></a>Peterson 算法描述</h3><p>抽象的代码描述，内容来自 <a href="https://en.wikipedia.org/wiki/Peterson%27s_algorithm">wiki</a>：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> flag[<span class="number">2</span>] = &#123;<span class="literal">false</span>, <span class="literal">false</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> turn;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*pc 1*/</span>P0:      flag[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">/*pc 2*/</span>P0_gate: turn = <span class="number">1</span>;</span><br><span class="line"><span class="comment">/*pc 3*/</span>         <span class="keyword">while</span> (flag[<span class="number">1</span>] == <span class="literal">true</span> &amp;&amp; turn == <span class="number">1</span>)</span><br><span class="line">                 &#123;</span><br><span class="line">                     <span class="comment">// busy wait</span></span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="comment">// critical section</span></span><br><span class="line">                 ...</span><br><span class="line">                 <span class="comment">// end of critical section</span></span><br><span class="line"><span class="comment">/*pc 4*/</span>         flag[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* pc 1*/</span>P1:      flag[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">/* pc 2*/</span>P1_gate: turn = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/* pc 3*/</span>         <span class="keyword">while</span> (flag[<span class="number">0</span>] == <span class="literal">true</span> &amp;&amp; turn == <span class="number">0</span>)</span><br><span class="line">                 &#123;</span><br><span class="line">                     <span class="comment">// busy wait</span></span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="comment">// critical section</span></span><br><span class="line">                 ...</span><br><span class="line">                 <span class="comment">// end of critical section</span></span><br><span class="line"><span class="comment">/* pc 4*/</span>        flag[<span class="number">1</span>] = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p>代码解释：</p><ul><li>flag 用于标识哪个线程想要进入临界区</li><li>turn 用于辅助flag表示，也是用来判断是否可以进入临界区</li></ul><p>规定如下：</p><blockquote><p>如果对方的 flag 为真且 turn 不是自己的名字，需要等待，否则（上述两条件任意一个为假）进入临界区。</p></blockquote><p>这时候我们启动 P1,P2 两个线程，模拟两个线程交替执行，然后将涉及到的状态变化画出来，正如图中所表示的一样。</p><p><img src="https://s2.loli.net/2022/04/19/l4dy1wmXIgMuUCx.png" alt="peterson"></p><p>综上所述，Peterson 算法，巧妙地运用了 flag, turn 标识达到了互斥访问的目的。</p><h3 id="表面上的谦让"><a href="#表面上的谦让" class="headerlink" title="表面上的谦让"></a>表面上的谦让</h3><p>这里我们可以看到，如果说 P1 先将 P2 的名字放到了 turn 上，假惺惺的说，你先进吧。但是 P2 执行的时候会覆盖掉 turn，让 P1 进，所以就出现了先修改 turn 变量的线程先进入，后修改的等待。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;并发控制算法之-Peterson&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>操作系统启动</title>
    <link href="https://bqyang.top/2022/os/os-start/"/>
    <id>https://bqyang.top/2022/os/os-start/</id>
    <published>2022-06-23T10:30:51.716Z</published>
    <updated>2022-06-25T04:36:38.101Z</updated>
    
    <content type="html"><![CDATA[<p>尝试揭开操作系统的神秘面纱，计算机世界中到底有没有 magic？</p><span id="more"></span><h1 id="QEMU"><a href="#QEMU" class="headerlink" title="QEMU"></a>QEMU</h1><h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget https://download.qemu.org/qemu-7.0.0.tar.xz</span><br><span class="line">tar xvJf qemu-7.0.0.tar.xz</span><br><span class="line">cd qemu-7.0.0</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">// make 后记得 make install</span><br></pre></td></tr></table></figure><blockquote><p>安装个 QEMU 真的是费死劲了，能遇到的问题基本上都遇到了，而且<strong>这个容器我挂了windows</strong>的一个目录（为了保存下来），make 花了<strong>3</strong>小时。</p></blockquote><p>遇到的具体问题如下：</p><ul><li>缺少依赖，pixman-1, gthread, glib, 我是基于 alpine 镜像构建的，很多依赖找起来很费事，不过要熟练使用 search 命令。</li></ul><p>具体解决方案省略，作为一个合格的工程师，肯定会找到办法的。</p><h1 id="CPU-Reset"><a href="#CPU-Reset" class="headerlink" title="CPU Reset"></a>CPU Reset</h1><p>程序就是状态机，操作系统也是一个 C 程序。那么问题就来了，电脑在 CPU Reset 之后（获得了一个初始状态）发生了什么？</p><blockquote><p>初始状态指的是：各种寄存器的初始值是什么。</p></blockquote><p><strong>计算机中没有任何神秘的东西</strong></p><p><img src="https://s2.loli.net/2022/05/06/e6anlsRhC2BULVu.png" alt="intel-cpu-reset"></p><p>可以看到，表 9-1 列出了在通电、重置、初始化后各种寄存器的值。这些都是<strong>约定</strong>，即硬件和软件约定好，每次加电后，CPU 状态设置为这些值，CPU 就是不断地执行指令，然后一步一步的加载出操作系统代码。</p><p><img src="https://s2.loli.net/2022/05/06/9SzlH2nRchoykQL.png" alt="image-20220506202315147"></p><h1 id="Legacy-BIOS-约定"><a href="#Legacy-BIOS-约定" class="headerlink" title="Legacy BIOS 约定"></a>Legacy BIOS 约定</h1><p>（操作系统与BIOS之间的约定，BIOS 上哪加载操作系统代码）</p><p>BIOS （Basic I/O System），BIOS 就是我们 CPU Reset 后 PC 指向的位置，也就意味着加电后执行的第一个程序是 BIOS 代码。然后 BIOS  代码都做了什么呢？他要做的事情都是约定好的。</p><p>MBR（Master Boot Record）主引导扇区，BIOS 要做的事情就是加载磁盘的前<strong>512字节</strong>（主引导扇区）到 <strong>0x7c00</strong>，<strong>检查这块磁盘是否可以作为启动盘</strong>。如果是，可以从磁盘中加载更多的内容到内存中，否则检查下一块磁盘的前512字节。</p><p>检查磁盘作为启动盘的标志是什么？<strong>55aa</strong></p><blockquote><p>怎么查看呢？有没有什么命令能查？</p><p>还真就是只有想不到的，没有做不到的。</p></blockquote><p>**hexdump ** 可以 <code>hexdump --help</code> 看一下具体细节，这里就是 <code>hexdump -n 512 /dev/sda    </code></p><p>补上一张 MBR 的图片</p><p><img src="https://s2.loli.net/2022/05/13/K9cL6sJ2etyP4QR.png" alt="o_mbr_anatomy"></p><p>是哪条指令将 MBR 中的内容加载到内存中的？</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 就是下面这条指令</span><br><span class="line">0xfa759:     rep insl (%dx),%es:(%di)</span><br><span class="line"># ...</span><br></pre></td></tr></table></figure><blockquote><p>如何查看上述的指令？x/i ($cs * 16 + $rip)</p></blockquote><p>cs （code segment register） 代码段寄存器</p><p>ds （data segment register） 数据段寄存器</p><p>为什么要按照这个算式进行查询呢？<code>($cs * 16 + $rip)</code> 早期的 IBM PC 机器，总线是 20 位，但是寄存器中都是 16 位的数据，所以怎么凑够这个 20 位的总线，代码段地址左移 4 位，然后加上偏移量，就是我们要执行的下一条指令地址。</p><p><strong>为什么叫做 x86 架构</strong></p><p>一般这种都是历史原因… 早期的 IBM PC 机器使用 Intel 8086 处理器，后来就把这个 8086 CPU 的架构叫做 x86。更详细的内容可以 Google 上看下，其实就连这个 <code>0x7c00  </code>都有一部分历史原因。</p><h1 id="Linux-操作系统启动流程"><a href="#Linux-操作系统启动流程" class="headerlink" title="Linux 操作系统启动流程"></a>Linux 操作系统启动流程</h1><p>CPU Reset –&gt; Firmware –&gt; Loader –&gt; Kernel_start() –&gt; 第一个程序 /bin/init –&gt; 程序执行+系统调用</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;尝试揭开操作系统的神秘面纱，计算机世界中到底有没有 magic？&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>同步原语-semaphore</title>
    <link href="https://bqyang.top/2022/os/concurrency-sema/"/>
    <id>https://bqyang.top/2022/os/concurrency-sema/</id>
    <published>2022-06-23T10:30:51.715Z</published>
    <updated>2022-04-27T08:26:56.324Z</updated>
    
    <content type="html"><![CDATA[<p>同步原语–信号量学习</p><span id="more"></span><h2 id="信号量定义"><a href="#信号量定义" class="headerlink" title="信号量定义"></a>信号量定义</h2><p>信号量就是一个拥有整数值的对象，可以用多个例程操控它。</p><blockquote><p>信号量的初始值决定了它的行为，在与它交互之前需要进行初始化，如下：</p></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># int sem_init(</span></span><br><span class="line"><span class="keyword">sem_t</span> *sem,</span><br><span class="line"><span class="keyword">int</span> pshared,</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> value);</span><br><span class="line"><span class="meta"># sem 信号</span></span><br><span class="line"><span class="meta"># value 指定了信号量的初始值</span></span><br><span class="line"><span class="meta"># pshared 表示在线程间共享，还是进程间</span></span><br><span class="line">sema_init()</span><br></pre></td></tr></table></figure><h2 id="使用-sema-实现-lock"><a href="#使用-sema-实现-lock" class="headerlink" title="使用 sema 实现 lock"></a>使用 sema 实现 lock</h2><p>这时应将 sema 的 value 设置为几？</p><p>可以想象，锁的状态其实只有<strong>上锁，未上锁</strong>两种状态，所以我们只需要使信号量满足这两种状态即可，即 value = 1，这种情况下，0，1就可以表示锁的这两种状态。</p><p>想进入临界区（以下用 CS 代替），就需要获取锁，检查信号量是否被占用：</p><ul><li>未上锁，信号量的值减一，进入临界区</li><li>上锁，信号量值减一，睡眠等待</li></ul><p>退出 CS，调用 <code>sema_post</code> 释放信号：</p><ul><li>有等待线程：信号量值加一，退出临界区，唤醒一个等待中的线程</li><li>没有等待线程：信号量值加一，退出临界区，无需唤醒</li></ul><blockquote><p>当信号量为负数时，比如说 -3，代表着有三个线程在等待这个信号被释放</p></blockquote><p>不难看出，当我们使用信号量来实现锁的时候，只有这两种状态（上锁，未上锁），所以这种信号通常也被称为<strong>binary semaphore</strong></p><h2 id="sema-实现-CVs"><a href="#sema-实现-CVs" class="headerlink" title="sema 实现 CVs"></a>sema 实现 CVs</h2><p><code>sema_init(sema, 0, 0)</code></p><p>想要父进程等待子进程执行结束的话，为什么 value 的值要设置为 0 ？</p><h2 id="sema-实现-producer-consumer-模型"><a href="#sema-实现-producer-consumer-模型" class="headerlink" title="sema 实现 producer/consumer 模型"></a>sema 实现 producer/consumer 模型</h2><p>如同当初使用 CVs 实现生产者消费者模型时一样，这里也是需要两个信号量来表示何时生产者可发送，接收者可接收。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    sem_init(&amp;empty, <span class="number">0</span>, MAX); <span class="comment">// MAX are empty</span></span><br><span class="line">    sem_init(&amp;full, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">// 0 are full</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 MAX &gt; 1 时，会出现什么问题？（仔细观察，的确不难看出，data-race）</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> buffer[MAX];</span><br><span class="line"><span class="keyword">int</span> fill = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> use = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    buffer[fill] = value; <span class="comment">// Line F1</span></span><br><span class="line">    fill = (fill + <span class="number">1</span>) % MAX; <span class="comment">// Line F2</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = buffer[use]; <span class="comment">// Line G1</span></span><br><span class="line">    use = (use + <span class="number">1</span>) % MAX; <span class="comment">// Line G2</span></span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">sem_t</span> empty;</span><br><span class="line"><span class="keyword">sem_t</span> full;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">producer</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loops; i++) &#123;</span><br><span class="line">        sem_wait(&amp;empty); <span class="comment">// Line P1</span></span><br><span class="line">        put(i); <span class="comment">// Line P2</span></span><br><span class="line">        sem_post(&amp;full); <span class="comment">// Line P3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">consumer</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (tmp != <span class="number">-1</span>) &#123;</span><br><span class="line">        sem_wait(&amp;full); <span class="comment">// Line C1</span></span><br><span class="line">        tmp = get(); <span class="comment">// Line C2</span></span><br><span class="line">        sem_post(&amp;empty); <span class="comment">// Line C3</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, tmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="哲学家吃饭"><a href="#哲学家吃饭" class="headerlink" title="哲学家吃饭.."></a>哲学家吃饭..</h2><p><img src="https://s2.loli.net/2022/04/27/wYIi1fhCQog2XVP.png" alt="image-20220427140847674"></p><ul><li><p><strong>如何解决相互依赖的问题</strong></p></li><li><p><strong>什么情况下会出现死锁</strong></p></li></ul><h2 id="Thread-Throttling"><a href="#Thread-Throttling" class="headerlink" title="Thread Throttling"></a>Thread Throttling</h2><p>线程节流，控制线程数量。</p><p>通过信号量控制进入临界区的线程数量</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;同步原语–信号量学习&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
</feed>
