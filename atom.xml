<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>杨宝强的技术笔记</title>
  
  <subtitle>宝强的技术成长</subtitle>
  <link href="https://bqyang.top/atom.xml" rel="self"/>
  
  <link href="https://bqyang.top/"/>
  <updated>2022-05-17T09:58:57.886Z</updated>
  <id>https://bqyang.top/</id>
  
  <author>
    <name>杨宝强</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>打印字符</title>
    <link href="https://bqyang.top/2022/language/c/print/"/>
    <id>https://bqyang.top/2022/language/c/print/</id>
    <published>2022-05-17T06:31:17.737Z</published>
    <updated>2022-05-17T09:58:57.886Z</updated>
    
    <content type="html"><![CDATA[<p>for循环打印字符</p><span id="more"></span><p>还是有点意思的，使用嵌套for循环输出如下格式：</p><pre class="line-numbers language-none"><code class="language-none">ABCDEFGHIJK...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>另一个输出这样：</p><pre class="line-numbers language-none"><code class="language-none">  A   ABA ABCBA<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>华</p><hr><p>​                    丽</p><hr><p>​                                    的</p><hr><p>​                                                    分</p><hr><p>​                                                                    割</p><hr><p>​                                                                                    线</p><hr><p>答案如下：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;int main(void) &#123;    for (int i &#x3D; 0, s &#x3D; &#39;A&#39;; i &lt; 6; i++, s+&#x3D;i) &#123;          for(int j &#x3D; s, k &#x3D; 0; k &lt;&#x3D; i; k++, j++ ) &#123;            printf(&quot;%c&quot;, j);        &#125;        printf(&quot;\n&quot;);    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;int main(void) &#123;    printf(&quot;Please input start letter for print\n&quot;);       char alpha;    scanf(&quot;%c&quot;, &amp;alpha);    char A &#x3D; 65;    for (char t &#x3D; A; t &lt;&#x3D; alpha; t++) &#123;           for (char j &#x3D; alpha; j &gt; t; j--) &#123;            printf(&quot; &quot;);        &#125;                for(char i &#x3D; A; i &lt; t; i++) &#123;                 printf(&quot;%c&quot;, i);        &#125;        for (char k &#x3D; t; k &gt;&#x3D; A; k--) &#123;               printf(&quot;%c&quot;, k);        &#125;                printf(&quot;\n&quot;);    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;for循环打印字符&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>C-String</title>
    <link href="https://bqyang.top/2022/language/c/string/"/>
    <id>https://bqyang.top/2022/language/c/string/</id>
    <published>2022-05-11T10:47:31.133Z</published>
    <updated>2022-05-11T11:17:50.298Z</updated>
    
    <content type="html"><![CDATA[<p>复习 C 语言字符串</p><span id="more"></span><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p><strong>字符串 （character string）</strong> 是一个或多个字符的序列。</p><p>实际上，字符串就是一个字符数组，**但是在字符末尾插入了 \0 **用来表示字符串的结束。</p><p>所以，数组的容量一定是要比待存储的字符串字节数多 1，用来存储 \0，举个例子，我们想存储名字 <code>abc </code> 就必须使用 <code>char name[4]</code> 来存储。</p><blockquote><p>末尾的 \0 计算机会自动帮我们加上</p></blockquote><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>接收控制台输入，parisel.c</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">PRAISE</span> <span class="token string">"good jobbbb"</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">char</span> name<span class="token punctuation">[</span><span class="token number">40</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Input you name "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s, %s\n"</span><span class="token punctuation">,</span> name<span class="token punctuation">,</span> PRAISE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>问题：</p><ul><li>为什么 scanf 接收参数的时候不需要传递指针？</li></ul><h1 id="字符串和字符"><a href="#字符串和字符" class="headerlink" title="字符串和字符"></a>字符串和字符</h1><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 字符串 "x"</span><span class="token comment">// 字符   'x'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这两个虽然看起来相似，但是底层的存储结构是不一样的，字符使用 char 类型来存储，字符串使用的是数组，而且还需要一个 <code>\0</code>，由两个字符组成。</p><h1 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h1><p>为什么使用符号常量更好？</p><ul><li><em>常量名称可以表达更多的意思</em></li><li><em>方便后续修改</em></li></ul><h2 id="定义常量"><a href="#定义常量" class="headerlink" title="定义常量"></a>定义常量</h2><p><code>#define PI 3.14</code> 更通用的表示为 <code>#define NAME value</code>, C 中一般采用大写名称来表示常量。</p><p>代码中使用这样的常量，会在编译时替换掉（预处理阶段替换），即<em>编译时替换</em>（compile-time substitution）。</p><h2 id="const-限定符号"><a href="#const-限定符号" class="headerlink" title="const 限定符号"></a>const 限定符号</h2><p>Go 中使用的方式 <code>const name = &quot;xx&quot;</code></p><p>C 中要这样用 <code>const int Months = 12;</code></p><blockquote><p>C 中 const 声明的是变量，不是常量。</p></blockquote><h2 id="看几个标准库中的常量"><a href="#看几个标准库中的常量" class="headerlink" title="看几个标准库中的常量"></a>看几个标准库中的常量</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;复习 C 语言字符串&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Rust-Enums</title>
    <link href="https://bqyang.top/2022/language/rust/enum/"/>
    <id>https://bqyang.top/2022/language/rust/enum/</id>
    <published>2022-05-10T07:53:07.016Z</published>
    <updated>2022-05-11T06:29:35.881Z</updated>
    
    <content type="html"><![CDATA[<p>Rust 枚举</p><span id="more"></span><p><strong>定义、声明</strong></p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">enmu <span class="token class-name">IpAddrKind</span> <span class="token punctuation">&#123;</span>    <span class="token constant">V4</span><span class="token punctuation">,</span>    <span class="token constant">V6</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>定义了一个枚举数据类型，IpAddrKind，枚举中有两个变量，V4，V6。但是这样存在一个问题，实际的 IP 地址应该存储在哪里，这只是定义了两种 Ip 类型。</p><p>如何使用 enum 存储值？</p><p>方法一，使用 struct：</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">struct</span> <span class="token type-definition class-name">IpAddr</span> <span class="token punctuation">&#123;</span>    kind<span class="token punctuation">:</span> <span class="token class-name">IpAddrKind</span><span class="token punctuation">,</span>    address<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token keyword">let</span> home <span class="token operator">=</span> <span class="token class-name">IpAddr</span> <span class="token punctuation">&#123;</span>    kind<span class="token punctuation">:</span> <span class="token class-name">IpAddrKind</span><span class="token punctuation">::</span><span class="token constant">V4</span><span class="token punctuation">,</span>    address<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">let</span> loopback <span class="token operator">=</span> <span class="token class-name">IpAddr</span> <span class="token punctuation">&#123;</span>    kind<span class="token punctuation">:</span> <span class="token class-name">IpAddrKind</span><span class="token punctuation">::</span><span class="token constant">V6</span><span class="token punctuation">,</span>    address<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"::1"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>方法二，使用 enum 存储：</p><p>直接使用 enum 存储值，这个有点意思..</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">enum</span> <span class="token type-definition class-name">IpAddr</span> <span class="token punctuation">&#123;</span>    <span class="token constant">V4</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token constant">V6</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token keyword">let</span> home <span class="token operator">=</span> <span class="token class-name">IpAddr</span><span class="token punctuation">::</span><span class="token constant">V4</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> loopback <span class="token operator">=</span> <span class="token class-name">IpAddr</span><span class="token punctuation">::</span><span class="token constant">V6</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"::1"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>标准库中如何定义 IpAddr 的：</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">struct</span> <span class="token type-definition class-name">Ipv4Addr</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// --snip--</span><span class="token punctuation">&#125;</span><span class="token keyword">struct</span> <span class="token type-definition class-name">Ipv6Addr</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// --snip--</span><span class="token punctuation">&#125;</span><span class="token keyword">enum</span> <span class="token type-definition class-name">IpAddr</span> <span class="token punctuation">&#123;</span>    <span class="token constant">V4</span><span class="token punctuation">(</span><span class="token class-name">Ipv4Addr</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token constant">V6</span><span class="token punctuation">(</span><span class="token class-name">Ipv6Addr</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>**可以给 enum 添加 method..**这里其实 Go 也可以实现：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// 类似这样的代码</span><span class="token keyword">type</span> Strings <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token keyword">func</span> <span class="token punctuation">(</span>s Strings<span class="token punctuation">)</span> <span class="token function">Less</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>The <code>Option</code> Enum</strong></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Rust 枚举&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Rust-Structs</title>
    <link href="https://bqyang.top/2022/language/rust/structs/"/>
    <id>https://bqyang.top/2022/language/rust/structs/</id>
    <published>2022-05-10T07:26:34.826Z</published>
    <updated>2022-05-11T02:54:20.456Z</updated>
    
    <content type="html"><![CDATA[<p>rust 中的结构体和方法（method）。</p><span id="more"></span><h1 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h1><p>其实各种语言对 Struct 的实例化都差不多，主要就是关注下 Rust 里关于 struct 的语法。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// struct from C</span><span class="token keyword">struct</span> <span class="token class-name">foo</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> age<span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token comment">// struct from Rust</span><span class="token keyword">struct</span> <span class="token type-definition class-name">bar</span> <span class="token punctuation">&#123;</span>    active<span class="token punctuation">:</span> <span class="token keyword">bool</span><span class="token punctuation">,</span>    username<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">,</span>    email<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">,</span>    sign_in_count<span class="token punctuation">:</span> <span class="token keyword">u64</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// struct from Go</span><span class="token keyword">type</span> foobar <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>    name <span class="token builtin">string</span>    age <span class="token builtin">int</span>    email <span class="token builtin">string</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>都差不多..</p><h2 id="打印结构体"><a href="#打印结构体" class="headerlink" title="打印结构体"></a>打印结构体</h2><p>没想到 rust 里边打印一个结构体这么麻烦，如果说打印某个字段直接用 <code>println!(&quot;&#123;&#125;&quot;, xx.xx);</code> 就行，但是要是打印整个结构体中的内容，还得给结构体定义前加上 <code>#[derive(Debug)] </code>..这样才能打印出调试信息。</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token attribute attr-name">#[derive(Debug)]</span><span class="token keyword">struct</span> <span class="token type-definition class-name">User</span> <span class="token punctuation">&#123;</span>    name<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">,</span>    age<span class="token punctuation">:</span> <span class="token keyword">u32</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>输出完整结构体算是调试功能，但是我们需要手动添加相关内容让某个结构体使用这个功能。</p></blockquote><p>添加完以后才能输出完整的结构体：</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token comment">// pretty print</span><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"&#123;:#?&#125;"</span><span class="token punctuation">,</span> xx<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="dbg"><a href="#dbg" class="headerlink" title="dbg!"></a>dbg!</h2><p>可以用来输出调试信息，<code>dbg!(xx);</code></p><h1 id="method"><a href="#method" class="headerlink" title="method"></a>method</h1><p>method 的第一个参数永远是 self。    </p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">struct</span> <span class="token type-definition class-name">User</span> <span class="token punctuation">&#123;</span>    name<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">,</span>    age<span class="token punctuation">:</span> <span class="token keyword">u32</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token keyword">impl</span> <span class="token class-name">User</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">fn</span> <span class="token function-definition function">print_name</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token operator">&amp;</span><span class="token class-name">String</span> <span class="token punctuation">&#123;</span>        <span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">.</span>name    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;rust 中的结构体和方法（method）。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Rust-Ownership</title>
    <link href="https://bqyang.top/2022/language/rust/ownership/"/>
    <id>https://bqyang.top/2022/language/rust/ownership/</id>
    <published>2022-05-09T11:47:42.459Z</published>
    <updated>2022-05-10T07:21:55.003Z</updated>
    
    <content type="html"><![CDATA[<p>Rust 核心概念了解 —— Ownership</p><span id="more"></span><p>Ownership 就是定义了一些规则，比如在函数中传递参数的时候是怎么处理参数的，官网的解释为<strong>Rust程序如何管理内存的一系列规则</strong>。</p><p><strong>内存管理的三种方式</strong></p><ul><li>Go 语言这类，自动垃圾回收机制</li><li>C 语言，手动垃圾回收，显示分配、释放</li><li>Rust 独一档，结合<strong>编译器、ownership 定义的规则</strong>，如果说没有按照 Rust Ownership 定义的规则，那么编译就不会通过。</li></ul><p>第一次知道，还能有这样的内存管理方式..</p><h1 id="ownership-by-example"><a href="#ownership-by-example" class="headerlink" title="ownership by example"></a>ownership by example</h1><p>（通过例子学习 ownership）</p><blockquote><p>The Stack and the Heap</p></blockquote><p><code>All data stored on the stack must have a known, fixed size. Data with an unknown size at compile time or a size that might change must be stored on the heap instead.</code></p><p><code>Accessing data in the heap is slower than accessing data on the stack because you have to follow a pointer to get there. </code></p><h2 id="ownership-Rules"><a href="#ownership-Rules" class="headerlink" title="ownership Rules"></a>ownership Rules</h2><ul><li>Rust 中每一个值都有一个被叫做 <code>owner</code> 的变量，比如 a = 1, 1 的 owner 就是 a。</li><li>同一时刻有且仅有一个 owner。</li><li>当 owner 超出范围时（超出作用域），value 会被丢弃。</li></ul><h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h2><p>作用域大家了解的已经很多了，要是直接看 C 代码其实还是有点懵逼的。。不信你试试。。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>很显然，答案不是 2 ，2； 正确答案为：2， 1；</p></blockquote><p>Rust 中其实也类似，如下：</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span><span class="token comment">// 这时候变量开始有效</span>    <span class="token punctuation">&#125;</span>     <span class="token comment">// 从这时起，就无效</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>两个重要的点：</p><ul><li>变量 s 在作用域内，有效</li><li>变量 s 超出作用域，无效</li></ul><h2 id="内存和分配"><a href="#内存和分配" class="headerlink" title="内存和分配"></a>内存和分配</h2><p>Rust 中内存释放的方式，<strong>超出了作用域自动释放</strong>。Rust 也算是帮我们做了内存管理，虽然没有 GC，但是也不用我们手动进行 free，避免出现 double free 问题，如上述分配的 s 变量，超出了作用域就被释放掉。</p><h2 id="ownership-Move"><a href="#ownership-Move" class="headerlink" title="ownership Move"></a>ownership Move</h2><p>Stack </p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> y <span class="token operator">=</span> x<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>Heap</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> s1 <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> s2 <span class="token operator">=</span> s1<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>两段代码表达的意思相近，但是，在不同的内存空间上有着很大的差别。</p><ul><li><p>stack 不赘述</p></li><li><p>heap</p><p><img src="https://doc.rust-lang.org/book/img/trpl04-02.svg" alt="s1 and s2 pointing to the same value"></p></li></ul><p>执行完赋值操作后，有两个指向同一块内存的指针，但是这也会存在一种情况，当 s1 和 s2 都用不到时候，会进行 free，就会出现 double free 的情况。</p><p>所以，为了保证内存安全，在 <code>let s2 = s1;</code> 执行完成后，Rust <strong>认为 s1 不再有效</strong>。即，将 s1 ownership move to s2.</p><h2 id="ownership-Clone"><a href="#ownership-Clone" class="headerlink" title="ownership Clone"></a>ownership Clone</h2><p>(deeply copy)</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> s1 <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> s2 <span class="token operator">=</span> s1<span class="token punctuation">.</span><span class="token class-name">Copy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"s1 is &#123;&#125;, s2 is &#123;&#125;"</span><span class="token punctuation">,</span> s1<span class="token punctuation">,</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://doc.rust-lang.org/book/img/trpl04-03.svg" alt="s1 and s2 to two places"></p><h2 id="Stack-Only-Data-Copy"><a href="#Stack-Only-Data-Copy" class="headerlink" title="Stack-Only Data: Copy"></a>Stack-Only Data: Copy</h2><p><code>The reason is that types such as integers that have a known size at compile time are stored entirely on the stack, so copies of the actual values are quick to make. That means there’s no reason we would want to prevent </code>x<code>from being valid after we create the variable</code>y<code>. </code></p><p>总而言之，栈上的数据会进行 Copy，堆上的数据会进行 move。</p><h2 id="函数之间-ownership-的改变"><a href="#函数之间-ownership-的改变" class="headerlink" title="函数之间 ownership 的改变"></a>函数之间 ownership 的改变</h2><p>将变量传递给函数的时候也可能会发生 move 或 copy，和分配差不多。</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// s comes into scope</span>    <span class="token function">takes_ownership</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment">// s's value moves into the function...</span>    <span class="token comment">// ... and so is no longer valid here</span>    <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>                      <span class="token comment">// x comes into scope</span>    <span class="token function">makes_copy</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token comment">// x would move into the function,</span>    <span class="token comment">// but i32 is Copy, so it's okay to still</span>    <span class="token comment">// use x afterward</span><span class="token punctuation">&#125;</span> <span class="token comment">// Here, x goes out of scope, then s. But because s's value was moved, nothing</span><span class="token comment">// special happens.</span><span class="token keyword">fn</span> <span class="token function-definition function">takes_ownership</span><span class="token punctuation">(</span>some_string<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// some_string comes into scope</span>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"&#123;&#125;"</span><span class="token punctuation">,</span> some_string<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token comment">// Here, some_string goes out of scope and `drop` is called. The backing</span><span class="token comment">// memory is freed.</span><span class="token keyword">fn</span> <span class="token function-definition function">makes_copy</span><span class="token punctuation">(</span>some_integer<span class="token punctuation">:</span> <span class="token keyword">i32</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// some_integer comes into scope</span>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"&#123;&#125;"</span><span class="token punctuation">,</span> some_integer<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token comment">// Here, some_integer goes out of scope. Nothing special happens.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="函数返回时与-ownership"><a href="#函数返回时与-ownership" class="headerlink" title="函数返回时与 ownership"></a>函数返回时与 ownership</h2><p>返回值也会转移 ownership。</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> s1 <span class="token operator">=</span> <span class="token function">gives_ownership</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// gives_ownership moves its return</span>    <span class="token comment">// value into s1</span>    <span class="token keyword">let</span> s2 <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// s2 comes into scope</span>    <span class="token keyword">let</span> s3 <span class="token operator">=</span> <span class="token function">takes_and_gives_back</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// s2 is moved into</span>    <span class="token comment">// takes_and_gives_back, which also</span>    <span class="token comment">// moves its return value into s3</span><span class="token punctuation">&#125;</span> <span class="token comment">// Here, s3 goes out of scope and is dropped. s2 was moved, so nothing</span><span class="token comment">// happens. s1 goes out of scope and is dropped.</span><span class="token keyword">fn</span> <span class="token function-definition function">gives_ownership</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token class-name">String</span> <span class="token punctuation">&#123;</span>             <span class="token comment">// gives_ownership will move its</span>    <span class="token comment">// return value into the function</span>    <span class="token comment">// that calls it</span>    <span class="token keyword">let</span> some_string <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"yours"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// some_string comes into scope</span>    some_string                              <span class="token comment">// some_string is returned and</span>    <span class="token comment">// moves out to the calling</span>    <span class="token comment">// function</span><span class="token punctuation">&#125;</span><span class="token comment">// This function takes a String and returns one</span><span class="token keyword">fn</span> <span class="token function-definition function">takes_and_gives_back</span><span class="token punctuation">(</span>a_string<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token class-name">String</span> <span class="token punctuation">&#123;</span> <span class="token comment">// a_string comes into</span>    <span class="token comment">// scope</span>    a_string  <span class="token comment">// a_string is returned and moves out to the calling function</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>综上所述，每次进行函数传参的时候都会发生 ownership 的转移，如果说我们给 funcA 传一个 A 参数后，仍然要使用 A 参数，应该怎么办呢？</p><ul><li> 可以把这个参数从 funcA 中返回</li></ul><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> s1 <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> <span class="token punctuation">(</span>s2<span class="token punctuation">,</span> len<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">calculate_length</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"The length of string &#123;&#125; is &#123;&#125;"</span><span class="token punctuation">,</span> s2<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">fn</span> <span class="token function-definition function">calculate_length</span><span class="token punctuation">(</span>s<span class="token punctuation">:</span> string<span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token keyword">usize</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> length <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">(</span>s<span class="token punctuation">,</span> length<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>牛x的 Rust 当然还提供了另一种方式，<strong>reference</strong>。</li></ul><h2 id="Reference-and-Borrowing"><a href="#Reference-and-Borrowing" class="headerlink" title="Reference and Borrowing"></a>Reference and Borrowing</h2><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>本以为这个 reference 和 pointer 是一个东西，但是 rust 中貌似并不是这么定义的，且看且分析。</p><p><code> A reference is like a pointer in that it’s an address we can follow to access data stored at that address that is owned by some other variable.</code></p><p>reference 和 pointer 相同的点，存储的都是地址，可以通过这个地址访问存储在这个地址上的数据，这个数据可能是属于别的变量的。 <strong>不同的点</strong>，reference 指向的永远是<strong>有效</strong>的地址。</p><p><img src="https://doc.rust-lang.org/book/img/trpl04-05.svg" alt="&amp;String s pointing at String s1"></p><p>因此，上述代码就可以就改为，</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> s1 <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> len <span class="token operator">=</span> <span class="token function">calculate_length</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"The length of '&#123;&#125;' is &#123;&#125;."</span><span class="token punctuation">,</span> s1<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">fn</span> <span class="token function-definition function">calculate_length</span><span class="token punctuation">(</span>s<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token keyword">usize</span> <span class="token punctuation">&#123;</span> <span class="token comment">// s is a reference to a String</span>    s<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面这段引用，再一次解释了，传递引用给函数时发生了什么，不再赘述。</p><blockquote><p><code>When functions have references as parameters instead of the actual values, we won’t need to return the values in order to give back ownership, because we never had ownership.</code></p></blockquote><h3 id="Borrowing"><a href="#Borrowing" class="headerlink" title="Borrowing"></a>Borrowing</h3><p>（把创建 reference 的行为定义成 borrowing）。在实际生活中，就跟借东西是一个意思，假设一个人拥有一辆保时捷，你借过来开两天，然后还回去，我们从未拥有过保时捷。</p><p>然后问题就来了，比如我们接过来保时捷开两天，发现他的颜色看着不顺眼，你想给他改装，这时候怎么办？如下。</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> s1 <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">change</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">fn</span> <span class="token function-definition function">change</span><span class="token punctuation">(</span>some_str<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>         some_str<span class="token punctuation">.</span><span class="token function">push_str</span><span class="token punctuation">(</span><span class="token string">"RTFM"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">error[E0596]: cannot borrow &#96;*some_str&#96; as mutable, as it is behind a &#96;&amp;&#96; reference --&gt; src&#x2F;main.rs:8:5  |7 | fn change(some_str: &amp;String) &#123;  |                     ------- help: consider changing this to be a mutable reference: &#96;&amp;mut String&#96;8 |     some_str.push_str(&quot;RTFM&quot;);  |     ^^^^^^^^^^^^^^^^^^^^^^^^^ &#96;some_str&#96; is a &#96;&amp;&#96; reference, so the data it refers to cannot be borrowed as mutableFor more information about this error, try &#96;rustc --explain E0596&#96;.error: could not compile &#96;borrowing&#96; due to previous error<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>验证了一个结论，默认情况加，<strong>borrow</strong>过来的东西是不可修改的，除非加上<strong>mut</strong>(mutable)，如下：</p><pre class="line-numbers language-none"><code class="language-none">fn main() &#123;    let mut s1 &#x3D; String::from(&quot;hello&quot;);    change(&amp;mut s1);&#125;fn change(some_str: &amp;mut String) &#123;         some_str.push_str(&quot;RTFM&quot;);     &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样就可肆无忌惮的修改 reference 指向的内容了，形如这样的被称为 <code>mutable reference</code>。</p><p>Mutable referenct 一个最大限制：<strong>在同一时刻只能拥有某个变量的一个 mut reference</strong>。可以试试下面这段代码：</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> <span class="token keyword">mut</span> s1 <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"RTFM"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> r1 <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> s1<span class="token punctuation">;</span>    <span class="token keyword">let</span> r2 <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> s2<span class="token punctuation">;</span>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"&#123;&#125; &#123;&#125;"</span><span class="token punctuation">,</span> r1<span class="token punctuation">,</span> r2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">error[E0499]: cannot borrow &#96;s1&#96; as mutable more than once at a time --&gt; src&#x2F;main.rs:5:14  |4 |     let s2 &#x3D; &amp;mut s1;  |              ------- first mutable borrow occurs here5 |     let s3 &#x3D; &amp;mut s1;  |              ^^^^^^^ second mutable borrow occurs here6 | 7 |     println!(&quot;&#123;&#125; &#123;&#125;&quot;, s2, s3);  |                       -- first borrow later used hereFor more information about this error, try &#96;rustc --explain E0499&#96;.error: could not compile &#96;borrowing&#96; due to previous error<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>mutable reference and immutable reference</strong></p><p><strong>不能同时拥有可变的和不可变的 reference</strong>，意味着，要么只有一个 mutable，要么有多个 immutable，不能有一个 mutable 和多个 immutable 的情况。</p><h2 id="Reference-scope"><a href="#Reference-scope" class="headerlink" title="Reference scope"></a>Reference scope</h2><p>reference 的生效范围，**Note that a reference’s scope starts from where it is introduced and continues through the last time that reference is used. **</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> <span class="token keyword">mut</span> s <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> r1 <span class="token operator">=</span> <span class="token operator">&amp;</span>s<span class="token punctuation">;</span> <span class="token comment">// no problem</span>    <span class="token keyword">let</span> r2 <span class="token operator">=</span> <span class="token operator">&amp;</span>s<span class="token punctuation">;</span> <span class="token comment">// no problem</span>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"&#123;&#125; and &#123;&#125;"</span><span class="token punctuation">,</span> r1<span class="token punctuation">,</span> r2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// variables r1 and r2 will not be used after this point</span>    <span class="token keyword">let</span> r3 <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> s<span class="token punctuation">;</span> <span class="token comment">// no problem</span>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"&#123;&#125;"</span><span class="token punctuation">,</span> r3<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Dangling-References"><a href="#Dangling-References" class="headerlink" title="Dangling References"></a>Dangling References</h2><p>悬垂引用，有点类似 dangling pointer， rust 中，编译器会检查 reference 指向的内容是否有效，不会发生这种情况。。</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> reference_to_nothing <span class="token operator">=</span> <span class="token function">dangle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">fn</span> <span class="token function-definition function">dangle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token operator">&amp;</span><span class="token class-name">String</span> <span class="token punctuation">&#123;</span> <span class="token comment">// dangle returns a reference to a String</span>    <span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// s is a new String</span>    <span class="token operator">&amp;</span>s <span class="token comment">// we return a reference to the String, s</span><span class="token punctuation">&#125;</span> <span class="token comment">// Here, s goes out of scope, and is dropped. Its memory goes away.</span><span class="token comment">// Danger!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">$ cargo run   Compiling ownership v0.1.0 (file:&#x2F;&#x2F;&#x2F;projects&#x2F;ownership)error[E0106]: missing lifetime specifier --&gt; src&#x2F;main.rs:5:16  |5 | fn dangle() -&gt; &amp;String &#123;  |                ^ expected named lifetime parameter  |  &#x3D; help: this function&#39;s return type contains a borrowed value, but there is no value for it to be borrowed fromhelp: consider using the &#96;&#39;static&#96; lifetime  |5 | fn dangle() -&gt; &amp;&#39;static String &#123;  |                ~~~~~~~~For more information about this error, try &#96;rustc --explain E0106&#96;.error: could not compile &#96;ownership&#96; due to previous error<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Rules-of-Reference"><a href="#Rules-of-Reference" class="headerlink" title="Rules of Reference"></a>Rules of Reference</h2><ul><li>任何时刻，要么只能有一个 mutable reference，要么有多个 immutable reference。</li><li>Reference 指向的内容一定是有效的。</li></ul><h2 id="Slices"><a href="#Slices" class="headerlink" title="Slices"></a>Slices</h2><p>这个跟 Go 的切片引用类似..，直接贴张图，不再赘述。</p><p><img src="https://doc.rust-lang.org/book/img/trpl04-06.svg" alt="world containing a pointer to the byte at index 6 of String s and a length 5"></p><h2 id="完结撒花"><a href="#完结撒花" class="headerlink" title="完结撒花"></a>完结撒花</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;Rust 核心概念了解 —— Ownership&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Deployment 更新策略</title>
    <link href="https://bqyang.top/2022/k8s/deployment/"/>
    <id>https://bqyang.top/2022/k8s/deployment/</id>
    <published>2022-05-09T07:28:40.904Z</published>
    <updated>2022-05-09T11:36:05.417Z</updated>
    
    <content type="html"><![CDATA[<p>将笔记进行拆分，都写在一个里边很拥挤，不方便翻阅查看。</p><span id="more"></span><h1 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h1><h2 id="更新策略"><a href="#更新策略" class="headerlink" title="更新策略"></a>更新策略</h2><table><thead><tr><th>更新策略</th><th>描述</th></tr></thead><tbody><tr><td>Recreate</td><td>见名知意，更新的时候就是把已存在的 Pod 删除，创建一个新的</td></tr><tr><td>RollingUpdate</td><td>滚动更新，先准备新的 Pod，就绪后再删除老的 Pod，在更新期间也可以正常提供服务。<strong>默认配置</strong>。</td></tr></tbody></table><p><img src="https://s2.loli.net/2022/05/09/uwBeEpl6Gq41WkC.png" alt="img"></p><h2 id="Recreate-如何影响应用"><a href="#Recreate-如何影响应用" class="headerlink" title="Recreate 如何影响应用"></a>Recreate 如何影响应用</h2><p>在重启期间，无法正常访问服务，正如上图中会有一段空档期。</p><h2 id="Deployment-和-Replicas-的关系"><a href="#Deployment-和-Replicas-的关系" class="headerlink" title="Deployment 和 Replicas 的关系"></a>Deployment 和 Replicas 的关系</h2><p><img src="https://s2.loli.net/2022/05/09/cmYjDQrSAguyaN3.png" alt="img"></p><p>正如我们看到的，<code>Deployment</code> 和 <code>Replica</code> 并不是总是一对一的关系，在更新操作执行后，会出现上图中的情况。</p><h2 id="RollingUpdate"><a href="#RollingUpdate" class="headerlink" title="RollingUpdate"></a>RollingUpdate</h2><p><img src="https://s2.loli.net/2022/05/09/GzleTsRbmFaNLwI.png" alt="img"></p><h3 id="Deployment-配置"><a href="#Deployment-配置" class="headerlink" title="Deployment 配置"></a>Deployment 配置</h3><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">kind</span><span class="token punctuation">:</span> Deployment<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> kiada<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">strategy</span><span class="token punctuation">:</span>    <span class="token key atrule">type</span><span class="token punctuation">:</span> RollingUpdate    <span class="token key atrule">rollingUpdate</span><span class="token punctuation">:</span>      <span class="token key atrule">maxSurge</span><span class="token punctuation">:</span> <span class="token number">0</span>      <span class="token key atrule">maxUnavailable</span><span class="token punctuation">:</span> <span class="token number">1</span>  <span class="token key atrule">minReadySeconds</span><span class="token punctuation">:</span> <span class="token number">10</span>  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">3</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token punctuation">...</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="配置一次替换多少个-Pod"><a href="#配置一次替换多少个-Pod" class="headerlink" title="配置一次替换多少个 Pod"></a>配置一次替换多少个 Pod</h3><p>通过 <code>maxSurge</code> 和 <code>maxUnavailable</code> 配置</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>maxSurge</td><td>The maximum number of Pods above the desired number of replicas that the Deployment can have during the rolling update. The value can be an absolute number or a percentage of the desired number of replicas.<br /><br />在滚动更新期间 Deployment 可以超过 replica 中最大的 Pod 数量。</td></tr><tr><td>maxUnavaliable</td><td>The maximum number of Pods relative to the desired replica count that can be unavailable during the rolling update. The value can be an absolute number or a percentage of the desired number of replicas.<br /><br />最少可用的 Pod 数量为 total - maxUnavailable，最多不可用的 Pod 数量为 maxUnavailable</td></tr></tbody></table><p> <code>maxSurge</code> 和 <code>maxUnavailable</code> 会影响 Replica 中期望的 Pod 数量。</p><p><strong>maxSurge = 0, maxUnavailable = 1</strong></p><p><img src="https://s2.loli.net/2022/05/09/toFLwvXl5HuqObE.png" alt="img"></p><p><strong>maxSurge = 1, maxUnavailable = 0</strong></p><p><img src="https://s2.loli.net/2022/05/09/cE5UJVdDAa8mkrg.png" alt="img"></p><p><strong>maxSurge = 1, maxUnavailable = 1</strong></p><p><img src="https://s2.loli.net/2022/05/09/mnLPUaQyldEHxj3.png" alt="img"></p><h3 id="暂停、恢复-RollingUpdate"><a href="#暂停、恢复-RollingUpdate" class="headerlink" title="暂停、恢复 RollingUpdate"></a>暂停、恢复 RollingUpdate</h3><p><code>kubectl rollout pause deployment kiada</code> 和 <code>kubectl rollout resume deployment kiada</code></p><p>这个骚操作还是第一次听说..</p><h3 id="minReadySeconds"><a href="#minReadySeconds" class="headerlink" title="minReadySeconds"></a>minReadySeconds</h3><p>在 RollingUpdate 过程中，新创建的 Pod Ready 后，<strong>还不算结束</strong>，要等待 <code>minReadySeconds</code> 这么久后， Pod 才会变为 available 状态。</p><p>默认情况下是 0，Pod Ready 了就算 available.</p><h3 id="检查-rollout-是否在执行"><a href="#检查-rollout-是否在执行" class="headerlink" title="检查 rollout 是否在执行"></a>检查 rollout 是否在执行</h3><p><code>kubectl describe deployment xxx</code></p><h3 id="回滚-Rolling-Back"><a href="#回滚-Rolling-Back" class="headerlink" title="回滚 Rolling Back"></a>回滚 Rolling Back</h3><ul><li><p>回滚到上一版本</p><p><code>kubectl rollout undo deployment kiada</code></p></li></ul><blockquote><p>undo 命令也可以在 RollingUpdate 过程中使用，用来取消这个升级</p></blockquote><ul><li><p>回滚到指定版本</p><p><code>kubectl rollout undo deployment kiada --to-revision=1</code></p></li></ul><h3 id="回滚和使用-yaml-文件恢复的区别"><a href="#回滚和使用-yaml-文件恢复的区别" class="headerlink" title="回滚和使用 yaml 文件恢复的区别"></a>回滚和使用 yaml 文件恢复的区别</h3><ul><li>回滚使用 <code>kubectl rollout undo</code> 命令，只是恢复 pod-templete 内容</li><li>使用 apply -f 的方式会将所有的内容进行恢复</li></ul><p>比如我们在 1.2 版本中修改了升级方式为 RollingUpdate，1.1 仍然为 Recreate，这时候如果我们通过，apply 的方式，会将我们改的内容进行覆盖。</p><p>一般情况下，都是用 <code>kubectl rollout undo</code> 命令，之前没学到这个命令，在操作更新版本的时候，都是 edit deployment 然后修改一下 镜像的版本，出了问题也是简单粗暴的处理，直接将版本恢复回去。</p><p>下次上线升级的时候，可以考虑使用这种方式，两个字，优雅。</p><h3 id="显示-rollout-历史"><a href="#显示-rollout-历史" class="headerlink" title="显示 rollout 历史"></a>显示 rollout 历史</h3><p><code>kubectl rollout history deploy kiada</code></p><ul><li><p>查看某次升级的具体信息</p><p><code>kubectl rollout history deployment kiada --revision 2</code></p><p>查看 kiada 这个 Deployment 在 revision 为 2 的版本做了哪些调整。</p></li></ul><p><img src="https://s2.loli.net/2022/05/09/XWgT2rFj7blSqU9.png" alt="img"></p><ul><li><code>revisionHistoryLimit</code> 用来配置保存多少个历史记录，默认是 10。</li></ul><h2 id="Traffic-shadowing"><a href="#Traffic-shadowing" class="headerlink" title="Traffic shadowing"></a>Traffic shadowing</h2><p>（这个应该翻译成啥呢？）</p><p><img src="https://s2.loli.net/2022/05/09/Pu9zvCGAU4e1dZy.png" alt="img"></p><p>利用 Ingress 进行流量复制，将请求转发一份到新的版本中，然后忽略掉响应。</p><h2 id="完"><a href="#完" class="headerlink" title="完"></a>完</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;将笔记进行拆分，都写在一个里边很拥挤，不方便翻阅查看。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>操作系统启动</title>
    <link href="https://bqyang.top/2022/os/os-start/"/>
    <id>https://bqyang.top/2022/os/os-start/</id>
    <published>2022-05-05T11:02:26.938Z</published>
    <updated>2022-05-13T03:22:13.982Z</updated>
    
    <content type="html"><![CDATA[<hr><p>尝试揭开操作系统的神秘面纱。</p><span id="more"></span><h1 id="QEMU"><a href="#QEMU" class="headerlink" title="QEMU"></a>QEMU</h1><h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><pre class="line-numbers language-none"><code class="language-none">wget https:&#x2F;&#x2F;download.qemu.org&#x2F;qemu-7.0.0.tar.xztar xvJf qemu-7.0.0.tar.xzcd qemu-7.0.0.&#x2F;configuremake&#x2F;&#x2F; make 后记得 make install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>安装个 QEMU 真的是费死劲了，能遇到的问题基本上都遇到了，而且<strong>这个容器我挂了windows</strong>的一个目录（为了保存下来），make 花了<strong>3</strong>小时。</p></blockquote><p>遇到的具体问题如下：</p><ul><li>缺少依赖，pixman-1, gthread, glib, 我是基于 alpine 镜像构建的，很多依赖找起来很费事，不过要熟练使用 search 命令。</li></ul><p>具体解决方案省略，作为一个合格的工程师，肯定会找到办法的。</p><h1 id="CPU-Reset"><a href="#CPU-Reset" class="headerlink" title="CPU Reset"></a>CPU Reset</h1><p>程序就是状态机，操作系统也是一个 C 程序。那么问题就来了，电脑在 CPU Reset 之后（获得了一个初始状态）发生了什么？</p><blockquote><p>初始状态指的是：各种寄存器的初始值是什么。</p></blockquote><p><strong>计算机中没有任何神秘的东西</strong></p><p><img src="https://s2.loli.net/2022/05/06/e6anlsRhC2BULVu.png" alt="intel-cpu-reset"></p><p>可以看到，表 9-1 列出了在通电、重置、初始化后各种寄存器的值。这些都是<strong>约定</strong>，即硬件和软件约定好，每次加电后，CPU 状态设置为这些值，CPU 就是不断地执行指令，然后一步一步的加载出操作系统代码。</p><p><img src="https://s2.loli.net/2022/05/06/9SzlH2nRchoykQL.png" alt="image-20220506202315147"></p><h1 id="Legacy-BIOS-约定"><a href="#Legacy-BIOS-约定" class="headerlink" title="Legacy BIOS 约定"></a>Legacy BIOS 约定</h1><p>（操作系统与BIOS之间的约定，BIOS 上哪加载操作系统代码）</p><p>BIOS （Basic I/O System），BIOS 就是我们 CPU Reset 后 PC 指向的位置，也就意味着加电后执行的第一个程序是 BIOS 代码。然后 BIOS  代码都做了什么呢？他要做的事情都是约定好的。</p><p>MBR（Master Boot Record）主引导扇区，BIOS 要做的事情就是加载磁盘的前<strong>512字节</strong>（主引导扇区）到 <strong>0x7c00</strong>，<strong>检查这块磁盘是否可以作为启动盘</strong>。如果是，可以从磁盘中加载更多的内容到内存中，否则检查下一块磁盘的前512字节。</p><p>检查磁盘作为启动盘的标志是什么？<strong>55aa</strong></p><blockquote><p>怎么查看呢？有没有什么命令能查？</p><p>还真就是只有想不到的，没有做不到的。</p></blockquote><p>**hexdump ** 可以 <code>hexdump --help</code> 看一下具体细节，这里就是 <code>hexdump -n 512 /dev/sda    </code></p><p>补上一张 MBR 的图片</p><p><img src="https://s2.loli.net/2022/05/13/K9cL6sJ2etyP4QR.png" alt="o_mbr_anatomy"></p><p>是哪条指令将 MBR 中的内容加载到内存中的？</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly"># 就是下面这条指令0xfa759:     rep insl (%dx),%es:(%di)# ...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>如何查看上述的指令？x/i ($cs * 16 + $rip)</p></blockquote><p>cs （code segment register） 代码段寄存器</p><p>ds （data segment register） 数据段寄存器</p><p>为什么要按照这个算式进行查询呢？<code>($cs * 16 + $rip)</code> 早期的 IBM PC 机器，总线是 20 位，但是寄存器中都是 16 位的数据，所以怎么凑够这个 20 位的总线，代码段地址左移 4 位，然后加上偏移量，就是我们要执行的下一条指令地址。</p><h1 id="为什么叫做-x86-架构"><a href="#为什么叫做-x86-架构" class="headerlink" title="为什么叫做 x86 架构"></a>为什么叫做 x86 架构</h1><p>一般这种都是历史原因… 早期的 IBM PC 机器使用 Intel 8086 处理器，后来就把这个 8086 CPU 的架构叫做 x86。更详细的内容可以 Google 上看下，其实就连这个 <code>0x7c00  </code>都有一部分历史原因。</p>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;p&gt;尝试揭开操作系统的神秘面纱。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>同步原语-semaphore</title>
    <link href="https://bqyang.top/2022/os/concurrency-sema/"/>
    <id>https://bqyang.top/2022/os/concurrency-sema/</id>
    <published>2022-04-25T02:48:51.361Z</published>
    <updated>2022-04-27T06:46:19.575Z</updated>
    
    <content type="html"><![CDATA[<p>同步原语–信号量学习</p><span id="more"></span><h2 id="信号量定义"><a href="#信号量定义" class="headerlink" title="信号量定义"></a>信号量定义</h2><p>信号量就是一个拥有整数值的对象，可以用多个例程操控它。</p><blockquote><p>信号量的初始值决定了它的行为，在与它交互之前需要进行初始化，如下：</p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;semaphore.h></span></span><span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">int</span> <span class="token expression"><span class="token function">sem_init</span><span class="token punctuation">(</span></span></span><span class="token class-name">sem_t</span> <span class="token operator">*</span>sem<span class="token punctuation">,</span><span class="token keyword">int</span> pshared<span class="token punctuation">,</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">sem</span> <span class="token expression">信号</span></span><span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">value</span> <span class="token expression">指定了信号量的初始值</span></span><span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">pshared</span> <span class="token expression">表示在线程间共享，还是进程间</span></span><span class="token function">sema_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="使用-sema-实现-lock"><a href="#使用-sema-实现-lock" class="headerlink" title="使用 sema 实现 lock"></a>使用 sema 实现 lock</h2><p>这时应将 sema 的 value 设置为几？</p><p>可以想象，锁的状态其实只有<strong>上锁，未上锁</strong>两种状态，所以我们只需要使信号量满足这两种状态即可，即 value = 1，这种情况下，0，1就可以表示锁的这两种状态。</p><p>想进入临界区（以下用 CS 代替），就需要获取锁，检查信号量是否被占用：</p><ul><li>未上锁，信号量的值减一，进入临界区</li><li>上锁，信号量值减一，睡眠等待</li></ul><p>退出 CS，调用 <code>sema_post</code> 释放信号：</p><ul><li>有等待线程：信号量值加一，退出临界区，唤醒一个等待中的线程</li><li>没有等待线程：信号量值加一，退出临界区，无需唤醒</li></ul><blockquote><p>当信号量为负数时，比如说 -3，代表着有三个线程在等待这个信号被释放</p></blockquote><p>不难看出，当我们使用信号量来实现锁的时候，只有这两种状态（上锁，未上锁），所以这种信号通常也被称为<strong>binary semaphore</strong></p><h2 id="sema-实现-CVs"><a href="#sema-实现-CVs" class="headerlink" title="sema 实现 CVs"></a>sema 实现 CVs</h2><p><code>sema_init(sema, 0, 0)</code></p><p>想要父进程等待子进程执行结束的话，为什么 value 的值要设置为 0 ？</p><h2 id="sema-实现-producer-consumer-模型"><a href="#sema-实现-producer-consumer-模型" class="headerlink" title="sema 实现 producer/consumer 模型"></a>sema 实现 producer/consumer 模型</h2><p>如同当初使用 CVs 实现生产者消费者模型时一样，这里也是需要两个信号量来表示何时生产者可发送，接收者可接收。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// ...</span>    <span class="token function">sem_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>empty<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> MAX<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// MAX are empty</span>    <span class="token function">sem_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>full<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 0 are full</span>    <span class="token comment">// ...</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当 MAX &gt; 1 时，会出现什么问题？（仔细观察，的确不难看出，data-race）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> buffer<span class="token punctuation">[</span>MAX<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> fill <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">int</span> use <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    buffer<span class="token punctuation">[</span>fill<span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">;</span> <span class="token comment">// Line F1</span>    fill <span class="token operator">=</span> <span class="token punctuation">(</span>fill <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> MAX<span class="token punctuation">;</span> <span class="token comment">// Line F2</span><span class="token punctuation">&#125;</span> <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> tmp <span class="token operator">=</span> buffer<span class="token punctuation">[</span>use<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// Line G1</span>    use <span class="token operator">=</span> <span class="token punctuation">(</span>use <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> MAX<span class="token punctuation">;</span> <span class="token comment">// Line G2</span>    <span class="token keyword">return</span> tmp<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token class-name">sem_t</span> empty<span class="token punctuation">;</span><span class="token class-name">sem_t</span> full<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">producer</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> loops<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">sem_wait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>empty<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Line P1</span>        <span class="token function">put</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Line P2</span>        <span class="token function">sem_post</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>full<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Line P3</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">consumer</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> tmp <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>tmp <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">sem_wait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>full<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Line C1</span>        tmp <span class="token operator">=</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Line C2</span>        <span class="token function">sem_post</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>empty<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Line C3</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="哲学家吃饭"><a href="#哲学家吃饭" class="headerlink" title="哲学家吃饭.."></a>哲学家吃饭..</h2><p><img src="https://s2.loli.net/2022/04/27/wYIi1fhCQog2XVP.png" alt="image-20220427140847674"></p><ul><li><p><strong>如何解决相互依赖的问题</strong></p></li><li><p><strong>什么情况下会出现死锁</strong></p></li></ul><h2 id="Thread-Throttling"><a href="#Thread-Throttling" class="headerlink" title="Thread Throttling"></a>Thread Throttling</h2><p>线程节流，控制线程数量。</p><p>通过信号量控制进入临界区的线程数量</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;同步原语–信号量学习&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>并发控制-Condition-variables</title>
    <link href="https://bqyang.top/2022/os/concurrency-cv/"/>
    <id>https://bqyang.top/2022/os/concurrency-cv/</id>
    <published>2022-04-24T08:51:57.520Z</published>
    <updated>2022-04-24T09:36:40.764Z</updated>
    
    <content type="html"><![CDATA[<p>检查某些<strong>特定条件</strong>是否满足，然后决定线程是否继续执行。</p><span id="more"></span><p>使用<strong>变量</strong>控制具体该哪个线程执行。</p><p>使用 CVs 实现 生产者/消费者 模型，最终实现：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> buffer<span class="token punctuation">[</span>MAX<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> fill_ptr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">int</span> use_ptr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    buffer<span class="token punctuation">[</span>fill_ptr<span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">;</span>    fill_ptr <span class="token operator">=</span> <span class="token punctuation">(</span>fill_ptr <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> MAX<span class="token punctuation">;</span>    count<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> tmp <span class="token operator">=</span> buffer<span class="token punctuation">[</span>use_ptr<span class="token punctuation">]</span><span class="token punctuation">;</span>    use_ptr <span class="token operator">=</span> <span class="token punctuation">(</span>use_ptr <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> MAX<span class="token punctuation">;</span>    count<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> tmp<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token class-name">cond_t</span> empty<span class="token punctuation">,</span> fill<span class="token punctuation">;</span><span class="token class-name">mutex_t</span> mutex<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">producer</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> loops<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">Pthread_mutex_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// p1</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> MAX<span class="token punctuation">)</span> <span class="token comment">// p2</span>            <span class="token function">Pthread_cond_wait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>empty<span class="token punctuation">,</span> <span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// p3</span>        <span class="token function">put</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// p4</span>        <span class="token function">Pthread_cond_signal</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>fill<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// p5</span>        <span class="token function">Pthread_mutex_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// p6</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">consumer</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> loops<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">Pthread_mutex_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// c1</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// c2</span>            <span class="token function">Pthread_cond_wait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>fill<span class="token punctuation">,</span> <span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// c3</span>        <span class="token keyword">int</span> tmp <span class="token operator">=</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// c4</span>        <span class="token function">Pthread_cond_signal</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>empty<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// c5</span>        <span class="token function">Pthread_mutex_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// c6</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为什么判断 <code>count == MAX OR count == 0</code> 的时候使用 <code>while</code> 而不是 <code>if</code>？？</p><blockquote><p>结论不重要，重要的是分析的过程</p></blockquote><p>// TODO 需要画状态机执行流程分析</p><blockquote><p><code>Pthread_cond_wait</code> 主要职责：将当前线程休眠<strong>并释放锁</strong>，当被唤醒的时候会尝试<strong>重新获取锁</strong>。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;检查某些&lt;strong&gt;特定条件&lt;/strong&gt;是否满足，然后决定线程是否继续执行。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>跟兄弟们聊聊</title>
    <link href="https://bqyang.top/2022/summary/about-0423/"/>
    <id>https://bqyang.top/2022/summary/about-0423/</id>
    <published>2022-04-23T05:24:37.969Z</published>
    <updated>2022-04-23T06:59:12.009Z</updated>
    
    <content type="html"><![CDATA[<p>今天上来就是为了跟兄弟们聊聊，在工作中怎么“优雅”的向别人提问，还有关于工作态度的一点理解。</p><span id="more"></span><p>这不也是闲的没事情嘛，明天还得补一天班，东拼西凑弄个五天假期，估计不少程序员同事还得加个两天。前两天女朋友刚好有一个面试，整个对话过程里外里透露着要剥削你。</p><p>她上来就给你承诺，法定节假日都是遵循国家规定的，后边说到加班的时候，冷不丁来一句，法定节假日加班是没有三倍工资的，我俩直接四目相对人都傻了。</p><p>后边当然就是果断拒绝，毕竟也是刚开始面试，还有很多机会。</p><p>好！接下来就聊聊，我最近工作上遇到的一件事情，或者说一类事情。（跟我没关系，是一种现象）开始之前先跟兄弟们说一下我平常的状态，每天基本上都是独来独往，因为住的也比较近嘛，中午也不在公司都是买完回家吃，所以跟同事平时的交流只有工作上的事情。对于公司里、同事间的八卦，我当然也感兴趣，但是奈何交流的不多，自然知道的也就比较少。</p><p>我想的就是，每天按时上下班，工作期间把活做完，合理安排时间。现在这家公司已经很人性化了，不用 KPI 逼着你出活，不用每天加班，给我们开发的时间也都绰绰有余。当给你一个完全没有涉猎过的领域时，你是有足够的时间从零开始的。</p><p>委婉的说，自己可支配时间很多，说白了，很多时间都是闲着没事干。</p><p>也就是这样，各种千奇百怪的人都冒出来了，先说说我，我就在座位上不忙的时候每天都有机会看会技术文章，忙的时候也不会抱怨，毕竟赚的就是这份钱。再说我见到的，大家都很默契的找到了同伴，两个人一组，基本上每天也都是固定的时间，到点就下楼。说实话，很羡慕但是自己还不敢出去转悠。我们这边工位一天有 1/4 的时间都是空着。</p><p>这都是我看到的，也没有刻意的去盯着谁谁，大家每天都是这个套路。</p><p>反正就我目前的想法来讲，有这个时间，不如多搞点技术。咱也别把话说的太死，万一以后咱也一样呢。</p><p>另一个就是怎么向别人提问，想跟兄弟们聊的并不是提问的方式，而是向别人提问的时候应该抱着怎样的态度，这是我的观点。</p><p>我们组前几个月新来了一个小子，五年工作经验，最开始没接触不知道他底，后边聊了几次，问了几次问题。话语之间就感觉到这tm五年，这五年怎么过来的。一些我这种初级问的问题，从他口中不知道问出来多少次，而且他问的还是我，一个初级。</p><p>就是觉得挺诧异，你不应该自己详细了解之后，然后针对没搞明白的地方进行提问吗，难道说要从到到尾给你讲一遍？这怎么体现你的学习能力，适应能力。所以所别很随便的就去提问，或者说我们要提就要提一些有意义的问题。</p><p>人不可能把你当小白对待，更没有时间给你做针对性的培训。不要把希望寄托在别人身上，既然一切的答案都在代码中，有时间浏览工作无关的网页，为什么不能花些时间去研究一下代码呢？</p><p>每个人的心里都有一杆秤，你张口，就可能会掉秤。咬咬牙，啃下来，那你就有机会涨。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天上来就是为了跟兄弟们聊聊，在工作中怎么“优雅”的向别人提问，还有关于工作态度的一点理解。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>并发控制-互斥（自旋锁、互斥锁）</title>
    <link href="https://bqyang.top/2022/os/concurrency-lock/"/>
    <id>https://bqyang.top/2022/os/concurrency-lock/</id>
    <published>2022-04-20T14:10:43.287Z</published>
    <updated>2022-04-24T08:52:37.868Z</updated>
    
    <content type="html"><![CDATA[<p>锁.</p><span id="more"></span><p>如何定义一把锁？</p><ul><li>basic - 能否达到互斥</li><li>fairness - 能否保证公平，极端情况下，是否会出现 thread 获取不到锁的情况</li><li>performance - 性能，使用锁带来的负载。<ul><li>没有竞争时</li><li>单核多线程竞争</li><li>多核多线程竞争</li></ul></li></ul><h2 id="原子指令-Bus-Lock"><a href="#原子指令-Bus-Lock" class="headerlink" title="原子指令 Bus Lock"></a>原子指令 Bus Lock</h2><p>正如我们最熟悉的<strong>累加</strong>运算，很多像我一样的初级程序员都会在编写并发程序的时候注意不到这个问题，运算过程中涉及到 load/store 指令，但是并不是原子操作。</p><p>所以在没有并发控制的情况下，很容易就会导致 data-race 的问题。我们可以通过算法，比如之前文章提到的 <code>Peterson</code> 来实现并发控制，但是我们可以图省事，把这项工作交给硬件工程师去做呀？</p><p>我们向硬件工程师提需求，让底层提供一条可以在多线程场景下使用的指令而且还得是并发安全的</p><p>有了硬件提供给我们一条原子的 读+写 （load+store） 指令，那我们就放心的去并发访问了，这里就是 exchange （x86 叫这个，别的又叫 Test_And_Set） 指令。</p><blockquote><p>请注意！不要误以为是 CAS</p></blockquote><p>只要执行 exchange 每次都会进行<strong>值的交换</strong>，就看交换得到的值是什么！</p><p>如何使用 exchange 实现互斥？</p><p><code>lock xchg</code> 这个 lock 就会将 bus 锁住（或许这就是为啥它叫 Bus Lock），所以这时候就不是共享的内存了，是<strong>持有这个 bus lock</strong> 线程专有的内存。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// global param</span><span class="token keyword">int</span> table <span class="token operator">=</span> YES<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>retry<span class="token operator">:</span>  <span class="token comment">// use NOPE exchange table(YES)</span>  <span class="token keyword">int</span> got <span class="token operator">=</span> <span class="token function">xchg</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>table<span class="token punctuation">,</span> NOPE<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// if got == NOPE mean other thread have exchanged; so should wait</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>got <span class="token operator">==</span> NOPE<span class="token punctuation">)</span>    <span class="token keyword">goto</span> retry<span class="token punctuation">;</span>  <span class="token function">assert</span><span class="token punctuation">(</span>got <span class="token operator">==</span> YES<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// unlock: use YES exchange NOPE</span><span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token function">xchg</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>table<span class="token punctuation">,</span> YES<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实现互斥的协议（即上述代码的描述）：</p><ul><li>想上厕所的同学 (一条 xchg 指令)<ul><li>天黑请闭眼（锁总线）</li><li>看一眼桌子上有什么 (🔑 或 🔞)</li><li>把 🔞 放到桌上 (覆盖之前有的任何东西)</li><li>天亮请睁眼；看到 🔑 才可以进厕所哦</li></ul></li><li>出厕所的同学<ul><li>把 🔑 放到桌上</li></ul></li></ul><blockquote><p>原子指令的模型</p><ul><li>保证之前的 store 都写入内存（在执行原子指令时，保证所有的 store 都执行完毕）</li><li>保证 load/store 不与原子指令乱序</li></ul></blockquote><p><strong>这里真的是解答了一个困惑我很长时间而且没有得到解决的疑问！</strong></p><p>原子操作并不是无锁的！</p><h3 id="TODO-Lock-指令的现代实现"><a href="#TODO-Lock-指令的现代实现" class="headerlink" title="// TODO Lock 指令的现代实现"></a>// TODO Lock 指令的现代实现</h3><h2 id="RISC-V-中原子操作的实现"><a href="#RISC-V-中原子操作的实现" class="headerlink" title="RISC-V 中原子操作的实现"></a>RISC-V 中原子操作的实现</h2><h2 id="自旋锁-spin-lock"><a href="#自旋锁-spin-lock" class="headerlink" title="自旋锁 (spin lock)"></a>自旋锁 (spin lock)</h2><p><a href="https://en.wikipedia.org/wiki/Spinlock#:~:text=In%20software%20engineering%2C%20a%20spinlock,a%20kind%20of%20busy%20waiting.">wiki</a> 定义：a <strong>spinlock</strong> is a <a href="https://en.wikipedia.org/wiki/Lock_(computer_science)">lock</a> that causes a <a href="https://en.wikipedia.org/wiki/Thread_(computer_science)">thread</a> trying to acquire it to simply wait in a loop (“spin”) while repeatedly checking whether the lock is available. </p><blockquote><p>spin 自旋，在这里就是循环等待锁被释放；GMP 模型中有一个 spining m 用来寻找可执行的 g 同样也是自旋。</p></blockquote><p>从上述的代码也不难看出，就是通过不断的循环，load 锁的状态，直到锁被上一个持有者释放。</p><p>自旋锁存在的问题：</p><ul><li>空转</li><li>获得自旋锁的线程可能被切换</li></ul><p>自旋锁使用场景：</p><p>操作系统内核的并发数据结构</p><ul><li>临界区几乎不拥堵，很快就能执行完</li><li>持有自旋锁时禁止执行流切换</li></ul><h2 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;锁.&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>图片仓库被屏蔽</title>
    <link href="https://bqyang.top/2022/warning/"/>
    <id>https://bqyang.top/2022/warning/</id>
    <published>2022-04-19T10:03:54.932Z</published>
    <updated>2022-04-19T12:18:32.924Z</updated>
    
    <content type="html"><![CDATA[<p>使用 gitee 做的图床被封了，导致很多图片都失效了，正在申请恢复，然后将图片一点点迁移到 SM.MS …</p><p>SM.MS 又有加载延迟的问题.. 但是也比看不了强..</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;使用 gitee 做的图床被封了，导致很多图片都失效了，正在申请恢复，然后将图片一点点迁移到 SM.MS …&lt;/p&gt;
&lt;p&gt;SM.MS 又有加载延迟的问题.. 但是也比看不了强..&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>perterson 算法学习</title>
    <link href="https://bqyang.top/2022/peterson/"/>
    <id>https://bqyang.top/2022/peterson/</id>
    <published>2022-04-18T06:31:47.361Z</published>
    <updated>2022-04-19T12:17:15.034Z</updated>
    
    <content type="html"><![CDATA[<p>并发控制算法之-Peterson</p><span id="more"></span><h3 id="Peterson-算法解决了什么问题"><a href="#Peterson-算法解决了什么问题" class="headerlink" title="Peterson 算法解决了什么问题"></a>Peterson 算法解决了什么问题</h3><ul><li>peterson 算法解决的是双线程访问共享变量导致的 data-race 问题。</li></ul><blockquote><p>这里确实是双线程，但是该算法在多线程场景下也适用。</p></blockquote><h3 id="Peterson-算法描述"><a href="#Peterson-算法描述" class="headerlink" title="Peterson 算法描述"></a>Peterson 算法描述</h3><p>抽象的代码描述，内容来自 <a href="https://en.wikipedia.org/wiki/Peterson%27s_algorithm">wiki</a>：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">bool flag<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>false<span class="token punctuation">,</span> false<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> turn<span class="token punctuation">;</span><span class="token comment">/*pc 1*/</span>P0<span class="token operator">:</span>      flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> true<span class="token punctuation">;</span><span class="token comment">/*pc 2*/</span>P0_gate<span class="token operator">:</span> turn <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">/*pc 3*/</span>         <span class="token keyword">while</span> <span class="token punctuation">(</span>flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> true <span class="token operator">&amp;&amp;</span> turn <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>                 <span class="token punctuation">&#123;</span>                     <span class="token comment">// busy wait</span>                 <span class="token punctuation">&#125;</span>                 <span class="token comment">// critical section</span>                 <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                 <span class="token comment">// end of critical section</span><span class="token comment">/*pc 4*/</span>         flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> false<span class="token punctuation">;</span><span class="token comment">/* pc 1*/</span>P1<span class="token operator">:</span>      flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> true<span class="token punctuation">;</span><span class="token comment">/* pc 2*/</span>P1_gate<span class="token operator">:</span> turn <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">/* pc 3*/</span>         <span class="token keyword">while</span> <span class="token punctuation">(</span>flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> true <span class="token operator">&amp;&amp;</span> turn <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>                 <span class="token punctuation">&#123;</span>                     <span class="token comment">// busy wait</span>                 <span class="token punctuation">&#125;</span>                 <span class="token comment">// critical section</span>                 <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                 <span class="token comment">// end of critical section</span><span class="token comment">/* pc 4*/</span>        flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> false<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码解释：</p><ul><li>flag 用于标识哪个线程想要进入临界区</li><li>turn 用于辅助flag表示，也是用来判断是否可以进入临界区</li></ul><p>规定如下：</p><blockquote><p>如果对方的 flag 为真且 turn 不是自己的名字，需要等待，否则（上述两条件任意一个为假）进入临界区。</p></blockquote><p>这时候我们启动 P1,P2 两个线程，模拟两个线程交替执行，然后将涉及到的状态变化画出来，正如图中所表示的一样。</p><p><img src="https://s2.loli.net/2022/04/19/l4dy1wmXIgMuUCx.png" alt="peterson"></p><p>综上所述，Peterson 算法，巧妙地运用了 flag, turn 标识达到了互斥访问的目的。</p><h3 id="表面上的谦让"><a href="#表面上的谦让" class="headerlink" title="表面上的谦让"></a>表面上的谦让</h3><p>这里我们可以看到，如果说 P1 先将 P2 的名字放到了 turn 上，假惺惺的说，你先进吧。但是 P2 执行的时候会覆盖掉 turn，让 P1 进，所以就出现了先修改 turn 变量的线程先进入，后修改的等待。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;并发控制算法之-Peterson&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>宽松内存模型</title>
    <link href="https://bqyang.top/2022/RMO/"/>
    <id>https://bqyang.top/2022/RMO/</id>
    <published>2022-04-16T15:52:21.800Z</published>
    <updated>2022-04-19T06:02:45.861Z</updated>
    
    <content type="html"><![CDATA[<hr><p>最近学习到一个关于内存模型的知识点，一开始对内存模型的认识还是以为是描述数据结构实在内存中怎样进行存储的。</p><span id="more"></span><p>后来发现我这种理解完全被这个名字所误导了，宽松内存模型指的是，在多核处理器的情况下，对访问共享内存行为的描述。</p><p>解释下面这个 C 代码：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"thread.h"</span></span><span class="token comment">// 全局变量 x, y</span><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>atomic_int flag<span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">FLAG</span> <span class="token expression"><span class="token function">atomic_load</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>flag<span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">FLAG_XOR</span><span class="token expression"><span class="token punctuation">(</span>val<span class="token punctuation">)</span> <span class="token function">atomic_fetch_xor</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>flag<span class="token punctuation">,</span> val<span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">WAIT_FOR</span><span class="token expression"><span class="token punctuation">(</span>cond<span class="token punctuation">)</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>cond<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">;</span></span></span><span class="token comment">// 指定编译的时候不要进行内联优化</span> <span class="token keyword">__attribute__</span><span class="token punctuation">(</span><span class="token punctuation">(</span>noinline<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">void</span> <span class="token function">write_x_read_y</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> y_val<span class="token punctuation">;</span>  <span class="token comment">// 汇编实现变量 +1 的操作</span>  <span class="token keyword">asm</span> <span class="token keyword">volatile</span><span class="token punctuation">(</span>    <span class="token string">"movl $1, %0;"</span> <span class="token comment">// x = 1</span>    <span class="token string">"movl %2, %1;"</span> <span class="token comment">// y_val = y</span>    <span class="token operator">:</span> <span class="token string">"=m"</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"=r"</span><span class="token punctuation">(</span>y_val<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token string">"m"</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span>  <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> y_val<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 代码含义如上</span> <span class="token keyword">__attribute__</span><span class="token punctuation">(</span><span class="token punctuation">(</span>noinline<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">void</span> <span class="token function">write_y_read_x</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> x_val<span class="token punctuation">;</span>  <span class="token keyword">asm</span> <span class="token keyword">volatile</span><span class="token punctuation">(</span>    <span class="token string">"movl $1, %0;"</span> <span class="token comment">// y = 1</span>    <span class="token string">"movl %2, %1;"</span> <span class="token comment">// x_val = x</span>    <span class="token operator">:</span> <span class="token string">"=m"</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"=r"</span><span class="token punctuation">(</span>x_val<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token string">"m"</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>  <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> x_val<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">T1</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">WAIT_FOR</span><span class="token punctuation">(</span><span class="token punctuation">(</span>FLAG <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">write_x_read_y</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">FLAG_XOR</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">T2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">WAIT_FOR</span><span class="token punctuation">(</span><span class="token punctuation">(</span>FLAG <span class="token operator">&amp;</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">write_y_read_x</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">FLAG_XOR</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// thread sync func</span><span class="token keyword">void</span> <span class="token function">Tsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    x <span class="token operator">=</span> y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">/*      No memory operand will be moved across the operation,      either forward or backward. Further,       instructions will be issued as necessary to prevent       the processor from speculating loads across       the operation and from queuing stores after the operation.      简言之就是会保证 x=y=0 这条赋值操作执行完成      或许你会问，我把这个赋值语句写在前边    */</span>    <span class="token function">__sync_synchronize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// full barrier</span>    <span class="token function">assert</span><span class="token punctuation">(</span>FLAG <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">FLAG_XOR</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 这里没搞懂，为什么执行 XOR 会使 cache miss</span>    <span class="token comment">// T1 and T2 clear 0/1-bit, respectively      </span>    <span class="token function">WAIT_FOR</span><span class="token punctuation">(</span>FLAG <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">fflush</span><span class="token punctuation">(</span><span class="token constant">stdout</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 创建线程，线程的起点为 T1</span>  <span class="token function">create</span><span class="token punctuation">(</span>T1<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">create</span><span class="token punctuation">(</span>T2<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">create</span><span class="token punctuation">(</span>Tsync<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码执行流程分析：</p><ul><li>T1,T2 函数开始执行就会被卡住，因为 FLAG 变量初始值为 0</li><li>Tsync 函数，初始化全局变量 x,y 然后执行了一个 <code>__sync_synchronize();</code> 函数，详情见注释。</li></ul><p>然后 <code>FLAG_XOR</code> 命令，让 T1, T2 两个在等待中的开始执行。</p><p>write_y_read_x 和 write_x_read_y 两个函数，也比较简单，就是将 x y 分别进行赋值的操作，然后读取另一个变量。写 y 读 x，写 x 读 y。我们看下具体的汇编代码：</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">00000000004008f1 &lt;write_x_read_y&gt;:  ... # 省略无关代码  # 将 1 赋值 x  4008f9:       c7 05 89 17 20 00 01    movl   $0x1,0x201789(%rip)        # 60208c &lt;x&gt;  # 读取 y 变量  400903:       8b 05 87 17 20 00       mov    0x201787(%rip),%eax        # 602090 &lt;y&gt;  ...  400921:       c3                      retq<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 从程序就是状态机的视角去分析的话，如下：</p><p>在开始时，我们有 x,y两个全局变量，T1,T2 两个线程，然后 T1，T2 开始交替执行。</p><p><img src="https://s2.loli.net/2022/04/19/x6KeQ2mMXN9qOJ3.jpg" alt="28d0652f7b48792aeea6c52883045fe.jpg"></p><p>从上图我们不难得出，所有的输出结果无外乎是</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 0 1</span><span class="token comment">// 1 0</span><span class="token comment">// 1 1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>我们看一下执行 1000 次的输出结果是什么样</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//   756 0 0 </span><span class="token comment">//   242 0 1</span><span class="token comment">//     2 1 0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>很奇怪，根本不存在序列为 <code>1 1</code> 的组合，而且输出占最多次数的是  <code>0 0</code> ，从我们刚才列出的输出结果中，并没有这个序列。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><p>实际上，我们的代码经过编译器优化后生成汇编指令，汇编指令被放到处理器上进行执行。在多核的情况下，为了榨取 CPU 的最高性能，<code>处理器会对待执行的汇编代码进行优化</code> 也就是将汇编代码再执行一次编译优化的过程，即处理器也是编译器。</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">movl   $0x1,0x201789(%rip)mov    0x201787(%rip),%eax<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>从我们人类的视角出发，我们更偏向于顺序化执行，但如果从处理器的视角出发，会对这两条指令进行优化。</p><p>他做的优化是：将写操作放入到待执行队列中，如果说队列塞满了，批量进行写操作。所以，第一条 mov 指令会被放入到队列中，然后先进行读操作。</p><p><img src="https://s2.loli.net/2022/04/19/X5LUKbMhiE9JpCt.png" alt="mem-tso.png"></p><p>所以这就是为什么我们没有看到 1 1 的原因。</p><h3 id="如何进行修复"><a href="#如何进行修复" class="headerlink" title="如何进行修复"></a>如何进行修复</h3><p>既然找到了问题的源头，那么就“有从下手了”，我们不让他放入到队列中，直接执行即可。</p><h3 id="Go-中的内存模型是怎样的？"><a href="#Go-中的内存模型是怎样的？" class="headerlink" title="Go 中的内存模型是怎样的？"></a>Go 中的内存模型是怎样的？</h3><p>// TODO</p>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;p&gt;最近学习到一个关于内存模型的知识点，一开始对内存模型的认识还是以为是描述数据结构实在内存中怎样进行存储的。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>一点总结</title>
    <link href="https://bqyang.top/2022/tips0309/"/>
    <id>https://bqyang.top/2022/tips0309/</id>
    <published>2022-03-09T11:52:02.048Z</published>
    <updated>2022-04-10T07:32:32.396Z</updated>
    
    <content type="html"><![CDATA[<p>这是一篇记录关于生活的记录。</p><span id="more"></span><p>时不时的想感慨一下，但是都是在脑海中一闪而过，现在努力回忆也记不清了，那就和大家聊聊近况吧！</p><p>过完年回来其实并不忙，每天都有时间去学习，要知道，传统的互联网公司，都是赶着进度走的。就好像老师昨天布置了三天的作业量，截止日期还没到的时候，又布置好三天后的作业了。在这种情况下，想参加什么课外活动是根本不可能的，所以你想做一些工作之外的事情也是抽不出来时间的，这也是我比较喜欢现在这家公司的一点。</p><p>我其实并不是喜欢，”前辈们“经常提到的一句话，在压力的驱动下做某些事情可能会更加高效。我觉得这更像是他们把一些繁琐复杂的，他们不想做的工作，强加到你身上的一个借口。所以说，当发生了别人强加于我某些事情时，我所关注的点就变了，我不会把解决问题放在第一位，相反，我在想，本来是你的事情，为什么现在变成了我的事情？</p><blockquote><p>在这里郑重声明，只是描述现象，不具有任何指向性。</p></blockquote><p>上边描述的内容，扯的有点远了，陷入了负面、消极的情绪之中，确实亲身经历过，每每说到这种话题的时候，就开始抑制不住自己。</p><p>也不吐槽啥了..跟大家汇报下最近的收获吧！</p><h3 id="收获-1-生活上"><a href="#收获-1-生活上" class="headerlink" title="收获 1 生活上"></a>收获 1 生活上</h3><p>我办了人生中的第一张信用卡，就算家里人知道我不会乱花钱，那也不敢让家里人知道，他们可能从某些地方听谁家的孩子欠了多少钱，就是这个信用卡什么乱七八糟的.. 我妈嘱咐我很多次不能碰这个东西哈哈。</p><p>但是我说办信用卡是为了买书是不是太装杯了哈哈，作为一名程序员，常需要汲取新鲜的技术和知识，以应对不断变化的大环境，随时做好换工作的准备。国外有一个专门做技术书籍的网站，manning.com 不知道大家有没有听说过，这里边采用了一种模式，<strong>连载</strong>，常看小说的人可能了解的比较多，就是作者还没有更新完全部章节呢，但是呢，他更一点你就可以看一点。</p><p>对！国内的资料在某些方面已经很多了，但是针对某些新鲜的技术，新鲜的领域，都是一些纯英文的资料。国内的技术人经过二次加工然后才呈现给大家。那干嘛不自己主动的去查阅最新的、一手的资料呢？</p><p>个人觉得没啥缺点，唯一的缺点就是我的缺点，我太穷了买不起哈哈，正常国内一本技术书，再贵也就 80 90块钱，这国外买本书打 5 折，还得 24 美元，算下来也得 150 块钱。</p><p>随后不久，就拥有了人生中第二张信用卡，但第二张并不是自己想办的，组长让我们帮她在某银行上班的媳妇一个忙，让我们组的人帮忙注册信用卡，大家没有拒绝的，那我这也不好意思拒绝了，不当那个出头的。</p><p>不过也还好，之前那个只有在境外消费的时候才用到，第二张就当作自己的“花呗”，每个月都会提前还款，对个人征信也是有好处的，反正也没啥毛病。。</p><blockquote><p>如果你克制不住自己消费的欲望，经常把钱花到透支.. 那可能你不适合信用卡..</p></blockquote><h3 id="收获-2-工作上"><a href="#收获-2-工作上" class="headerlink" title="收获 2 工作上"></a>收获 2 工作上</h3><p>作为一名新兵蛋子，能经历一个从零到一的项目，对自己来说可以算是莫大的帮助。从 21 年 8 月入职以来，就一直沉浸在各种的 bug 之中，每天都是解决不完的 bug。</p><p>今年过完年回来，才开始真正的做需求，从最初的年度规划到需求设计-需求评审-技术方案-代码开发（进行中）。可以在其中的每一步学习到很多东西，也包括人与人之间的交流，针对某些问题展开辩论，最终定下来某个方案。</p><p>讨论并不可怕，怕的就是某些时候这个“讨论”是根本没有意义的，最终确定不下来方案，没有可执行的计划。就好像，寝室六个人坐在一起，在讨论今天晚上吃什么，讨论了一晚上，也不知道吃什么，是不是挺形象的。</p><p>在做这个需求的时候，发现需要考虑的东西真的是挺多的，我最开始没有想的那么细致，先是把整体框架搭建出来，写上几个 TODO，直接给大家上个图，献丑了。</p><p><img src="https://gitee.com/yangbaoqiang/images/raw/master/blogpics/image-20220310211719535.png" alt="image-20220310211719535"></p><p>比如说上图，就是将一个点，分成几个阶段，然后记录下每个阶段该做什么事情，后续可能根据集体情况再进行调整。</p><p>以前实习的时候，公司前辈提到，某个业务逻辑先想清楚，想好了再写，写的又快又有质量。现在想想，其实和写作文一个意思，当然我作文写的并不好哈哈，语文经常不及格。所以这招对我来说好像并没有那么适用。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这是一篇记录关于生活的记录。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>k8s 2nd</title>
    <link href="https://bqyang.top/2022/k8s2nd/"/>
    <id>https://bqyang.top/2022/k8s2nd/</id>
    <published>2022-03-02T08:20:23.003Z</published>
    <updated>2022-04-29T07:30:51.493Z</updated>
    
    <content type="html"><![CDATA[<p>各个部分及其字段的含义。</p><span id="more"></span><p><img src="https://gitee.com/yangbaoqiang/images/raw/master/blogpics/image-20220302162130087.png" alt="image-20220302162130087"></p><p><img src="https://gitee.com/yangbaoqiang/images/raw/master/blogpics/image-20220302162138717.png" alt="image-20220302162138717"></p><p>更通俗的方式：</p><p><code>kubectl explain nodes</code></p><p>可以查看 node 的相关信息。</p><p>一个 pod 不应该运行多个容器：</p><ul><li>比如多个进程都会输出日志到控制台，会出现日志混乱。</li><li>container runtime 指挥在 root 进程崩溃的时候进行重启，并不关心子进程。</li><li>如果在一个 pod 中运行多个 container ，水平扩展的时候，会根据 pod 进行扩展，而不是根据 pod 中的 container 进行扩展。</li></ul><p>什么时候需要一个 pod 运行多个容器？</p><p><img src="https://gitee.com/yangbaoqiang/images/raw/master/blogpics/image-20220303135731675.png" alt="image-20220303135731675"></p><p>怎么确定是需要 sidecar 还是要 separate 模式？</p><p>• Do these containers have to run on the same host? </p><p>• Do I want to manage them as a single unit? </p><p>• Do they form a unified whole instead of being independent components? </p><p>• Do they have to be scaled together? </p><p>• Can a single node meet their combined resource needs? </p><p>只输出 yaml 文件 <code>kubectl run kubia --image=luksa/kubia:1.0 --dry-run=client -o yaml &gt; mypod.yaml</code></p><p>–dry-run=client 只输出定义不执行创建。</p><p>使用 port-forward 的执行过程。</p><p><img src="https://gitee.com/yangbaoqiang/images/raw/master/blogpics/image-20220303152703523.png" alt="image-20220303152703523"></p><p>pod 日志的相关操作：</p><ul><li>查看日志 <code>kubectl logs kubia</code></li><li>实时查看 <code>kubectl logs --follow kubia</code> 简版 <code>kubectl logs -f kubia</code></li><li>查看最近两分钟的日志 <code>kubectl logs kubia --since=2m</code></li><li>查看从某个时间点开始的日志 <code>kubectl logs kubia --since-time=xxxxxx</code></li><li>查看倒数10行的日志 <code>kubectl logs kubia --tail=10</code></li></ul><p>日志文件存储在哪里了？</p><p>pod 中的container日志，通常会存储在 node 的 <code>/var/log/containers</code> 中，每一个容器对应上一个独立的文件。<strong>如果 container 重启了，它的日志会写入到新的文件中</strong>，想要查看以前的日志文件，使用 <code>--previous(-p)</code> 命令。</p><p><img src="https://gitee.com/yangbaoqiang/images/raw/master/blogpics/image-20220303155702882.png" alt="image-20220303155702882"></p><p>对应的日志文件是长这个样子的.. 里边存储的日志也是 json 格式的。</p><hr><p>作者提到一个pod运行多个容器，现在要往一个运行容器的pod中再添加一个容器？</p><p>要怎么才能做到呢？</p><p>擦，感觉被骗了，人家后边是新创建一个 pod，新 pod  中包含两个 container。</p><p>分别查看pod中多个容器的日志</p><ul><li><code>kubectl logs kubia-ssl -c kubia</code> <strong>指定容器的名称</strong></li><li><code>kubectl logs kubia-ssl --all-containers</code> 查看所有容器的日志</li></ul><h3 id="Pod-的生命周期"><a href="#Pod-的生命周期" class="headerlink" title="Pod 的生命周期"></a>Pod 的生命周期</h3><p>状态变化过程：</p><p><img src="https://gitee.com/yangbaoqiang/images/raw/master/blogpics/image-20220304100100883.png" alt="image-20220304100100883"></p><p>Pod condition 变化过程：</p><p><img src="https://gitee.com/yangbaoqiang/images/raw/master/blogpics/image-20220304102134299.png" alt="image-20220304102134299"></p><p>Pod 重启策略</p><p><img src="https://gitee.com/yangbaoqiang/images/raw/master/blogpics/image-20220304134321707.png" alt="image-20220304134321707"></p><p>Pod 重启中的指数回退算法：</p><p>防止 pod 频繁重启，所以增加了每次 pod 的重启间隔。</p><p><img src="https://gitee.com/yangbaoqiang/images/raw/master/blogpics/image-20220304140257223.png" alt="image-20220304140257223"></p><p>当容器正常运行 10 分钟之后，这个重置时间会被清零。</p><p>探活过程，及参数解释：</p><p><img src="https://gitee.com/yangbaoqiang/images/raw/master/blogpics/image-20220304145015728.png" alt="image-20220304145015728"></p><ul><li><p>initialDelaySeconds：延迟探测时间</p></li><li><p>periodSeconds ：探测时间间隔</p></li><li><p>timeoutSeconds ：响应超时时间</p></li><li><p>failureThreshold ：失败次数</p></li></ul><p>Pod 探活指针，如果说要通过 httpGet 进行实现，那么在 handler 中<strong>不要做额外的重试工作</strong>，这种就像 k8s 通过 failureThreshold  参数给你搞了一个 for 循环，for 一次执行一次你的 handler，然后你在 handler 中又添加了 for 循环，其实这样是没有必要的。</p><p>比起这样直接添加 failureThreshold  的值即可。</p><p>在 Pod <strong>开始后，结束前</strong>执行某些特定操作。</p><p><img src="https://gitee.com/yangbaoqiang/images/raw/master/blogpics/image-20220308181524107.png" alt="image-20220308181524107"></p><p>post-start AND pre-stop</p><blockquote><p>post-start  并不是开始后执行，而是容器创建了就开始执行。</p></blockquote><p>pre-stop</p><p>当容器在初始化时候被终止，所有类型的探针都不会被执行。</p><p><strong>Pod 的声明周期</strong></p><p><img src="https://gitee.com/yangbaoqiang/images/raw/master/blogpics/image-20220322180937014.png" alt="image-20220322180937014"></p><p>imagePullPolicy：（init 阶段执行）</p><ul><li>Not specified 未指定的话，默认就是 always</li><li>Always 每一次启动或重启容器，都拉取镜像。<strong>如果有本地缓存，就不会重新拉取了</strong></li><li>Never</li><li>IfNotPresent </li></ul><p><img src="https://gitee.com/yangbaoqiang/images/raw/master/blogpics/image-20220322181518924.png" alt="image-20220322181518924"></p><p>拉一个 initContainer 镜像，执行一个初始化，然后再拉下一个 init 镜像，直到所有的 initContainer 执行完毕。</p><p><img src="https://gitee.com/yangbaoqiang/images/raw/master/blogpics/image-20220322181920040.png" alt="image-20220322181920040"></p><p><strong>Pod 的完整声明周期</strong></p><p><img src="https://gitee.com/yangbaoqiang/images/raw/master/blogpics/image-20220322215904044.png" alt="image-20220322215904044"></p><p><img src="https://gitee.com/yangbaoqiang/images/raw/master/blogpics/image-20220322215918443.png" alt="image-20220322215918443"></p><p><strong>为什么要给 Pod 挂卷</strong></p><p>为的就是重启的时候持久化数据。</p><blockquote><p>卷的生命周期和pod的生命周期是保持一致的，卷的生命周期独立于容器（即容器重启了，并不影响卷。如果pod被删除了，卷也会被删除）。</p></blockquote><p>卷的生命周期独立于 Pod 的情况，也就是挂载的卷不在 pod 内。</p><p><img src="https://gitee.com/yangbaoqiang/images/raw/master/blogpics/image-20220324100102363.png" alt="image-20220324100102363"></p><p><strong>emptyDir 卷类型</strong></p><p>从下图中可以看出，该类型的卷还是存储在了 Pod 所在的 Node 上</p><p><img src="https://gitee.com/yangbaoqiang/images/raw/master/blogpics/image-20220324143444116.png" alt="image-20220324143444116"></p><p><code>/var/lib/kubelet/pods/&lt;pod_UID&gt;/volumes/kubernetes.io~empty-dir/&lt;volume_name&gt;</code></p><p>hostPath 的用途？</p><p>通常来讲，Pod 被调度到哪个 Node 上是未知的，所以 hostPath 适用场景比较少。</p><p>当采用外部存储的时候，如果直接指定了存储卷的IP地址，那么在将 Pod 移动到另一个集群上时，比如从google移动到 Amazon，在 Google 的存储卷，在 Amazon 上不支持。</p><p>由此，k8s 引用了 PV(persistent volume)，抽象出来一个持久卷，从 yaml 直接指定存储卷，到间接引用 pv 对象，进行了引用间的解耦。</p><blockquote><p>Pod 并不会直接引用 PV，而是通过 PVC 。</p></blockquote><p>PV 的三种访问模式</p><table><thead><tr><th>访问模式</th><th>缩写</th><th>描述</th></tr></thead><tbody><tr><td>ReadWriteOnce</td><td>RWO</td><td>卷可以被一个 Worker Node 以读、写模式绑定。当他绑定到某个 node 时，不能被其他node 绑定。</td></tr><tr><td>ReadOnlyMany</td><td>ROX</td><td>卷可以被多个 node 以 读 的方式进行绑定。</td></tr><tr><td>ReadWriteMany</td><td>RWX</td><td>卷可以被多个 node 以 读/写的方式进行绑定。</td></tr></tbody></table><p>Pod 挂载到了 PVC，在删除的时候需要注意：</p><ul><li>删除了 pod pvc 显示的仍然是已绑定状态。</li><li>删除 pvc 后，绑定的 pv 是 released 状态，claim 列仍然显示已经被删除的 pvc。</li></ul><p>这是因为，pv 中可能保存了一些 application 存储在其中的数据，如果想要重复使用，需要将其中的数据清空。</p><p>想要 pv 可以重复使用，只有删除掉，然后重新创建。</p><blockquote><p>这个不会影响 volume 中存储的数据</p></blockquote><p>另一种方式是 edit pv 中的 claimRef，把这个 ref 删除掉， pv 的状态也会恢复为 available。</p><p>pv 的回收策略:</p><ul><li>retain</li><li>delete</li><li>recycle</li></ul><p>使用 configMap 的三种方式</p><p>单条 key - value 的方式进行注入</p><p>将整个 configMap 进行注入</p><p>将 configMap 以 volume 的方式进行注入</p><ul><li>通过 volume 的方式也可以指定特定的 key value，不需要卷下的所有内容。</li></ul><p>secret</p><p>worker node 上，secret 中的内容是存储在内存中的，并不会存储在磁盘上，进一步增加安全性。</p><p>downwardAPI</p><p>主要是用来暴露 pod 的一些信息给 pod 中的 application</p><p>还提供了一种聚合了 configMap、secret、downwardAPI 的 volume 类型，projected</p><h3 id="service"><a href="#service" class="headerlink" title="service"></a>service</h3><p>如果两个 pod 需要进行通信，想要知道另一个 pod 的 ip 地址是很困难的，原因如下：</p><ul><li>pod 只有在调度到指定 node 上才会有 IP 地址</li><li>pod 可能随时被替换，或者调度到其他的 node 上</li><li>水平扩展时，会出现很多相同服务的 pod</li></ul><p> 更新 service selector</p><p><code>kubectl set selector service service_name label_key=label_value</code></p><p>external service LB</p><p>配置分发模式，externalTrafficPolicy:</p><ul><li><p>Local 只转发给 service 选择的 node，不会通过这个node传递给另一个node</p></li><li><p>Cluster 如果说 service 选择的 node 没有我们想要的 pod 服务，那么会转发给下一个 node，需要额外的开销，下一跳，source ip 也会改成 转发 packet 的 node ip。</p></li></ul><h3 id="Ingress"><a href="#Ingress" class="headerlink" title="Ingress"></a>Ingress</h3><p><img src="https://s2.loli.net/2022/04/27/wJybIj2eWUGXvx3.png" alt="12image002"></p><p><img src="https://s2.loli.net/2022/04/27/UOyvTbXYrnofKu8.png" alt="12image003"></p><p>有了 service 还要 ingress 干啥？</p><p>如果说通过 service 对外提供服务，数量少还好，如果服务数量多，会需要占用很多外部IP，导致没必要的资源浪费。</p><p>可以通过 ingress 对 service 进行一层封装，这就好像我们不是直接访问 pod 一样，而是通过 service 访问一样。统一通过 ingress 访问我们集群体提供的服务，而且 ingress 是 7 层的，可以提供更多功能，比如 cookie TLS 等，相比之下 service 是 4 层的负载均衡。</p><p>所谓的 7，4 层负载均衡，都是在请求到达真正服务器之前做的一些处理，差别简单的说就是，在做负载均衡的时候，使用的信息不一样，在 7 层可以用 http 相关的东西，4 层可以用 TCP/UDP 相关的东西。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;各个部分及其字段的含义。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>chi 框架路由分析</title>
    <link href="https://bqyang.top/2022/chi/"/>
    <id>https://bqyang.top/2022/chi/</id>
    <published>2022-02-22T09:21:53.087Z</published>
    <updated>2022-02-24T02:26:34.506Z</updated>
    
    <content type="html"><![CDATA[<p>（暂时还没写完，不过为了方便阅读，我也发表了出来。这样回家就不用带电脑了。。）</p><p>chi 框架相对容易一些，跟上一篇文章中的 appsrv 框架进行一个简单地对比，看一下实现的差异在哪里。</p><span id="more"></span><p>废话不多说，直接上源码</p><hr><blockquote><p>下面这段话是我看过后才写的，这个框架中涉及到的了节点的拆分替换。这样做的好处就是可以节省更多的空间，如果彼此之间没有公共部分的话。</p></blockquote><p>我用这三个路由进行的测试：</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 1 &quot;&#x2F;&quot;&#x2F;&#x2F; 2 &quot;&#x2F;hello&#x2F;world&quot;&#x2F;&#x2F; 3 &quot;&#x2F;hello&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果是按照上述方式进行插入，执行的 2 的时候，node 的存储方式就是一个 <code>hello/world</code> ，但是当 3 执行的时候，匹配到了相同的前缀 <code>hello</code> 此时会将 <code>hello/world</code> 拆分成两个 node，而 3 中的 hello 这个node的实现，就是 2中的 hello。不知道这样表述是否清晰。。</p><hr><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// 路由的插入</span><span class="token keyword">func</span> <span class="token punctuation">(</span>n <span class="token operator">*</span>node<span class="token punctuation">)</span> <span class="token function">InsertRoute</span><span class="token punctuation">(</span>method methodTyp<span class="token punctuation">,</span> pattern <span class="token builtin">string</span><span class="token punctuation">,</span> handler http<span class="token punctuation">.</span>Handler<span class="token punctuation">)</span> <span class="token operator">*</span>node <span class="token punctuation">&#123;</span>    <span class="token keyword">var</span> parent <span class="token operator">*</span>node    <span class="token comment">// 获取访问路径，形如 /hello/world</span>    search <span class="token operator">:=</span> pattern    <span class="token keyword">for</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// Handle key exhaustion</span>        <span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>search<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// Insert or update the node's leaf handler</span>            n<span class="token punctuation">.</span><span class="token function">setEndpoint</span><span class="token punctuation">(</span>method<span class="token punctuation">,</span> handler<span class="token punctuation">,</span> pattern<span class="token punctuation">)</span>            <span class="token keyword">return</span> n        <span class="token punctuation">&#125;</span>        <span class="token comment">// We're going to be searching for a wild node next,</span>        <span class="token comment">// in this case, we need to get the tail</span>        <span class="token keyword">var</span> label <span class="token operator">=</span> search<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        <span class="token keyword">var</span> segTail <span class="token builtin">byte</span>        <span class="token keyword">var</span> segEndIdx <span class="token builtin">int</span>        <span class="token keyword">var</span> segTyp nodeTyp        <span class="token keyword">var</span> segRexpat <span class="token builtin">string</span>        <span class="token keyword">if</span> label <span class="token operator">==</span> <span class="token string">'&#123;'</span> <span class="token operator">||</span> label <span class="token operator">==</span> <span class="token string">'*'</span> <span class="token punctuation">&#123;</span>            segTyp<span class="token punctuation">,</span> <span class="token boolean">_</span><span class="token punctuation">,</span> segRexpat<span class="token punctuation">,</span> segTail<span class="token punctuation">,</span> <span class="token boolean">_</span><span class="token punctuation">,</span> segEndIdx <span class="token operator">=</span> <span class="token function">patNextSegment</span><span class="token punctuation">(</span>search<span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">var</span> prefix <span class="token builtin">string</span>        <span class="token keyword">if</span> segTyp <span class="token operator">==</span> ntRegexp <span class="token punctuation">&#123;</span>            prefix <span class="token operator">=</span> segRexpat        <span class="token punctuation">&#125;</span>        <span class="token comment">// Look for the edge to attach to</span>        parent <span class="token operator">=</span> n        n <span class="token operator">=</span> n<span class="token punctuation">.</span><span class="token function">getEdge</span><span class="token punctuation">(</span>segTyp<span class="token punctuation">,</span> label<span class="token punctuation">,</span> segTail<span class="token punctuation">,</span> prefix<span class="token punctuation">)</span>        <span class="token comment">// No edge, create one</span>        <span class="token keyword">if</span> n <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>            child <span class="token operator">:=</span> <span class="token operator">&amp;</span>node<span class="token punctuation">&#123;</span>label<span class="token punctuation">:</span> label<span class="token punctuation">,</span> tail<span class="token punctuation">:</span> segTail<span class="token punctuation">,</span> prefix<span class="token punctuation">:</span> search<span class="token punctuation">&#125;</span>            hn <span class="token operator">:=</span> parent<span class="token punctuation">.</span><span class="token function">addChild</span><span class="token punctuation">(</span>child<span class="token punctuation">,</span> search<span class="token punctuation">)</span>            hn<span class="token punctuation">.</span><span class="token function">setEndpoint</span><span class="token punctuation">(</span>method<span class="token punctuation">,</span> handler<span class="token punctuation">,</span> pattern<span class="token punctuation">)</span>            <span class="token keyword">return</span> hn        <span class="token punctuation">&#125;</span>        <span class="token comment">// Found an edge to match the pattern</span>        <span class="token keyword">if</span> n<span class="token punctuation">.</span>typ <span class="token operator">></span> ntStatic <span class="token punctuation">&#123;</span>            <span class="token comment">// We found a param node, trim the param from the search path and continue.</span>            <span class="token comment">// This param/wild pattern segment would already be on the tree from a previous</span>            <span class="token comment">// call to addChild when creating a new node.</span>            search <span class="token operator">=</span> search<span class="token punctuation">[</span>segEndIdx<span class="token punctuation">:</span><span class="token punctuation">]</span>            <span class="token keyword">continue</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// Static nodes fall below here.</span>        <span class="token comment">// Determine longest prefix of the search key on match.</span>        <span class="token comment">// 匹配最长前缀，一个时间复杂度为 O(n) 的算法，遇到不同的直接 break</span>        commonPrefix <span class="token operator">:=</span> <span class="token function">longestPrefix</span><span class="token punctuation">(</span>search<span class="token punctuation">,</span> n<span class="token punctuation">.</span>prefix<span class="token punctuation">)</span>        <span class="token keyword">if</span> commonPrefix <span class="token operator">==</span> <span class="token function">len</span><span class="token punctuation">(</span>n<span class="token punctuation">.</span>prefix<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 走到这个 if 里边，说明当前 parent 的前缀，被完全包含在了 child 中</span>            <span class="token comment">// the common prefix is as long as the current node's prefix we're attempting to insert.</span>            <span class="token comment">// keep the search going.</span>            search <span class="token operator">=</span> search<span class="token punctuation">[</span>commonPrefix<span class="token punctuation">:</span><span class="token punctuation">]</span>            <span class="token keyword">continue</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// Split the node</span>        child <span class="token operator">:=</span> <span class="token operator">&amp;</span>node<span class="token punctuation">&#123;</span>            typ<span class="token punctuation">:</span>    ntStatic<span class="token punctuation">,</span>            prefix<span class="token punctuation">:</span> search<span class="token punctuation">[</span><span class="token punctuation">:</span>commonPrefix<span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// replace 的过程就是将，旧 node 替换成最大相同前缀的样子</span>        parent<span class="token punctuation">.</span><span class="token function">replaceChild</span><span class="token punctuation">(</span>search<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> segTail<span class="token punctuation">,</span> child<span class="token punctuation">)</span>        <span class="token comment">// Restore the existing node</span>        <span class="token comment">// 上述已经替换了，但是还剩下 旧 node 除了最大相同前缀余下的部分，</span>        <span class="token comment">// 这里的操作就是将这个 node 的后半部分重新插入</span>        n<span class="token punctuation">.</span>label <span class="token operator">=</span> n<span class="token punctuation">.</span>prefix<span class="token punctuation">[</span>commonPrefix<span class="token punctuation">]</span>        n<span class="token punctuation">.</span>prefix <span class="token operator">=</span> n<span class="token punctuation">.</span>prefix<span class="token punctuation">[</span>commonPrefix<span class="token punctuation">:</span><span class="token punctuation">]</span>        child<span class="token punctuation">.</span><span class="token function">addChild</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> n<span class="token punctuation">.</span>prefix<span class="token punctuation">)</span>        <span class="token comment">// If the new key is a subset, set the method/handler on this node and finish.</span>        <span class="token comment">// 拆分后，如果search就没了，说明 search 是 parent node 的 prefix 的子集</span>        <span class="token comment">// 直接更新当前 node 的 handler 即可</span>        search <span class="token operator">=</span> search<span class="token punctuation">[</span>commonPrefix<span class="token punctuation">:</span><span class="token punctuation">]</span>        <span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>search<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>            child<span class="token punctuation">.</span><span class="token function">setEndpoint</span><span class="token punctuation">(</span>method<span class="token punctuation">,</span> handler<span class="token punctuation">,</span> pattern<span class="token punctuation">)</span>            <span class="token keyword">return</span> child        <span class="token punctuation">&#125;</span>        <span class="token comment">// Create a new edge for the node</span>        <span class="token comment">// 这里其实也好理解了，如果说拆分后，search 中还有内容，</span>        <span class="token comment">// 也不用管了，直接扔到下一个child中，之后再添加的时候，</span>        <span class="token comment">// 通过匹配最大相同前缀的方式，继续拆。。</span>        subchild <span class="token operator">:=</span> <span class="token operator">&amp;</span>node<span class="token punctuation">&#123;</span>            typ<span class="token punctuation">:</span>    ntStatic<span class="token punctuation">,</span>            label<span class="token punctuation">:</span>  search<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>            prefix<span class="token punctuation">:</span> search<span class="token punctuation">,</span>        <span class="token punctuation">&#125;</span>        hn <span class="token operator">:=</span> child<span class="token punctuation">.</span><span class="token function">addChild</span><span class="token punctuation">(</span>subchild<span class="token punctuation">,</span> search<span class="token punctuation">)</span>        hn<span class="token punctuation">.</span><span class="token function">setEndpoint</span><span class="token punctuation">(</span>method<span class="token punctuation">,</span> handler<span class="token punctuation">,</span> pattern<span class="token punctuation">)</span>        <span class="token keyword">return</span> hn    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>个人感觉这个插入的过程还是挺绕的。。需要结合例子动手看一下，光在脑子里想，抱歉！我智商不够..</p><p>chi 框架中，将 node 分成了几个类型，如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> nodeTyp <span class="token builtin">uint8</span><span class="token keyword">const</span> <span class="token punctuation">(</span>ntStatic   nodeTyp <span class="token operator">=</span> <span class="token boolean">iota</span> <span class="token comment">// /home</span>ntRegexp                  <span class="token comment">// /&#123;id:[0-9]+&#125;</span>ntParam                   <span class="token comment">// /&#123;user&#125;</span>ntCatchAll                <span class="token comment">// /api/v1/*</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>看看插入过程涉及到的一些杂七杂八的函数：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// patNextSegment returns the next segment details from a pattern:</span><span class="token comment">// node type, param key, regexp string, param tail byte, param starting index, param ending index</span><span class="token keyword">func</span> <span class="token function">patNextSegment</span><span class="token punctuation">(</span>pattern <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>nodeTyp<span class="token punctuation">,</span> <span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">byte</span><span class="token punctuation">,</span> <span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    ps <span class="token operator">:=</span> strings<span class="token punctuation">.</span><span class="token function">Index</span><span class="token punctuation">(</span>pattern<span class="token punctuation">,</span> <span class="token string">"&#123;"</span><span class="token punctuation">)</span>    ws <span class="token operator">:=</span> strings<span class="token punctuation">.</span><span class="token function">Index</span><span class="token punctuation">(</span>pattern<span class="token punctuation">,</span> <span class="token string">"*"</span><span class="token punctuation">)</span>    <span class="token comment">// 静态node，既不是参数，也不是正则表达式</span>    <span class="token keyword">if</span> ps <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> ws <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> ntStatic<span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>pattern<span class="token punctuation">)</span> <span class="token comment">// we return the entire thing</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// Sanity check 完整性检查，也体现了路由的规则，通配符只能出现在 &#123;&#125; 之后</span>    <span class="token keyword">if</span> ps <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> ws <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> ws <span class="token operator">&lt;</span> ps <span class="token punctuation">&#123;</span>        <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"chi: wildcard '*' must be the last pattern in a route, otherwise use a '&#123;param&#125;'"</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">var</span> tail <span class="token builtin">byte</span> <span class="token operator">=</span> <span class="token string">'/'</span> <span class="token comment">// Default endpoint tail to / byte</span>    <span class="token keyword">if</span> ps <span class="token operator">>=</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// Param/Regexp pattern is next</span>        nt <span class="token operator">:=</span> ntParam        <span class="token comment">// Read to closing &#125; taking into account opens and closes in curl count (cc)</span>        <span class="token comment">// 这里就是找成对的 &#123;&#125; ，虽然没在 leetcode 上做这个题，但是也听过。。</span>        <span class="token comment">// 如果 cc > 0，说明花括号多了</span>        <span class="token comment">// 如果 cc &lt; 0，说明花括号少了</span>        <span class="token comment">// 如果 cc == 0，说明正好匹配上</span>        cc <span class="token operator">:=</span> <span class="token number">0</span>        pe <span class="token operator">:=</span> ps        <span class="token keyword">for</span> i<span class="token punctuation">,</span> c <span class="token operator">:=</span> <span class="token keyword">range</span> pattern<span class="token punctuation">[</span>ps<span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> c <span class="token operator">==</span> <span class="token string">'&#123;'</span> <span class="token punctuation">&#123;</span>                cc<span class="token operator">++</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> c <span class="token operator">==</span> <span class="token string">'&#125;'</span> <span class="token punctuation">&#123;</span>                cc<span class="token operator">--</span>                <span class="token keyword">if</span> cc <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>                    pe <span class="token operator">=</span> ps <span class="token operator">+</span> i                    <span class="token keyword">break</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> pe <span class="token operator">==</span> ps <span class="token punctuation">&#123;</span>            <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"chi: route param closing delimiter '&#125;' is missing"</span><span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 拿到了括号中的参数名称</span>        key <span class="token operator">:=</span> pattern<span class="token punctuation">[</span>ps<span class="token operator">+</span><span class="token number">1</span> <span class="token punctuation">:</span> pe<span class="token punctuation">]</span>        pe<span class="token operator">++</span> <span class="token comment">// set end to next position，花括号后边的那个值</span>        <span class="token comment">// tail 指向的就是花括号后边的第一个字节，比如 /&#123;name&#125;/world</span>        <span class="token keyword">if</span> pe <span class="token operator">&lt;</span> <span class="token function">len</span><span class="token punctuation">(</span>pattern<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            tail <span class="token operator">=</span> pattern<span class="token punctuation">[</span>pe<span class="token punctuation">]</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">/*        从这里往下开始就是有关正则的内容        */</span>        <span class="token keyword">var</span> rexpat <span class="token builtin">string</span>        <span class="token keyword">if</span> idx <span class="token operator">:=</span> strings<span class="token punctuation">.</span><span class="token function">Index</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token string">":"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> idx <span class="token operator">>=</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>            nt <span class="token operator">=</span> ntRegexp            rexpat <span class="token operator">=</span> key<span class="token punctuation">[</span>idx<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span>            key <span class="token operator">=</span> key<span class="token punctuation">[</span><span class="token punctuation">:</span>idx<span class="token punctuation">]</span>        <span class="token punctuation">&#125;</span><span class="token comment">// 如果是正则匹配，人家还给校验了开始和结束。。</span>        <span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>rexpat<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> rexpat<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'^'</span> <span class="token punctuation">&#123;</span>                rexpat <span class="token operator">=</span> <span class="token string">"^"</span> <span class="token operator">+</span> rexpat            <span class="token punctuation">&#125;</span>            <span class="token keyword">if</span> rexpat<span class="token punctuation">[</span><span class="token function">len</span><span class="token punctuation">(</span>rexpat<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'$'</span> <span class="token punctuation">&#123;</span>                rexpat <span class="token operator">+=</span> <span class="token string">"$"</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>                <span class="token comment">/*        注释里边提到了这几个参数是啥意思，不过还是看一眼        nt节点类型        key参数名称        rexpat 正则表达式字符串        tailkey 参数后边的一个字节        ps参数开始的索引位置        pe参数结束的索引位置        */</span>        <span class="token keyword">return</span> nt<span class="token punctuation">,</span> key<span class="token punctuation">,</span> rexpat<span class="token punctuation">,</span> tail<span class="token punctuation">,</span> ps<span class="token punctuation">,</span> pe    <span class="token punctuation">&#125;</span>    <span class="token comment">// Wildcard pattern as finale</span>    <span class="token keyword">if</span> ws <span class="token operator">&lt;</span> <span class="token function">len</span><span class="token punctuation">(</span>pattern<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">&#123;</span>        <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"chi: wildcard '*' must be the last value in a route. trim trailing text or use a '&#123;param&#125;' instead"</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> ntCatchAll<span class="token punctuation">,</span> <span class="token string">"*"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> ws<span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>pattern<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// ntyp节点类型</span><span class="token comment">// labellabel 表示的就是 path 路径上的第一个字节</span><span class="token comment">// tail表示与 label 相反，表示最后一个字节</span><span class="token comment">// prefix当前 node 中存储的 path</span><span class="token keyword">func</span> <span class="token punctuation">(</span>n <span class="token operator">*</span>node<span class="token punctuation">)</span> <span class="token function">getEdge</span><span class="token punctuation">(</span>ntyp nodeTyp<span class="token punctuation">,</span> label<span class="token punctuation">,</span> tail <span class="token builtin">byte</span><span class="token punctuation">,</span> prefix <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token operator">*</span>node <span class="token punctuation">&#123;</span> <span class="token comment">// 首先是通过 节点类型找到对应的 节点集合，剩下的就比较简单了..</span>    nds <span class="token operator">:=</span> n<span class="token punctuation">.</span>children<span class="token punctuation">[</span>ntyp<span class="token punctuation">]</span>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token function">len</span><span class="token punctuation">(</span>nds<span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> nds<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>label <span class="token operator">==</span> label <span class="token operator">&amp;&amp;</span> nds<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>tail <span class="token operator">==</span> tail <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> ntyp <span class="token operator">==</span> ntRegexp <span class="token operator">&amp;&amp;</span> nds<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>prefix <span class="token operator">!=</span> prefix <span class="token punctuation">&#123;</span>                <span class="token keyword">continue</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">return</span> nds<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// 写的 endpoint，其实就是给 node 设置上 handler，正如人家在下面注释所描述的</span><span class="token keyword">func</span> <span class="token punctuation">(</span>n <span class="token operator">*</span>node<span class="token punctuation">)</span> <span class="token function">setEndpoint</span><span class="token punctuation">(</span>method methodTyp<span class="token punctuation">,</span> handler http<span class="token punctuation">.</span>Handler<span class="token punctuation">,</span> pattern <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// Set the handler for the method type on the node</span>    <span class="token keyword">if</span> n<span class="token punctuation">.</span>endpoints <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>        n<span class="token punctuation">.</span>endpoints <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span>endpoints<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// &#123;name&#125; &#123;job&#125; paramKeys 中存储的就是这些名字</span>    paramKeys <span class="token operator">:=</span> <span class="token function">patParamKeys</span><span class="token punctuation">(</span>pattern<span class="token punctuation">)</span>    <span class="token comment">// 往下就没啥好说了，通过位运算找到对应的分支，然后直接赋值就行了。。</span>    <span class="token keyword">if</span> method<span class="token operator">&amp;</span>mSTUB <span class="token operator">==</span> mSTUB <span class="token punctuation">&#123;</span>        n<span class="token punctuation">.</span>endpoints<span class="token punctuation">.</span><span class="token function">Value</span><span class="token punctuation">(</span>mSTUB<span class="token punctuation">)</span><span class="token punctuation">.</span>handler <span class="token operator">=</span> handler    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> method<span class="token operator">&amp;</span>mALL <span class="token operator">==</span> mALL <span class="token punctuation">&#123;</span>        h <span class="token operator">:=</span> n<span class="token punctuation">.</span>endpoints<span class="token punctuation">.</span><span class="token function">Value</span><span class="token punctuation">(</span>mALL<span class="token punctuation">)</span>        h<span class="token punctuation">.</span>handler <span class="token operator">=</span> handler        h<span class="token punctuation">.</span>pattern <span class="token operator">=</span> pattern        h<span class="token punctuation">.</span>paramKeys <span class="token operator">=</span> paramKeys        <span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> m <span class="token operator">:=</span> <span class="token keyword">range</span> methodMap <span class="token punctuation">&#123;</span>            h <span class="token operator">:=</span> n<span class="token punctuation">.</span>endpoints<span class="token punctuation">.</span><span class="token function">Value</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span>            h<span class="token punctuation">.</span>handler <span class="token operator">=</span> handler            h<span class="token punctuation">.</span>pattern <span class="token operator">=</span> pattern            h<span class="token punctuation">.</span>paramKeys <span class="token operator">=</span> paramKeys        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        h <span class="token operator">:=</span> n<span class="token punctuation">.</span>endpoints<span class="token punctuation">.</span><span class="token function">Value</span><span class="token punctuation">(</span>method<span class="token punctuation">)</span>        h<span class="token punctuation">.</span>handler <span class="token operator">=</span> handler        h<span class="token punctuation">.</span>pattern <span class="token operator">=</span> pattern        h<span class="token punctuation">.</span>paramKeys <span class="token operator">=</span> paramKeys    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后这个就是最核心最复杂的了吧…，不过我们为了方便理解，可以暂时先忽略掉<strong>正则匹配</strong>，<strong>带参数</strong>的部分代码。。只关注 nodetyp 是 static 的即可。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// addChild appends the new `child` node to the tree using the `pattern` as the trie key.</span><span class="token comment">// For a URL router like chi's, we split the static, param, regexp and wildcard segments</span><span class="token comment">// into different nodes. In addition, addChild will recursively call itself until every</span><span class="token comment">// pattern segment is added to the url pattern tree as individual nodes, depending on type.</span><span class="token comment">// 人家上边注释说的非常清晰了..</span><span class="token keyword">func</span> <span class="token punctuation">(</span>n <span class="token operator">*</span>node<span class="token punctuation">)</span> <span class="token function">addChild</span><span class="token punctuation">(</span>child <span class="token operator">*</span>node<span class="token punctuation">,</span> prefix <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token operator">*</span>node <span class="token punctuation">&#123;</span>    search <span class="token operator">:=</span> prefix    <span class="token comment">// handler leaf node added to the tree is the child.</span>    <span class="token comment">// this may be overridden later down the flow</span>    hn <span class="token operator">:=</span> child    <span class="token comment">// Parse next segment</span>    segTyp<span class="token punctuation">,</span> <span class="token boolean">_</span><span class="token punctuation">,</span> segRexpat<span class="token punctuation">,</span> segTail<span class="token punctuation">,</span> segStartIdx<span class="token punctuation">,</span> segEndIdx <span class="token operator">:=</span> <span class="token function">patNextSegment</span><span class="token punctuation">(</span>search<span class="token punctuation">)</span>    <span class="token comment">// Add child depending on next up segment</span>    <span class="token keyword">switch</span> segTyp <span class="token punctuation">&#123;</span>        <span class="token comment">// 这里直接判断类型呗，如果是static就直接加入到parent的children节点中</span>        <span class="token keyword">case</span> ntStatic<span class="token punctuation">:</span>        <span class="token comment">// Search prefix is all static (that is, has no params in path)</span>        <span class="token comment">// noop</span>        <span class="token keyword">default</span><span class="token punctuation">:</span>        <span class="token comment">// Search prefix contains a param, regexp or wildcard</span>        <span class="token keyword">if</span> segTyp <span class="token operator">==</span> ntRegexp <span class="token punctuation">&#123;</span>            rex<span class="token punctuation">,</span> err <span class="token operator">:=</span> regexp<span class="token punctuation">.</span><span class="token function">Compile</span><span class="token punctuation">(</span>segRexpat<span class="token punctuation">)</span>            <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>                <span class="token function">panic</span><span class="token punctuation">(</span>fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">"chi: invalid regexp pattern '%s' in route param"</span><span class="token punctuation">,</span> segRexpat<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">&#125;</span>            child<span class="token punctuation">.</span>prefix <span class="token operator">=</span> segRexpat            child<span class="token punctuation">.</span>rex <span class="token operator">=</span> rex        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> segStartIdx <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// Route starts with a param</span>            child<span class="token punctuation">.</span>typ <span class="token operator">=</span> segTyp            <span class="token keyword">if</span> segTyp <span class="token operator">==</span> ntCatchAll <span class="token punctuation">&#123;</span>                segStartIdx <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                segStartIdx <span class="token operator">=</span> segEndIdx            <span class="token punctuation">&#125;</span>            <span class="token keyword">if</span> segStartIdx <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>                segStartIdx <span class="token operator">=</span> <span class="token function">len</span><span class="token punctuation">(</span>search<span class="token punctuation">)</span>            <span class="token punctuation">&#125;</span>            child<span class="token punctuation">.</span>tail <span class="token operator">=</span> segTail <span class="token comment">// for params, we set the tail</span>            <span class="token keyword">if</span> segStartIdx <span class="token operator">!=</span> <span class="token function">len</span><span class="token punctuation">(</span>search<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// add static edge for the remaining part, split the end.</span>                <span class="token comment">// its not possible to have adjacent param nodes, so its certainly</span>                <span class="token comment">// going to be a static node next.</span>                search <span class="token operator">=</span> search<span class="token punctuation">[</span>segStartIdx<span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token comment">// advance search position</span>                nn <span class="token operator">:=</span> <span class="token operator">&amp;</span>node<span class="token punctuation">&#123;</span>                    typ<span class="token punctuation">:</span>    ntStatic<span class="token punctuation">,</span>                    label<span class="token punctuation">:</span>  search<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                    prefix<span class="token punctuation">:</span> search<span class="token punctuation">,</span>                <span class="token punctuation">&#125;</span>                hn <span class="token operator">=</span> child<span class="token punctuation">.</span><span class="token function">addChild</span><span class="token punctuation">(</span>nn<span class="token punctuation">,</span> search<span class="token punctuation">)</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> segStartIdx <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// Route has some param</span>            <span class="token comment">// starts with a static segment</span>            child<span class="token punctuation">.</span>typ <span class="token operator">=</span> ntStatic            child<span class="token punctuation">.</span>prefix <span class="token operator">=</span> search<span class="token punctuation">[</span><span class="token punctuation">:</span>segStartIdx<span class="token punctuation">]</span>            child<span class="token punctuation">.</span>rex <span class="token operator">=</span> <span class="token boolean">nil</span>            <span class="token comment">// add the param edge node</span>            search <span class="token operator">=</span> search<span class="token punctuation">[</span>segStartIdx<span class="token punctuation">:</span><span class="token punctuation">]</span>            nn <span class="token operator">:=</span> <span class="token operator">&amp;</span>node<span class="token punctuation">&#123;</span>                typ<span class="token punctuation">:</span>   segTyp<span class="token punctuation">,</span>                label<span class="token punctuation">:</span> search<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                tail<span class="token punctuation">:</span>  segTail<span class="token punctuation">,</span>            <span class="token punctuation">&#125;</span>            hn <span class="token operator">=</span> child<span class="token punctuation">.</span><span class="token function">addChild</span><span class="token punctuation">(</span>nn<span class="token punctuation">,</span> search<span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    n<span class="token punctuation">.</span>children<span class="token punctuation">[</span>child<span class="token punctuation">.</span>typ<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>n<span class="token punctuation">.</span>children<span class="token punctuation">[</span>child<span class="token punctuation">.</span>typ<span class="token punctuation">]</span><span class="token punctuation">,</span> child<span class="token punctuation">)</span>    <span class="token comment">// 排序操作，暂时不知道人家这个用途。。</span>    n<span class="token punctuation">.</span>children<span class="token punctuation">[</span>child<span class="token punctuation">.</span>typ<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">Sort</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> hn<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;（暂时还没写完，不过为了方便阅读，我也发表了出来。这样回家就不用带电脑了。。）&lt;/p&gt;
&lt;p&gt;chi 框架相对容易一些，跟上一篇文章中的 appsrv 框架进行一个简单地对比，看一下实现的差异在哪里。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>一个 web 框架的那些事</title>
    <link href="https://bqyang.top/2022/webFrame/"/>
    <id>https://bqyang.top/2022/webFrame/</id>
    <published>2022-02-18T08:29:25.030Z</published>
    <updated>2022-02-20T14:23:30.250Z</updated>
    
    <content type="html"><![CDATA[<p>项目上用了一套开源的云管理代码，他们框架中的路由的相关功能都是自研的，学习学习人家是怎么实现的。</p><span id="more"></span><p>大致分成以下几个部分：</p><ul><li>使用什么数据结构存储</li><li>路由的查找过程</li><li>关于正则的路由是怎么实现的</li></ul><p><strong>实现路由的数据结构</strong></p><p>这里巧妙的运用了 Go 原生 map 的特性，结合 map 高效的查询，构建了一颗<strong>基数树</strong>。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> RadixNode <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>data        <span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>stringNodes <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token operator">*</span>RadixNoderegexpNodes <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>RegexpNodesegNames    <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">&#125;</span><span class="token keyword">type</span> RegexpNode <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>node   <span class="token operator">*</span>RadixNoderegStr <span class="token builtin">string</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>光看声明方式或许有些抽象，把图画出来就好多了。（回头补上）</p><p><strong>路由注册过程</strong></p><p>核心的代码就这么多，对于我这种菜鸟来说，阅读起来还行，不是那么费劲，但是要想写出来这种代码，得有几年功底哈哈。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// segments 就是将 path 通过 "/" 进行分割，得到的结果</span><span class="token keyword">func</span> <span class="token punctuation">(</span>r <span class="token operator">*</span>RadixNode<span class="token punctuation">)</span> <span class="token function">add</span><span class="token punctuation">(</span>segments <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">,</span> data <span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> depth <span class="token builtin">int</span><span class="token punctuation">,</span> segNames <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 递归的终止条件</span>    <span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>segments<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 这里的 data 就是 handler 的信息，最后要通过 path 最终找到handler</span>        <span class="token keyword">if</span> r<span class="token punctuation">.</span>data <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 添加了重复路由，会报这个错误</span>            <span class="token keyword">return</span> fmt<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"Duplicate data for node"</span><span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            r<span class="token punctuation">.</span>data <span class="token operator">=</span> data            r<span class="token punctuation">.</span>segNames <span class="token operator">=</span> segNames            <span class="token keyword">return</span> <span class="token boolean">nil</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">var</span> nextNode <span class="token operator">*</span>RadixNode        <span class="token comment">// 判断是否为正则匹配的 path （为了方便理解可以先看下边 else 的部分）</span>        <span class="token keyword">if</span> <span class="token function">isRegexSegment</span><span class="token punctuation">(</span>segments<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">var</span> <span class="token punctuation">(</span>                <span class="token comment">// 正则字符串</span>                regStr     <span class="token builtin">string</span>                segName    <span class="token builtin">string</span>                <span class="token comment">// 把 "&lt; >" 去掉</span>                segStr     <span class="token operator">=</span> segments<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span> <span class="token punctuation">:</span> <span class="token function">len</span><span class="token punctuation">(</span>segments<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>                <span class="token comment">// 后续判断是否为 paramName:reg 的这种形式</span>                splitIndex <span class="token operator">=</span> strings<span class="token punctuation">.</span><span class="token function">IndexByte</span><span class="token punctuation">(</span>segStr<span class="token punctuation">,</span> <span class="token string">':'</span><span class="token punctuation">)</span>            <span class="token punctuation">)</span>            <span class="token keyword">if</span> splitIndex <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>                regStr <span class="token operator">=</span> <span class="token string">".*"</span> <span class="token comment">// match anything</span>                segName <span class="token operator">=</span> <span class="token string">"&lt;"</span> <span class="token operator">+</span> segStr <span class="token operator">+</span> <span class="token string">">"</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// &lt;phone_number:^1[0-9-]&#123;10&#125;$></span>                <span class="token comment">// 结合上边这个表达式，一下就清晰明了了</span>                regStr <span class="token operator">=</span> segStr<span class="token punctuation">[</span>splitIndex<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span>                segName <span class="token operator">=</span> <span class="token string">"&lt;"</span> <span class="token operator">+</span> segStr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span>splitIndex<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">">"</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">// TODO 暂时没看出来这个 segNames 和 depth 的关系</span>            <span class="token keyword">if</span> segNames <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>                segNames <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token punctuation">&#125;</span>            segNames<span class="token punctuation">[</span>depth<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> segName<span class="token comment">// 这里的逻辑就和下边的一样了，不再赘述</span>            <span class="token keyword">if</span> node<span class="token punctuation">,</span> ok <span class="token operator">:=</span> <span class="token function">isRegstrInRegexpNodes</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span>regexpNodes<span class="token punctuation">,</span> regStr<span class="token punctuation">)</span><span class="token punctuation">;</span> ok <span class="token punctuation">&#123;</span>                nextNode <span class="token operator">=</span> node            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                nextNode <span class="token operator">=</span> <span class="token function">NewRadix</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                regNode <span class="token operator">:=</span> <span class="token function">NewRegexpNode</span><span class="token punctuation">(</span>nextNode<span class="token punctuation">,</span> regStr<span class="token punctuation">)</span>                <span class="token comment">// 这里采用的是 array 存储，所以在查找的时候有一种可能</span>                <span class="token comment">// 就是一个node下挂着多个正则匹配，并且秉着先进来的优先级高的方式</span>                r<span class="token punctuation">.</span>regexpNodes <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span>regexpNodes<span class="token punctuation">,</span> regNode<span class="token punctuation">)</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 这里的 stringNodes 存储结构见下图，其实很简单，一个 node 代表的就是path中的一部分</span>            <span class="token comment">// 如果说两个 path 有重合的部分，那么他们之间就可以共用这些 node，这也是基数树的一个特征</span>            <span class="token comment">// ** 正如这里的判断，其实就是验证是否可以有公共的部分 **</span>            <span class="token keyword">if</span> node<span class="token punctuation">,</span> ok <span class="token operator">:=</span> r<span class="token punctuation">.</span>stringNodes<span class="token punctuation">[</span>segments<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span> ok <span class="token punctuation">&#123;</span>                nextNode <span class="token operator">=</span> node            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 走到这里说明，这个 seg 不存在，也就是没有公共部分，需要新建</span>                nextNode <span class="token operator">=</span> <span class="token function">NewRadix</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                r<span class="token punctuation">.</span>stringNodes<span class="token punctuation">[</span>segments<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> nextNode            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 递归调用</span>        <span class="token keyword">return</span> nextNode<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>segments<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">,</span> data<span class="token punctuation">,</span> depth<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> segNames<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/yangbaoqiang/images/raw/master/blogpics/image-20220218174102417.png" alt="image-20220218174102417"></p><p>这里我想了下，不用递归行不行，答案肯定是可以的，所有的递归都是可以通过 for 循环来完成的。但是细想了下，毕竟只有在项目启动中执行一次，也没必要，这样看起来更清晰，代码更简洁。</p><p><strong>路由查找过程</strong></p><p>先简单看看正则匹配的过程。比如我们定义了一个路由 <code>/user/&lt;^1[0-9-]&#123;10&#125;$&gt;</code> (按照人家框架的约束条件声明)</p><p>那么只要是匹配到该规则的路径，都是相同的 handler 进行处理。</p><p>如果上述路由注册的过程看明白了的话，我想你心里已经可以构建出一颗基数树，没有也没关系，我给你画出来，请见下图。</p><p><img src="https://gitee.com/yangbaoqiang/images/raw/master/blogpics/image-20220220154418325.png" alt="image-20220220154418325"></p><p>画的比较简陋，不过大概意思就是这样。</p><p><strong>代码实现</strong></p><p>我们可以尝试使用下面的函数，加上上面的图作为辅助，查找一下 <code>/student/Peter</code></p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// 可以先看下返回结果</span><span class="token comment">// bool 表示是否找到</span><span class="token comment">// RadixNode 则表示具体的 node，也可以理解为最终的 handler</span><span class="token keyword">func</span> <span class="token punctuation">(</span>r <span class="token operator">*</span>RadixNode<span class="token punctuation">)</span> <span class="token function">match</span><span class="token punctuation">(</span>segments <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">*</span>RadixNode<span class="token punctuation">,</span> <span class="token builtin">bool</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>segments<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> r<span class="token punctuation">,</span> <span class="token boolean">true</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span>stringNodes<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token function">len</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span>regexpNodes<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> r<span class="token punctuation">,</span> <span class="token boolean">false</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 不难看出，这里仍然采用的是递归调用的方式</span>    <span class="token keyword">if</span> node<span class="token punctuation">,</span> ok <span class="token operator">:=</span> r<span class="token punctuation">.</span>stringNodes<span class="token punctuation">[</span>segments<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span> ok <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> rnode<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> node<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>segments<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> rnode <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token operator">&amp;&amp;</span> rnode<span class="token punctuation">.</span>data <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> rnode<span class="token punctuation">,</span> <span class="token boolean">true</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">var</span> nodeTmp <span class="token operator">*</span>RadixNode    <span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> regNode <span class="token operator">:=</span> <span class="token keyword">range</span> r<span class="token punctuation">.</span>regexpNodes <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> regexp<span class="token punctuation">.</span><span class="token function">MustCompile</span><span class="token punctuation">(</span>regNode<span class="token punctuation">.</span>regStr<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">MatchString</span><span class="token punctuation">(</span>segments<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> rnode<span class="token punctuation">,</span> fullMatch <span class="token operator">:=</span> regNode<span class="token punctuation">.</span>node<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>segments<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> rnode <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token operator">&amp;&amp;</span> rnode<span class="token punctuation">.</span>data <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> fullMatch <span class="token punctuation">&#123;</span>                    <span class="token keyword">return</span> rnode<span class="token punctuation">,</span> fullMatch                <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">if</span> nodeTmp <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>                        log<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"segments %v match mutil node"</span><span class="token punctuation">,</span> segments<span class="token punctuation">)</span>                        <span class="token keyword">continue</span>                    <span class="token punctuation">&#125;</span>                    nodeTmp <span class="token operator">=</span> rnode                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> nodeTmp <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> nodeTmp<span class="token punctuation">,</span> <span class="token boolean">false</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> r<span class="token punctuation">,</span> <span class="token boolean">false</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>从上述代码可以看出，路由匹配过程中，优先级最高的是名称相同，其次才是正则匹配。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;项目上用了一套开源的云管理代码，他们框架中的路由的相关功能都是自研的，学习学习人家是怎么实现的。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>真的遇到了变量逃逸</title>
    <link href="https://bqyang.top/2022/VariableEscape/"/>
    <id>https://bqyang.top/2022/VariableEscape/</id>
    <published>2022-02-15T06:03:40.623Z</published>
    <updated>2022-02-15T08:34:55.153Z</updated>
    
    <content type="html"><![CDATA[<p>看看到底是怎么回事吧！</p><span id="more"></span><p><strong>我是怎么发现的</strong></p><p>先简单交代一下需要实现的效果，一开始有两个数组，然后通过一个数组中的内容确定是否在另一个数组中存在。一开始我们很容易想到一个时间复杂度为 O（n^2)  算法。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> rNode <span class="token operator">:=</span> <span class="token keyword">range</span> remoteNodes <span class="token punctuation">&#123;</span>    <span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> lNode <span class="token operator">:=</span> <span class="token keyword">range</span> localNodes <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> lNode<span class="token punctuation">.</span>Name <span class="token operator">==</span> rNode<span class="token punctuation">.</span>Name <span class="token punctuation">&#123;</span>            <span class="token comment">// do something</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实际工作上代码与这个类似，然后我想这怎么优化一下，降到 O(n) 的时间复杂度，脑子里想到了一种空间换取时间的方式。</p><p>额外声明一个 map ，map 我们都熟悉，查询时间复杂度为 O（1），于是就有了如下的代码</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">nodeMap <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span>NodeStruct<span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>remoteNodes<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">// 声明好了就开始往里塞数据呗</span><span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> rNode <span class="token operator">:=</span> <span class="token keyword">range</span> remoteNodes <span class="token punctuation">&#123;</span>    nodeMap<span class="token punctuation">[</span>rNode<span class="token punctuation">.</span>Name<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>rNode<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当时感觉很牛啊，就开始调试代码，数据也开始往库中插入，最后看一下是否达到了预期。</p><p>不看不知道，一看吓一跳，数据都是一样的，也就是说同一条数据插入了 n 次，整的自己有点蒙了。</p><p>又开始一行行的进行调试，感觉问题出在 map 上，但是**用 goland ** 调试的时候，看了一下 map 中的内容，是正确的。后边我在 linux 环境下复现的时候，使用 dlv 调试，每次往路边存储一个 key-value 的键值对打印出来的内容都是“错误的”</p><p><img src="https://gitee.com/yangbaoqiang/images/raw/master/blogpics/image-20220215155911343.png" alt="image-20220215155911343"></p><p>虽然 goland 内置的也是 dlv 但是显示出来的内容确截然不同。</p><p><strong>我是怎么解决的</strong></p><p>至于为什么会发生逃逸，关键操作就是 <code>nodeMap[rNode.Name] = &amp;rNode</code> 本来，rNode 是 for 循环内的局部变量，取址操作，让编译器判定这个变量需要存储到堆上。</p><p>怎么理解呢，如果说是局部变量，使用完了栈会通过 add 命令加回去，但是，取地址的操作，会使这个变量分配到堆上，后续通过 GC 进行回收。这个可能是最本质的区别。</p><p>解决也好办，我们就当它是局部变量就好了，修改代码如下 <code>nodeMap[rNode.Name] = rNode</code> 。</p><p>再通过 gcflag 看一下，<code>go run -gcflags=&quot;-m&quot; xx.go</code></p><p><img src="https://gitee.com/yangbaoqiang/images/raw/master/blogpics/image-20220215162311639.png" alt="image-20220215162311639"></p><p>直接提示我们 dog 移到了 heap 上..</p><hr><p>例子代码：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"bytes"</span><span class="token string">"fmt"</span><span class="token string">"sync"</span><span class="token punctuation">)</span><span class="token keyword">type</span> dog <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>name <span class="token builtin">string</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>dogs <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>dog<span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span>name<span class="token punctuation">:</span> <span class="token string">"dog1"</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#123;</span>name<span class="token punctuation">:</span> <span class="token string">"dog2"</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#123;</span>name<span class="token punctuation">:</span> <span class="token string">"dog3"</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#123;</span>name<span class="token punctuation">:</span> <span class="token string">"dog4"</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span>dogMap <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token operator">*</span>dog<span class="token punctuation">)</span><span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> dog <span class="token operator">:=</span> <span class="token keyword">range</span> dogs <span class="token punctuation">&#123;</span>dogMap<span class="token punctuation">[</span>dog<span class="token punctuation">.</span>name<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>dog<span class="token punctuation">&#125;</span><span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> v <span class="token operator">:=</span> <span class="token keyword">range</span> dogMap <span class="token punctuation">&#123;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;看看到底是怎么回事吧！&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>DDIA 读书笔记</title>
    <link href="https://bqyang.top/2022/DDIA/"/>
    <id>https://bqyang.top/2022/DDIA/</id>
    <published>2022-01-13T07:09:49.584Z</published>
    <updated>2022-02-25T02:30:31.932Z</updated>
    
    <content type="html"><![CDATA[<p>Designing Data-intensive Applications</p><span id="more"></span><h2 id="CH1：-Reliable-Scalable-Maintainable"><a href="#CH1：-Reliable-Scalable-Maintainable" class="headerlink" title="CH1： Reliable, Scalable, Maintainable"></a>CH1： Reliable, Scalable, Maintainable</h2><p>主要解释这三个词是什么意思，以及从哪些角度进行思考。</p><p><strong>影响设计数据系统的多个因素</strong></p><ul><li>遗留系统的依赖问题</li><li>设计这个系统的人的经验和技能</li><li>要交付的时间</li><li>对风险的容忍度</li><li>监管限制？ 这个没搞懂，是权限的意思么？</li></ul><p>在 DDIA 中主要关注三个方面</p><ul><li><p>Reliability 可靠性</p><p>即使遇到硬件或软件的 fault，人为的 error 系统应该正常工作。</p></li><li><p>Scalability 可扩展性</p></li></ul><p>​        随着系统的增长（规模上），能够妥善的处理增长带来的问题。</p><ul><li><p>Maintainablity 可维护性</p><p>人员变动随着时间变化着，不同的人维护着同一套代码。</p></li></ul><p><strong>Reliablity</strong></p><ul><li>应用程序像用户期待的那样执行函数</li><li>可以容忍用户错误的操作或非常规的操作</li><li>性能可以满足日常需求，并且足以应对突发的负载</li><li>能够阻止未授权的请求</li></ul><p>作者给我们总结了，如果上述的这些条件都满足了，意味着正常工作，我们可以粗略的认为可靠性就是，在系统出错的时候，仍然能正常工作。</p><p>这里对错误和失败又进行了区分，有哪些是可以容忍的，哪些是不行的。</p><p>错误通常被定义为系统中的一个组件偏离了最初的规范。比如一个接口本应该返回A，但是返回B了。失败通常表示整个系统宕机了，不能正常提供服务。</p><p>硬件错误</p><ul><li>硬盘故障，RAM 故障，电源被关闭了，插错网口了</li></ul><p>软件错误</p><ul><li>软件失控了，把所有计算资源都消耗了。</li><li>Linux 内核错误，导致程序都 hang 住了。</li><li>系统依赖的服务挂掉了，变成无响应的或者返回错误的响应。</li><li>Cascading failures 这种不知道中文怎么翻译，不过大概意思就是扇面的那种，一个错误导致多个，多个错误导致更多的错误。</li></ul><p>​    没有快捷的方法来解决这些系统性的错误在软件中，只能做好监控，识别差异（未能达到预期）</p><p>人为错误</p><ul><li>在某种程度上，最小化系统犯错的机会。</li><li>在出错最多的地方与引起错误的地方进行解耦。使用与生产环境一样的配置，来探索发现问题。</li><li>详细的测试工作，单元测试，系统测试，手动测试，自动测试等。</li><li>能够从人为制造的错误中快速进行恢复，最小化其带来的影响。比如，具备快速回滚的能力</li><li>配置好详细清晰的监控，比如性能监控和错误比率。当出错的时候，监控数据以及日志对于我们排查问题来说是无价的。</li><li>对员工有一个完整，良好的培训过程。</li></ul><p>总而言之，可靠性会关乎到公司，部门的信誉，和用户的体验也有很大联系。</p><p><strong>可扩展性</strong></p><p>可扩展性是用来描述系统在面对突发负载的能力。当讨论扩展性的使用，其实就是在考虑如下的两个问题：</p><ul><li>如果系统以某种特别的方式进行增长，我们可以采取什么措施来应对？</li><li>我们应该怎么增加计算资源来处理额外的负载？</li></ul><p><em>负载</em></p><p>负载可以用一些参数来表述：数据库的读写比，同一时间在线的用户数量，缓存的命中率..</p><p>作者以 Twitter 为例，具体描述了<em>负载</em>。</p><p><em>性能</em></p><p>在网络应用中，性能更多的意味着响应时间。</p><p>是什么导致了每次响应时间都不相同？</p><ul><li>后台进程的上下文切换</li><li>网络丢包，TCP 重传</li><li>GC pause</li><li>页缺失导致从磁盘重新加载</li><li>等等</li></ul><p><strong>可维护性</strong></p><p>广为人知的是，软件中的主要开销是维护工作，而不是起初开发。比如，修 Bug，保证系统运行，调研失败原因，适应新的平台，偿还技术债务，添加新的特性等。</p><p>三个软件涉及原则：</p><ul><li><p>可操作性，Operability</p><p>能使运维团队很容易操作。</p></li><li><p>简易性，Simplicity</p><p>能让新的工程师很容易明白，尽量设计的简洁。</p></li><li><p>可进行性，Evolvability</p><p>能让工程师在修改的时候很方便，可以应对未被考虑到的需求变化，也可以用这几个词来形容，<em>extensibility</em>, <em>modifiability</em>, or <em>plasticity</em>.</p></li></ul><p>（上述的名词翻译都是我自己凭感觉搞得，不存在普遍性）</p><p>作者简述了一个好的运维团队应该要做的事情..</p><h2 id="CH2：Data-Models-And-Query-Languages"><a href="#CH2：Data-Models-And-Query-Languages" class="headerlink" title="CH2：Data Models And Query Languages"></a>CH2：Data Models And Query Languages</h2><p>数据模型是按照每一层进行分布的，关键的问题在于每一层是如何表示的？</p><ul><li>实际生活中，有组织，商品，现金流，传感器，等。我们以对象或者数据结构的方式对其进行建模。可以理解为数据表达方式</li><li>这些数据是以哪种结构进行存储的，JSON\XML\数据库中的表结构，等等。</li><li>这些数据是存储在哪种物理器件上的，内存，磁盘，网络中。</li><li>在更底层，这些内容以电子，脉冲信号的形式存在。</li></ul><p>万变不离其宗，每一层都是对底层的封装，提供更简洁接口。</p><p><strong>NoSQL 数据库的诞生</strong></p><p>采纳 NoSQL 数据库的几个驱动力：</p><ul><li>需要比关系数据库更容易实现的可扩展性，包括非常大的数据集或非常高的写入吞吐量</li><li>免费开源的软件</li><li>关系型数据模型并不支持的查询</li><li>对关系模式的不看好，渴望一个更加动态和富有表达力的数据模型</li></ul><p><strong>Many-to-One and Many-to-Many</strong></p><p>作者在这里探讨了一个点，在多对一或多对多的关系中，为什么存储另一个字段的 ID，二不是值。</p><p>举个例子，用户对应的地区，职业，一个用户可以对应到多个地区，工作，家庭住址等，也可以对应到多个职业。</p><p>所以，在存储用户对应的这些信息的时候，如果说在页面上需要用户自己输入，那存储用户的具体信息是有意义的。如果在页面上呈现出来的是一个标准的下拉列表，让用户去选择，有很多的好处：</p><ul><li>一致的格式和拼写</li><li>避免歧义，比如重名问题</li><li>利于更新 – 因为名称仅存在了一个地方，其他都是对它 ID 的引用</li><li>本地化支持 – 作者想表达的是国际化时候很方便</li><li>利于搜索</li></ul><p><strong>网络模型</strong>（The network model）</p><p>太复杂不够灵活。</p><p><strong>关系模型</strong></p><p>即使索引改变了，也不需要我们在代码中手动调整指定，查询优化器会自定的帮我们做这些事情。</p><p><strong>文档模型与关系模型</strong></p><p>有利于文档模型的一点就是灵活性，更好的局部性（可以理解为相关的信息都在一起），关系模型中支持连表查询，多对一，多对多的关系。</p><p>文档模型中的限制：</p><ul><li>不能直接引用文档中嵌套的数据，取而代之的是需要说明那个引用在文档中的路径。作者提到只要嵌套不是很深，都不是问题。</li><li>对 Join 这类查询，无法提供良好的支持，但主要取决于应用。作者提到，比如在用于分析的应用中，可能永远用不到多对多的关系，这时采用文档数据库来存储更合适，比如什么时间发生了什么时间。</li></ul><p>文档模型的灵活性</p><p>有一点被误解的是，文档数据库是<em>无模式的</em>。但是，当代码从数据库中读取数据的时候，通常会假设某种结构用于接收读到的数据，这种模式是隐式的，也不是由数据库强迫加上的。</p><p>对于上述情况，有一个更专业的术语 <em>schema-on-read</em> ， 还有一种 <em>schema-on-write</em> 在写入数据库的时候就已经明确了</p><p><em>schema-on-read</em> 像动态类型语言（python），<em>schema-on-write</em> 像强类型的语言。</p><p>这两种模型的区别在应用想要修改数据格式的时候非常明显：</p><p>作者通过修改名称举例，目前采用一个字段进行存储名称，但是现在想通过 <em>first name</em> 和 <em>last name</em> 的模式进行存储。</p><p>文档模型</p><ul><li>直接在代码中做处理即可</li></ul><p>关系模型</p><ul><li>需要在数据库中添加列</li><li>然后更新那一列的值</li></ul><blockquote><p>在数据库中添加列的操作会使数据库停机，大多数数据库执行 Alter 语句通常在几毫秒内就可以完成，但是 MySQL 中会复制整张表，当处理一张拥有很多数据的表时，这可能会执行几分钟甚至几小时</p></blockquote><p>什么时候使用文档模型最合适？作者给出了两点参考</p><ul><li>一个对象有很多种类型，把每种类型的对象放在单独的表中不切合实际。</li><li>外部系统决定数据结构，可能随时改变。</li></ul><p>数据库未来的发展：作者提到的是数据库会结合这两者的优点，让应用从中受益。</p><p><strong>图状数据模型</strong></p><p>关系模型的数据库虽然支持多对多的关系，如果应用中存在大量的多对多映射，应考虑使用图来建模。</p><p>图由两种对象组成： 顶点（也称为结点或实体）和边（也称为关系或弧）。 很多数据</p><p>可以建模为图。 典型的例子包括：</p><ul><li><p>社交网络</p><p>顶点是人，边表示哪些人相互认识</p></li><li><p>网络图</p></li><li><p>公路或铁路网</p><p>顶点是交叉路口，边表示公路或铁路</p></li></ul><p><em>属性图</em> 的几个重要方面</p><ul><li>一个顶点可以通过任意一边连接到其他顶点。没有模式限制哪个类型可以连接哪个类型或者不可以连接。</li><li>给定一个顶点，可以很高效的找出进来的边，和出去的边。因此可以遍历整张图。</li><li>使用不同的标签代表不同的关系，可以存储各种各样的信息在一张图中，并且可以维护一个整洁的数据模型。</li></ul><blockquote><p>选择性跳过一些内容，不是很感兴趣.. 主要是关于图的查询，比如在关系型数据库中如何使用 SQL 等，还介绍了其他几种不同的图查询语言。</p></blockquote><p><strong>总结</strong></p><p>这一节主要学到了，document，graph，relational，三种数据模型，</p><ul><li><p>document 的使用场景主要是，各个数据之间都是独立，一条数据不存在（几乎不）与另一条的关联关系。</p></li><li><p>graph 与 document 相反，在图模型中，任何事物都有可能与其他事物关联到一起。</p></li><li><p>relational 关系模型是我们接触最频繁的..</p></li></ul><p>突然想到一个问题，要设计某些东西的时候，我们好像没有去发散的思考，这个场景下，是否真的适合使用 MySQL，取而代之的是，为了往 MySQL 上套，强行这样思考。</p><p>确实这是一个值得深思的问题，研究问题要从问题的本质出发，而不要被工具束缚。</p><h2 id="CH3：Store-and-Retrieval"><a href="#CH3：Store-and-Retrieval" class="headerlink" title="CH3：Store and Retrieval"></a>CH3：Store and Retrieval</h2><p>通过标题来看应该是讲，数据的存储和检索。</p><p><em>作为一个应用开发者，为什么需要关心数据库是如何存储和检索数据的？</em></p><ul><li>虽然我们不需要从头开始实现一个数据库，但是我们需要知道如何进行选择一种最适合我们的</li></ul><p>作者通过一个文件进行举例，文件中的每一行都是一个 k-v 形式的键值对。当前这种情况也会遇到很多问题，比如控制并发写入，怎样进行错误处理等..</p><p>另外，性能也存在一定的问题，想要寻找某个 Key 对应的 Value 时，只能从头到尾进行遍历，作者由此引出<strong>索引</strong></p><p>不同类型索引之间的共同点：</p><ul><li>都需要额外增加元数据信息来提高搜索速度</li></ul><p>索引的添加和删除并不会影响数据本身的内容，只会影响查询数据的性能。</p><p><strong>Hash Indexes</strong></p><p>作者最开始还是通过文件进行举例，文件还是存储在磁盘上，然后在内存中存储一个 <em>Hash Map</em> ， Map 中存储了 key value 是 真正的 val 在 磁盘中的位置。</p><p><img src="https://gitee.com/yangbaoqiang/images/raw/master/blogpics/image-20220119160522679.png" alt="image-20220119160522679"></p><p>为了防止 log 文件过大的解决办法：</p><ul><li>设定某一个阈值，当 log 文件达到这个值的时候，就把他拆分成几份。</li><li>后续的写操作都在另一个新的文件中进行写入。</li><li>压缩 log 文件，只保留对 key 的最新一次更新，如下。</li></ul><p><img src="https://gitee.com/yangbaoqiang/images/raw/master/blogpics/image-20220119160204309.png" alt="image-20220119160204309"></p><ul><li>通过压缩后，可能会导致某一段的文件过小，这里也可以进行段的合并操作，如下。</li></ul><p><img src="https://gitee.com/yangbaoqiang/images/raw/master/blogpics/image-20220119161051840.png" alt="image-20220119161051840"></p><p>正如之前看到的，所有对 log 文件的操作都基于 append 的，为什么不能直接更新之前的操作呢？使用 append-only 的好处是：</p><ul><li>append 的操作是顺序写，而不是随机写，速度快</li><li>如果 log 文件是 append-only 的，并发和崩溃恢复很容易实现</li><li>合并之前被拆分的 log 文件，有助于防止 log 文件的碎片化</li></ul><p><em>Hash Map</em> 带来的限制：</p><ul><li>hash map 不能太大，必须保证内存可以装下</li><li>范围查询效率不高</li></ul><p><strong>SSTable and LSM-Trees</strong></p><p>SSTable (Sorted String Table) 按照 Key 进行排序，如下。</p><p><img src="https://gitee.com/yangbaoqiang/images/raw/master/blogpics/image-20220119165619717.png" alt="image-20220119165619717"></p><p>看的过程中我想到一个问题，不同的 key 在不同的 log 文件中都有存在，是怎么在合并后的 log 文件中进行存储的呢？难道是每次读取到同样的 key 的时候都要再进行一次更新操作吗？</p><p>紧接着，作者在下文中就提到了这个问题：</p><p><code>What if the same key appears in several input segments?</code></p><p>在看“答案”的时候，作者提到了一点，当出现这种情况的时候，以最新的 log 文件中的数据为准，忽略旧的（在这之前操作）log 文件。</p><p>作者简述了一个采用 SSTable 和平衡树（红黑，AVL）作为底层数据结构的存储引擎，工作流程大致如下：</p><ul><li>当有写操作时，将写操作的内容加入到内存中的平衡树，这种结构也被称为 <code>memtable</code></li><li>当 <code>memtable</code> 超过某个阈值的时候，将其以 SSTable 的形式写入到磁盘中。如果这个时候有新的写操作，可以在一个新的 memtable 中进行插入。</li><li>当有读操作的时候，会从 memtable 中进行查找，然后在最近的 SSTable 中进行查找，直至找到最后一个</li><li>后台程序会将 log 文件进行合并、压缩操作。</li></ul><p>上述存储引擎存在一个问题，内存作为易失型存储，所以存在 memtable 中的数据是有可能丢失，为了解决这类问题，作者随后提到</p><ul><li>用一个存储在 disk 中的 log 文件用来存储操作日志，比如写操作发生时，不仅仅在 memtable 中进行插入，也在 log 文件中插入</li></ul><blockquote><p>该 log 文件是无序的，因为它只有在宕机等情况发生时才会用到，如果与之对应的 memtable 写入disk后，这个 log 文件也就变成无用的，可以删除掉。</p></blockquote><p><em>LSM-tree</em></p><p>LSM - log structured merge</p><p>当在 LSM-tree 中查找一个不存在的 key 时，需要从 memtable 找到最后一个 log 文件。为了优化这个问题，引入了 <code>Bloom Filter</code>。</p><p>LSM-tree 两种压缩策略</p><ul><li>size-tiered</li><li>leveled</li></ul><blockquote><p>以后有兴趣可以深入了解一下，这种存储的数据的策略，这里只是根据书中内容作为简要了解即可！</p></blockquote><p><em>B 树</em></p><p>学过很多次，看看作者是怎么结合实例进行讲解的。。</p><p>LSM 最后将数据划分到大小不一的 log 文件中（通常是 Mb）<strong>B</strong> 树采用的是，固定的块大小或页大小（通常大小为 4 KB）的方式进行存储。这样能更贴合硬件，因为磁盘也是采用这种固定大小块的方式进行数据的写入和存储。</p><p>B 树中，每一页都是存储在磁盘上，可以通过地址进行索引，并且页与页之间可以相互引用</p><p>分支因子：branch childs ，表示一个父节点拥有多少个子节点，实际使用中，分支因子的数量<em>取决于</em>存储页引用需要的空间大小和范围边界，通常来说是几百个。</p><p>在添加数据到叶子结点的时候，可能会导致页的拆分</p><p><img src="https://gitee.com/yangbaoqiang/images/raw/master/blogpics/image-20220124184754571.png" alt="image-20220124184754571"></p><p>假设当前page已经不能再容纳新的key时，在添加 key 334 后，进行了 page 的拆分。</p><p>平衡二叉树通过自旋算法，能想起来的有 LL，RR，LR，RL…保证了任意两个节点之间的只能有一个节点。我记得是有这么一条定义。。记不清楚了。。</p><p>作者举例，当 page = 4 KB，branching factor = 500 的时候，一个四层的 B 树可以容纳 250 TB 的数据。</p><p>如果在写入数据的时候，数据库崩溃了，会出现什么问题？</p><ul><li>比如，上述发生插入操作的时候，导致了 page 的分裂，这时候需要将当前这个 range 拆分成两个，并修改父节点对他们的引用。如果这时候数据库崩溃了，可能会出现类似<em>悬垂指针</em>的问题。为了解决这个问题，让数据库对崩溃有一定的容错能力，在实现 B-tree 的时候会额外在磁盘上添加一个数据结构，<em>write-ahead logging</em> (WAL, 也被称为 redo log)。</li></ul><blockquote><p>怪不得都说 DDIA 是必读书籍，读起来就是两个字，畅快。循序渐进，对我这种菜鸟来说太棒了！</p></blockquote><p>WAL ，append-only 的文件格式。<strong>在将修改操作实际应用到磁盘中数据的之前，必须将修改写入到这个文件中</strong>，恢复后，可以使用这个文件进行恢复。</p><p><strong>优化 B 树</strong></p><ul><li>copy-on-write</li><li>尽量减少key所占用的空间，可以通过缩写的方式，key 只是用来表明边界的。</li><li>保持相邻的key在磁盘上的位置也是相邻的，如果一个查询要查出一个很大范文的内容并要求是有序的，一页一页查找的效率十分低下。<ul><li>想法时候，但是随着数据的增长，很难维护一个这样的数据结构</li></ul></li><li>添加额外的指针，将兄弟节点连接起来，这样在遍历的时候就不需要回到父节点找到其他的兄弟节点。</li><li>从 B 树优化出来一个叫 <code>fractal tree</code> 听都没听过…</li></ul><p><strong>对比 B 树 和 LSM 树</strong></p><p>当我们评测存储引擎性能的时候有哪些事情是值得考虑的？</p><ul><li><em>write amplification</em>（写放大）<ul><li>在数据库的生命周期中，一次写入数据库的操作导致多次写入磁盘的操作被称为写放大。</li><li>注：SSD 被写入的次数是有限制的</li></ul></li></ul><p>LSM 优缺点：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// TODO </span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>索引</strong></p><ul><li>Secondary Index （二级索引）<ul><li>索引中 value 存储的是引用</li></ul></li><li>Clustered Index （聚簇索引）<ul><li>索引中 value 存储的是数据</li></ul></li><li>Covring Index （覆盖索引）<ul><li>是聚簇和非聚簇索引的一种折中方式</li><li>覆盖索引对应的 value 中可以包含多个列</li></ul></li></ul><p>注：MySQL 中，二级索引的 value 存储的是主键 id</p><p><strong>多列索引</strong></p><p>作者给我们做了一个科普吧算是，介绍了一维索引的局限性，已经多维索引可以在哪些场景中用到。</p><p><strong>全文搜索，模糊索引</strong></p><p>同上</p><p><strong>事务处理与分析处理</strong></p><p>作者对事务（transaction）进行了解释，并没有像教科书那种直接给出定义，而是结合历史告诉我们，事务一词的来源。以前在商业数据处理中， 一个往数据库中写入的操作往往意味着背后发生了一笔交易，或者是一笔订单，给员工汇款等操作。随着数据库不仅仅用于商业领域，transaction 这个词仍然延续使用。</p><p>其代表的是，一个逻辑单元中全部的写操作和读操作。</p><blockquote><p>事务并不一定要有 ACID （atomicity, consistency, isolation, durability）</p></blockquote><p>OLTP (online transaction processing)</p><p>OLAP (online analystic processing)</p><p><img src="https://gitee.com/yangbaoqiang/images/raw/master/blogpics/image-20220127203058810.png" alt="image-20220127203058810"></p><p><em>数据仓库的由来</em></p><p>90 年左右，一些公司开始停止在 OLTP 中进行数据分析，而是在一个单独的数据库中进行分析，这种独立的数据库被称为：data warehouse. 数据仓库。</p><p><strong>数据仓库</strong></p><p>从 OLTP 提取数据到  OLAP 的过程被称为： ETL (extract-transform-load)</p><p><img src="https://gitee.com/yangbaoqiang/images/raw/master/blogpics/image-20220127205128006.png" alt="image-20220127205128006"></p><blockquote><p>作者提到。。小规模的公司可能都没听过数据仓库。。。身在其中啊。。</p></blockquote><p><strong>Stars schema and Snowflakes</strong></p><p>这一小节通读下来，可以学习到的是：</p><p>星模式-一个主表中存储的都是其他表（子表）的主键。比如，订单表中存储的商户id，商户表中存储了商户信息</p><p>雪花模式-星模式的一种变种，子表中存储的其他表的主键。订单表中存储的商户id，商户表中存储了商户信息，还存储了户主信息，户主表中存储了户主的信息。</p><p>可以理解为雪花模式是比星模式表达的更完整，拓展的更多的一种模式。</p><p><strong>面向列的存储</strong></p><p>row-oriented 和 column-oriented 存储方式上的区别</p><p><img src="https://gitee.com/yangbaoqiang/images/raw/master/blogpics/image-20220128100950280.png" alt="image-20220128100950280"></p><p><em>采用位图压缩列</em></p><p><img src="https://gitee.com/yangbaoqiang/images/raw/master/blogpics/image-20220128102336567.png" alt="image-20220128102336567"></p><p>这里感觉书中描述的不是那么清晰（也可能是我自己翻译后理解的比较烂哈哈）：</p><ul><li>比如我们有 n 个列，但是经过去重后发现只有 m 个商品，可以通过，建立 m 个 bitmap 然后，每一个 bitmap 的长度是  n 的方式，来压缩列。</li><li>如果 bitmap 中，对应比特位为 1 说明该行有这个值，为 0，说明无。</li></ul><p><em>在 bitmap 中查找数据</em></p><p><img src="https://gitee.com/yangbaoqiang/images/raw/master/blogpics/image-20220128104519124.png" alt="image-20220128104519124"></p><p>这个地方确实是非常巧妙，比如要找 product_sk 的 id 在 30，68，69 这三个数之间的，直接把这三个对应的 bitmap 找出来，进行 OR 运算，bit 位 是 1 的就代表找到了。</p><p>第二个例子中展示了当进行 AND （与）运算的时候，直接将不同的 bitmap 进行 AND，可以这样做的根本原因是，虽然不同的数据在不同的 bitmap 中，但是 bitmap 中的每一位都是彼此对应的。</p><p><em>内存带宽和矢量化处理</em></p><p>内存带宽这里涉及到 SIMD 一个指令，包含多个数据。跟普通的三、四地址的指令好像还不太一样。。</p><p><em>data cube and materialized view</em></p><p><img src="https://gitee.com/yangbaoqiang/images/raw/master/blogpics/image-20220128115616403.png" alt="image-20220128115616403"></p><p>缓存聚合数据。</p><h2 id="CH4：-Encoding-and-Evolution"><a href="#CH4：-Encoding-and-Evolution" class="headerlink" title="CH4： Encoding and Evolution"></a>CH4： Encoding and Evolution</h2><p>Backward compatibility</p><p>​    Newer code can read data that was written by older code.</p><p>Forward compatibility</p><p>​    Older code can read data that was written by newer code.</p><p><strong>数据的编码方式</strong></p><p>程序处理的数据通常由两种（至少）表示方式：</p><ul><li>In memory</li><li>self-contained sequence of bytes （Json）</li></ul><p>encoding ： In memory —&gt; sequence</p><p><em>二进制编码</em></p><p>Facebook - Thirft </p><ul><li>Thrift 有两种压缩方式： <em>BinaryProtocol</em> and <em>CompactProtocol</em></li></ul><p>Google - Protobuf</p><ul><li>Protobuf 只有一种压缩方式，从书中结论来看，比 Thrift 压缩的要小一点，但是差别不大。</li></ul><p>Thrift 采用如下第一种的方式声明 schema</p><p><img src="https://gitee.com/yangbaoqiang/images/raw/master/blogpics/image-20220130115402674.png" alt="image-20220130115402674"></p><p>Thrift - BinaryProtocol</p><p><img src="https://gitee.com/yangbaoqiang/images/raw/master/blogpics/image-20220130115645112.png" alt="image-20220130115645112"></p><p>有数据类型标识，字段的 tag （表示字段名称），可以在图中看到有很多地方都是 00 ，这些未用到字节，如果可以进一步被压缩，仍然可以节省很多空间。</p><p>由此可以引出 Thrift 的第二种压缩方式：CompactProtocol ，它确实也是这么做的，通过把更多的信息<strong>pack到尽可能少的字节中</strong>，这是不是和 SIMD 的基本思想是相同的？从 59 字节压缩到 34 字节，优化了将近 50 %的size。</p><p>如下图，把数据类型和字段的tag, pack 到了一个字节。</p><p><img src="https://gitee.com/yangbaoqiang/images/raw/master/blogpics/image-20220130115934939.png" alt="image-20220130115934939"></p><blockquote><p>这章节后半部分是在手机上阅读的。。没来得及做笔记整理，等我二刷中文版的时候，着重把这块补上。</p></blockquote><h2 id="CH5：Replication"><a href="#CH5：Replication" class="headerlink" title="CH5：Replication"></a>CH5：Replication</h2><p>从单一的数据系统转变为分布式的数据系统。</p><p>分布式系统有两种形式的存在方式</p><ul><li>Replication</li><li>Partitioning</li></ul><p>某些情况下，这两种模式会混合使用，下图中展示了，一个数据库分成了两个分片，又为两个分片搞了两个副本。</p><p><img src="https://gitee.com/yangbaoqiang/images/raw/master/blogpics/image-20220202141713490.png" alt="image-20220202141713490"></p><p><em>为什么需要 replication</em></p><ul><li>在距离上离用户更近</li><li>当某部分出错时可以保证系统正常工作</li><li>水平扩展机器，增加吞吐量</li></ul><p><strong>Leaders And Followers</strong></p><p><em>如何却确保 master 的数据到达了所有的  slave 上？</em></p><p><img src="https://gitee.com/yangbaoqiang/images/raw/master/blogpics/image-20220202144206792.png" alt="image-20220202144206792"></p><p><em>Synchronous Versus Asynchronous Replication</em></p><p><img src="https://gitee.com/yangbaoqiang/images/raw/master/blogpics/image-20220202145651487.png" alt="image-20220202145651487"></p><p>同步的优缺点</p><ul><li>slaves 一定是最新的副本，与 master 中保持一致</li></ul><p>缺点</p><ul><li>如果同步过程中 slave 没有响应，如上图 Follower 1 的处理时间会变成不可预测的。这时 master 不会处理任何写操作，直到收到 slave 的响应。</li></ul><p>异步的缺点：</p><ul><li>如果 master 崩溃了，可能会导致数据的丢失，即主从节点存储的数据不一致</li></ul><p><strong>配置新的 slave</strong></p><p>当一个 slave 加入到 cluster 中，slave 如何进行数据的同步。</p><ul><li>打快照</li><li>将快照发送到 slave</li><li>slave 连接到 master ，同步从 <em>打快照时间之后</em> 做的数据变更</li><li>上一步执行完成后，与其他的 slave 同步数据的方式就没有什么不同了</li></ul><p><strong>处理崩溃节点</strong></p><ul><li><p><strong>catch-up recovery</strong></p></li><li><p><strong>Failover</strong> 故障转移</p></li></ul><p><strong>replication logs 的实现</strong></p><p>用于slave同步数据的文件，是怎么存储 master 的操作日志的？</p><ul><li><p>基于语句的实现</p><ul><li>压缩性好</li><li>如果master 中用了 NOW() 这样的函数，这样在 slave 中执行会出问题的<ul><li>解决办法就是，计算出确定的值然后存储的 log 文件中</li></ul></li></ul></li><li><p>WAL</p><p>这里提到了怎样使用这个技术是实现数据库版本的升级，简而言之，先给 slave 节点进行升级，然后执行故障转移，让已经升级的 slave 成为 master 节点。</p><blockquote><p>这种方式的一个缺点就是，slave 和 存储引擎是紧耦合的</p></blockquote></li><li><p>基于行 row 的实现</p><ul><li>MySQL 触发器，逻辑日志</li></ul></li><li><p>基于 trigger 的实现</p><p>就是在执行相应语句时，执行特定的函数</p></li></ul><p><strong>slave 节点同步数据滞后的问题</strong></p><p>似乎每种高可用都有这类问题，如果在主库修改了一个数据，紧接着读取数据，这时候从节点去服务这个读请求，就会出现数据不一致的问题。</p><blockquote><p>第五章，一部分是在手机上读的没来得及做笔记。。二刷一定补上！</p></blockquote><h2 id="CH6：Partitioning"><a href="#CH6：Partitioning" class="headerlink" title="CH6：Partitioning"></a>CH6：Partitioning</h2><p>分布式数据库的另一种存储方式，分片，即每个地方只存储一部分数据，各个分片的内容合并起来才是一个完整的数据。</p><p>如何将一个大的数据库进行分片？</p><p>如何与分片进行交互，即数据的查询？</p><p>如何找到数据所在的正确的分片？</p><p><strong>分片和副本</strong></p><p>这俩通常会结合使用，如下：</p><p><img src="https://gitee.com/yangbaoqiang/images/raw/master/blogpics/image-20220214213701624.png" alt="image-20220214213701624"></p><h4 id="Key-Value-类型数据的分片"><a href="#Key-Value-类型数据的分片" class="headerlink" title="Key-Value 类型数据的分片"></a>Key-Value 类型数据的分片</h4><p>学到了几个名词：</p><p>skewed 倾斜，某个分区的数据要多余其他分区，把这种情况称为倾斜。</p><p>hot pot 热点，某个分区的负载比其他分区都要高，把这种情况的分区叫做热点。</p><p>避免热点分区最简单的方法就是，插入记录的时候随机选择分区。</p><p><img src="https://gitee.com/yangbaoqiang/images/raw/master/blogpics/image-20220215194050809.png" alt="image-20220215194050809"></p><p>图中索引为 12 的范围，包括了 T - Z，这种简单的将一本书包括两个字母索引，会导致其他的卷包含的索引不均匀。<em>为了使数据分布的更均匀，分区的边界需要适应数据。</em></p><h4 id="通过-key-的-hash-值进行分区"><a href="#通过-key-的-hash-值进行分区" class="headerlink" title="通过 key 的 hash 值进行分区"></a>通过 key 的 hash 值进行分区</h4><p><img src="https://gitee.com/yangbaoqiang/images/raw/master/blogpics/image-20220216101704556.png" alt="image-20220216101704556"></p><p>使用key的哈希值作为分区，给我们带来的一个损失就是：没办法执行高效的范围查询。</p><p><strong>Skewed Workloads and Relieving Hot Spots</strong></p><p>倾斜的工作负载指的是，某个分区的负载要明显高于其他分区。比如社交媒体中的明星有很多的粉丝，这种情况下很容易引起，瞬间大量操作同一个 key。</p><p>解决这种问题的办法就叫做：Relieving Hot Spots</p><p>就是让打在同一个分区上的请求，再次分布到别的分区之中。</p><p>作者提到的一个最简单的方法是：在 key 的开头或结尾添加随机数，这两个随机数可以将打在一个分区的请求均匀分布到 100 个 key 上，而不是只操作一个 key。</p><p>但是这又带来了另一个问题，就是读取数据的时候变得更加困难，需要将这100个key 都读取出来，再做汇总。</p><h4 id="Partitioning-and-Secondary-Indexes"><a href="#Partitioning-and-Secondary-Indexes" class="headerlink" title="Partitioning and Secondary Indexes"></a>Partitioning and Secondary Indexes</h4><p><strong>Partitioning Secondary Indexes by Document</strong></p><p>主要讲了分区和二级索引怎么搭配使用。</p><p><img src="https://gitee.com/yangbaoqiang/images/raw/master/blogpics/image-20220216113018175.png" alt="image-20220216113018175"></p><p>基于文档的二级索引分区，每个分区中的二级索引都是独立的，各自维护各自的索引，也被称为本地索引。</p><p><strong>Partitioning Secondary Indexes by Term</strong></p><p>按术语划分二级索引</p><p><img src="https://gitee.com/yangbaoqiang/images/raw/master/blogpics/image-20220216134733352.png" alt="image-20220216134733352"></p><p>与基于文档的方式相比，很容易看出，二级索引变成了全局索引。</p><p>但是也不能把索引全部放在一个分区上，会破坏分区的目的，也可能会成为性能的瓶颈。</p><h4 id="Rebalancing-Partitions"><a href="#Rebalancing-Partitions" class="headerlink" title="Rebalancing Partitions"></a>Rebalancing Partitions</h4><p>为什么我们需要对分区进行重平衡？</p><ul><li>查询吞吐量增加，需要添加 CPU 应对高负载。</li><li>数据规模增长，需要添加磁盘和 RAM 存储。</li><li>机器宕机的时候，其他的机器需要接管失败的机器。</li></ul><p><em>rebalancing</em> 的过程就是，将集群中一个节点负载转移到另一个。</p><p>期望 <em>rebalancing</em> 达到什么目的？</p><ul><li>在重平衡之后，负载能够均匀的分布在集群的节点上。</li><li>即发生了 rebalancing，也可以正常处理读、写请求。</li><li>不应该在节点间移动不必要的数据，快速重新平衡并最小化网络和磁盘 I/O 负载。</li></ul><p><strong>重平衡的策略</strong></p><p><em>hash mod N</em></p><p>对 N 取模带来的问题是，如果 node 数量 N 变化了，大多数 key 都需要从原 node 移动到另一个 node。</p><p><em>固定数量的 partitions</em></p><p>这里采用了一种在 node 上创建比 node 数量更多分区的方法，比如 node 数量是 10，一个 node 上创建 100 个分区，这样总数就是 1000 个分区。</p><p>按照上述的分配，如果这是新加入了一个 node ，这个新的 node 从那 10 个 node 上 steal 几个分区过来，如下图。</p><p><img src="https://gitee.com/yangbaoqiang/images/raw/master/blogpics/image-20220216170024338.png" alt="image-20220216170024338"></p><p>分区编号不会改变，分区中的 key 也不会改变。唯一改变的就是分区所在的 node，但是这个改变不是立即发生的，通过网络传输数据到另一个 node 需要花费很多时间。</p><p>这时，旧的分区在这个传输的过程中仍然用于处理读写请求。</p><p>这种模式在 ES 中有使用到。</p><p>一般是怎么确定固定数量的分区的数量呢？</p><ul><li>the number of partitions configured at the outset is the maximum number of nodes you can have</li></ul><blockquote><p>管理分区也是有开销的，所以选择了一个非常高的分区数量时，可能会适得其反。</p></blockquote><p><em>动态 partitions</em></p><p>大的会拆成小的，太小了会合并成一个。</p><p>动态分区的好处</p><ul><li>分区的数量可以适应数据的变化。</li></ul><blockquote><p>空的数据库会以一个唯一的分区开始，这时所有的读写操作只操作一个分区，直到达到了需要拆分的阈值。</p></blockquote><p><strong>Partitioning proportinally to nodes</strong></p><p><strong>自动或手动进行重平衡</strong></p><p>自动会很方便，运维只需要做很少的操作就能达到维护的目的。但是自动重平衡是不可预测的。</p><p>当自动重平衡和故障检测结合使用时会更加危险，比如某个 node 负载比较高，会时不时出现响应慢的问题。这时其他节点要是判定这个 node 崩溃了，开启了自动重平衡，这不是我们期待的结果。</p><p>所以，手动的可能没有自动的那么方便，但是可以阻止一些额外的问题。</p><h4 id="请求路由"><a href="#请求路由" class="headerlink" title="请求路由"></a>请求路由</h4><p>常见的三种方式：</p><ul><li>直接访问一个node 如果有就返回，没有就找下一个node</li><li>通过路由的方式，在 client 和 node 中间套一层。</li><li>第三种需要客户端进行配合，客户端对哪些分区存储了哪些key是有感知的。</li></ul><p><img src="https://gitee.com/yangbaoqiang/images/raw/master/blogpics/image-20220216214050273.png" alt="image-20220216214050273"></p><p>另一种方式为，分布式系统以来一个独立的服务，比如 ZooKeeper 来跟踪集群中的元数据。</p><p><img src="https://gitee.com/yangbaoqiang/images/raw/master/blogpics/image-20220216214512962.png" alt="image-20220216214512962"></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>这章讲了几种将数据库拆成分区的方法，不过针对的好像都是 key-value 类型的数据库。</p><p>分区的目的：<strong>将数据和查询的负载更均匀的分配到多台机器上</strong></p><p>两种分区的方法：</p><ul><li>key range 的分区方法，将 key 排序后进行存储的一个好处是，支持更高效的范围查询，同时也会带来一种风险，就是 hot spot 的问题。这种分区方式通常结合<strong>动态分区</strong>进行使用，在达到某个阈值的时候进行分区的拆分。</li><li>hash 分区，通过散列函数将数据更均匀的分布在多台机器上。虽然损失了高效的范围查询，但是给我们带来了更均匀的数据分布和负载均衡。hash 分区的方式通常结合<strong>固定数量</strong>的分区进行使用。</li></ul><p><em>分区和二级索引</em>的结合</p><ul><li>基于文档的，也叫 local index</li><li>基于术语的，也叫 global index</li></ul><h2 id="Ch7：Transactions"><a href="#Ch7：Transactions" class="headerlink" title="Ch7：Transactions"></a>Ch7：Transactions</h2><p>循序渐进，介绍了一些会导致数据系统出错的几个问题</p><ul><li>数据库软件或者硬件可能会随时出错，也包括在写操作执行一般的过程中</li><li>应用可能会随时崩溃，包括一些逻辑只执行了一半</li><li>网络的不可靠，切断了应用和数据库之间的关系</li><li>客户端之间的并发操作</li><li>客户端可能读取到了无意义的数据（脏数据）</li></ul><p><strong>事务</strong></p><p>事务是简化上述问题的一种机制。<strong>事务是应用程序将多个读取和写入组合成一个逻辑单元的一种方式。</strong></p><p>概念上，所有的读写操作在一个事务中被看成是一个操作，要么整个事务成功（commit），要么全部失败（abort, rollback）。</p><p>这下我就有点明白了，总说的分布式事务是什么意思，比如一个写请求，需要多个服务进行协调，为了保证数据的可靠性，要么所有的服务都响应成功，要么就都失败。</p><h4 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h4><p>atomicity 原子性</p><p>consistency 一致性</p><p>isolation 隔离性</p><p>durability 持久性</p><p>是数据库中的容错机制建立精确的术语</p><p><strong>Atomicity</strong></p><p>atomic 这个词通常代表的意思是，一个不可再分的操作。</p><p>在计算机中，代表着一些其他的意思，比如多线程环境下，某个线程修改了某个值，由 1 改成 2，这时候其他线程是看不到的，其他线程看到的仍然是 1。</p><p><strong>但是在 ACID 中</strong>，A 代表的意思是和并发没有任何关系的！像上述这种问题，在 ACID 中 I isolation 中覆盖了这样的场景。</p><p>Atomicity 描述了如果客户端想要请求多个写操作，但是在一部分写操作执行完成后发生了错误。如果多个写操作聚合到一个 atomic 事务中，就说明这个事务是由于错误未完成的，然后这个事务就可以进行回滚，数据库必须忽略和恢复写入成功的值。</p><p><strong>发生错误时，有回滚事务的能力，并且这个事务中的所有写操作都应该被忽略。</strong>这是 ACID 中 A 的定义。</p><p>作者提到 abortability（可回滚能力）可能更适合这个 A。</p><p><strong>Consitency</strong></p><p>ACID中的一致性的主要是指对数据有特定的预期状态， 任何数据更改必须满足这些状态约束（或者恒等条件）。</p><blockquote><p>说实话，这句话有点难懂。。原文是这样的 <code>The idea of ACID consistency is that you have certain statements about your data (invariants) that must always be true</code></p></blockquote><p>关于一致性的描述确实很模糊，看完知乎上这个回答清晰了很多。</p><p><img src="https://gitee.com/yangbaoqiang/images/raw/master/blogpics/image-20220218100501876.png" alt="image-20220218100501876"></p><p><strong>通常，应用程序会依赖数据库的 A 和 I 来实现 C</strong></p><p><strong>Isolation</strong></p><p><img src="https://gitee.com/yangbaoqiang/images/raw/master/blogpics/image-20220217151555996.png" alt="image-20220217151555996"></p><p>这个就有点和一开始说的 atomic 并发访问类似了。</p><p><strong>Durability</strong></p><p>数据库系统的目的就是提供一个安全的地方，可以用来存放数据，并且不需要担心数据的丢失。</p><p>单节点中，持久性意味着数据成功的写入了。master - slave 中，意味着副本中的数据也成功写入了。</p><p>完美的持久性其实并不存在，如果存储数据的磁盘和存储副本数据的磁盘都坏了，这也是一种情况。</p><h4 id="单对象与多对象事务操作"><a href="#单对象与多对象事务操作" class="headerlink" title="单对象与多对象事务操作"></a>单对象与多对象事务操作</h4><p><img src="https://gitee.com/yangbaoqiang/images/raw/master/blogpics/image-20220217173344302.png" alt="image-20220217173344302"></p><p>如果没有隔离性，user2 会看到一种非常诡异的现象，就是有未读邮件，但是未读邮件的数量显示为 0。</p><p><img src="https://gitee.com/yangbaoqiang/images/raw/master/blogpics/image-20220217173515223.png" alt="image-20220217173515223"></p><p>如果没有原子性，这时候未读邮件和未读数量的显示就不一致了。这种情况下，第二个更新数量的操作失败了，那么第一个插入未读邮件的操作是需要回滚的。</p><p><strong>多对象事务的需求</strong></p><p>主要还是为了事务的  A 和 I</p><p><strong>错误处理和驳回</strong></p><p>事务一个非常重要的特点：当错误发生的时候，可以进行驳回（忽略已修改的内容）并且安全的重试。</p><p>ACID 的哲学：<strong>如果数据库违背了 AID ，那还不如摒弃 AID，这样也比把数据搞成半截子强。</strong></p><p>重试事务也会有很多问题：</p><ul><li>比如事务执行成功了，但是 commit 未返回给客户端，此时客户端会认为这个事务是失败的，这样就会导致事务执行多次。。除非有一种去重的机制。。</li><li>如果事务执行失败是由于过载导致，那么事务的重试会加重负载。这种情况下可以添加重试次数的限制。</li><li>只有在”可控的“错误发生时，事务重试才有意义。如果这个事务中本身就有错误，那么怎么重试都是无意义的。（这句话是我自己理解的）</li><li>如果事务的执行存在数据库之外的副作用，那么即使事务被驳回了，副作用仍然会发生。作者举了一个例子，特别好！如果这个事务的执行伴随着发送邮件，那么重试的时候仍然会发送邮件。。</li></ul><h4 id="弱隔离级别"><a href="#弱隔离级别" class="headerlink" title="弱隔离级别"></a>弱隔离级别</h4><h5 id="Read-committed"><a href="#Read-committed" class="headerlink" title="Read committed"></a>Read committed</h5><p>读提交是最基础的事务隔离级别，提供了两种保障：</p><ul><li>当从数据库读的时候，只能读到已经被 committed 的内容。<strong>No dirty reads</strong></li><li>当写操作发生时，只有在事务 committed 的时候，才会覆盖原数据。<strong>No dirty writes</strong></li></ul><p><strong>No dirty reads</strong></p><p>dirty reads （脏读）如果一个事务对数据库中的内容进行了修改，但是事务还没提交，这时候另一个事务要是读到了未提交的数据，称这种情况未脏读。</p><p>读提交的事务隔离级别，<strong>必须阻止脏读</strong>，意味着所有的写操作只有在 committed 后才能被看到，如下图：</p><p><img src="https://gitee.com/yangbaoqiang/images/raw/master/blogpics/image-20220218112120009.png" alt="image-20220218112120009"></p><p><strong>No dirty writes</strong></p><p>dirty writes （脏写）如果一个未提交的事务修改的内容，被另一个事务覆盖了，这种情况称为脏写。</p><p><img src="https://gitee.com/yangbaoqiang/images/raw/master/blogpics/image-20220218134450702.png" alt="image-20220218134450702"></p><h4 id="实现读提交隔离级别"><a href="#实现读提交隔离级别" class="headerlink" title="实现读提交隔离级别"></a>实现读提交隔离级别</h4><p>写 ： 大多数情况，数据库实现读提交隔离级别都是通过<strong>行级别</strong>的锁来实现的，如果某个事务想修改某个值，一定要先获取锁。</p><p>读 ： 要是不想脏读，也可以通过行级锁实现，但是可能会出现一个写事务，阻塞非常多的读事务。更普遍的方式是，通过上边的 7-4 图中那样的方法。</p><h4 id="Snapshot-Isolation-and-Repeatable-Read"><a href="#Snapshot-Isolation-and-Repeatable-Read" class="headerlink" title="Snapshot Isolation and Repeatable Read"></a>Snapshot Isolation and Repeatable Read</h4><p>快照隔离和可重复读。</p><p>读提交中存在的问题：</p><p><img src="https://gitee.com/yangbaoqiang/images/raw/master/blogpics/image-20220221151207197.png" alt="image-20220221151207197"></p><p>这个账户有 1000 ，分成两个账户，每个中有 500。这个用户账上发生了一笔交易，从一个账户转移到另一个账户 100。</p><p>两个事务，一个读的，一个写。她查询第一个账户是 500，但是读提交的事务只有在整个事务 commit 后才能被看到，所以在事务提交后，她再次查账户是 400，但是她本来是 1000 块钱，那 100 就莫名其妙消失了。。</p><p><strong>快照隔离的一个关键原则是：读不会阻塞写，写不会阻塞读</strong></p><p><strong>MVCC</strong></p><p>数据库必须保存某个对象的多个不同提交版本，因为不同的进行中事务需要在不同时间看到不同的数据库状态。<em>因为在同一时刻保存了某个对象的多个版本，这个技术被称为 MVCC</em></p><p><strong>快照隔离的实现</strong></p><p>当事务开始的时候，会给每个事务一个唯一且自增的事务 ID。</p><p><img src="https://gitee.com/yangbaoqiang/images/raw/master/blogpics/image-20220222100812339.png" alt="image-20220222100812339"></p><p>如图所示，一个更新操作在内部被拆分成了删除和插入。事务13 要更新账户 1  的余额，把 created by = 3 的删除，插入了一条新的。</p><p><strong>一致性快照的可见性规则</strong></p><p><em>事务 ID 决定了他可以看到哪些对象，哪些看不到</em></p><ul><li>在事务开始的时候，数据库会创建一个在那个时刻其他正在执行的但是还没有提交或驳回的事务列表。</li><li>被驳回事务的写操作会被忽略。</li><li>事务 ID 更大的写操作会被忽略掉，尽管这些事务被提交了。</li><li><strong>所有其他写入对应用程序的查询都是可见的。</strong></li></ul><p>在快照隔离中，如果一个对象是可见的，必须满足以下两个条件：</p><ul><li>在读事务开启的时候，在另一个事务中创建的对象已经 commit 了。</li><li>对象没有被标记为删除，如果被删除了，当读事务开启的时候，请求删除的事务还没有提交。</li></ul><p><strong>索引在快照隔离中是怎样工作的</strong></p><p>主要是讲了两种建立索引树的方式。</p><ul><li>append-only<ul><li>有写事务的时候，会从某个特定的根创建一颗新的索引树</li></ul></li><li>copy-on-write<ul><li>写时复制，针对当前 page 进行操作的，如果想要更新的话，并不会覆盖当前页的内容，而是创建当前页的一个副本。</li></ul></li></ul><p><strong>可重复读和命名混乱</strong></p><p>MySQL 中把快照隔离称为<strong>可重复读</strong></p><h4 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h4><p>一个事务中的写操作影响了另一个事务中的查询操作。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Designing Data-intensive Applications&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
</feed>
