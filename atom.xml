<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>杨宝强的技术笔记</title>
  
  
  <link href="https://bqyang.top/atom.xml" rel="self"/>
  
  <link href="https://bqyang.top/"/>
  <updated>2022-06-08T14:42:48.298Z</updated>
  <id>https://bqyang.top/</id>
  
  <author>
    <name>杨宝强</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>go-error-handling</title>
    <link href="https://bqyang.top/2022/language/golang/go-errors/"/>
    <id>https://bqyang.top/2022/language/golang/go-errors/</id>
    <published>2022-06-08T09:44:48.608Z</published>
    <updated>2022-06-08T14:42:48.298Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2022/06/08/yfjlCg7NJxwhqbu.png" alt="scuffle"></p><p>这篇文章是我学习董哥发布的 <a href="https://mytechshares.com/2021/11/22/go-error-best-practice">错误处理</a> 文章的总结，好记性不如烂笔头，避坑啦！</p><span id="more"></span><p>通常情况下打印的错误信息是不包含堆栈的。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// %v 与 %s 相同</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, readFile())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readFile</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    _, err := ioutil.ReadFile(<span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output: open : The system cannot find the file specified.</span></span><br></pre></td></tr></table></figure><p>但是在很多情况下没有堆栈信息是很难定位问题的，除非是 panic 了，但是业务逻辑的代码不能直接 panic 可能会直接导致服务崩溃。</p><h2 id="官方方法-w"><a href="#官方方法-w" class="headerlink" title="官方方法 %w"></a>官方方法 %w</h2><p>还是上面那个例子：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readFile</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    _, err := ioutil.ReadFile(<span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="comment">// 这里只是简单了 wrap 错误信息，并不会增加调用栈的相关内容</span></span><br><span class="line">    <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;%w\n&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output: open : The system cannot find the file specified.</span></span><br></pre></td></tr></table></figure><h2 id="github-com-pkg-errors"><a href="#github-com-pkg-errors" class="headerlink" title="github.com/pkg/errors"></a>github.com/pkg/errors</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%s    print the error. If the error has a Cause it will be</span><br><span class="line">      printed recursively.</span><br><span class="line">%v    see %s</span><br><span class="line">%+v   extended format. Each Frame of the error&#x27;s StackTrace will</span><br><span class="line">      be printed in detail.</span><br></pre></td></tr></table></figure><h3 id="errors-Wrap"><a href="#errors-Wrap" class="headerlink" title="errors.Wrap"></a>errors.Wrap</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/pkg/errors&quot;</span></span><br><span class="line">    <span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%+v\n&quot;</span>, readFile())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readFile</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    _, err := ioutil.ReadFile(<span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> errors.Wrap(err, <span class="string">&quot;something failed&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">open : The system cannot find the file specified.</span></span><br><span class="line"><span class="comment">something failed</span></span><br><span class="line"><span class="comment">main.readFile</span></span><br><span class="line"><span class="comment">D:/program/code/newProject/errors-dev/main.go:15</span></span><br><span class="line"><span class="comment">main.main</span></span><br><span class="line"><span class="comment">D:/program/code/newProject/errors-dev/main.go:10</span></span><br><span class="line"><span class="comment">runtime.main</span></span><br><span class="line"><span class="comment">D:/program/language/go/go1.16.5/src/runtime/proc.go:225</span></span><br><span class="line"><span class="comment">runtime.goexit</span></span><br><span class="line"><span class="comment">D:/program/language/go/go1.16.5/src/runtime/asm_amd64.s:1371</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>使用 errors.Wrap 可以告诉我们堆栈信息，以及报错内容，还有一点需要注意的是：</p><blockquote><p>在调用 errors.Wrap() 时，<strong>最好判断一下 err 是不是 nil</strong>，之前在群里时候就有一个哥们遇到了这个问题，类型断言失败了，err 是 nil，然后进行了 wrap 操作，wrap 中判断 err 是 nil 会直接返回 nil，导致后续代码执行的时候拿到了一个 nil pointer。下图是他当时的场景。</p></blockquote><p><img src="https://s2.loli.net/2022/06/08/VBrMAkzKmLN6b5H.png" alt="断言失败，错误为 nil，return nil, nil"></p><p>董哥在文章中有提到这一点，自己现在还没遇到，既然有人已经在上边踩过坑了，需要引起注意！</p><p>还有一点需要注意的就是，<strong>不要过多使用 errors.Wrap</strong> 这样会输出重复的堆栈信息，可以试试下面这段代码：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readFile</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    _, err := ioutil.ReadFile(<span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="comment">// 会输出两次堆栈信息</span></span><br><span class="line">    <span class="keyword">return</span> errors.Wrap(errors.Wrap(err, <span class="string">&quot;something failed&quot;</span>), <span class="string">&quot;failed!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="error-级联问题"><a href="#error-级联问题" class="headerlink" title="error 级联问题"></a>error 级联问题</h2><p>这个是没接触过的问题，但是或多或少听说过 interface 赋值的问题（抓个时间把 interface 好好看看），在 Go 中，error 其实就是一个 interface。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The error built-in interface type is the conventional interface for</span></span><br><span class="line"><span class="comment">// representing an error condition, with the nil value representing no error.</span></span><br><span class="line"><span class="keyword">type</span> error <span class="keyword">interface</span> &#123;</span><br><span class="line">    Error() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  这时我们创建一个结构体，实现这个 interface</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> myError <span class="keyword">struct</span> &#123;</span><br><span class="line">    Info <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(my *myError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> my.Info</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整代码如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> myError <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i *myError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> i.<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Call1</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Call2</span><span class="params">()</span> *<span class="title">myError</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 在这个问题中我们需要知道的一点就是</span></span><br><span class="line">    <span class="comment">// err 是一个 interface</span></span><br><span class="line">    err := Call1()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;call1 is not nil: %v\n&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    err = Call2()</span><br><span class="line">    fmt.Println(err==<span class="literal">nil</span>)  <span class="comment">// false</span></span><br><span class="line">    fmt.Println(err)   <span class="comment">// nil</span></span><br><span class="line">    <span class="comment">// 上边这两个输出结果真的很矛盾。。</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;call2 err is not nil: %v\n&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案就是：**<a href="https://yourbasic.org/golang/gotcha-why-nil-error-not-equal-nil/">An interface value is equal to <code>nil</code> only if both its value and dynamic type are <code>nil</code>.</a> **接口类型的值只有在 type 和 value 都是空的时候才是 nil，这里我们调用 Call2() 函数后，nil 有了具体的类型，这才导致了后续判断的时候出现奇怪的现象。</p><p>不错，又是收获满满的一天，2022-06-08 22:42</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2022/06/08/yfjlCg7NJxwhqbu.png&quot; alt=&quot;scuffle&quot;&gt;&lt;/p&gt;
&lt;p&gt;这篇文章是我学习董哥发布的 &lt;a href=&quot;https://mytechshares.com/2021/11/22/go-error-best-practice&quot;&gt;错误处理&lt;/a&gt; 文章的总结，好记性不如烂笔头，避坑啦！&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>面向对象五大原则</title>
    <link href="https://bqyang.top/2022/design-pattern/principle/"/>
    <id>https://bqyang.top/2022/design-pattern/principle/</id>
    <published>2022-06-08T02:21:41.988Z</published>
    <updated>2022-06-08T08:34:08.801Z</updated>
    
    <content type="html"><![CDATA[<p>SOLID原则：由 5 个设计原则组成的，它们分别是：单一职责原则、开闭原则、里式替换原则、接口隔离原则和依赖反转原则，依次对应 SOLID 中的 S、O、L、I、D 这 5 个英文字母，</p><p>SRP单一职责原则 Single Responsibility Principle；</p><p>KISS保持简单 Keep It Simple and Stupid；</p><p>YAGNI不需要原则 You Ain’t Gonna Need It ； </p><p>DRY 不要重复原则 Don’t Repeat Yourself ； </p><p>LOD 迪米特法则 Law of Demeter。</p><span id="more"></span><h2 id="单一职责"><a href="#单一职责" class="headerlink" title="单一职责"></a>单一职责</h2><ol><li>如何理解单一职责原则（SRP）？- <ul><li>一个类只负责完成一个职责或者功能。不要设计大而全的类，要设计粒度小、功能单一的类。单一职责原则是为了实现代码高内聚、低耦合，提高代码的复用性、可读性、可维护性。</li></ul></li><li>如何判断类的职责是否足够单一？<ul><li>不同的应用场景、不同阶段的需求背景、不同的业务层面，对同一个类的职责是否单一，可能会有不同的判定结果。实际上，一些侧面的判断指标更具有指导意义和可执行性，比如，出现下面这些情况就有可能说明这类的设计不满足单一职责原则：类中的代码行数、函数或者属性过多；类依赖的其他类过多，或者依赖类的其他类过多；私有方法过多；比较难给类起一个合适的名字；类中大量的方法都是集中操作类中的某几个属性。</li></ul></li><li>类的职责是否设计得越单一越好？<ul><li>单一职责原则通过避免设计大而全的类，避免将不相关的功能耦合在一起，来提高类的内聚性。同时，类职责单一，类依赖的和被依赖的其他类也会变少，减少了代码的耦合性，以此来实现代码的高内聚、低耦合。但是，如果拆分得过细，实际上会适得其反，反倒会降低内聚性，也会影响代码的可维护性。</li></ul></li></ol><h2 id="开放-封闭"><a href="#开放-封闭" class="headerlink" title="开放-封闭"></a>开放-封闭</h2><p>假设一开始我们的计算器最初只提供加法运算，后续产品又想支持别的运算，这时候<strong>我们最好是通过增加代码的方式实现，而不是改动现有的代码</strong>。</p><p>尽管最初设计时没有考虑到，但是，在应对后续某一个变化时，我们应该对其进行抽象分类，<strong>我们希望的是在开发工作展开不久就知道可能发生的变化。查明可能发生的变化所等待的时间越长，要创建正确的抽象就越困难[ASD]。</strong></p><p>就比如最初的加法类，我们在很多个地方都用到了，后续添加减法类的时候，改动就不是一件小事情了，需要替换更多的内容。</p><p><img src="https://s2.loli.net/2022/06/08/5OZwjf724JpFNKy.png"></p><p><em><strong>开放-封闭原则是面向对象设计的核心所在。遵循这个原则可以带来面向对象技术所声称的巨大好处，也就是可维护、可扩展、可复用、灵活性好。开发人员应该仅对程序中呈现出频繁变化的那些部分做出抽象，然而，对于应用程序中的每个部分都刻意地进行抽象同样不是一个好主意。拒绝不成熟的抽象和抽象本身一样重要[ASD]</strong></em></p><h2 id="依赖反转"><a href="#依赖反转" class="headerlink" title="依赖反转"></a>依赖反转</h2><p>这里其实有个很形象的例子，因为自己一直在写面向过程的代码，Go 里边的 interface 用的也比较少，也正如书中讲到的例子一样，假设我们在对数据库进行操作时往往会把语句封装成具体的函数，使用上层的业务逻辑调用底层的这写函数，如 Figure 1 中展示的。<img src="https://s2.loli.net/2022/06/08/d8DR4uKUkErAhxm.png"></p><p>同时这里也会遇到一个问题，如果说在给另一个用户部署我们程序的时候，人家不想用 MySQL 但是业务逻辑是不需要动的，我们这时候也很难复用上层的业务逻辑（因为是和 MySQL 紧耦合的关系）。</p><p>那这时候应该怎么办呢？</p><p>我们可以根据不同的数据库抽象出来一层接口，只要是数据库就至少支持增、删、改、查四种操作，如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> database <span class="keyword">interface</span> &#123;</span><br><span class="line">    Insert() error</span><br><span class="line">    Update() error</span><br><span class="line">    Delete() error</span><br><span class="line">    Select() error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后底层去实现这个接口，MySQL 实现增、删、改、查，然后增加 Mongo、Redis 数据库依次实现这四个接口。</p><p>这样上层在调用的时候是通过接口来实现的，但是在 Go 里边这块还是有点模糊，我们当前的一个业务场景跟这个原则十分符合，只不过底层是各种不同的云服务，上层就是业务逻辑代码，这里代码中维护了一个全局map，把每一个底层云加入到这个 map 中，如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 伪代码如下</span></span><br><span class="line"><span class="keyword">var</span> drivers <span class="keyword">map</span>[<span class="keyword">string</span>]ICloudInterface</span><br></pre></td></tr></table></figure><p>然后在每一个云的 package 下执行 register，这样业务逻辑层，通过数据库中字段不同的值，在这里获取到对应的实体，调用对应的方法即可，做到了底层实现和业务逻辑的解耦，同时修改阿里云部分的内容并不会影响华为云的逻辑。</p><blockquote><p>之前看到过一句话，任何中间层的出现都是为了解耦。</p></blockquote><p><em>从业务逻辑中找到具体的底层对象，如果不通过全局变量来实现，不知道还没有别的更好的办法，</em> 等待着自己去发掘。</p><h2 id="里氏替换"><a href="#里氏替换" class="headerlink" title="里氏替换"></a>里氏替换</h2><p>子类对象（object of subtype/derived class）能够替换程序（program）中父类对象（object of base/parent class）出现的任何地方，并且保证原来程序的逻辑行为（behavior）不变及正确性不被破坏。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Transporter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> HttpClient httpClient;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Transporter</span><span class="params">(HttpClient httpClient)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.httpClient = httpClient;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Response <span class="title">sendRequest</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...use httpClient to send request</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityTransporter</span> <span class="keyword">extends</span> <span class="title">Transporter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String appId;</span><br><span class="line">  <span class="keyword">private</span> String appToken;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SecurityTransporter</span><span class="params">(HttpClient httpClient, String appId, String appToken)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(httpClient);</span><br><span class="line">    <span class="keyword">this</span>.appId = appId;</span><br><span class="line">    <span class="keyword">this</span>.appToken = appToken;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Response <span class="title">sendRequest</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isNotBlank(appId) &amp;&amp; StringUtils.isNotBlank(appToken)) &#123;</span><br><span class="line">      request.addPayload(<span class="string">&quot;app-id&quot;</span>, appId);</span><br><span class="line">      request.addPayload(<span class="string">&quot;app-token&quot;</span>, appToken);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.sendRequest(request);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;    </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demoFunction</span><span class="params">(Transporter transporter)</span> </span>&#123;    </span><br><span class="line">    Reuqest request = <span class="keyword">new</span> Request();</span><br><span class="line">    <span class="comment">//...省略设置request中数据值的代码...</span></span><br><span class="line">    Response response = transporter.sendRequest(request);</span><br><span class="line">    <span class="comment">//...省略其他逻辑...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 里式替换原则</span></span><br><span class="line">Demo demo = <span class="keyword">new</span> Demo();</span><br><span class="line">demo.demofunction(<span class="keyword">new</span> SecurityTransporter(<span class="comment">/*省略参数*/</span>););</span><br></pre></td></tr></table></figure><p>可以直接用 SecurityTransporter 替换掉 Transporter，即子类替换掉父类。尽管这样看起来里氏替换和多态很类似，但是他俩完全不是一回事。</p><p>多态是面向对象编程的一大特性，也是面向对象编程语言的一种语法。它是一种代码实现的思路。而里式替换是一种设计原则，是用来指导继承关系中子类该如何设计的，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑以及不破坏原有程序的正确性。（摘抄自极客时间）</p><p>哪些代码明显违背了 LSP？</p><ul><li>子类违背父类声明要实现的功能</li><li>子类违背父类对输入、输出、异常的约定</li><li>子类违背父类注释中所罗列的任何特殊说明</li></ul><p><em><strong>2022-6-8 暂封</strong></em></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;SOLID原则：由 5 个设计原则组成的，它们分别是：单一职责原则、开闭原则、里式替换原则、接口隔离原则和依赖反转原则，依次对应 SOLID 中的 S、O、L、I、D 这 5 个英文字母，&lt;/p&gt;
&lt;p&gt;SRP单一职责原则 Single Responsibility Principle；&lt;/p&gt;
&lt;p&gt;KISS保持简单 Keep It Simple and Stupid；&lt;/p&gt;
&lt;p&gt;YAGNI不需要原则 You Ain’t Gonna Need It ； &lt;/p&gt;
&lt;p&gt;DRY 不要重复原则 Don’t Repeat Yourself ； &lt;/p&gt;
&lt;p&gt;LOD 迪米特法则 Law of Demeter。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>策略模式</title>
    <link href="https://bqyang.top/2022/design-pattern/strategy/"/>
    <id>https://bqyang.top/2022/design-pattern/strategy/</id>
    <published>2022-06-07T13:10:53.515Z</published>
    <updated>2022-06-08T02:04:12.548Z</updated>
    
    <content type="html"><![CDATA[<p>由工厂模式引出策略模式，需要思考的是作者是怎么一步步引导我们的，以及工厂模式到底解决了什么问题？</p><span id="more"></span><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>二话不说先来看下策略模式的定义是什么？</p><p>策略模式（Strategy）：它定义了算法家族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化，不会影响到使用算法的客户。[DP]</p><p>由此可以联想到购物 App，618、双十一活动时以及一些法定节假日，这些都是促销活动，每次活动都有不同的优惠力度。商家在改变优惠活动的时候并不影响我们，给我们呈现的就是在那些节日我们拼单、凑满减。可能有时候就想花那 50 块钱，为了凑满减硬生生多花了几百。</p><p>言归正传，我们看下策略模式的结构图：</p><p><img src="https://s2.loli.net/2022/06/07/QPrZjJdivU4EMsl.png"></p><p>看到这张图第一眼其实跟工厂模式感觉不到什么差异，只不过是 Context 跟 Strategy 的关系变了。</p><p>更具体的区别在于调用时一个传递的是标识（用字符串来区分是哪计算类型），另一个是传递具体的对象，然后调用特定的方法。</p><p><img src="https://s2.loli.net/2022/06/08/IwgpQhSyAPVGdXu.png" alt="策略模式下的客户端实现"></p><p>需要初始化哪个类依赖于客户端的选择，那么可以通过哪种方式将算法的选择转移到后端的具体实现中呢？</p><h2 id="策略模式与工厂模式的结合"><a href="#策略模式与工厂模式的结合" class="headerlink" title="策略模式与工厂模式的结合"></a>策略模式与工厂模式的结合</h2><p><img src="https://s2.loli.net/2022/06/08/jMgGqYbRroJd2ED.png"></p><p>不难发现，这里构造函数接收一个字符串，也就是客户端传过来的值，然后我们根据这个值找到具体的分支（具体的子类），然后将这个子类赋给 Context 类的成员变量，后续客户端直接调用 Context 类的方法即可。</p><p>做到了，将类的初始化和客户端解耦。</p><h2 id="策略模式解析"><a href="#策略模式解析" class="headerlink" title="策略模式解析"></a>策略模式解析</h2><p>策略模式是一种定义一系列算法的方法，从概念上来看，所有这些算法完成的都是相同的工作，只是实现不同，它可以以相同的方式调用所有的算法，减少了各种算法类与使用算法类之间的耦合[DPE]。</p><p><strong>优点</strong>：</p><ul><li>策略模式的Strategy类层次为Context定义了一系列的可供重用的算法或行为。继承有助于析取出这些算法中的公共功能[DP]</li><li>策略模式的优点是简化了单元测试，因为每个算法都有自己的类，可以通过自己的接口单独测试[DPE]<ul><li>这个其实很好理解，大家都是独立的互不影响</li></ul></li><li>在基本的策略模式中，选择所用具体实现的职责由客户端对象承担，并转给策略模式的Context对象[DPE]</li><li>策略模式就是用来封装算法的，但在实践中，我们发现可以用它来封装几乎任何类型的规则，只要在分析过程中听到需要在不同时间应用不同的业务规则，就可以考虑使用策略模式处理这种变化的可能性[DPE]</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;由工厂模式引出策略模式，需要思考的是作者是怎么一步步引导我们的，以及工厂模式到底解决了什么问题？&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>简单工厂模式</title>
    <link href="https://bqyang.top/2022/design-pattern/easy-factory/"/>
    <id>https://bqyang.top/2022/design-pattern/easy-factory/</id>
    <published>2022-06-07T08:31:57.603Z</published>
    <updated>2022-06-07T13:10:41.386Z</updated>
    
    <content type="html"><![CDATA[<p>自己照着书上 JAVA 的代码翻译成了 Go 的代码，但是感觉很生硬，就比如，在 Go 中我们获取到了一个对应类型的 interface，这种情况下想要设置对应结构体的字段很麻烦，必须要实现 JAVA 中，那种 Get Set 的东西，如果说不想用这种方式，那么还需要对 interface 进行转换，并不是那么优雅。</p><p>工厂模式解决了什么问题：<strong>创建对象的问题</strong>。</p><span id="more"></span><h2 id="计算器的例子"><a href="#计算器的例子" class="headerlink" title="计算器的例子"></a>计算器的例子</h2><h3 id="JAVA-代码如下："><a href="#JAVA-代码如下：" class="headerlink" title="JAVA 代码如下："></a>JAVA 代码如下：</h3><p>这里展示的并不完整，可以通过 UML 图来看下类与类之间的关系。</p><p><img src="https://s2.loli.net/2022/06/07/MbtzFSdN4V561Ar.png"></p><p>UML 图如下：</p><p><img src="https://s2.loli.net/2022/06/07/AJlb27BFPM6hyea.png"></p><h3 id="Go-代码如下："><a href="#Go-代码如下：" class="headerlink" title="Go 代码如下："></a>Go 代码如下：</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Operation <span class="keyword">interface</span> &#123;</span><br><span class="line">    GetResult()</span><br><span class="line">    SetNum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SetNum <span class="keyword">interface</span> &#123;</span><br><span class="line">    SetNumber1(<span class="keyword">int</span>)</span><br><span class="line">    SetNumber2(<span class="keyword">int</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加法</span></span><br><span class="line"><span class="keyword">type</span> SADD <span class="keyword">struct</span> &#123;</span><br><span class="line">    Number1 <span class="keyword">int</span></span><br><span class="line">    Number2 <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *SADD)</span> <span class="title">GetResult</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(s.Number1 + s.Number2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *SADD)</span> <span class="title">SetNumber1</span><span class="params">(val <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    s.Number1 = val</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *SADD)</span> <span class="title">SetNumber2</span><span class="params">(val <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    s.Number2 = val</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 减法</span></span><br><span class="line"><span class="keyword">type</span> SSUB <span class="keyword">struct</span> &#123;</span><br><span class="line">    Number1 <span class="keyword">int</span></span><br><span class="line">    Number2 <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *SSUB)</span> <span class="title">GetResult</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(s.Number1 - s.Number2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *SSUB)</span> <span class="title">SetNumber1</span><span class="params">(val <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    s.Number1 = val</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *SSUB)</span> <span class="title">SetNumber2</span><span class="params">(val <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    s.Number2 = val</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工厂函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OperationFactory</span><span class="params">(oper <span class="keyword">string</span>)</span> <span class="title">Operation</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> oper &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> &amp;SADD&#123;&#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> &amp;SSUB&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    obj := OperationFactory(<span class="string">&quot;+&quot;</span>)</span><br><span class="line">    obj.SetNumber1(<span class="number">1</span>)</span><br><span class="line">    obj.SetNumber2(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    obj.GetResult()</span><br><span class="line">    <span class="comment">// Output: 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>综上所述，我们通过传入不同的运算符，然后返回不同的子类，调用每个子类相应的方法。</p><h2 id="商场打折例子"><a href="#商场打折例子" class="headerlink" title="商场打折例子"></a>商场打折例子</h2><p>比如我们要实现一个结算功能，然后根据商场不同的优惠活动，最终计算出一个总价出来，下图为小菜同学写的初版代码（其实人人都是小菜，但是没有人承认自己是小菜）。</p><p><img src="https://s2.loli.net/2022/06/07/NenaDz4uSV2xt6E.png"></p><p>那么这段代码存在什么问题呢？</p><ol><li>重复代码过多，<code>Convert.ToDouble</code> 调用多次，而且计算打折活动时的算法都是一样的，只是输入的折数不同。</li><li>代码扩展性不好，如果说这时候要增加额外的优惠活动，比如满 300-50，需要改动很多。</li></ol><p>用工厂模式重写，通过计算器的例子其实不难想出，我们仍需要一个父类，每个优惠活动都是其子类。</p><p>子类的抽象：</p><ul><li>并不需要为每种活动添加一个类，比如打八折、打九折这种可以抽象成一类</li><li>满 300 减 50 这种可以抽象成一类</li></ul><p><strong>面向对象的编程，并不是类越多越好，类的划分是为了封装，但分类的基础是抽象，具有相同属性和功能的对象的抽象集合才是类</strong></p><p>重写后的代码结构如下图所示：</p><p><img src="https://s2.loli.net/2022/06/07/cIM8w3vrBTVGgJU.png"></p><p>依次分为了，正常结算、优惠结算、满减结算；然后通过工程类，根据不同的需要创建特定的子类。</p><p>至此，一切看起来都很好，但是如果说商家想患者方法忽悠消费者，他又搞了一个打 5 折的活动，这时候难道我们要把响应的代码加上然后重新打包上线嘛？</p><p>很显然不能这样做，由此引出<strong>策略模式</strong>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;自己照着书上 JAVA 的代码翻译成了 Go 的代码，但是感觉很生硬，就比如，在 Go 中我们获取到了一个对应类型的 interface，这种情况下想要设置对应结构体的字段很麻烦，必须要实现 JAVA 中，那种 Get Set 的东西，如果说不想用这种方式，那么还需要对 interface 进行转换，并不是那么优雅。&lt;/p&gt;
&lt;p&gt;工厂模式解决了什么问题：&lt;strong&gt;创建对象的问题&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>UML 类图</title>
    <link href="https://bqyang.top/2022/design-pattern/UML/first-uml/"/>
    <id>https://bqyang.top/2022/design-pattern/UML/first-uml/</id>
    <published>2022-06-07T06:44:35.495Z</published>
    <updated>2022-06-07T07:40:35.205Z</updated>
    
    <content type="html"><![CDATA[<p>UML ，各种线条属实让人有点迷糊。</p><span id="more"></span><p><img src="https://s2.loli.net/2022/06/07/VAIjKL9sTeqMSwZ.png"></p><p>简单说明：</p><p>最上边的<em>动物</em>矩形框：</p><ul><li>第一行表示类名，如果是抽象类，则用斜体显示</li><li>第二行表示类的属性</li><li>第三行表示类的方法</li></ul><blockquote><p>‘+’表示public，‘-’表示private，‘#’表示protected。</p></blockquote><p>接口的两种表示方法：</p><ol><li>左下角的<em>飞翔</em> 矩形框：<ol><li>矩形表示法</li></ol></li><li>最下方的 <em>唐老鸭</em> 表示的也是接口：<ol><li>棒棒糖表示法</li></ol></li></ol><p>鸟与翅膀：</p><ul><li>合成（Composition，也有翻译成‘组合’的）是一种强的‘拥有’关系，体现了严格的部分和整体的关系，部分和整体的生命周期一样</li></ul><p>大雁与雁群：</p><ul><li>聚合表示一种弱的‘拥有’关系，体现的是A对象可以包含B对象，但B对象不是A对象的一部分</li></ul><p>剩下的图中都有很详细的说明，内容来自《大话设计模式》这本书，作为设计模式入门教材还是很不错的。</p><p>无奈的就是自己没有详细接触过一门面向对象编程语言，只能看懂大致的语法，没办法从面向对象的角度出发进行思考。</p><p>包括到现在，自己写的代码也都是面向过程的，一个函数套另一个函数，更多的像是函数式编程。</p><p>Go 中没有<strong>类</strong>的概念，关于结构体也是仁者见仁智者见智，我们可以把它类比成类，为结构体增加的方法类比成类中的方法。</p><p>将类的继承类比成接口的组合。</p><p>虽然实际接触过，但也了解到继承这个特性经常被人诟病。父类繁多、难以维护、阅读。相比之下，大家更推崇基于组合的方式，这正是 Go 中的实现方式。</p><p>自己对这块也是不太了解，只能是看着 JAVA 的代码想着 Go 的实现。。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;UML ，各种线条属实让人有点迷糊。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>go-generic</title>
    <link href="https://bqyang.top/2022/language/golang/go-generic/"/>
    <id>https://bqyang.top/2022/language/golang/go-generic/</id>
    <published>2022-06-06T07:08:18.767Z</published>
    <updated>2022-06-07T06:31:17.792Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2022/06/06/LNYfsvCZwxeh3l9.png"></p><p>go 泛型学习，距离泛型的发布已经有很长一段时间了，之前大概看了下官方文档，说有些东西可能将来都会改变，不保证向前兼容，就没有具体了解，1.18也发了几个版本了，感觉再不努力又要被小伙伴们卷完了。</p><span id="more"></span><h2 id="困扰"><a href="#困扰" class="headerlink" title="困扰"></a>困扰</h2><p>没有泛型的时候带给我们的困扰（虽然没有亲身体会过，但是感觉很麻烦）</p><h3 id="Case-1"><a href="#Case-1" class="headerlink" title="Case 1"></a>Case 1</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Sum returns the sum of the provided arguments.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sum</span><span class="params">(args ...<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> sum <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(args); i++ &#123;</span><br><span class="line">        sum += args[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要计算 n 数之和，如上述例子，如果这时要计算 int32, float64 类型元素的和呢？</p><p>通常情况下，我们需要进行 asserting type，或者为每种类型写不同的函数 <code>sumInt</code> <code>sumInt32</code> <code>sumInt64</code> 等，在源码中就有类似的代码。</p><h3 id="Case-2"><a href="#Case-2" class="headerlink" title="Case 2"></a>Case 2</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Declare &quot;host&quot; and &quot;port&quot; in order to create pointers to satisfy the</span></span><br><span class="line">    <span class="comment">// fields in the &quot;request&quot; struct.</span></span><br><span class="line">    host, port := <span class="string">&quot;local&quot;</span>, <span class="number">80</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(request&#123;</span><br><span class="line">        host: &amp;host,</span><br><span class="line">        port: &amp;port,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>This leads to cluttered, hard-to-read code where the only purpose variables serve is for deriving pointers.</p></blockquote><p>对每个变量进行取址操作，<em>我之前就写过这样的代码</em> ，为了取址不得不声明一个变量。</p><p>针对这种情况，可以实现不同的函数进行取址操作。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// PtrInt returns *i.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PtrInt</span><span class="params">(i <span class="keyword">int</span>)</span> *<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PtrStr returns *s.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PtrStr</span><span class="params">(s <span class="keyword">string</span>)</span> *<span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Use the two helper functions that return pointers to their provided</span></span><br><span class="line">    <span class="comment">// values. Remember, this pattern must scale with the number of distinct,</span></span><br><span class="line">    <span class="comment">// defined types that need to be passed by pointer instead of value.</span></span><br><span class="line">    <span class="built_in">print</span>(request&#123;</span><br><span class="line">        host: PtrStr(<span class="string">&quot;local&quot;</span>),</span><br><span class="line">        port: PtrInt(<span class="number">80</span>),</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看起来可能比上边的优雅了一些，但是还不够，我们看下泛型。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Ptr returns *value.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Ptr</span>[<span class="title">T</span> <span class="title">any</span>]<span class="params">(value T)</span> *<span class="title">T</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// No local variables and the typed helper functions can be collapsed into</span></span><br><span class="line">    <span class="comment">// a single, generic function for getting a pointer to a value.</span></span><br><span class="line">    <span class="built_in">print</span>(request&#123;</span><br><span class="line">        host: Ptr(<span class="string">&quot;local&quot;</span>),</span><br><span class="line">        port: Ptr(<span class="number">80</span>),</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一方面是代码量减少了很多，另一方看是看起来更整洁。</p><h2 id="generic-语法"><a href="#generic-语法" class="headerlink" title="generic 语法"></a>generic 语法</h2><p>使用 <em>泛型</em> 重写这段代码</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Sum returns the sum of the provided arguments.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sum</span><span class="params">(args ...<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> sum <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(args); i++ &#123;</span><br><span class="line">        sum += args[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>泛型版本：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sum</span>[<span class="title">T</span> <span class="title">int</span>]<span class="params">(args ...T)</span> <span class="title">T</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> sum T</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(args); i++ &#123;</span><br><span class="line">        sum += args[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>[]</code> 是用来定义泛型的，常用的模式为 <code>[&lt;ID&gt; &lt;CONSTRAINT&gt;]</code></p><ul><li><code>&lt;ID&gt;</code> 是用来表示泛型的符号；</li><li><code>&lt;CONSTRAINT&gt;</code> 约束，表明可使用的具体类型，如上，只能使用 int；</li></ul><p>但是这时候我们想支持 int64 类型的 n 数和应该怎么办？</p><h3 id="Constraint"><a href="#Constraint" class="headerlink" title="Constraint"></a>Constraint</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sum</span>[<span class="title">T</span> <span class="title">int</span>|<span class="title">int64</span>]<span class="params">(args ...T)</span> <span class="title">T</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> sum T</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(args); i++ &#123;</span><br><span class="line">        sum += args[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>|</code> 运算符，这时，T 就可以满足 int 或者 int64，至于为什么使用 <code>|</code> 运算符不做过多考究。</p><p>但是这时还有一个小问题，如果说要支持更多的类型应该怎么做？难道要 <code>int|int32|int64</code> ? go 也给我们提供了相应的语法。</p><h4 id="any-constraint"><a href="#any-constraint" class="headerlink" title="any constraint"></a><code>any</code> constraint</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sum_any.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sum</span>[<span class="title">T</span> <span class="title">any</span>]<span class="params">(args ...T)</span> <span class="title">T</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> sum T</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(args); i++ &#123;</span><br><span class="line">        sum += args[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(Sum([]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;...))</span><br><span class="line">    fmt.Println(Sum([]<span class="keyword">int8</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;...))</span><br><span class="line">    fmt.Println(Sum([]<span class="keyword">uint32</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;...))</span><br><span class="line">    fmt.Println(Sum([]<span class="keyword">float64</span>&#123;<span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>&#125;...))      </span><br><span class="line">    fmt.Println(Sum([]<span class="keyword">complex128</span>&#123;<span class="number">1.1i</span>, <span class="number">2.2i</span>, <span class="number">3.3i</span>&#125;...))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>去执行试下，会意外的发现使用 <code>any</code> 其实行不通，原因是啥呢？</p><blockquote><p>./sum_any.go:11:3: invalid operation: operator + not defined on sum (variable of type T constrained by any)</p></blockquote><p> <code>+</code> 运算符并不是对所有的类型都生效。</p><p>既然这样，我们是不是可以声明一个东西，限定只能输数字类型的参数呢？</p><h4 id="Composite-constraints"><a href="#Composite-constraints" class="headerlink" title="Composite constraints"></a>Composite constraints</h4><p>复合类型</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Numeric expresses a type constraint satisfied by any numeric type.</span></span><br><span class="line"><span class="keyword">type</span> Numeric <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="keyword">uint</span> | <span class="keyword">uint8</span> | <span class="keyword">uint16</span> | <span class="keyword">uint32</span> | <span class="keyword">uint64</span> |</span><br><span class="line">    <span class="keyword">int</span> | <span class="keyword">int8</span> | <span class="keyword">int16</span> | <span class="keyword">int32</span> | <span class="keyword">int64</span> |</span><br><span class="line">    <span class="keyword">float32</span> | <span class="keyword">float64</span> |</span><br><span class="line">    <span class="keyword">complex64</span> | <span class="keyword">complex128</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sum returns the sum of the provided arguments.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sum</span>[<span class="title">T</span> <span class="title">Numeric</span>]<span class="params">(args ...T)</span> <span class="title">T</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> sum T</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(args); i++ &#123;</span><br><span class="line">        sum += args[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面这种情况如何处理？</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// id is a new type definition for an int64</span></span><br><span class="line"><span class="keyword">type</span> id <span class="keyword">int64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(Sum([]id&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;...))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们给 int64 起了个别名，这时候编译就会报错了，那我们应该怎样去识别别名呢？</p><h4 id="Tilde"><a href="#Tilde" class="headerlink" title="Tilde ~"></a>Tilde <code>~</code></h4><p>波浪号就是干这个事情的，举个例子，<code>~int</code> 表示：</p><ul><li>内置的 int 类型</li><li><code>type Integer int </code> 类型，起别名的类型</li></ul><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Numeric <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="keyword">uint</span> | <span class="keyword">uint8</span> | <span class="keyword">uint16</span> | <span class="keyword">uint32</span> | <span class="keyword">uint64</span> |</span><br><span class="line">    <span class="comment">// 调整如下</span></span><br><span class="line">    <span class="keyword">int</span> | <span class="keyword">int8</span> | <span class="keyword">int16</span> | <span class="keyword">int32</span> | ~<span class="keyword">int64</span> |</span><br><span class="line">    <span class="keyword">float32</span> | <span class="keyword">float64</span> |</span><br><span class="line">    <span class="keyword">complex64</span> | <span class="keyword">complex128</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Type-inference"><a href="#Type-inference" class="headerlink" title="Type inference"></a>Type inference</h3><ul><li><input disabled="" type="checkbox"> <a href="https://go.googlesource.com/proposal/+/refs/heads/master/design/43651-type-parameters.md">Type Parameters Proposal</a> 待阅读</li></ul><ul><li>Type inference is a convenience feature</li><li>The Go compiler tries <em>really</em> hard to infer the intended types, but it does not always work when you think it should</li><li>If you are not sure why something written generically is not working, try providing the types explicitly</li></ul><h3 id="Explicit-types"><a href="#Explicit-types" class="headerlink" title="Explicit types"></a>Explicit types</h3><p>显示指定类型</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(Sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line">    fmt.Println(Sum([]id&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;...))</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Generic types can be specified explicitly by invoking a function</span></span><br><span class="line">    <span class="comment">// with the bracket notation and the list of types to use. Because</span></span><br><span class="line">    <span class="comment">// the Sum function only has a single, generic type -- &quot;T&quot; -- the</span></span><br><span class="line">    <span class="comment">// call &quot;Sum[float64]&quot; means that &quot;T&quot; will be replaced by &quot;float64&quot;</span></span><br><span class="line">    <span class="comment">// when compiling the code. Since the values &quot;1&quot; and &quot;2&quot; can both</span></span><br><span class="line">    <span class="comment">// be treated as &quot;float64,&quot; the code is valid.</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// go 类型推断为 int 类型，但是后续出现了浮点数，导致失败。</span></span><br><span class="line">    <span class="comment">// 我们可以明确规定这个为 浮点数类型。</span></span><br><span class="line">    fmt.Println(Sum[<span class="keyword">float64</span>](<span class="number">1</span>, <span class="number">2</span>, <span class="number">3.0</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Multiple-generic-types"><a href="#Multiple-generic-types" class="headerlink" title="Multiple generic types"></a>Multiple generic types</h3><p>到这里为止，接触到的都是接收单一参数的函数，这里学习下怎么接收多个泛型参数。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// PrintIDAndSum prints the provided ID and sum of the given values to stdout.</span></span><br><span class="line"><span class="comment">// 应该还记得 ~ 的用法吧，适配类型别名</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PrintIDAndSum</span>[<span class="title">T</span> ~<span class="title">string</span>, <span class="title">K</span> <span class="title">Numeric</span>]<span class="params">(id T, sum SumFn[K], values ...K)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The format string uses &quot;%v&quot; to emit the sum since using &quot;%d&quot; would</span></span><br><span class="line">    <span class="comment">// be invalid if the value type was a float or complex variant.</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%s has a sum of %v\n&quot;</span>, id, sum(values...))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意</p></blockquote><p>在调用这个函数时仍需要显示指定 <code>sum</code> 的类型，<code>PrintIDAndSum(&quot;xx&quot;, Sum[int32], 1, 2, 3)</code> ，如果没有指定类型，就会报错：<code>./mulgen.go:12:22: cannot use generic function Sum without instantiation</code></p><h3 id="Declaring-a-new-instance-of-T-with-var"><a href="#Declaring-a-new-instance-of-T-with-var" class="headerlink" title="Declaring a new instance of T with var"></a>Declaring a new instance of <code>T</code> with <code>var</code></h3><p>这里跟在上述 sum 中声明变量没什么区别。</p><h3 id="Declaring-a-new-instance-of-T-with-new"><a href="#Declaring-a-new-instance-of-T-with-new" class="headerlink" title="Declaring a new instance of T with new"></a>Declaring a new instance of <code>T</code> with <code>new</code></h3><p>new 之后的变量会被分配地址，不再是 nil。</p><h3 id="Structs"><a href="#Structs" class="headerlink" title="Structs"></a>Structs</h3><p>将泛型和结构体结合使用，不难看出语法上和函数定义大差不差。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Ledger[T ~<span class="keyword">string</span>, K Numeric] <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID T</span><br><span class="line">    Amounts []k</span><br><span class="line">    SumFnSumFn[K]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为泛型结构体添加方法，正因为结构体中有泛型，所以在声明方法时也要导入<strong>相应的符号，约束不需要</strong>，因为是为了类型推断使用。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l Ledger[T, K])</span> <span class="title">PrintIDAndSum</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%s has a sum of %v\n&quot;</span>, l.ID, l.SumFn(l.Amounts...))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单示例：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// generic struct</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Numeric <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> | <span class="keyword">int32</span> | <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Ledger[T ~<span class="keyword">string</span>, K Numeric] <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID T</span><br><span class="line">    Amounts []K</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l Ledger[T, K])</span> <span class="title">PrintA</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(l.ID)</span><br><span class="line">    <span class="built_in">print</span>(l.Amounts)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Ledger[<span class="keyword">string</span>, <span class="keyword">int</span>]&#123;</span><br><span class="line">        ID: <span class="string">&quot;test-qq&quot;</span>,</span><br><span class="line">        Amounts: []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>,<span class="number">3</span>&#125;,</span><br><span class="line">    &#125;.PrintA()</span><br><span class="line"></span><br><span class="line">    Ledger[<span class="keyword">string</span>, <span class="keyword">int32</span>]&#123;</span><br><span class="line">        ID: <span class="string">&quot;test-qq&quot;</span>,</span><br><span class="line">        Amounts: []<span class="keyword">int32</span>&#123;<span class="number">1</span>, <span class="number">2</span>,<span class="number">3</span>&#125;,</span><br><span class="line">    &#125;.PrintA()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Structural-Constraints"><a href="#Structural-Constraints" class="headerlink" title="Structural Constraints"></a>Structural Constraints</h4><p>这个特性还存在一些问题，泛型的结构体暂时禁止访问字段，其实感觉挺一般的，既然更版本了为啥不做好、做完善呢？</p><p>…</p><p><strong>匿名结构体</strong></p><p>如果说要接收任意包含这三个字段的结构体（即 Ledger 的实例），需要像下面这样实现，<strong>所有的结构体都实现了匿名结构体</strong>。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SomeFunc</span>[</span></span><br><span class="line">    T ~<span class="keyword">string</span>,</span><br><span class="line">    K Numeric,</span><br><span class="line">    L ~<span class="keyword">struct</span> &#123;</span><br><span class="line">        ID      T</span><br><span class="line">        Amounts []K</span><br><span class="line">        SumFn   SumFn[K]</span><br><span class="line">    &#125;,</span><br><span class="line">](l L) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    SomeFunc[<span class="keyword">string</span>, <span class="keyword">int</span>, Ledger[<span class="keyword">string</span>, <span class="keyword">int</span>]](Ledger[<span class="keyword">string</span>, <span class="keyword">int</span>]&#123;</span><br><span class="line">        ID:      <span class="string">&quot;acct-1&quot;</span>,</span><br><span class="line">        Amounts: []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,</span><br><span class="line">        SumFn:   Sum[<span class="keyword">int</span>],</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Structural constraints must match the struct <em>exactly</em>, and this means even if all of the fields in the constraint are present, the presence of additional fields in the provided value means the type does not satisfy the constraint.</p></blockquote><p>这里可以暂时不考虑，后续待官方完善了再学也不迟，毕竟现在工作中用不到这些东西..</p><h3 id="Interface-constraints"><a href="#Interface-constraints" class="headerlink" title="Interface constraints"></a>Interface constraints</h3><p>接口约束之前已经见过了， <code>Numeric</code>  限制了类型只能是 <code>int int32 int64</code></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Numeric <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> | <span class="keyword">int32</span> | <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于结构体来说，想通过接口调用方法，需要在上述那样的基础上再添加上方法。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Ledgerish expresses a constraint that may be satisfied by types that have</span></span><br><span class="line"><span class="comment">// ledger-like qualities.</span></span><br><span class="line"><span class="keyword">type</span> Ledgerish[T ~<span class="keyword">string</span>, K Numeric] <span class="keyword">interface</span> &#123;</span><br><span class="line">    ~<span class="keyword">struct</span> &#123;</span><br><span class="line">        ID      T</span><br><span class="line">        Amounts []K</span><br><span class="line">        SumFn   SumFn[K]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PrintIDAndSum()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Careful-Constructs"><a href="#Careful-Constructs" class="headerlink" title="Careful Constructs"></a>Careful Constructs</h3><h3 id="Internals"><a href="#Internals" class="headerlink" title="Internals"></a>Internals</h3><h4 id="Type-erasure"><a href="#Type-erasure" class="headerlink" title="Type erasure"></a>Type erasure</h4><p>在了解 Go 中泛型是怎么做到运行时安全前，先了解一下类型擦除。</p><p>Wiki 上的定义是：<em>the load-time process by which explicit type annotations are removed from a program before it is executed at run-time</em></p><p>翻译过来就是，程序在运行时执行前，进程显示的将类型注解从程序中移除掉。（自己翻译的）</p><p>伪代码演示如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ints = List&lt;Int32&gt;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">var</span> strs = List&lt;String&gt;&#123;<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;world&quot;</span>&#125;</span><br></pre></td></tr></table></figure><p><strong>Type erasure</strong> 执行后</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ints = List&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">var</span> strs = List&#123;<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;world&quot;</span>&#125;</span><br></pre></td></tr></table></figure><p>这两个的唯一区别就是将类型擦除掉了，这个特性在很多流行的编程语言中都有。</p><h5 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h5><p>java 中 type erasure 的体现：<a href="https://github.com/akutz/go-generics-the-hard-way/blob/main/05-internals/01-type-erasure/02-java.md">java-type-erasure</a></p><h5 id="Net"><a href="#Net" class="headerlink" title=".Net"></a>.Net</h5><p>.Net 中 type erasure 的体现：<a href="https://github.com/akutz/go-generics-the-hard-way/blob/main/05-internals/01-type-erasure/03-dotnet.md">.Net-type-erasure</a></p><h5 id="Golang"><a href="#Golang" class="headerlink" title="Golang"></a>Golang</h5><p>Go 中 type erasure 的体现：<a href="https://github.com/akutz/go-generics-the-hard-way/blob/main/05-internals/01-type-erasure/04-golang.md">Golang-type-erasure</a> ，这里介绍到，Go中没有反省模板，list 中保留的仍是具体类型，不像 JAVA 中翻译成 object。</p><h4 id="Runtime-safety"><a href="#Runtime-safety" class="headerlink" title="Runtime-safety"></a>Runtime-safety</h4><p>关于泛型这里我一直有个疑问，比如我们定义了一个泛型数组，使用 Go 代码声明如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> List[T any] []T</span><br></pre></td></tr></table></figure><p>假设我们在初始化的时候使用 int，但是后续执行 append 操作的时候加一个 string 能不能行得通？<strong>显然在 Go  中并不行</strong>。那么在其他语言中呢？</p><h5 id="JAVA-1"><a href="#JAVA-1" class="headerlink" title="JAVA"></a>JAVA</h5><p><a href="https://github.com/akutz/go-generics-the-hard-way/blob/main/05-internals/02-runtime-type-safety/01-java.md">java-runtime-safety</a> 从这里不难看出，java 中擦出了初始化泛型的信息，很难保持在 runtime 时安全。</p><h5 id="NET"><a href="#NET" class="headerlink" title=".NET"></a>.NET</h5><p><a href="https://github.com/akutz/go-generics-the-hard-way/blob/main/05-internals/02-runtime-type-safety/02-dotnet.md">.NET-runtime-safety</a> 这里保持了泛型的相关信息，所以在运行时是安全的。</p><h5 id="Golang-1"><a href="#Golang-1" class="headerlink" title="Golang"></a>Golang</h5><p><a href="https://github.com/akutz/go-generics-the-hard-way/blob/main/05-internals/02-runtime-type-safety/03-golang.md">Golang-runtime-safety</a> 通过前面的内容我们知道，Go 中没有进行 type erasure，所以也可以做到 runtime 时安全。</p><h4 id="Runtime-instantiation"><a href="#Runtime-instantiation" class="headerlink" title="Runtime-instantiation"></a>Runtime-instantiation</h4><blockquote><p>The ability to instantiate new types using generics at runtime，在运行时使用泛型初始化的能力。</p></blockquote><p>我觉得，如果要支持运行时初始化的能力，需要具备动态推断类型的能力，在运行时检测泛型是哪种类型。</p><h5 id="JAVA-2"><a href="#JAVA-2" class="headerlink" title="JAVA"></a>JAVA</h5><p><a href="https://github.com/akutz/go-generics-the-hard-way/blob/main/05-internals/03-runtime-instantiation/01-java.md">java-runtime-instantiation</a> 不支持，Java中的泛型纯粹是编译时特性。</p><h5 id="NET-1"><a href="#NET-1" class="headerlink" title=".NET"></a>.NET</h5><p><a href="https://github.com/akutz/go-generics-the-hard-way/blob/main/05-internals/03-runtime-instantiation/02-dotnet.md">.NET-runtime-instantiation</a> 支持.. 这么一看.. .NET 还是牛逼..我有个大学同学人家都是 JAVA，Python，这兄弟学了两年 .NET 哈哈哈哈，后来由于比较冷门，也放弃了哈哈。</p><h5 id="Golang-2"><a href="#Golang-2" class="headerlink" title="Golang"></a>Golang</h5><p><a href="https://github.com/akutz/go-generics-the-hard-way/blob/main/05-internals/03-runtime-instantiation/03-golang.md">golang-runtime-instantiation</a> 不支持，Go 中的泛型同 java 一样都是编译时的特性，在编译时就确定好了类型。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><table><thead><tr><th></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th></tr></thead><tbody><tr><td></td><td align="center">Compile-time type safety</td><td align="center">Type erasure</td><td align="center">Runtime type safety</td><td align="center">Runtime instantiation</td></tr><tr><td>Java</td><td align="center">✓</td><td align="center">✓</td><td align="center"></td><td align="center"></td></tr><tr><td>.NET</td><td align="center">✓</td><td align="center"></td><td align="center">✓</td><td align="center">✓</td></tr><tr><td>Go</td><td align="center">✓</td><td align="center"></td><td align="center">✓</td><td align="center"></td></tr></tbody></table><p>至此，泛型的学习就告一段落了，学到了语法，如何使用，已经在某些简单的场景下使用泛型带来的便利性。也或多或少的了解到了其他语言的泛型特性。</p><p>参考链接：</p><ol><li><a href="https://github.com/akutz/go-generics-the-hard-way/">go-generics-the-hard-way</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2022/06/06/LNYfsvCZwxeh3l9.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;go 泛型学习，距离泛型的发布已经有很长一段时间了，之前大概看了下官方文档，说有些东西可能将来都会改变，不保证向前兼容，就没有具体了解，1.18也发了几个版本了，感觉再不努力又要被小伙伴们卷完了。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>初识 go-ast</title>
    <link href="https://bqyang.top/2022/language/golang/go-ast/"/>
    <id>https://bqyang.top/2022/language/golang/go-ast/</id>
    <published>2022-06-02T09:17:42.991Z</published>
    <updated>2022-06-04T07:41:08.614Z</updated>
    
    <content type="html"><![CDATA[<p>什么是 ast？ 用 ast 能做什么？</p><p>前一阵子学到了一个 linter，用的就是这个 ast，正好接这个机会了解一下。</p><span id="more"></span><p>ast (Abstact Syntax Tree) 翻译过来就是抽象语法树，第一次听到这个应该还是在读大学时候，没想到终究还是要填坑。</p><blockquote><p>AST 是源代码的一种抽象表示。</p></blockquote><p>学习如何读取一个 <code>.go</code> 文件，然后输出它的 AST 语法树并读懂这个语法树，文件内容如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    name = <span class="string">&quot;bqyang&quot;</span></span><br><span class="line">    <span class="built_in">println</span>(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如上边的代码块，这是平时我们看到的，在源代码编译过程中，会经历生成 AST 的这个阶段，用 Go 来表示的话，如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  0  *ast.File &#123;</span><br><span class="line">  1  .  Doc: nil</span><br><span class="line">  2  .  Package: foo:1:1</span><br><span class="line">  3  .  Name: *ast.Ident &#123;</span><br><span class="line">  4  .  .  NamePos: foo:1:9</span><br><span class="line">  5  .  .  Name: &quot;main&quot;</span><br><span class="line">  6  .  .  Obj: nil</span><br><span class="line">  7  .  &#125;</span><br><span class="line">  8  .  Decls: []ast.Decl (len = 2) &#123;</span><br><span class="line">  9  .  .  0: *ast.GenDecl &#123;</span><br><span class="line"> 10  .  .  .  Doc: nil</span><br><span class="line"> 11  .  .  .  TokPos: foo:3:1</span><br><span class="line"> 12  .  .  .  Tok: var</span><br><span class="line"> 13  .  .  .  Lparen: -</span><br><span class="line"> 14  .  .  .  Specs: []ast.Spec (len = 1) &#123;</span><br><span class="line"> 15  .  .  .  .  0: *ast.ValueSpec &#123;</span><br><span class="line"> 16  .  .  .  .  .  Doc: nil</span><br><span class="line"> 17  .  .  .  .  .  Names: []*ast.Ident (len = 1) &#123;</span><br><span class="line"> 18  .  .  .  .  .  .  0: *ast.Ident &#123;</span><br><span class="line"> 19  .  .  .  .  .  .  .  NamePos: foo:3:5</span><br><span class="line"> 20  .  .  .  .  .  .  .  Name: &quot;name&quot;</span><br><span class="line"> 21  .  .  .  .  .  .  .  Obj: *ast.Object &#123;</span><br><span class="line"> 22  .  .  .  .  .  .  .  .  Kind: var</span><br><span class="line"> 23  .  .  .  .  .  .  .  .  Name: &quot;name&quot;</span><br><span class="line"> 24  .  .  .  .  .  .  .  .  Decl: *(obj @ 15)</span><br><span class="line"> 25  .  .  .  .  .  .  .  .  Data: 0</span><br><span class="line"> 26  .  .  .  .  .  .  .  .  Type: nil</span><br><span class="line"> 27  .  .  .  .  .  .  .  &#125;</span><br><span class="line"> 28  .  .  .  .  .  .  &#125;</span><br><span class="line"> 29  .  .  .  .  .  &#125;</span><br><span class="line"> 30  .  .  .  .  .  Type: *ast.Ident &#123;</span><br><span class="line"> 31  .  .  .  .  .  .  NamePos: foo:3:10</span><br><span class="line"> 32  .  .  .  .  .  .  Name: &quot;string&quot;</span><br><span class="line"> 33  .  .  .  .  .  .  Obj: nil</span><br><span class="line"> 34  .  .  .  .  .  &#125;</span><br><span class="line"> 35  .  .  .  .  .  Values: nil</span><br><span class="line"> 36  .  .  .  .  .  Comment: nil</span><br><span class="line"> 37  .  .  .  .  &#125;</span><br><span class="line"> 38  .  .  .  &#125;</span><br><span class="line"> 39  .  .  .  Rparen: -</span><br><span class="line"> 40  .  .  &#125;</span><br><span class="line"> 41  .  .  1: *ast.FuncDecl &#123;</span><br><span class="line"> 42  .  .  .  Doc: nil</span><br><span class="line"> 43  .  .  .  Recv: nil</span><br><span class="line"> 44  .  .  .  Name: *ast.Ident &#123;</span><br><span class="line"> 45  .  .  .  .  NamePos: foo:5:6</span><br><span class="line"> 46  .  .  .  .  Name: &quot;main&quot;</span><br><span class="line"> 47  .  .  .  .  Obj: *ast.Object &#123;</span><br><span class="line"> 48  .  .  .  .  .  Kind: func</span><br><span class="line"> 49  .  .  .  .  .  Name: &quot;main&quot;</span><br><span class="line"> 50  .  .  .  .  .  Decl: *(obj @ 41)</span><br><span class="line"> 51  .  .  .  .  .  Data: nil</span><br><span class="line"> 52  .  .  .  .  .  Type: nil</span><br><span class="line"> 53  .  .  .  .  &#125;</span><br><span class="line"> 54  .  .  .  &#125;</span><br><span class="line"> 55  .  .  .  Type: *ast.FuncType &#123;</span><br><span class="line"> 56  .  .  .  .  Func: foo:5:1</span><br><span class="line"> 57  .  .  .  .  Params: *ast.FieldList &#123;</span><br><span class="line"> 58  .  .  .  .  .  Opening: foo:5:10</span><br><span class="line"> 59  .  .  .  .  .  List: nil</span><br><span class="line"> 60  .  .  .  .  .  Closing: foo:5:11</span><br><span class="line"> 61  .  .  .  .  &#125;</span><br><span class="line"> 62  .  .  .  .  Results: nil</span><br><span class="line"> 63  .  .  .  &#125;</span><br><span class="line"> 64  .  .  .  Body: *ast.BlockStmt &#123;</span><br><span class="line"> 65  .  .  .  .  Lbrace: foo:5:13</span><br><span class="line"> 66  .  .  .  .  List: []ast.Stmt (len = 1) &#123;</span><br><span class="line"> 67  .  .  .  .  .  0: *ast.ExprStmt &#123;</span><br><span class="line"> 68  .  .  .  .  .  .  X: *ast.CallExpr &#123;</span><br><span class="line"> 69  .  .  .  .  .  .  .  Fun: *ast.Ident &#123;</span><br><span class="line"> 70  .  .  .  .  .  .  .  .  NamePos: foo:6:5</span><br><span class="line"> 71  .  .  .  .  .  .  .  .  Name: &quot;println&quot;</span><br><span class="line"> 72  .  .  .  .  .  .  .  .  Obj: nil</span><br><span class="line"> 73  .  .  .  .  .  .  .  &#125;</span><br><span class="line"> 74  .  .  .  .  .  .  .  Lparen: foo:6:12</span><br><span class="line"> 75  .  .  .  .  .  .  .  Args: []ast.Expr (len = 1) &#123;</span><br><span class="line"> 76  .  .  .  .  .  .  .  .  0: *ast.Ident &#123;</span><br><span class="line"> 77  .  .  .  .  .  .  .  .  .  NamePos: foo:6:13</span><br><span class="line"> 78  .  .  .  .  .  .  .  .  .  Name: &quot;name&quot;</span><br><span class="line"> 79  .  .  .  .  .  .  .  .  .  Obj: *(obj @ 21)</span><br><span class="line"> 80  .  .  .  .  .  .  .  .  &#125;</span><br><span class="line"> 81  .  .  .  .  .  .  .  &#125;</span><br><span class="line"> 82  .  .  .  .  .  .  .  Ellipsis: -</span><br><span class="line"> 83  .  .  .  .  .  .  .  Rparen: foo:6:17</span><br><span class="line"> 84  .  .  .  .  .  .  &#125;</span><br><span class="line"> 85  .  .  .  .  .  &#125;</span><br><span class="line"> 86  .  .  .  .  &#125;</span><br><span class="line"> 87  .  .  .  .  Rbrace: foo:7:1</span><br><span class="line"> 88  .  .  .  &#125;</span><br><span class="line"> 89  .  .  &#125;</span><br><span class="line"> 90  .  &#125;</span><br><span class="line"> 91  .  Scope: *ast.Scope &#123;</span><br><span class="line"> 92  .  .  Outer: nil</span><br><span class="line"> 93  .  .  Objects: map[string]*ast.Object (len = 2) &#123;</span><br><span class="line"> 94  .  .  .  &quot;name&quot;: *(obj @ 21)</span><br><span class="line"> 95  .  .  .  &quot;main&quot;: *(obj @ 47)</span><br><span class="line"> 96  .  .  &#125;</span><br><span class="line"> 97  .  &#125;</span><br><span class="line"> 98  .  Imports: nil</span><br><span class="line"> 99  .  Unresolved: []*ast.Ident (len = 2) &#123;</span><br><span class="line">100  .  .  0: *(obj @ 30)</span><br><span class="line">101  .  .  1: *(obj @ 69)</span><br><span class="line">102  .  &#125;</span><br><span class="line">103  .  Comments: nil</span><br><span class="line">104  &#125;</span><br></pre></td></tr></table></figure><p>现在看起来比较懵逼，其实我在写这段话的时候，也不清楚这里边每个字段都是什么意思，我们先有一个整体的认识，然后再逐个了解。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;什么是 ast？ 用 ast 能做什么？&lt;/p&gt;
&lt;p&gt;前一阵子学到了一个 linter，用的就是这个 ast，正好接这个机会了解一下。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>根管治疗+全瓷冠</title>
    <link href="https://bqyang.top/2022/summary/about-0602/"/>
    <id>https://bqyang.top/2022/summary/about-0602/</id>
    <published>2022-06-02T02:59:42.025Z</published>
    <updated>2022-06-02T03:45:43.131Z</updated>
    
    <content type="html"><![CDATA[<p>从小就是牙口不好，小时候家里对这方面也没有过多关注过，自己也不注重口腔健康，当时爽了，现在完蛋了。</p><p>不仅钱花得多，还非常的折腾。</p><p>我是清明节回家补了一颗龋齿（蛀牙），那天补牙的时候，突然有一下特别疼（就是那个感觉一瞬间就布遍全身，我感觉不咋疼），医生在那一顿叹气，哎呀，露神经了，这就不好弄了。</p><span id="more"></span><p>就是龋齿太深了，已经到牙神经部分了，当时医生没有做过多的处理，问我是要盖上还是直接补，当时我也不明白啥意思，反正最后是听了医生的建议，直接补上了。</p><p>补上后感觉那个地方一直在跳动，别的感觉就没啥了，直到一个月后，就是四月底吧。那天吃午饭，明显的感觉咬到了像石子一样的东西，照镜子一看，补的那块牙掉了一块渣。</p><p>自打那天开始就一直疼，牙髓发炎了，但是当时上着班，而且也挂不上号，拖了两天没去。</p><blockquote><p>北京这边的医院挂号真的好复杂啊，我当时抢北京大学口腔医院的号，抢了两天都没有。而且就算你挂上了也不是当天的号，都是 N + 1 或者 N + 2 的这种。</p></blockquote><p>然后选了一个二甲的保底，挂到了某个首都医科大学附属的三甲医院。</p><p>去了那天就做了牙髓失活术（先打麻药，然后应该是往里放了点什么药），整个人感觉活过来了一样，完全没感觉了。</p><p>后续就是非常折腾，大概跑了 6 次，期间还因为政策原因推迟了很久。</p><p>这周一是最后一次去，把牙冠戴上了， 医生只给了我两个选项，一个是 5000 的，另一个是 6500 的。因为我这个颗牙参与咀嚼比较多，我选了一个质量更好的一点的。</p><p>现在唯一的感觉就是那个对牙咬合不齐，总感觉这个地方比较高。</p><p>于是又约了医生下周一还得再跑一趟.. 另外把别的蛀牙补一下。</p><p>感谢医保报销，感谢公司的医疗保险。。确确实实感受到了医疗方面的保障..</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;从小就是牙口不好，小时候家里对这方面也没有过多关注过，自己也不注重口腔健康，当时爽了，现在完蛋了。&lt;/p&gt;
&lt;p&gt;不仅钱花得多，还非常的折腾。&lt;/p&gt;
&lt;p&gt;我是清明节回家补了一颗龋齿（蛀牙），那天补牙的时候，突然有一下特别疼（就是那个感觉一瞬间就布遍全身，我感觉不咋疼），医生在那一顿叹气，哎呀，露神经了，这就不好弄了。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>数组-简单题</title>
    <link href="https://bqyang.top/2022/leetcode/array/easy/"/>
    <id>https://bqyang.top/2022/leetcode/array/easy/</id>
    <published>2022-05-30T13:49:02.926Z</published>
    <updated>2022-06-01T14:06:57.527Z</updated>
    
    <content type="html"><![CDATA[<p>虽然有些不是最优解，大体上还是挺让我惊讶的，竟然做出来了..</p><span id="more"></span><table><thead><tr><th align="left">最近提交时间</th><th align="left">题目</th><th align="left">题目难度</th><th align="left">提交次数</th></tr></thead><tbody><tr><td align="left">2022-5-30</td><td align="left"><a href="https://leetcode.cn/problems/plus-one/">#66 加一</a></td><td align="left">简单</td><td align="left">4 次</td></tr><tr><td align="left">2022-5-30</td><td align="left"><a href="https://leetcode.cn/problems/search-insert-position/">#35 搜索插入位置</a></td><td align="left">简单</td><td align="left">7 次</td></tr><tr><td align="left">2022-5-30</td><td align="left"><a href="https://leetcode.cn/problems/remove-element/">#27 移除元素</a></td><td align="left">简单</td><td align="left">5 次</td></tr><tr><td align="left">2022-5-30</td><td align="left"><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/">#26 删除有序数组中的重复项</a></td><td align="left">简单</td><td align="left">1 次</td></tr><tr><td align="left">2022-5-31</td><td align="left"><a href="https://leetcode.cn/problems/merge-sorted-array/">#88 合并两个有序数组</a></td><td align="left">简单</td><td align="left">3 次</td></tr><tr><td align="left">2022-6-01</td><td align="left"><a href="https://leetcode.cn/problems/valid-parentheses/solution/you-xiao-de-gua-hao-by-leetcode-solution/">#29 有效的括号</a></td><td align="left">简单</td><td align="left">1 次</td></tr><tr><td align="left">2022-6-01</td><td align="left"><a href="https://leetcode.cn/problems/palindrome-number/">#9 回文数</a></td><td align="left">简单</td><td align="left">5 次</td></tr></tbody></table><p>今天搞了四道关于数组的简单题，过程上都是大差不差，很难一次性把答案写的完美，都需要调整一下亦或是语法写错了…</p><p>印象比较深刻的是 27 和 66 花的时间稍微久一些，很多情况第一时间没有考虑到导致提交次数比较多。还有一个使用了 二分算法的，在判断取 start 还是 end 的时候比较纠结，但是后来还是巧妙地化解了。</p><p><a href="https://leetcode.cn/problems/plus-one/">#66 加一</a></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">plusOne</span><span class="params">(digits []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="comment">// 直接对最后一位进行加一操作</span></span><br><span class="line">    digits[<span class="built_in">len</span>(digits)<span class="number">-1</span>]++</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理进位的情况</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="built_in">len</span>(digits) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        <span class="comment">// 因为 0 对 任何数取余都是 0 所以要排除 0 的情况</span></span><br><span class="line">        <span class="comment">// 这也导致我多提交一次..尬</span></span><br><span class="line">        <span class="keyword">if</span> digits[i]!=<span class="number">0</span> &amp;&amp; digits[i]%<span class="number">10</span> == <span class="number">0</span> &#123;</span><br><span class="line">            digits[i] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> i &gt;= <span class="number">1</span> &#123;</span><br><span class="line">                digits[i<span class="number">-1</span>]++</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res := []<span class="keyword">int</span>&#123;<span class="number">1</span>&#125;</span><br><span class="line">                <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="built_in">len</span>(digits); j++ &#123;</span><br><span class="line">                    res = <span class="built_in">append</span>(res, <span class="number">0</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> res</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> digits</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/search-insert-position/">#35 搜索插入位置</a></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">searchInsert</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    start := <span class="number">0</span></span><br><span class="line">    end := <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 直接用两个 if 处理越界的情况</span></span><br><span class="line">    <span class="keyword">if</span> nums[end] &lt; target &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(nums)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> nums[start] &gt;= target &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> midIndex <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二分的方式进行处理</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        midIndex = (start + end) / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> nums[midIndex] &gt;= target &#123;</span><br><span class="line">            end = midIndex</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            start = midIndex</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> start == end<span class="number">-1</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> nums[start] &lt;= target &#123;</span><br><span class="line">                <span class="keyword">return</span> end</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> start</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/remove-element/">#27 移除元素</a></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 我写的 n^2 的时间复杂度</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeElement</span><span class="params">(nums []<span class="keyword">int</span>, val <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> index := <span class="number">0</span>; index &lt; <span class="built_in">len</span>(nums); index++ &#123;</span><br><span class="line">        <span class="keyword">if</span> nums[index] == val &#123;</span><br><span class="line">            <span class="keyword">for</span> i := index+<span class="number">1</span>; i &lt; <span class="built_in">len</span>(nums); i ++ &#123;</span><br><span class="line">                nums[i - <span class="number">1</span>] = nums[i]</span><br><span class="line">            &#125;</span><br><span class="line">            index--</span><br><span class="line">            nums = nums[:<span class="built_in">len</span>(nums)<span class="number">-1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(nums)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 人家这个 O(N) 的时间复杂度</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeElement</span><span class="params">(nums []<span class="keyword">int</span>, val <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    left := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> nums &#123; <span class="comment">// v 即 nums[right]</span></span><br><span class="line">        <span class="keyword">if</span> v != val &#123;</span><br><span class="line">            nums[left] = v</span><br><span class="line">            left++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/">#26 删除有序数组中的重复项</a></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeDuplicates</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> index, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="comment">// 找出最后一个重复数字的索引，然后保留一个， 其余的切掉</span></span><br><span class="line">        last := <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i := index+<span class="number">1</span>; i &lt; <span class="built_in">len</span>(nums) &amp;&amp; num == nums[i]; i++ &#123;</span><br><span class="line">            last = i</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> last != <span class="number">0</span> &#123;</span><br><span class="line">            nums = <span class="built_in">append</span>(nums[:index], nums[last:]...)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(nums)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>暴力解法没什么不好的，先写出来，再考虑优化的事情，一个好的算法必须要经历千百次的调试。（我总结的hh）</p><p><a href="https://leetcode.cn/problems/merge-sorted-array/">#88 合并两个有序数组</a>  </p><p>这道题我用了时间复杂度为 O(n) 的，题目中给定了两个数组，nums1 的大小就是合并之后的大小…这个让我有点懵逼。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(nums1 []<span class="keyword">int</span>, m <span class="keyword">int</span>, nums2 []<span class="keyword">int</span>, n <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> data []<span class="keyword">int</span></span><br><span class="line">    <span class="keyword">var</span> i, j <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> i &lt; m &amp;&amp; j &lt; n &#123;</span><br><span class="line">        <span class="keyword">if</span> nums1[i] &lt;= nums2[j] &#123;</span><br><span class="line">            data = <span class="built_in">append</span>(data, nums1[i])</span><br><span class="line">            i++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            data = <span class="built_in">append</span>(data, nums2[j])</span><br><span class="line">            j++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> i != m &#123;</span><br><span class="line">        data = <span class="built_in">append</span>(data, nums1[i:]...)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> j != n &#123;</span><br><span class="line">        data = <span class="built_in">append</span>(data, nums2[j:]...)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/palindrome-number/">#9 回文数</a>  </p><p>这个是最初版，表面上看起来没啥问题，也能通过一部分测试用例，但是，这里判断数字位数有一个 bug，比如 101 这种数字，算出来的位数是 1。不符合预期。。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isPalindrome</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="comment">// 如题目描述的，负数不属于回文数，直接处理即可</span></span><br><span class="line">    <span class="keyword">if</span> x &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算这个数字的位数</span></span><br><span class="line">    <span class="keyword">var</span> count <span class="keyword">int</span></span><br><span class="line">    temp := x</span><br><span class="line">    <span class="keyword">for</span> temp % <span class="number">10</span> != <span class="number">0</span> &#123;</span><br><span class="line">        count++</span><br><span class="line">        temp /= <span class="number">100</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 倒序 然后进行比较</span></span><br><span class="line">    <span class="keyword">var</span> result <span class="keyword">int</span></span><br><span class="line">    temp1 := x</span><br><span class="line">    <span class="keyword">for</span> temp1 &gt; <span class="number">0</span> &#123;</span><br><span class="line">        data := temp1 % <span class="number">10</span></span><br><span class="line">        result += data * <span class="keyword">int</span>(math.Pow(<span class="keyword">float64</span>(<span class="number">10</span>), <span class="keyword">float64</span>(count<span class="number">-1</span>)))</span><br><span class="line">        temp1 /= <span class="number">10</span></span><br><span class="line">        count--</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> result == x &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了解决上述计算位数的问题，我将这个数字转换成字符串，但是后续的算法没有改变，这里试试使用字符串进行判断的方式，尝试一下，（先写 blog 再尝试）。即，将算位数的地方修改成如下的形式：</p><p><code>  dig := utf8.RuneCountInString(strconv.Itoa(x))</code></p><p>下边这个是直接转换成字符串的方式进行处理：</p><blockquote><p>竟然一次通过了，unbelievable..</p></blockquote><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isPalindrome</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    data := strconv.Itoa(x)</span><br><span class="line">    count := utf8.RuneCountInString(data)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> first, last := <span class="number">0</span>, count<span class="number">-1</span>; first &lt;= count<span class="number">-1</span> &amp;&amp; last &gt;= <span class="number">0</span>; &#123;</span><br><span class="line">        <span class="keyword">if</span> data[first] != data[last] &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// go 中不支持 这种写法 for ; ; xx++, xx++</span></span><br><span class="line">        first++</span><br><span class="line">        last--</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <a href="https://leetcode.cn/problems/valid-parentheses/solution/you-xiao-de-gua-hao-by-leetcode-solution/">#29 有效的括号</a> </p><p>有效的括号，这里没搞懂啥意思啊，<code>([)]</code> 这样是不行的吗？一开始没读懂题的意思，理解成了这个字符串中的括号是否成对，如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isValid</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> one []<span class="keyword">int32</span></span><br><span class="line">    <span class="keyword">var</span> two []<span class="keyword">int32</span></span><br><span class="line">    <span class="keyword">var</span> three []<span class="keyword">int32</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, val := <span class="keyword">range</span> s &#123;</span><br><span class="line">        <span class="keyword">switch</span> val &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;&#123;&#x27;</span>:</span><br><span class="line">            one = <span class="built_in">append</span>(one, val)</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;&#125;&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(one) != <span class="number">0</span> &#123;</span><br><span class="line">                one = one[:<span class="built_in">len</span>(one)<span class="number">-1</span>]</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;[&#x27;</span>:</span><br><span class="line">            two = <span class="built_in">append</span>(two, val)</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;]&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(two) != <span class="number">0</span> &#123;</span><br><span class="line">                two = two[:<span class="built_in">len</span>(two)<span class="number">-1</span>]</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">            three = <span class="built_in">append</span>(three, val)</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(three) != <span class="number">0</span> &#123;</span><br><span class="line">                three = three[:<span class="built_in">len</span>(three)<span class="number">-1</span>]</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(one) == <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(two) == <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(three) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>采用了三个栈的方式求解，相当的暴力hh，后来看了别人的解答才明白这个到底是什么意思，如 <code>([)]</code> 这种形式，就是说第一个右括号匹配最后一个左括号，这时候是 <code>[)</code> 应该给人家返回 false，如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isValid1</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> one []<span class="keyword">int32</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, val := <span class="keyword">range</span> s &#123;</span><br><span class="line">        <span class="keyword">switch</span> val &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;&#123;&#x27;</span>, <span class="string">&#x27;[&#x27;</span>, <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">            one = <span class="built_in">append</span>(one, val)</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;&#125;&#x27;</span>, <span class="string">&#x27;]&#x27;</span>, <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(one) != <span class="number">0</span> &#123;</span><br><span class="line">                data := one[<span class="built_in">len</span>(one)<span class="number">-1</span>]</span><br><span class="line">                <span class="keyword">if</span> data+<span class="number">2</span> == val || data+<span class="number">1</span> == val &#123;</span><br><span class="line">                    one = one[:<span class="built_in">len</span>(one)<span class="number">-1</span>]</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(one) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>果然啊，人家要的就是这种方式，其实这里考察的是<strong>栈</strong>..</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;虽然有些不是最优解，大体上还是挺让我惊讶的，竟然做出来了..&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>再学递归（几个有意思的递归练习）</title>
    <link href="https://bqyang.top/2022/language/c/recur/"/>
    <id>https://bqyang.top/2022/language/c/recur/</id>
    <published>2022-05-24T14:08:21.157Z</published>
    <updated>2022-06-01T13:27:06.623Z</updated>
    
    <content type="html"><![CDATA[<p>逃不过的汉诺塔…</p><span id="more"></span><p>由间到难：</p><ul><li>给定一个整数，如 1234，使用递归的方式打印出，4321。</li><li>给定一个整数，如 9，使用递归的方式打印出该数的二进制形式，输入 9，输出 1001。</li></ul><p>这两个数以同一种类型，做出来一个另一个也迎刃而解，如果没什么思路的话，也不建议直接去查答案，肯定可以，我这么笨的都能琢磨出来，多花点时间。</p><p>（提示请见评论）</p><ul><li><p>给定一个整数，求这个数的阶乘。</p></li><li><p>汉诺塔..只要是认认真真学过一门语言肯定会接触到这个例子，具体描述请见百科。</p></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hanoi</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">char</span>, <span class="keyword">char</span>, <span class="keyword">char</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    hanoi(<span class="number">3</span>, <span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;z&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hanoi</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">char</span> from, <span class="keyword">char</span> mid, <span class="keyword">char</span> to)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// from x to z through y</span></span><br><span class="line">        hanoi(n<span class="number">-1</span>, from, to, mid);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;take %d from %c to %c\n&quot;</span>, n, from, to);</span><br><span class="line">        <span class="comment">// from z to x through y</span></span><br><span class="line">        hanoi(n<span class="number">-1</span>, mid, from, to);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;逃不过的汉诺塔…&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>打印字符</title>
    <link href="https://bqyang.top/2022/language/c/print/"/>
    <id>https://bqyang.top/2022/language/c/print/</id>
    <published>2022-05-17T06:31:17.737Z</published>
    <updated>2022-05-17T10:01:15.161Z</updated>
    
    <content type="html"><![CDATA[<p>for循环打印字符</p><span id="more"></span><p>还是有点意思的，使用嵌套for循环输出如下格式：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A</span><br><span class="line">BC</span><br><span class="line">DEF</span><br><span class="line">GHIJK</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>另一个输出这样：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  A  </span><br><span class="line"> ABA </span><br><span class="line">ABCBA</span><br></pre></td></tr></table></figure><p>华</p><hr><p>​                    丽</p><hr><p>​                                    的</p><hr><p>​                                                    分</p><hr><p>​                                                                    割</p><hr><p>​                                                                                    线</p><hr><p>答案如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, s = <span class="string">&#x27;A&#x27;</span>; i &lt; <span class="number">6</span>; i++, s+=i) &#123;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = s, k = <span class="number">0</span>; k &lt;= i; k++, j++ ) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Please input start letter for print\n&quot;</span>);   </span><br><span class="line">    <span class="keyword">char</span> alpha;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;alpha);</span><br><span class="line">    <span class="keyword">char</span> A = <span class="number">65</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> t = A; t &lt;= alpha; t++) &#123;   </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> j = alpha; j &gt; t; j--) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> i = A; i &lt; t; i++) &#123;     </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> k = t; k &gt;= A; k--) &#123;   </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, k);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;for循环打印字符&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>C-String</title>
    <link href="https://bqyang.top/2022/language/c/string/"/>
    <id>https://bqyang.top/2022/language/c/string/</id>
    <published>2022-05-11T10:47:31.133Z</published>
    <updated>2022-05-11T11:17:50.298Z</updated>
    
    <content type="html"><![CDATA[<p>复习 C 语言字符串</p><span id="more"></span><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p><strong>字符串 （character string）</strong> 是一个或多个字符的序列。</p><p>实际上，字符串就是一个字符数组，**但是在字符末尾插入了 \0 **用来表示字符串的结束。</p><p>所以，数组的容量一定是要比待存储的字符串字节数多 1，用来存储 \0，举个例子，我们想存储名字 <code>abc </code> 就必须使用 <code>char name[4]</code> 来存储。</p><blockquote><p>末尾的 \0 计算机会自动帮我们加上</p></blockquote><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>接收控制台输入，parisel.c</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRAISE <span class="meta-string">&quot;good jobbbb&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">40</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Input you name &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, name);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s, %s\n&quot;</span>, name, PRAISE);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题：</p><ul><li>为什么 scanf 接收参数的时候不需要传递指针？</li></ul><h1 id="字符串和字符"><a href="#字符串和字符" class="headerlink" title="字符串和字符"></a>字符串和字符</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字符串 &quot;x&quot;</span></span><br><span class="line"><span class="comment">// 字符   &#x27;x&#x27;</span></span><br></pre></td></tr></table></figure><p>这两个虽然看起来相似，但是底层的存储结构是不一样的，字符使用 char 类型来存储，字符串使用的是数组，而且还需要一个 <code>\0</code>，由两个字符组成。</p><h1 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h1><p>为什么使用符号常量更好？</p><ul><li><em>常量名称可以表达更多的意思</em></li><li><em>方便后续修改</em></li></ul><h2 id="定义常量"><a href="#定义常量" class="headerlink" title="定义常量"></a>定义常量</h2><p><code>#define PI 3.14</code> 更通用的表示为 <code>#define NAME value</code>, C 中一般采用大写名称来表示常量。</p><p>代码中使用这样的常量，会在编译时替换掉（预处理阶段替换），即<em>编译时替换</em>（compile-time substitution）。</p><h2 id="const-限定符号"><a href="#const-限定符号" class="headerlink" title="const 限定符号"></a>const 限定符号</h2><p>Go 中使用的方式 <code>const name = &quot;xx&quot;</code></p><p>C 中要这样用 <code>const int Months = 12;</code></p><blockquote><p>C 中 const 声明的是变量，不是常量。</p></blockquote><h2 id="看几个标准库中的常量"><a href="#看几个标准库中的常量" class="headerlink" title="看几个标准库中的常量"></a>看几个标准库中的常量</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;复习 C 语言字符串&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Rust-Enums</title>
    <link href="https://bqyang.top/2022/language/rust/enum/"/>
    <id>https://bqyang.top/2022/language/rust/enum/</id>
    <published>2022-05-10T07:53:07.016Z</published>
    <updated>2022-05-11T06:29:35.881Z</updated>
    
    <content type="html"><![CDATA[<p>Rust 枚举</p><span id="more"></span><p><strong>定义、声明</strong></p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">enmu IpAddrKind &#123;</span><br><span class="line">    V4,</span><br><span class="line">    V6,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义了一个枚举数据类型，IpAddrKind，枚举中有两个变量，V4，V6。但是这样存在一个问题，实际的 IP 地址应该存储在哪里，这只是定义了两种 Ip 类型。</p><p>如何使用 enum 存储值？</p><p>方法一，使用 struct：</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IpAddr</span></span> &#123;</span><br><span class="line">    kind: IpAddrKind,</span><br><span class="line">    address: <span class="built_in">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> home = IpAddr &#123;</span><br><span class="line">    kind: IpAddrKind::V4,</span><br><span class="line">    address: <span class="built_in">String</span>::from(<span class="string">&quot;127.0.0.1&quot;</span>),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> loopback = IpAddr &#123;</span><br><span class="line">    kind: IpAddrKind::V6,</span><br><span class="line">    address: <span class="built_in">String</span>::from(<span class="string">&quot;::1&quot;</span>),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>方法二，使用 enum 存储：</p><p>直接使用 enum 存储值，这个有点意思..</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">IpAddr</span></span> &#123;</span><br><span class="line">    V4(<span class="built_in">String</span>),</span><br><span class="line">    V6(<span class="built_in">String</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> home = IpAddr::V4(<span class="built_in">String</span>::from(<span class="string">&quot;127.0.0.1&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> loopback = IpAddr::V6(<span class="built_in">String</span>::from(<span class="string">&quot;::1&quot;</span>));</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>标准库中如何定义 IpAddr 的：</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Ipv4Addr</span></span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Ipv6Addr</span></span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">IpAddr</span></span> &#123;</span><br><span class="line">    V4(Ipv4Addr),</span><br><span class="line">    V6(Ipv6Addr),</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>**可以给 enum 添加 method..**这里其实 Go 也可以实现：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类似这样的代码</span></span><br><span class="line"><span class="keyword">type</span> Strings []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Strings)</span> <span class="title">Less</span><span class="params">()</span> <span class="title">bool</span></span> &#123;<span class="keyword">return</span> <span class="literal">true</span>&#125;</span><br></pre></td></tr></table></figure><p><strong>The <code>Option</code> Enum</strong></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Rust 枚举&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Rust-Structs</title>
    <link href="https://bqyang.top/2022/language/rust/structs/"/>
    <id>https://bqyang.top/2022/language/rust/structs/</id>
    <published>2022-05-10T07:26:34.826Z</published>
    <updated>2022-05-11T02:55:01.151Z</updated>
    
    <content type="html"><![CDATA[<p>rust 中的结构体和方法（method）。</p><span id="more"></span><h1 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h1><p>其实各种语言对 Struct 的实例化都差不多，主要就是关注下 Rust 里关于 struct 的语法。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// struct from C</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">foo</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// struct from Rust</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bar</span></span> &#123;</span><br><span class="line">    active: <span class="built_in">bool</span>,</span><br><span class="line">    username: <span class="built_in">String</span>,</span><br><span class="line">    email: <span class="built_in">String</span>,</span><br><span class="line">    sign_in_count: <span class="built_in">u64</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// struct from Go</span></span><br><span class="line"><span class="keyword">type</span> foobar <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    age <span class="keyword">int</span></span><br><span class="line">    email <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>都差不多..</p><h2 id="打印结构体"><a href="#打印结构体" class="headerlink" title="打印结构体"></a>打印结构体</h2><p>没想到 rust 里边打印一个结构体这么麻烦，如果说打印某个字段直接用 <code>println!(&quot;&#123;&#125;&quot;, xx.xx);</code> 就行，但是要是打印整个结构体中的内容，还得给结构体定义前加上 <code>#[derive(Debug)] </code>..这样才能打印出调试信息。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">User</span></span> &#123;</span><br><span class="line">    name: <span class="built_in">String</span>,</span><br><span class="line">    age: <span class="built_in">u32</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输出完整结构体算是调试功能，但是我们需要手动添加相关内容让某个结构体使用这个功能。</p></blockquote><p>添加完以后才能输出完整的结构体：</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pretty print</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:#?&#125;&quot;</span>, xx);</span><br></pre></td></tr></table></figure><h2 id="dbg"><a href="#dbg" class="headerlink" title="dbg!"></a>dbg!</h2><p>可以用来输出调试信息，<code>dbg!(xx);</code></p><h1 id="method"><a href="#method" class="headerlink" title="method"></a>method</h1><p>method 的第一个参数永远是 self。    </p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">User</span></span> &#123;</span><br><span class="line">    name: <span class="built_in">String</span>,</span><br><span class="line">    age: <span class="built_in">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> User &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">print_name</span></span>(&amp;<span class="keyword">self</span>) -&gt; &amp;<span class="built_in">String</span> &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;rust 中的结构体和方法（method）。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Rust-Ownership</title>
    <link href="https://bqyang.top/2022/language/rust/ownership/"/>
    <id>https://bqyang.top/2022/language/rust/ownership/</id>
    <published>2022-05-09T11:47:42.459Z</published>
    <updated>2022-05-10T07:46:48.236Z</updated>
    
    <content type="html"><![CDATA[<p>Rust 核心概念了解 —— Ownership</p><span id="more"></span><p>Ownership 就是定义了一些规则，比如在函数中传递参数的时候是怎么处理参数的，官网的解释为<strong>Rust程序如何管理内存的一系列规则</strong>。</p><p><strong>内存管理的三种方式</strong></p><ul><li>Go 语言这类，自动垃圾回收机制</li><li>C 语言，手动垃圾回收，显示分配、释放</li><li>Rust 独一档，结合<strong>编译器、ownership 定义的规则</strong>，如果说没有按照 Rust Ownership 定义的规则，那么编译就不会通过。</li></ul><p>第一次知道，还能有这样的内存管理方式..</p><h1 id="ownership-by-example"><a href="#ownership-by-example" class="headerlink" title="ownership by example"></a>ownership by example</h1><p>（通过例子学习 ownership）</p><blockquote><p>The Stack and the Heap</p></blockquote><p><code>All data stored on the stack must have a known, fixed size. Data with an unknown size at compile time or a size that might change must be stored on the heap instead.</code></p><p><code>Accessing data in the heap is slower than accessing data on the stack because you have to follow a pointer to get there. </code></p><h2 id="ownership-Rules"><a href="#ownership-Rules" class="headerlink" title="ownership Rules"></a>ownership Rules</h2><ul><li>Rust 中每一个值都有一个被叫做 <code>owner</code> 的变量，比如 a = 1, 1 的 owner 就是 a。</li><li>同一时刻有且仅有一个 owner。</li><li>当 owner 超出范围时（超出作用域），value 会被丢弃。</li></ul><h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h2><p>作用域大家了解的已经很多了，要是直接看 C 代码其实还是有点懵逼的。。不信你试试。。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>很显然，答案不是 2 ，2； 正确答案为：2， 1；</p></blockquote><p>Rust 中其实也类似，如下：</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> s = <span class="string">&quot;hello&quot;</span>;<span class="comment">// 这时候变量开始有效</span></span><br><span class="line">    &#125;     <span class="comment">// 从这时起，就无效</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个重要的点：</p><ul><li>变量 s 在作用域内，有效</li><li>变量 s 超出作用域，无效</li></ul><h2 id="内存和分配"><a href="#内存和分配" class="headerlink" title="内存和分配"></a>内存和分配</h2><p>Rust 中内存释放的方式，<strong>超出了作用域自动释放</strong>。Rust 也算是帮我们做了内存管理，虽然没有 GC，但是也不用我们手动进行 free，避免出现 double free 问题，如上述分配的 s 变量，超出了作用域就被释放掉。</p><h2 id="ownership-Move"><a href="#ownership-Move" class="headerlink" title="ownership Move"></a>ownership Move</h2><p>Stack </p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> y = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Heap</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> s2 = s1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两段代码表达的意思相近，但是，在不同的内存空间上有着很大的差别。</p><ul><li><p>stack 不赘述</p></li><li><p>heap</p><p><img src="https://doc.rust-lang.org/book/img/trpl04-02.svg" alt="s1 and s2 pointing to the same value"></p></li></ul><p>执行完赋值操作后，有两个指向同一块内存的指针，但是这也会存在一种情况，当 s1 和 s2 都用不到时候，会进行 free，就会出现 double free 的情况。</p><p>所以，为了保证内存安全，在 <code>let s2 = s1;</code> 执行完成后，Rust <strong>认为 s1 不再有效</strong>。即，将 s1 ownership move to s2.</p><h2 id="ownership-Clone"><a href="#ownership-Clone" class="headerlink" title="ownership Clone"></a>ownership Clone</h2><p>(deeply copy)</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> s2 = s1.<span class="built_in">Copy</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;s1 is &#123;&#125;, s2 is &#123;&#125;&quot;</span>, s1, s2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://doc.rust-lang.org/book/img/trpl04-03.svg" alt="s1 and s2 to two places"></p><h2 id="Stack-Only-Data-Copy"><a href="#Stack-Only-Data-Copy" class="headerlink" title="Stack-Only Data: Copy"></a>Stack-Only Data: Copy</h2><p><code>The reason is that types such as integers that have a known size at compile time are stored entirely on the stack, so copies of the actual values are quick to make. That means there’s no reason we would want to prevent </code>x<code>from being valid after we create the variable</code>y<code>. </code></p><p>总而言之，栈上的数据会进行 Copy，堆上的数据会进行 move。</p><h2 id="函数之间-ownership-的改变"><a href="#函数之间-ownership-的改变" class="headerlink" title="函数之间 ownership 的改变"></a>函数之间 ownership 的改变</h2><p>将变量传递给函数的时候也可能会发生 move 或 copy，和分配差不多。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> s = <span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>);  <span class="comment">// s comes into scope</span></span><br><span class="line"></span><br><span class="line">    takes_ownership(s);             <span class="comment">// s&#x27;s value moves into the function...</span></span><br><span class="line">    <span class="comment">// ... and so is no longer valid here</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">5</span>;                      <span class="comment">// x comes into scope</span></span><br><span class="line"></span><br><span class="line">    makes_copy(x);                  <span class="comment">// x would move into the function,</span></span><br><span class="line">    <span class="comment">// but i32 is Copy, so it&#x27;s okay to still</span></span><br><span class="line">    <span class="comment">// use x afterward</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// Here, x goes out of scope, then s. But because s&#x27;s value was moved, nothing</span></span><br><span class="line"><span class="comment">// special happens.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">takes_ownership</span></span>(some_string: <span class="built_in">String</span>) &#123; <span class="comment">// some_string comes into scope</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, some_string);</span><br><span class="line">&#125; <span class="comment">// Here, some_string goes out of scope and `drop` is called. The backing</span></span><br><span class="line"><span class="comment">// memory is freed.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">makes_copy</span></span>(some_integer: <span class="built_in">i32</span>) &#123; <span class="comment">// some_integer comes into scope</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, some_integer);</span><br><span class="line">&#125; <span class="comment">// Here, some_integer goes out of scope. Nothing special happens.</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="函数返回时与-ownership"><a href="#函数返回时与-ownership" class="headerlink" title="函数返回时与 ownership"></a>函数返回时与 ownership</h2><p>返回值也会转移 ownership。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> s1 = gives_ownership();         <span class="comment">// gives_ownership moves its return</span></span><br><span class="line">    <span class="comment">// value into s1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> s2 = <span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>);     <span class="comment">// s2 comes into scope</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> s3 = takes_and_gives_back(s2);  <span class="comment">// s2 is moved into</span></span><br><span class="line">    <span class="comment">// takes_and_gives_back, which also</span></span><br><span class="line">    <span class="comment">// moves its return value into s3</span></span><br><span class="line">&#125; <span class="comment">// Here, s3 goes out of scope and is dropped. s2 was moved, so nothing</span></span><br><span class="line"><span class="comment">// happens. s1 goes out of scope and is dropped.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">gives_ownership</span></span>() -&gt; <span class="built_in">String</span> &#123;             <span class="comment">// gives_ownership will move its</span></span><br><span class="line">    <span class="comment">// return value into the function</span></span><br><span class="line">    <span class="comment">// that calls it</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> some_string = <span class="built_in">String</span>::from(<span class="string">&quot;yours&quot;</span>); <span class="comment">// some_string comes into scope</span></span><br><span class="line"></span><br><span class="line">    some_string                              <span class="comment">// some_string is returned and</span></span><br><span class="line">    <span class="comment">// moves out to the calling</span></span><br><span class="line">    <span class="comment">// function</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This function takes a String and returns one</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">takes_and_gives_back</span></span>(a_string: <span class="built_in">String</span>) -&gt; <span class="built_in">String</span> &#123; <span class="comment">// a_string comes into</span></span><br><span class="line">    <span class="comment">// scope</span></span><br><span class="line"></span><br><span class="line">    a_string  <span class="comment">// a_string is returned and moves out to the calling function</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>综上所述，每次进行函数传参的时候都会发生 ownership 的转移，如果说我们给 funcA 传一个 A 参数后，仍然要使用 A 参数，应该怎么办呢？</p><ul><li> 可以把这个参数从 funcA 中返回</li></ul><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> (s2, len) = calculate_length(s1);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The length of string &#123;&#125; is &#123;&#125;&quot;</span>, s2, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">calculate_length</span></span>(s: string) -&gt; (<span class="built_in">String</span>, <span class="built_in">usize</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> length = s.len();</span><br><span class="line">    (s, length)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>牛x的 Rust 当然还提供了另一种方式，<strong>reference</strong>。</li></ul><h2 id="Reference-and-Borrowing"><a href="#Reference-and-Borrowing" class="headerlink" title="Reference and Borrowing"></a>Reference and Borrowing</h2><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>本以为这个 reference 和 pointer 是一个东西，但是 rust 中貌似并不是这么定义的，且看且分析。</p><p><code> A reference is like a pointer in that it’s an address we can follow to access data stored at that address that is owned by some other variable.</code></p><p>reference 和 pointer 相同的点，存储的都是地址，可以通过这个地址访问存储在这个地址上的数据，这个数据可能是属于别的变量的。 <strong>不同的点</strong>，reference 指向的永远是<strong>有效</strong>的地址。</p><p><img src="https://doc.rust-lang.org/book/img/trpl04-05.svg" alt="&amp;String s pointing at String s1"></p><p>因此，上述代码就可以就改为，</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> len = calculate_length(&amp;s1);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The length of &#x27;&#123;&#125;&#x27; is &#123;&#125;.&quot;</span>, s1, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">calculate_length</span></span>(s: &amp;<span class="built_in">String</span>) -&gt; <span class="built_in">usize</span> &#123; <span class="comment">// s is a reference to a String</span></span><br><span class="line">    s.len()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面这段引用，再一次解释了，传递引用给函数时发生了什么，不再赘述。</p><blockquote><p><code>When functions have references as parameters instead of the actual values, we won’t need to return the values in order to give back ownership, because we never had ownership.</code></p></blockquote><h3 id="Borrowing"><a href="#Borrowing" class="headerlink" title="Borrowing"></a>Borrowing</h3><p>（把创建 reference 的行为定义成 borrowing）。在实际生活中，就跟借东西是一个意思，假设一个人拥有一辆保时捷，你借过来开两天，然后还回去，我们从未拥有过保时捷。</p><p>然后问题就来了，比如我们接过来保时捷开两天，发现他的颜色看着不顺眼，你想给他改装，这时候怎么办？如下。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    change(&amp;s1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">change</span></span>(some_str: &amp;<span class="built_in">String</span>) &#123;     </span><br><span class="line">    some_str.push_str(<span class="string">&quot;RTFM&quot;</span>);     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">error[E0596]: cannot borrow `*some_str` as mutable, as it is behind a `&amp;` reference</span><br><span class="line"> --&gt; src/main.rs:8:5</span><br><span class="line">  |</span><br><span class="line">7 | fn change(some_str: &amp;String) &#123;</span><br><span class="line">  |                     ------- help: consider changing this to be a mutable reference: `&amp;mut String`</span><br><span class="line">8 |     some_str.push_str(&quot;RTFM&quot;);</span><br><span class="line">  |     ^^^^^^^^^^^^^^^^^^^^^^^^^ `some_str` is a `&amp;` reference, so the data it refers to cannot be borrowed as mutable</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0596`.</span><br><span class="line">error: could not compile `borrowing` due to previous error</span><br></pre></td></tr></table></figure><p>验证了一个结论，默认情况加，<strong>borrow</strong>过来的东西是不可修改的，除非加上<strong>mut</strong>(mutable)，如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let mut s1 = String::from(&quot;hello&quot;);</span><br><span class="line"></span><br><span class="line">    change(&amp;mut s1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn change(some_str: &amp;mut String) &#123;     </span><br><span class="line">    some_str.push_str(&quot;RTFM&quot;);     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可肆无忌惮的修改 reference 指向的内容了，形如这样的被称为 <code>mutable reference</code>。</p><p>Mutable referenct 一个最大限制：<strong>在同一时刻只能拥有某个变量的一个 mut reference</strong>。可以试试下面这段代码：</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> s1 = <span class="built_in">String</span>::from(<span class="string">&quot;RTFM&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> r1 = &amp;<span class="keyword">mut</span> s1;</span><br><span class="line">    <span class="keyword">let</span> r2 = &amp;<span class="keyword">mut</span> s2;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; &#123;&#125;&quot;</span>, r1, r2);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">error[E0499]: cannot borrow `s1` as mutable more than once at a time</span><br><span class="line"> --&gt; src/main.rs:5:14</span><br><span class="line">  |</span><br><span class="line">4 |     let s2 = &amp;mut s1;</span><br><span class="line">  |              ------- first mutable borrow occurs here</span><br><span class="line">5 |     let s3 = &amp;mut s1;</span><br><span class="line">  |              ^^^^^^^ second mutable borrow occurs here</span><br><span class="line">6 | </span><br><span class="line">7 |     println!(&quot;&#123;&#125; &#123;&#125;&quot;, s2, s3);</span><br><span class="line">  |                       -- first borrow later used here</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0499`.</span><br><span class="line">error: could not compile `borrowing` due to previous error</span><br></pre></td></tr></table></figure><p><strong>mutable reference and immutable reference</strong></p><p><strong>不能同时拥有可变的和不可变的 reference</strong>，意味着，要么只有一个 mutable，要么有多个 immutable，不能有一个 mutable 和多个 immutable 的情况。</p><h2 id="Reference-scope"><a href="#Reference-scope" class="headerlink" title="Reference scope"></a>Reference scope</h2><p>reference 的生效范围，**Note that a reference’s scope starts from where it is introduced and continues through the last time that reference is used. **</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> r1 = &amp;s; <span class="comment">// no problem</span></span><br><span class="line">    <span class="keyword">let</span> r2 = &amp;s; <span class="comment">// no problem</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; and &#123;&#125;&quot;</span>, r1, r2);</span><br><span class="line">    <span class="comment">// variables r1 and r2 will not be used after this point</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> r3 = &amp;<span class="keyword">mut</span> s; <span class="comment">// no problem</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, r3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Dangling-References"><a href="#Dangling-References" class="headerlink" title="Dangling References"></a>Dangling References</h2><p>悬垂引用，有点类似 dangling pointer， rust 中，编译器会检查 reference 指向的内容是否有效，不会发生这种情况。。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> reference_to_nothing = dangle();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">dangle</span></span>() -&gt; &amp;<span class="built_in">String</span> &#123; <span class="comment">// dangle returns a reference to a String</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> s = <span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>); <span class="comment">// s is a new String</span></span><br><span class="line"></span><br><span class="line">    &amp;s <span class="comment">// we return a reference to the String, s</span></span><br><span class="line">&#125; <span class="comment">// Here, s goes out of scope, and is dropped. Its memory goes away.</span></span><br><span class="line"><span class="comment">// Danger!</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling ownership v0.1.0 (file:///projects/ownership)</span><br><span class="line">error[E0106]: missing lifetime specifier</span><br><span class="line"> --&gt; src/main.rs:5:16</span><br><span class="line">  |</span><br><span class="line">5 | fn dangle() -&gt; &amp;String &#123;</span><br><span class="line">  |                ^ expected named lifetime parameter</span><br><span class="line">  |</span><br><span class="line">  = help: this function&#x27;s return type contains a borrowed value, but there is no value for it to be borrowed from</span><br><span class="line">help: consider using the `&#x27;static` lifetime</span><br><span class="line">  |</span><br><span class="line">5 | fn dangle() -&gt; &amp;&#x27;static String &#123;</span><br><span class="line">  |                ~~~~~~~~</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0106`.</span><br><span class="line">error: could not compile `ownership` due to previous error</span><br></pre></td></tr></table></figure><h2 id="Rules-of-Reference"><a href="#Rules-of-Reference" class="headerlink" title="Rules of Reference"></a>Rules of Reference</h2><ul><li>任何时刻，要么只能有一个 mutable reference，要么有多个 immutable reference。</li><li>Reference 指向的内容一定是有效的。</li></ul><h2 id="Slices"><a href="#Slices" class="headerlink" title="Slices"></a>Slices</h2><p>这个跟 Go 的切片引用类似..，直接贴张图，不再赘述。</p><p><img src="https://doc.rust-lang.org/book/img/trpl04-06.svg" alt="world containing a pointer to the byte at index 6 of String s and a length 5"></p><h2 id="完结撒花"><a href="#完结撒花" class="headerlink" title="完结撒花"></a>完结撒花</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;Rust 核心概念了解 —— Ownership&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Deployment 更新策略</title>
    <link href="https://bqyang.top/2022/k8s/deployment/"/>
    <id>https://bqyang.top/2022/k8s/deployment/</id>
    <published>2022-05-09T07:28:40.904Z</published>
    <updated>2022-05-09T11:47:48.305Z</updated>
    
    <content type="html"><![CDATA[<p>将笔记进行拆分，都写在一个里边很拥挤，不方便翻阅查看。</p><span id="more"></span><h1 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h1><h2 id="更新策略"><a href="#更新策略" class="headerlink" title="更新策略"></a>更新策略</h2><table><thead><tr><th>更新策略</th><th>描述</th></tr></thead><tbody><tr><td>Recreate</td><td>见名知意，更新的时候就是把已存在的 Pod 删除，创建一个新的</td></tr><tr><td>RollingUpdate</td><td>滚动更新，先准备新的 Pod，就绪后再删除老的 Pod，在更新期间也可以正常提供服务。<strong>默认配置</strong>。</td></tr></tbody></table><p><img src="https://s2.loli.net/2022/05/09/uwBeEpl6Gq41WkC.png" alt="img"></p><h2 id="Recreate-如何影响应用"><a href="#Recreate-如何影响应用" class="headerlink" title="Recreate 如何影响应用"></a>Recreate 如何影响应用</h2><p>在重启期间，无法正常访问服务，正如上图中会有一段空档期。</p><h2 id="Deployment-和-Replicas-的关系"><a href="#Deployment-和-Replicas-的关系" class="headerlink" title="Deployment 和 Replicas 的关系"></a>Deployment 和 Replicas 的关系</h2><p><img src="https://s2.loli.net/2022/05/09/cmYjDQrSAguyaN3.png" alt="img"></p><p>正如我们看到的，<code>Deployment</code> 和 <code>Replica</code> 并不是总是一对一的关系，在更新操作执行后，会出现上图中的情况。</p><h2 id="RollingUpdate"><a href="#RollingUpdate" class="headerlink" title="RollingUpdate"></a>RollingUpdate</h2><p><img src="https://s2.loli.net/2022/05/09/GzleTsRbmFaNLwI.png" alt="img"></p><h3 id="Deployment-配置"><a href="#Deployment-配置" class="headerlink" title="Deployment 配置"></a>Deployment 配置</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kiada</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">strategy:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">RollingUpdate</span></span><br><span class="line">    <span class="attr">rollingUpdate:</span></span><br><span class="line">      <span class="attr">maxSurge:</span> <span class="number">0</span></span><br><span class="line">      <span class="attr">maxUnavailable:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">minReadySeconds:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="string">...</span></span><br></pre></td></tr></table></figure><h3 id="配置一次替换多少个-Pod"><a href="#配置一次替换多少个-Pod" class="headerlink" title="配置一次替换多少个 Pod"></a>配置一次替换多少个 Pod</h3><p>通过 <code>maxSurge</code> 和 <code>maxUnavailable</code> 配置</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>maxSurge</td><td>The maximum number of Pods above the desired number of replicas that the Deployment can have during the rolling update. The value can be an absolute number or a percentage of the desired number of replicas.<br /><br />在滚动更新期间 Deployment 可以超过 replica 中最大的 Pod 数量。</td></tr><tr><td>maxUnavaliable</td><td>The maximum number of Pods relative to the desired replica count that can be unavailable during the rolling update. The value can be an absolute number or a percentage of the desired number of replicas.<br /><br />最少可用的 Pod 数量为 total - maxUnavailable，最多不可用的 Pod 数量为 maxUnavailable</td></tr></tbody></table><p> <code>maxSurge</code> 和 <code>maxUnavailable</code> 会影响 Replica 中期望的 Pod 数量。</p><p><strong>maxSurge = 0, maxUnavailable = 1</strong></p><p><img src="https://s2.loli.net/2022/05/09/toFLwvXl5HuqObE.png" alt="img"></p><p><strong>maxSurge = 1, maxUnavailable = 0</strong></p><p><img src="https://s2.loli.net/2022/05/09/cE5UJVdDAa8mkrg.png" alt="img"></p><p><strong>maxSurge = 1, maxUnavailable = 1</strong></p><p><img src="https://s2.loli.net/2022/05/09/mnLPUaQyldEHxj3.png" alt="img"></p><h3 id="暂停、恢复-RollingUpdate"><a href="#暂停、恢复-RollingUpdate" class="headerlink" title="暂停、恢复 RollingUpdate"></a>暂停、恢复 RollingUpdate</h3><p><code>kubectl rollout pause deployment kiada</code> 和 <code>kubectl rollout resume deployment kiada</code></p><p>这个骚操作还是第一次听说..</p><h3 id="minReadySeconds"><a href="#minReadySeconds" class="headerlink" title="minReadySeconds"></a>minReadySeconds</h3><p>在 RollingUpdate 过程中，新创建的 Pod Ready 后，<strong>还不算结束</strong>，要等待 <code>minReadySeconds</code> 这么久后， Pod 才会变为 available 状态。</p><p>默认情况下是 0，Pod Ready 了就算 available.</p><h3 id="检查-rollout-是否在执行"><a href="#检查-rollout-是否在执行" class="headerlink" title="检查 rollout 是否在执行"></a>检查 rollout 是否在执行</h3><p><code>kubectl describe deployment xxx</code></p><h3 id="回滚-Rolling-Back"><a href="#回滚-Rolling-Back" class="headerlink" title="回滚 Rolling Back"></a>回滚 Rolling Back</h3><ul><li><p>回滚到上一版本</p><p><code>kubectl rollout undo deployment kiada</code></p></li></ul><blockquote><p>undo 命令也可以在 RollingUpdate 过程中使用，用来取消这个升级</p></blockquote><ul><li><p>回滚到指定版本</p><p><code>kubectl rollout undo deployment kiada --to-revision=1</code></p></li></ul><h3 id="回滚和使用-yaml-文件恢复的区别"><a href="#回滚和使用-yaml-文件恢复的区别" class="headerlink" title="回滚和使用 yaml 文件恢复的区别"></a>回滚和使用 yaml 文件恢复的区别</h3><ul><li>回滚使用 <code>kubectl rollout undo</code> 命令，只是恢复 pod-templete 内容</li><li>使用 apply -f 的方式会将所有的内容进行恢复</li></ul><p>比如我们在 1.2 版本中修改了升级方式为 RollingUpdate，1.1 仍然为 Recreate，这时候如果我们通过，apply 的方式，会将我们改的内容进行覆盖。</p><p>一般情况下，都是用 <code>kubectl rollout undo</code> 命令，之前没学到这个命令，在操作更新版本的时候，都是 edit deployment 然后修改一下 镜像的版本，出了问题也是简单粗暴的处理，直接将版本恢复回去。</p><p>下次上线升级的时候，可以考虑使用这种方式，两个字，优雅。</p><h3 id="显示-rollout-历史"><a href="#显示-rollout-历史" class="headerlink" title="显示 rollout 历史"></a>显示 rollout 历史</h3><p><code>kubectl rollout history deploy kiada</code></p><ul><li><p>查看某次升级的具体信息</p><p><code>kubectl rollout history deployment kiada --revision 2</code></p><p>查看 kiada 这个 Deployment 在 revision 为 2 的版本做了哪些调整。</p></li></ul><p><img src="https://s2.loli.net/2022/05/09/XWgT2rFj7blSqU9.png" alt="img"></p><ul><li><code>revisionHistoryLimit</code> 用来配置保存多少个历史记录，默认是 10。</li></ul><h2 id="Traffic-shadowing"><a href="#Traffic-shadowing" class="headerlink" title="Traffic shadowing"></a>Traffic shadowing</h2><p>（这个应该翻译成啥呢？）</p><p><img src="https://s2.loli.net/2022/05/09/Pu9zvCGAU4e1dZy.png" alt="img"></p><p>利用 Ingress 进行流量复制，将请求转发一份到新的版本中，然后忽略掉响应。</p><h2 id="完"><a href="#完" class="headerlink" title="完"></a>完</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;将笔记进行拆分，都写在一个里边很拥挤，不方便翻阅查看。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>操作系统启动</title>
    <link href="https://bqyang.top/2022/os/os-start/"/>
    <id>https://bqyang.top/2022/os/os-start/</id>
    <published>2022-05-05T11:02:26.938Z</published>
    <updated>2022-05-13T03:22:13.982Z</updated>
    
    <content type="html"><![CDATA[<hr><p>尝试揭开操作系统的神秘面纱。</p><span id="more"></span><h1 id="QEMU"><a href="#QEMU" class="headerlink" title="QEMU"></a>QEMU</h1><h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget https://download.qemu.org/qemu-7.0.0.tar.xz</span><br><span class="line">tar xvJf qemu-7.0.0.tar.xz</span><br><span class="line">cd qemu-7.0.0</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">// make 后记得 make install</span><br></pre></td></tr></table></figure><blockquote><p>安装个 QEMU 真的是费死劲了，能遇到的问题基本上都遇到了，而且<strong>这个容器我挂了windows</strong>的一个目录（为了保存下来），make 花了<strong>3</strong>小时。</p></blockquote><p>遇到的具体问题如下：</p><ul><li>缺少依赖，pixman-1, gthread, glib, 我是基于 alpine 镜像构建的，很多依赖找起来很费事，不过要熟练使用 search 命令。</li></ul><p>具体解决方案省略，作为一个合格的工程师，肯定会找到办法的。</p><h1 id="CPU-Reset"><a href="#CPU-Reset" class="headerlink" title="CPU Reset"></a>CPU Reset</h1><p>程序就是状态机，操作系统也是一个 C 程序。那么问题就来了，电脑在 CPU Reset 之后（获得了一个初始状态）发生了什么？</p><blockquote><p>初始状态指的是：各种寄存器的初始值是什么。</p></blockquote><p><strong>计算机中没有任何神秘的东西</strong></p><p><img src="https://s2.loli.net/2022/05/06/e6anlsRhC2BULVu.png" alt="intel-cpu-reset"></p><p>可以看到，表 9-1 列出了在通电、重置、初始化后各种寄存器的值。这些都是<strong>约定</strong>，即硬件和软件约定好，每次加电后，CPU 状态设置为这些值，CPU 就是不断地执行指令，然后一步一步的加载出操作系统代码。</p><p><img src="https://s2.loli.net/2022/05/06/9SzlH2nRchoykQL.png" alt="image-20220506202315147"></p><h1 id="Legacy-BIOS-约定"><a href="#Legacy-BIOS-约定" class="headerlink" title="Legacy BIOS 约定"></a>Legacy BIOS 约定</h1><p>（操作系统与BIOS之间的约定，BIOS 上哪加载操作系统代码）</p><p>BIOS （Basic I/O System），BIOS 就是我们 CPU Reset 后 PC 指向的位置，也就意味着加电后执行的第一个程序是 BIOS 代码。然后 BIOS  代码都做了什么呢？他要做的事情都是约定好的。</p><p>MBR（Master Boot Record）主引导扇区，BIOS 要做的事情就是加载磁盘的前<strong>512字节</strong>（主引导扇区）到 <strong>0x7c00</strong>，<strong>检查这块磁盘是否可以作为启动盘</strong>。如果是，可以从磁盘中加载更多的内容到内存中，否则检查下一块磁盘的前512字节。</p><p>检查磁盘作为启动盘的标志是什么？<strong>55aa</strong></p><blockquote><p>怎么查看呢？有没有什么命令能查？</p><p>还真就是只有想不到的，没有做不到的。</p></blockquote><p>**hexdump ** 可以 <code>hexdump --help</code> 看一下具体细节，这里就是 <code>hexdump -n 512 /dev/sda    </code></p><p>补上一张 MBR 的图片</p><p><img src="https://s2.loli.net/2022/05/13/K9cL6sJ2etyP4QR.png" alt="o_mbr_anatomy"></p><p>是哪条指令将 MBR 中的内容加载到内存中的？</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 就是下面这条指令</span><br><span class="line">0xfa759:     rep insl (%dx),%es:(%di)</span><br><span class="line"># ...</span><br></pre></td></tr></table></figure><blockquote><p>如何查看上述的指令？x/i ($cs * 16 + $rip)</p></blockquote><p>cs （code segment register） 代码段寄存器</p><p>ds （data segment register） 数据段寄存器</p><p>为什么要按照这个算式进行查询呢？<code>($cs * 16 + $rip)</code> 早期的 IBM PC 机器，总线是 20 位，但是寄存器中都是 16 位的数据，所以怎么凑够这个 20 位的总线，代码段地址左移 4 位，然后加上偏移量，就是我们要执行的下一条指令地址。</p><h1 id="为什么叫做-x86-架构"><a href="#为什么叫做-x86-架构" class="headerlink" title="为什么叫做 x86 架构"></a>为什么叫做 x86 架构</h1><p>一般这种都是历史原因… 早期的 IBM PC 机器使用 Intel 8086 处理器，后来就把这个 8086 CPU 的架构叫做 x86。更详细的内容可以 Google 上看下，其实就连这个 <code>0x7c00  </code>都有一部分历史原因。</p>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;p&gt;尝试揭开操作系统的神秘面纱。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>同步原语-semaphore</title>
    <link href="https://bqyang.top/2022/os/concurrency-sema/"/>
    <id>https://bqyang.top/2022/os/concurrency-sema/</id>
    <published>2022-04-25T02:48:51.361Z</published>
    <updated>2022-04-27T08:26:56.324Z</updated>
    
    <content type="html"><![CDATA[<p>同步原语–信号量学习</p><span id="more"></span><h2 id="信号量定义"><a href="#信号量定义" class="headerlink" title="信号量定义"></a>信号量定义</h2><p>信号量就是一个拥有整数值的对象，可以用多个例程操控它。</p><blockquote><p>信号量的初始值决定了它的行为，在与它交互之前需要进行初始化，如下：</p></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># int sem_init(</span></span><br><span class="line"><span class="keyword">sem_t</span> *sem,</span><br><span class="line"><span class="keyword">int</span> pshared,</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> value);</span><br><span class="line"><span class="meta"># sem 信号</span></span><br><span class="line"><span class="meta"># value 指定了信号量的初始值</span></span><br><span class="line"><span class="meta"># pshared 表示在线程间共享，还是进程间</span></span><br><span class="line">sema_init()</span><br></pre></td></tr></table></figure><h2 id="使用-sema-实现-lock"><a href="#使用-sema-实现-lock" class="headerlink" title="使用 sema 实现 lock"></a>使用 sema 实现 lock</h2><p>这时应将 sema 的 value 设置为几？</p><p>可以想象，锁的状态其实只有<strong>上锁，未上锁</strong>两种状态，所以我们只需要使信号量满足这两种状态即可，即 value = 1，这种情况下，0，1就可以表示锁的这两种状态。</p><p>想进入临界区（以下用 CS 代替），就需要获取锁，检查信号量是否被占用：</p><ul><li>未上锁，信号量的值减一，进入临界区</li><li>上锁，信号量值减一，睡眠等待</li></ul><p>退出 CS，调用 <code>sema_post</code> 释放信号：</p><ul><li>有等待线程：信号量值加一，退出临界区，唤醒一个等待中的线程</li><li>没有等待线程：信号量值加一，退出临界区，无需唤醒</li></ul><blockquote><p>当信号量为负数时，比如说 -3，代表着有三个线程在等待这个信号被释放</p></blockquote><p>不难看出，当我们使用信号量来实现锁的时候，只有这两种状态（上锁，未上锁），所以这种信号通常也被称为<strong>binary semaphore</strong></p><h2 id="sema-实现-CVs"><a href="#sema-实现-CVs" class="headerlink" title="sema 实现 CVs"></a>sema 实现 CVs</h2><p><code>sema_init(sema, 0, 0)</code></p><p>想要父进程等待子进程执行结束的话，为什么 value 的值要设置为 0 ？</p><h2 id="sema-实现-producer-consumer-模型"><a href="#sema-实现-producer-consumer-模型" class="headerlink" title="sema 实现 producer/consumer 模型"></a>sema 实现 producer/consumer 模型</h2><p>如同当初使用 CVs 实现生产者消费者模型时一样，这里也是需要两个信号量来表示何时生产者可发送，接收者可接收。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    sem_init(&amp;empty, <span class="number">0</span>, MAX); <span class="comment">// MAX are empty</span></span><br><span class="line">    sem_init(&amp;full, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">// 0 are full</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 MAX &gt; 1 时，会出现什么问题？（仔细观察，的确不难看出，data-race）</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> buffer[MAX];</span><br><span class="line"><span class="keyword">int</span> fill = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> use = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    buffer[fill] = value; <span class="comment">// Line F1</span></span><br><span class="line">    fill = (fill + <span class="number">1</span>) % MAX; <span class="comment">// Line F2</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = buffer[use]; <span class="comment">// Line G1</span></span><br><span class="line">    use = (use + <span class="number">1</span>) % MAX; <span class="comment">// Line G2</span></span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">sem_t</span> empty;</span><br><span class="line"><span class="keyword">sem_t</span> full;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">producer</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loops; i++) &#123;</span><br><span class="line">        sem_wait(&amp;empty); <span class="comment">// Line P1</span></span><br><span class="line">        put(i); <span class="comment">// Line P2</span></span><br><span class="line">        sem_post(&amp;full); <span class="comment">// Line P3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">consumer</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (tmp != <span class="number">-1</span>) &#123;</span><br><span class="line">        sem_wait(&amp;full); <span class="comment">// Line C1</span></span><br><span class="line">        tmp = get(); <span class="comment">// Line C2</span></span><br><span class="line">        sem_post(&amp;empty); <span class="comment">// Line C3</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, tmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="哲学家吃饭"><a href="#哲学家吃饭" class="headerlink" title="哲学家吃饭.."></a>哲学家吃饭..</h2><p><img src="https://s2.loli.net/2022/04/27/wYIi1fhCQog2XVP.png" alt="image-20220427140847674"></p><ul><li><p><strong>如何解决相互依赖的问题</strong></p></li><li><p><strong>什么情况下会出现死锁</strong></p></li></ul><h2 id="Thread-Throttling"><a href="#Thread-Throttling" class="headerlink" title="Thread Throttling"></a>Thread Throttling</h2><p>线程节流，控制线程数量。</p><p>通过信号量控制进入临界区的线程数量</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;同步原语–信号量学习&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>并发控制-Condition-variables</title>
    <link href="https://bqyang.top/2022/os/concurrency-cv/"/>
    <id>https://bqyang.top/2022/os/concurrency-cv/</id>
    <published>2022-04-24T08:51:57.520Z</published>
    <updated>2022-04-24T09:36:40.764Z</updated>
    
    <content type="html"><![CDATA[<p>检查某些<strong>特定条件</strong>是否满足，然后决定线程是否继续执行。</p><span id="more"></span><p>使用<strong>变量</strong>控制具体该哪个线程执行。</p><p>使用 CVs 实现 生产者/消费者 模型，最终实现：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> buffer[MAX];</span><br><span class="line"><span class="keyword">int</span> fill_ptr = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> use_ptr = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    buffer[fill_ptr] = value;</span><br><span class="line">    fill_ptr = (fill_ptr + <span class="number">1</span>) % MAX;</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = buffer[use_ptr];</span><br><span class="line">    use_ptr = (use_ptr + <span class="number">1</span>) % MAX;</span><br><span class="line">    count--;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">cond_t</span> empty, fill;</span><br><span class="line"><span class="keyword">mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">producer</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loops; i++) &#123;</span><br><span class="line">        Pthread_mutex_lock(&amp;mutex); <span class="comment">// p1</span></span><br><span class="line">        <span class="keyword">while</span> (count == MAX) <span class="comment">// p2</span></span><br><span class="line">            Pthread_cond_wait(&amp;empty, &amp;mutex); <span class="comment">// p3</span></span><br><span class="line">        put(i); <span class="comment">// p4</span></span><br><span class="line">        Pthread_cond_signal(&amp;fill); <span class="comment">// p5</span></span><br><span class="line">        Pthread_mutex_unlock(&amp;mutex); <span class="comment">// p6</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">consumer</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loops; i++) &#123;</span><br><span class="line">        Pthread_mutex_lock(&amp;mutex); <span class="comment">// c1</span></span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>) <span class="comment">// c2</span></span><br><span class="line">            Pthread_cond_wait(&amp;fill, &amp;mutex); <span class="comment">// c3</span></span><br><span class="line">        <span class="keyword">int</span> tmp = get(); <span class="comment">// c4</span></span><br><span class="line">        Pthread_cond_signal(&amp;empty); <span class="comment">// c5</span></span><br><span class="line">        Pthread_mutex_unlock(&amp;mutex); <span class="comment">// c6</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, tmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么判断 <code>count == MAX OR count == 0</code> 的时候使用 <code>while</code> 而不是 <code>if</code>？？</p><blockquote><p>结论不重要，重要的是分析的过程</p></blockquote><p>// TODO 需要画状态机执行流程分析</p><blockquote><p><code>Pthread_cond_wait</code> 主要职责：将当前线程休眠<strong>并释放锁</strong>，当被唤醒的时候会尝试<strong>重新获取锁</strong>。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;检查某些&lt;strong&gt;特定条件&lt;/strong&gt;是否满足，然后决定线程是否继续执行。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>跟兄弟们聊聊</title>
    <link href="https://bqyang.top/2022/summary/about-0423/"/>
    <id>https://bqyang.top/2022/summary/about-0423/</id>
    <published>2022-04-23T05:24:37.969Z</published>
    <updated>2022-04-23T06:59:12.009Z</updated>
    
    <content type="html"><![CDATA[<p>今天上来就是为了跟兄弟们聊聊，在工作中怎么“优雅”的向别人提问，还有关于工作态度的一点理解。</p><span id="more"></span><p>这不也是闲的没事情嘛，明天还得补一天班，东拼西凑弄个五天假期，估计不少程序员同事还得加个两天。前两天女朋友刚好有一个面试，整个对话过程里外里透露着要剥削你。</p><p>她上来就给你承诺，法定节假日都是遵循国家规定的，后边说到加班的时候，冷不丁来一句，法定节假日加班是没有三倍工资的，我俩直接四目相对人都傻了。</p><p>后边当然就是果断拒绝，毕竟也是刚开始面试，还有很多机会。</p><p>好！接下来就聊聊，我最近工作上遇到的一件事情，或者说一类事情。（跟我没关系，是一种现象）开始之前先跟兄弟们说一下我平常的状态，每天基本上都是独来独往，因为住的也比较近嘛，中午也不在公司都是买完回家吃，所以跟同事平时的交流只有工作上的事情。对于公司里、同事间的八卦，我当然也感兴趣，但是奈何交流的不多，自然知道的也就比较少。</p><p>我想的就是，每天按时上下班，工作期间把活做完，合理安排时间。现在这家公司已经很人性化了，不用 KPI 逼着你出活，不用每天加班，给我们开发的时间也都绰绰有余。当给你一个完全没有涉猎过的领域时，你是有足够的时间从零开始的。</p><p>委婉的说，自己可支配时间很多，说白了，很多时间都是闲着没事干。</p><p>也就是这样，各种千奇百怪的人都冒出来了，先说说我，我就在座位上不忙的时候每天都有机会看会技术文章，忙的时候也不会抱怨，毕竟赚的就是这份钱。再说我见到的，大家都很默契的找到了同伴，两个人一组，基本上每天也都是固定的时间，到点就下楼。说实话，很羡慕但是自己还不敢出去转悠。我们这边工位一天有 1/4 的时间都是空着。</p><p>这都是我看到的，也没有刻意的去盯着谁谁，大家每天都是这个套路。</p><p>反正就我目前的想法来讲，有这个时间，不如多搞点技术。咱也别把话说的太死，万一以后咱也一样呢。</p><p>另一个就是怎么向别人提问，想跟兄弟们聊的并不是提问的方式，而是向别人提问的时候应该抱着怎样的态度，这是我的观点。</p><p>我们组前几个月新来了一个小子，五年工作经验，最开始没接触不知道他底，后边聊了几次，问了几次问题。话语之间就感觉到这tm五年，这五年怎么过来的。一些我这种初级问的问题，从他口中不知道问出来多少次，而且他问的还是我，一个初级。</p><p>就是觉得挺诧异，你不应该自己详细了解之后，然后针对没搞明白的地方进行提问吗，难道说要从到到尾给你讲一遍？这怎么体现你的学习能力，适应能力。所以所别很随便的就去提问，或者说我们要提就要提一些有意义的问题。</p><p>人不可能把你当小白对待，更没有时间给你做针对性的培训。不要把希望寄托在别人身上，既然一切的答案都在代码中，有时间浏览工作无关的网页，为什么不能花些时间去研究一下代码呢？</p><p>每个人的心里都有一杆秤，你张口，就可能会掉秤。咬咬牙，啃下来，那你就有机会涨。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天上来就是为了跟兄弟们聊聊，在工作中怎么“优雅”的向别人提问，还有关于工作态度的一点理解。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
</feed>
