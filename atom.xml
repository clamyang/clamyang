<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>杨宝强的技术笔记</title>
  
  <subtitle>欢迎~</subtitle>
  <link href="https://bqyang.top/atom.xml" rel="self"/>
  
  <link href="https://bqyang.top/"/>
  <updated>2021-12-08T14:44:05.753Z</updated>
  <id>https://bqyang.top/</id>
  
  <author>
    <name>杨宝强</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>linker and loader</title>
    <link href="https://bqyang.top/2021/linker&amp;loader/"/>
    <id>https://bqyang.top/2021/linker&amp;loader/</id>
    <published>2021-12-08T12:12:27.061Z</published>
    <updated>2021-12-08T14:44:05.753Z</updated>
    
    <content type="html"><![CDATA[<p>学习下 linker 和 loader 中的内容，记录一下学习过程遇到的笔记以及知识点。主要的内容来自 csapp。</p><h3 id="为什么要学链接"><a href="#为什么要学链接" class="headerlink" title="为什么要学链接"></a>为什么要学链接</h3><ul><li>理解链接器能帮助我构造大型程序</li><li>理解链接器能帮助我避免一些危险的编程错误</li><li>理解链接器能帮助我理解语言中作用域规则的实现</li><li>理解链接器能帮助我理解其他系统概念</li><li>理解链接器能帮助我利用共享库</li></ul><p>这是文中提到的一些关键点，我个人更想了解的是，linker 和 loader 的相关过程，毕竟 Go 是编译类型的语言，还是有必要去了解一下其底层的编译的内容的。</p><p>书中的例子都是 C 语言实现的，只需要你简单了解一下语法即可，很简单。</p><h3 id="编译器驱动程序"><a href="#编译器驱动程序" class="headerlink" title="编译器驱动程序"></a>编译器驱动程序</h3><p>一个编译的过程有以下几个步骤：（一个 gcc 可以拆成以下四步）</p><ul><li>语言预处理器</li><li>编译器</li><li>汇编器</li><li>链接器</li></ul><p>这个就像 Go 语言中，一个 go build 可以拆分成 compile 和 link 的过程。</p><p>比如要编译 main.c 和 sum.c 文件， 通过 <code>gcc -Og -o prog main.c sum.c</code> 即可输出 prog 可执行文件。也可以一步一步拆解进行，如下：</p><ul><li>C 语言预处理器： <code>cpp main.c ./main.i</code>  翻译成一个 ASCII 码的中间文件</li><li>C 编译器： <code>cc1 ./main.i -Og -o ./main.s</code>  翻译成一个ASCII 码的<strong>汇编语言文件</strong></li><li>汇编器： <code>as -o ./main.o ./main.s</code>  翻译成一个<strong>可重定位目标文件</strong></li><li>链接器： <code>ld -o prog ./main.o ./sum.o</code> 生成一个<strong>可重定位目标文件</strong></li></ul><h3 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h3><ul><li>符号解析<ul><li>目的是将每个符号引用正好和一个符号定义关联起来，比如将符号对应到函数、全局变量等。</li></ul></li><li>重定位<ul><li>把每个符号定义与一个内存位置关联起来。</li></ul></li></ul><h3 id="目标文件"><a href="#目标文件" class="headerlink" title="目标文件"></a>目标文件</h3><h3 id="可重定位目标文件"><a href="#可重定位目标文件" class="headerlink" title="可重定位目标文件"></a>可重定位目标文件</h3><h3 id="符号和符号表"><a href="#符号和符号表" class="headerlink" title="符号和符号表"></a>符号和符号表</h3><h3 id="符号解析"><a href="#符号解析" class="headerlink" title="符号解析"></a>符号解析</h3><h3 id="重定位"><a href="#重定位" class="headerlink" title="重定位"></a>重定位</h3><h3 id="加载可执行目标文件"><a href="#加载可执行目标文件" class="headerlink" title="加载可执行目标文件"></a>加载可执行目标文件</h3><h3 id="动态链接共享库"><a href="#动态链接共享库" class="headerlink" title="动态链接共享库"></a>动态链接共享库</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;学习下 linker 和 loader 中的内容，记录一下学习过程遇到的笔记以及知识点。主要的内容来自 csapp。&lt;/p&gt;
&lt;h3 id=&quot;为什么要学链接&quot;&gt;&lt;a href=&quot;#为什么要学链接&quot; class=&quot;headerlink&quot; title=&quot;为什么要学链接&quot;&gt;&lt;/a</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>elf 文件格式</title>
    <link href="https://bqyang.top/2021/elf/"/>
    <id>https://bqyang.top/2021/elf/</id>
    <published>2021-12-06T06:07:18.656Z</published>
    <updated>2021-12-08T14:42:20.343Z</updated>
    
    <content type="html"><![CDATA[<p>简单整理下 ELF (executable and linkable format) 的几个知识点，这里跟 linker&amp;&amp;loader 中有一点重复内容。</p><span id="more"></span><h3 id="sections"><a href="#sections" class="headerlink" title="sections"></a>sections</h3><ul><li><p><code>.text </code> 存放编译好的二进制可执行代码</p></li><li><p><code>.data</code> 存放已经初始化好的全局变量</p></li><li><p><code>.rodata</code> 存放只读数据，<code>const</code> 变量等</p></li><li><p><a href="https://en.wikipedia.org/wiki/.bss">.bss</a>  未初始化全局变量，运行时会置 0，</p><ul><li>比如在全局作用域下，<code>var name string</code> 这种就是分配在 <code>.bss</code> section 中</li></ul></li><li><p><code>.symtab</code> 符号表，记录函数和变量</p></li><li><p><code>.strtab</code> 字符串表、字符串常量和变量名</p></li></ul><h3 id="ELF的三种格式"><a href="#ELF的三种格式" class="headerlink" title="ELF的三种格式"></a>ELF的三种格式</h3><ul><li><p>可重定位文件</p><ul><li>包含二进制代码和数据，其形式可以在编译时与其他可重定位目标文件合并起来，创建一个可执行目标文件。</li></ul></li><li><p>可执行文件</p><ul><li>包含二进制代码和数据，其形式可以被直接复制到内存并执行。</li></ul></li><li><p>共享对象文件</p><ul><li>一种特殊类型的可重定位目标文件，可以在加载或运行时被动态地加载进内存并链接。</li></ul></li></ul><h4 id="可执行文件格式"><a href="#可执行文件格式" class="headerlink" title="可执行文件格式"></a>可执行文件格式</h4><p>如下图所示：</p><p><img src="https://gitee.com/yangbaoqiang/images/raw/master/blogpics/image-20211206141434504.png" alt="image-20211206141434504"></p><p>代码段：用来存放编译好的代码</p><p>数据段：包括已经初始化的全局变量，未初始化的全局变量</p><p><code>.text</code> 和 <code>.rodata</code> 两个 section 组成代码段 <code>segment</code>，其他也类似。</p><h3 id="TODO-程序如何加载到内存"><a href="#TODO-程序如何加载到内存" class="headerlink" title="TODO 程序如何加载到内存"></a>TODO 程序如何加载到内存</h3><h3 id="TODO-链接的过程"><a href="#TODO-链接的过程" class="headerlink" title="TODO 链接的过程"></a>TODO 链接的过程</h3>]]></content>
    
    
    <summary type="html">&lt;p&gt;简单整理下 ELF (executable and linkable format) 的几个知识点，这里跟 linker&amp;amp;&amp;amp;loader 中有一点重复内容。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>golang 中的抢占</title>
    <link href="https://bqyang.top/2021/preemptSchedule/"/>
    <id>https://bqyang.top/2021/preemptSchedule/</id>
    <published>2021-12-05T03:46:03.601Z</published>
    <updated>2021-12-05T11:33:40.502Z</updated>
    
    <content type="html"><![CDATA[<p>关于 go 1.13 协作式抢占的一点理解</p><span id="more"></span><p>基于协作式的抢占，要 goroutine 进行配合，在 G 执行的函数中添加栈的边界检查。</p><p>我一开始有一点没想明白，假设有个 G 正在 P 上执行，但是呢，抢占条件的检测是 false 不需要抢占，执行几行代码后，我又想抢占了。这时候怎么办？</p><p>需要知道的是，协作式一定需要 goroutine 进行配合，配合的意思就是：一定是栈边界检查为true。执行完第一个条件检查不要紧，你会发现只要是函数调用的地方（你的代码，println 也会检查）基本上都加入了栈边界检查。尽最大努力进行抢占。</p><p>如果说整个函数就一个简单的运算，没有别的任何函数调用，如果第一次边界检查为 false，后续想抢占应该也是不行的，只能等当前的 G 主动退出。</p><p>最近时间都花在 GC 上了，GC 和抢占的内容紧密关联。因为 STW 的时候就需要进行抢占，把 P 上执行的 G 都给挂起。</p><p>// TODO 立个 flag 一定把协作式抢占与基于信号的抢占整理出来。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;关于 go 1.13 协作式抢占的一点理解&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Weekend</title>
    <link href="https://bqyang.top/2021/HappyWeekend/"/>
    <id>https://bqyang.top/2021/HappyWeekend/</id>
    <published>2021-12-04T14:17:37.352Z</published>
    <updated>2021-12-04T14:49:37.020Z</updated>
    
    <content type="html"><![CDATA[<p>为了听键盘按键声音（全键都是 35 g 的，今天给键盘搞了个增压弹簧，非字母键位都加了 10 g），迫不得已写篇周记，记录下这周点滴。</p><span id="more"></span><p>这篇文章来记录下生活中让我感到这世界还是好人多的时刻。</p><p>2021-11-29 至 2021-12-04</p><p>公司来了通知，告诉我们要更换发工资的银行卡，本来想着没啥麻烦的，不就是新办一张银行卡嘛，更何况有银行的职员来我们公司给办理。</p><p>好家伙，到了办卡那天真的是糟糕透顶，银行职员说，要办理银行卡的手机号一定是与本人身份证绑定的。忽然想到，我这个都是我妈的身份证办的卡，想回家也挺麻烦的，还要做个 48 小时内的核酸。</p><p>这也不能耽误公司给我发工资啊！谁会跟钱过不去呢，然后大中午的骑着电动车又跑去办张移动的手机卡，二话不说，先交个 100 元话费，然后换了个最便宜的套餐，好像是 8 块钱一个月。</p><p>我心思这下应该好了吧，手机卡刚办的，然后趁着人家银行职员没走，又抓紧去试试能不能继续办卡，没有任何意外，仍然不行。给移动客服打电话，让我去移动标准厅办理实名制，哎，这个我还是挺纳闷的，当初办理的时候就是用我的身份证办理的，为啥仍需要去营业厅办理实名制呢？？</p><p>没招呗，人家要求啥咱只好照办.. 然后大周六早上骑着电动车去营业厅，吭哧吭哧骑了得 30 分钟吧，想先去银行看看，我直接好家伙，银行没开门，这tm白跑一趟.. 怎么着也不能白来啊，又跑到附近的移动营业厅办理实名制，我tm又好家伙了，人家说你这个已经实名制了！</p><p>这一前一后真的是挺无语，不过好在移动营业厅的服务人员很友善，跟我说明了情况，帮我开了一个工单，用来证明当前这个手机号确实是我的身份证办理的。</p><p>拿着小哥开的工单，打开地图寻找下一个银行营业点，吭哧吭哧又骑了 20 分钟，来到了上地！还看到了我实习时所在的那座大厦，早已是两年前的事情了，心里也是不由自主的乐了起来，想起当年实习的时光。</p><p>到了银行，在机器上办不了，只好去窗口办理，又遇到一个非常有耐心并且非常有爱心的柜员。简单的跟她说明了情况，后续办理过程都是挺顺利的。中间有个小插曲就是，窗口开卡要 5 块钱的工本费并且只能是现金！</p><p>我又好家伙了.. 这上哪找 5 块钱现金，大家都用支付宝、微信付款，出门带个手机就行了，这又四处招人问，大哥，您有现金不，大姐麻烦问下您有现金不…</p><p>整个银行没一个人有现金哈哈哈哈哈哈</p><p>有个大哥在银行门口抽烟呢，当时也没抱啥希望，过去问，大哥您好，麻烦问下，您有现金不，想跟您换点，5 块钱就行。哈哈哈哈哈哈哈哈哈哈哈，幸运的是，大哥包里有！</p><p>大哥在包里找啊找，说这 5 块钱得放这两三年了。我给大哥扫微信，给了大哥 6.66，祝大哥发发发哈哈哈哈</p><p>这也是给自己提个醒，出门办事还是得装点现金，万一要用呢。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;为了听键盘按键声音（全键都是 35 g 的，今天给键盘搞了个增压弹簧，非字母键位都加了 10 g），迫不得已写篇周记，记录下这周点滴。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>GC 源码梳理</title>
    <link href="https://bqyang.top/2021/GC/"/>
    <id>https://bqyang.top/2021/GC/</id>
    <published>2021-12-02T08:11:37.293Z</published>
    <updated>2021-12-08T05:55:15.832Z</updated>
    
    <content type="html"><![CDATA[<p>Golang GC 垃圾回收知识点总结，有些内容还没有完成，只是抛出了问题.. </p><span id="more"></span><h2 id="GC-连连问"><a href="#GC-连连问" class="headerlink" title="GC 连连问"></a>GC 连连问</h2><h3 id="GC-的流程阶段"><a href="#GC-的流程阶段" class="headerlink" title="GC 的流程阶段"></a>GC 的流程阶段</h3><ul><li><p>sweep termination</p></li><li><p>mark</p></li><li><p>mark termination</p></li><li><p>sweep</p></li></ul><h3 id="GC-的触发时机"><a href="#GC-的触发时机" class="headerlink" title="GC 的触发时机"></a>GC 的触发时机</h3><p>1.runtime.GC 手动触发</p><p>2.mallocgc 根据内存分配大小，比如当前使用 4M，当内存分配到达 8M 时，会触发 GC，这个百分比是可以调整的，通过 设置 triggerRatio 指定触发 GC 的阈值 go1.16.5 中，是 7/8.0 = 87.5% </p><p>3.forcegchelper 定时触发 GC</p><p>mallocgc 是主要的触发函数。</p><h3 id="GC-的起点"><a href="#GC-的起点" class="headerlink" title="GC 的起点"></a>GC 的起点</h3><p>gcStart，控制 worker 的数量，大约占 CPU 的 1/4。</p><h3 id="为什么老版本需要重新扫描栈？"><a href="#为什么老版本需要重新扫描栈？" class="headerlink" title="为什么老版本需要重新扫描栈？"></a>为什么老版本需要重新扫描栈？</h3><h3 id="GC-标记的根都有什么？"><a href="#GC-标记的根都有什么？" class="headerlink" title="GC 标记的根都有什么？"></a>GC 标记的根都有什么？</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// gcMarkRootPrepare queues root scanning jobs (stacks, globals, and</span><span class="token comment">// some miscellany) and initializes scanning-related state.</span><span class="token comment">//</span><span class="token comment">// The world must be stopped.</span><span class="token comment">/*写在最前边，我们关注的重点只是 GC，不要过多的被其他知识点所蒙蔽，比如这里，我们只需要知道，根从哪里来，根都包含什么其它的都可以忽略．．*/</span><span class="token keyword">func</span> <span class="token function">gcMarkRootPrepare</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">assertWorldStopped</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment">// Compute how many data and BSS root blocks there are.</span>    nBlocks <span class="token operator">:=</span> <span class="token keyword">func</span><span class="token punctuation">(</span>bytes <span class="token builtin">uintptr</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token function">int</span><span class="token punctuation">(</span><span class="token function">divRoundUp</span><span class="token punctuation">(</span>bytes<span class="token punctuation">,</span> rootBlockBytes<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 初始化需要被扫描的 data、bss 段个数</span>    work<span class="token punctuation">.</span>nDataRoots <span class="token operator">=</span> <span class="token number">0</span>    work<span class="token punctuation">.</span>nBSSRoots <span class="token operator">=</span> <span class="token number">0</span>        <span class="token comment">/*    暂时记录下目前的理解：    这里的 bss data 段，有可能会变得，比如说进行动态链接的时候，    就会把那个被链接的文件加入到 activeModules 中，所以都是通过    函数调用的方式来获取对应的数据    注：他这个对总数的赋值操作有点迷惑，不知道为啥要这样写..    */</span>    <span class="token comment">// Scan globals.</span>    <span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> datap <span class="token operator">:=</span> <span class="token keyword">range</span> <span class="token function">activeModules</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        nDataRoots <span class="token operator">:=</span> <span class="token function">nBlocks</span><span class="token punctuation">(</span>datap<span class="token punctuation">.</span>edata <span class="token operator">-</span> datap<span class="token punctuation">.</span>data<span class="token punctuation">)</span>        <span class="token keyword">if</span> nDataRoots <span class="token operator">></span> work<span class="token punctuation">.</span>nDataRoots <span class="token punctuation">&#123;</span>            work<span class="token punctuation">.</span>nDataRoots <span class="token operator">=</span> nDataRoots        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> datap <span class="token operator">:=</span> <span class="token keyword">range</span> <span class="token function">activeModules</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        nBSSRoots <span class="token operator">:=</span> <span class="token function">nBlocks</span><span class="token punctuation">(</span>datap<span class="token punctuation">.</span>ebss <span class="token operator">-</span> datap<span class="token punctuation">.</span>bss<span class="token punctuation">)</span>        <span class="token keyword">if</span> nBSSRoots <span class="token operator">></span> work<span class="token punctuation">.</span>nBSSRoots <span class="token punctuation">&#123;</span>            work<span class="token punctuation">.</span>nBSSRoots <span class="token operator">=</span> nBSSRoots        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// Scan span roots for finalizer specials.</span>    <span class="token comment">//</span>    <span class="token comment">// We depend on addfinalizer to mark objects that get</span>    <span class="token comment">// finalizers after root marking.</span>    <span class="token comment">//</span>    <span class="token comment">// We're going to scan the whole heap (that was available at the time the</span>    <span class="token comment">// mark phase started, i.e. markArenas) for in-use spans which have specials.</span>    <span class="token comment">//</span>    <span class="token comment">// Break up the work into arenas, and further into chunks.</span>    <span class="token comment">//</span>    <span class="token comment">// Snapshot allArenas as markArenas. This snapshot is safe because allArenas</span>    <span class="token comment">// is append-only.</span>    <span class="token comment">// 扫描整个 heap，对 allArenas 做快照</span>    mheap_<span class="token punctuation">.</span>markArenas <span class="token operator">=</span> mheap_<span class="token punctuation">.</span>allArenas<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token function">len</span><span class="token punctuation">(</span>mheap_<span class="token punctuation">.</span>allArenas<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token function">len</span><span class="token punctuation">(</span>mheap_<span class="token punctuation">.</span>allArenas<span class="token punctuation">)</span><span class="token punctuation">]</span>    <span class="token comment">// 计算需要扫描的 span 数量，arena * （单个 arena 中 span 的数量）</span>    work<span class="token punctuation">.</span>nSpanRoots <span class="token operator">=</span> <span class="token function">len</span><span class="token punctuation">(</span>mheap_<span class="token punctuation">.</span>markArenas<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>pagesPerArena <span class="token operator">/</span> pagesPerSpanRoot<span class="token punctuation">)</span>    <span class="token comment">// Scan stacks.</span>    <span class="token comment">//</span>    <span class="token comment">// Gs may be created after this point, but it's okay that we</span>    <span class="token comment">// ignore them because they begin life without any roots, so</span>    <span class="token comment">// there's nothing to scan, and any roots they create during</span>    <span class="token comment">// the concurrent phase will be caught by the write barrier.</span>    <span class="token comment">// 如注释所说，尽管这时候有 goroutine 被创建，也不需要担心</span>    <span class="token comment">// 因为他们没有 root，即不需要扫描。如果在并发阶段创建出来的 goroutine，</span>    <span class="token comment">// 这个 G 使用的 root 会被 write barrier 捕获到。</span>    work<span class="token punctuation">.</span>nStackRoots <span class="token operator">=</span> <span class="token function">int</span><span class="token punctuation">(</span>atomic<span class="token punctuation">.</span><span class="token function">Loaduintptr</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>allglen<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment">// 初始化标记的开始位置</span>    work<span class="token punctuation">.</span>markrootNext <span class="token operator">=</span> <span class="token number">0</span>    <span class="token comment">//　计算所有根的数量</span>    <span class="token comment">//　包括了：Data　段，BSS　段,span,以及 goroutine 栈</span>    work<span class="token punctuation">.</span>markrootJobs <span class="token operator">=</span> <span class="token function">uint32</span><span class="token punctuation">(</span>fixedRootCount <span class="token operator">+</span> work<span class="token punctuation">.</span>nDataRoots <span class="token operator">+</span> work<span class="token punctuation">.</span>nBSSRoots <span class="token operator">+</span> work<span class="token punctuation">.</span>nSpanRoots <span class="token operator">+</span> work<span class="token punctuation">.</span>nStackRoots<span class="token punctuation">)</span>    <span class="token comment">// Calculate base indexes of each root type</span>    <span class="token comment">// markroot 标记的时候会根据不同的 i 找到不同的根</span>    work<span class="token punctuation">.</span>baseData <span class="token operator">=</span> <span class="token function">uint32</span><span class="token punctuation">(</span>fixedRootCount<span class="token punctuation">)</span>    work<span class="token punctuation">.</span>baseBSS <span class="token operator">=</span> work<span class="token punctuation">.</span>baseData <span class="token operator">+</span> <span class="token function">uint32</span><span class="token punctuation">(</span>work<span class="token punctuation">.</span>nDataRoots<span class="token punctuation">)</span>    work<span class="token punctuation">.</span>baseSpans <span class="token operator">=</span> work<span class="token punctuation">.</span>baseBSS <span class="token operator">+</span> <span class="token function">uint32</span><span class="token punctuation">(</span>work<span class="token punctuation">.</span>nBSSRoots<span class="token punctuation">)</span>    work<span class="token punctuation">.</span>baseStacks <span class="token operator">=</span> work<span class="token punctuation">.</span>baseSpans <span class="token operator">+</span> <span class="token function">uint32</span><span class="token punctuation">(</span>work<span class="token punctuation">.</span>nSpanRoots<span class="token punctuation">)</span>    work<span class="token punctuation">.</span>baseEnd <span class="token operator">=</span> work<span class="token punctuation">.</span>baseStacks <span class="token operator">+</span> <span class="token function">uint32</span><span class="token punctuation">(</span>work<span class="token punctuation">.</span>nStackRoots<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>结合上边代码来看，GC 标记过程中涉及到的根有：全局变量，stack，heap（span）</li></ul><h3 id="单独使用-D-屏障有何问题？"><a href="#单独使用-D-屏障有何问题？" class="headerlink" title="单独使用 D 屏障有何问题？"></a>单独使用 D 屏障有何问题？</h3><h3 id="单独使用-Y-屏障有何问题？"><a href="#单独使用-Y-屏障有何问题？" class="headerlink" title="单独使用 Y 屏障有何问题？"></a>单独使用 Y 屏障有何问题？</h3><h3 id="混合写屏障是怎么一回事？"><a href="#混合写屏障是怎么一回事？" class="headerlink" title="混合写屏障是怎么一回事？"></a>混合写屏障是怎么一回事？</h3><h3 id="协助标记流程"><a href="#协助标记流程" class="headerlink" title="协助标记流程"></a>协助标记流程</h3><h3 id="对象的交叉引用是如何剪枝的？"><a href="#对象的交叉引用是如何剪枝的？" class="headerlink" title="对象的交叉引用是如何剪枝的？"></a>对象的交叉引用是如何剪枝的？</h3><h4 id="与运算"><a href="#与运算" class="headerlink" title="与运算"></a>与运算</h4><p>两个都是一才是一</p><h4 id="或运算"><a href="#或运算" class="headerlink" title="或运算"></a>或运算</h4><p>有一个是一就是一</p><h4 id="异或运算"><a href="#异或运算" class="headerlink" title="异或运算"></a>异或运算</h4><p>同零异一</p><h3 id="GC-的-CPU-使用率"><a href="#GC-的-CPU-使用率" class="headerlink" title="GC 的 CPU 使用率"></a>GC 的 CPU 使用率</h3><ul><li>GC cpu 使用率主要用来控制，启动 mark worker 的数量</li></ul><p>mark worker count = gomaxprocs * 25%</p><p>如果 gomaxprocs = 4，那么只需要启动一个 markworker</p><p>对于计算结果不为整数的情况，比如 gomaxprocs = 6，那么 work count  = 1.5，会对结果 + 0.5 进行 rounding， 然后通过计算误差是否 &gt; 0.3 判断开几个全职 worker</p><p>2/1.5 -1 = 1/3 &gt; 0.3</p><h3 id="gcTriggerKind"><a href="#gcTriggerKind" class="headerlink" title="gcTriggerKind"></a>gcTriggerKind</h3><p>gc 触发类型：</p><ul><li>gcTriggerHeap 内存到达阈值</li><li>gcTriggerTime 到达触发时间</li><li>gcTriggerCycle 可以理解为用户手动触发类型</li></ul><h3 id="STW-时间怎么算出来的？"><a href="#STW-时间怎么算出来的？" class="headerlink" title="STW 时间怎么算出来的？"></a>STW 时间怎么算出来的？</h3><h3 id="GC-过程中是什么时候将对象标记为黑色的"><a href="#GC-过程中是什么时候将对象标记为黑色的" class="headerlink" title="GC 过程中是什么时候将对象标记为黑色的"></a>GC 过程中是什么时候将对象标记为黑色的</h3><p>换句话说，是通过修改了什么变量，就代表这个指针被标记为黑色。</p><p>解释如下：</p><p>​    通过源码分析，我们可以知道，从白色对象到灰色对象是通过 greyobject 来实现的，同事也能够知道在 gcw 队列中的对象都是灰色的。</p><p>​    标记为黑色的过程是从 gcw 队列中取出灰色对象，再遍历其子对象并将其标灰，也即是说当灰色对象出队的时候就自动变成黑色了，就完成了将一个灰色对象标记位黑色的过程，在 Go 的源码中，其实并不存在的某个方法或者某个标志位，来表示一个对象是黑色的。</p><h2 id="gcStart-源码剖析"><a href="#gcStart-源码剖析" class="headerlink" title="gcStart 源码剖析"></a>gcStart 源码剖析</h2><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// gcStart starts the GC. It transitions from _GCoff to _GCmark (if</span><span class="token comment">// debug.gcstoptheworld == 0) or performs all of GC (if</span><span class="token comment">// debug.gcstoptheworld != 0).</span><span class="token comment">//</span><span class="token comment">// This may return without performing this transition in some cases,</span><span class="token comment">// such as when called on a system stack or with locks held.</span><span class="token comment">// gcStart 是 GC 的起点，并将 GC 的状态由 _GCoff 切换到 _GCmark，</span><span class="token comment">// 如果 gcStart 在系统栈上被调用或者持有锁的时候，就不会执行状态的改变直接返回了。</span><span class="token keyword">func</span> <span class="token function">gcStart</span><span class="token punctuation">(</span>trigger gcTrigger<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// Since this is called from malloc and malloc is called in</span>    <span class="token comment">// the guts of a number of libraries that might be holding</span>    <span class="token comment">// locks, don't attempt to start GC in non-preemptible or</span>    <span class="token comment">// potentially unstable situations.</span>    <span class="token comment">// 如果 gcStart 是从 malloc 调用的，并且 malloc 又是被其他的库调用的，</span>    <span class="token comment">// 这种情况下可能会持有锁（mp.locks > 1）</span>    <span class="token comment">// 不要再非抢占或者不稳定的情况下调用 gcStart</span>    <span class="token comment">/*       我的理解：如果不是非抢占模式，可能会导致后面 stw 时，一些 g 没有办法停止       会影响 GC 的结果。    */</span>    mp <span class="token operator">:=</span> <span class="token function">acquirem</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment">// mp.locks > 1 说明在 gcStart 之前就持有锁</span>    <span class="token comment">// mp.preemptoff != "" 说明在 non-preempt 模式下</span>    <span class="token keyword">if</span> gp <span class="token operator">:=</span> <span class="token function">getg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> gp <span class="token operator">==</span> mp<span class="token punctuation">.</span>g0 <span class="token operator">||</span> mp<span class="token punctuation">.</span>locks <span class="token operator">></span> <span class="token number">1</span> <span class="token operator">||</span> mp<span class="token punctuation">.</span>preemptoff <span class="token operator">!=</span> <span class="token string">""</span> <span class="token punctuation">&#123;</span>        <span class="token function">releasem</span><span class="token punctuation">(</span>mp<span class="token punctuation">)</span>        <span class="token keyword">return</span>    <span class="token punctuation">&#125;</span>    <span class="token function">releasem</span><span class="token punctuation">(</span>mp<span class="token punctuation">)</span>    mp <span class="token operator">=</span> <span class="token boolean">nil</span>    <span class="token comment">// Pick up the remaining unswept/not being swept spans concurrently</span>    <span class="token comment">//</span>    <span class="token comment">// This shouldn't happen if we're being invoked in background</span>    <span class="token comment">// mode since proportional sweep should have just finished</span>    <span class="token comment">// sweeping everything, but rounding errors, etc, may leave a</span>    <span class="token comment">// few spans unswept. In forced mode, this is necessary since</span>    <span class="token comment">// GC can be forced at any point in the sweeping cycle.</span>    <span class="token comment">//</span>    <span class="token comment">// We check the transition condition continuously here in case</span>    <span class="token comment">// this G gets delayed in to the next GC cycle.</span>    <span class="token comment">/*        trigger.test() 检测是否满足 GC 的触发条件        sweepone() 我的理解是：清扫上次 GC 遗留下来的 unswept 的 span        ？？ 是否可以理解成 sweep termination 的阶段     */</span>    <span class="token keyword">for</span> trigger<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">sweepone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">^</span><span class="token function">uintptr</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        sweep<span class="token punctuation">.</span>nbgsweep<span class="token operator">++</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// Perform GC initialization and the sweep termination</span>    <span class="token comment">// transition.</span>    <span class="token comment">/*    semaacquire 的操作，是否可以理解为，通过 atomic 去掉了锁。换句话说，只有获取了某个 sema，才能对 gc 状态进行修改。    */</span>    <span class="token function">semacquire</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>work<span class="token punctuation">.</span>startSema<span class="token punctuation">)</span>    <span class="token comment">// Re-check transition condition under transition lock.</span>    <span class="token keyword">if</span> <span class="token operator">!</span>trigger<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">semrelease</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>work<span class="token punctuation">.</span>startSema<span class="token punctuation">)</span>        <span class="token keyword">return</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// For stats, check if this GC was forced by the user.</span>    work<span class="token punctuation">.</span>userForced <span class="token operator">=</span> trigger<span class="token punctuation">.</span>kind <span class="token operator">==</span> gcTriggerCycle    <span class="token comment">// In gcstoptheworld debug mode, upgrade the mode accordingly.</span>    <span class="token comment">// We do this after re-checking the transition condition so</span>    <span class="token comment">// that multiple goroutines that detect the heap trigger don't</span>    <span class="token comment">// start multiple STW GCs.</span>    <span class="token comment">// 如果没开启 GODEBUG 都是 gcBackgroundMode 模式</span>    mode <span class="token operator">:=</span> gcBackgroundMode    <span class="token keyword">if</span> debug<span class="token punctuation">.</span>gcstoptheworld <span class="token operator">==</span> <span class="token number">1</span> <span class="token punctuation">&#123;</span>        mode <span class="token operator">=</span> gcForceMode    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> debug<span class="token punctuation">.</span>gcstoptheworld <span class="token operator">==</span> <span class="token number">2</span> <span class="token punctuation">&#123;</span>        mode <span class="token operator">=</span> gcForceBlockMode    <span class="token punctuation">&#125;</span>    <span class="token comment">// Ok, we're doing it! Stop everybody else</span>    <span class="token comment">// 获取 STW 需要的 semaphore</span>    <span class="token function">semacquire</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>gcsema<span class="token punctuation">)</span>    <span class="token function">semacquire</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>worldsema<span class="token punctuation">)</span>    <span class="token keyword">if</span> trace<span class="token punctuation">.</span>enabled <span class="token punctuation">&#123;</span>        <span class="token function">traceGCStart</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// Check that all Ps have finished deferred mcache flushes.</span>    <span class="token comment">// TODO 检查 P 的 mcache</span>    <span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> p <span class="token operator">:=</span> <span class="token keyword">range</span> allp <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> fg <span class="token operator">:=</span> atomic<span class="token punctuation">.</span><span class="token function">Load</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p<span class="token punctuation">.</span>mcache<span class="token punctuation">.</span>flushGen<span class="token punctuation">)</span><span class="token punctuation">;</span> fg <span class="token operator">!=</span> mheap_<span class="token punctuation">.</span>sweepgen <span class="token punctuation">&#123;</span>            <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"runtime: p"</span><span class="token punctuation">,</span> p<span class="token punctuation">.</span>id<span class="token punctuation">,</span> <span class="token string">"flushGen"</span><span class="token punctuation">,</span> fg<span class="token punctuation">,</span> <span class="token string">"!= sweepgen"</span><span class="token punctuation">,</span> mheap_<span class="token punctuation">.</span>sweepgen<span class="token punctuation">)</span>            <span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">"p mcache not flushed"</span><span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 开启 nproc 个 gcMarkWorker，加入到 workerPool 中</span>    <span class="token comment">// 创建完一个 worker，休眠一个 worker</span>    <span class="token comment">// 由 schedule.findRunnableGCWorker 唤醒</span>    <span class="token function">gcBgMarkStartWorkers</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment">// 重置标志位，allg 的标志位，heapArena 的标志位</span>    <span class="token comment">// 清空了每一个 g 的 AssistBytes</span>    <span class="token function">systemstack</span><span class="token punctuation">(</span>gcResetMarkState<span class="token punctuation">)</span>    work<span class="token punctuation">.</span>stwprocs<span class="token punctuation">,</span> work<span class="token punctuation">.</span>maxprocs <span class="token operator">=</span> gomaxprocs<span class="token punctuation">,</span> gomaxprocs    <span class="token keyword">if</span> work<span class="token punctuation">.</span>stwprocs <span class="token operator">></span> ncpu <span class="token punctuation">&#123;</span>        <span class="token comment">// This is used to compute CPU time of the STW phases,</span>        <span class="token comment">// so it can't be more than ncpu, even if GOMAXPROCS is.</span>        work<span class="token punctuation">.</span>stwprocs <span class="token operator">=</span> ncpu    <span class="token punctuation">&#125;</span>    work<span class="token punctuation">.</span>heap0 <span class="token operator">=</span> atomic<span class="token punctuation">.</span><span class="token function">Load64</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>memstats<span class="token punctuation">.</span>heap_live<span class="token punctuation">)</span>    work<span class="token punctuation">.</span>pauseNS <span class="token operator">=</span> <span class="token number">0</span>    work<span class="token punctuation">.</span>mode <span class="token operator">=</span> mode    now <span class="token operator">:=</span> <span class="token function">nanotime</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    work<span class="token punctuation">.</span>tSweepTerm <span class="token operator">=</span> now    work<span class="token punctuation">.</span>pauseStart <span class="token operator">=</span> now    <span class="token keyword">if</span> trace<span class="token punctuation">.</span>enabled <span class="token punctuation">&#123;</span>        <span class="token function">traceGCSTWStart</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// STW 调用者必须为 stopTheWorldWithSema 获取 worldsema 并且 关闭抢占</span>    <span class="token function">systemstack</span><span class="token punctuation">(</span>stopTheWorldWithSema<span class="token punctuation">)</span>    <span class="token comment">// Finish sweep before we start concurrent scan.</span>    <span class="token comment">// 确保本次 GC 开始时，已完成上一次 GC 的 sweep 工作</span>    <span class="token function">systemstack</span><span class="token punctuation">(</span><span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">finishsweep_m</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>    <span class="token comment">// clearpools before we start the GC. If we wait they memory will not be</span>    <span class="token comment">// reclaimed until the next GC cycle.</span>    <span class="token comment">// 1.处理 sync.Pool</span>    <span class="token comment">// 2.清空 sudog cache</span>    <span class="token comment">// 3.清空 defer pools</span>    <span class="token function">clearpools</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment">// 增加 gc 周期数</span>    work<span class="token punctuation">.</span>cycles<span class="token operator">++</span>    <span class="token comment">// 开始本次 gc 周期</span>    gcController<span class="token punctuation">.</span><span class="token function">startCycle</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    work<span class="token punctuation">.</span>heapGoal <span class="token operator">=</span> memstats<span class="token punctuation">.</span>next_gc    <span class="token comment">// In STW mode, disable scheduling of user Gs. This may also</span>    <span class="token comment">// disable scheduling of this goroutine, so it may block as</span>    <span class="token comment">// soon as we start the world again.</span>    <span class="token keyword">if</span> mode <span class="token operator">!=</span> gcBackgroundMode <span class="token punctuation">&#123;</span>        <span class="token function">schedEnableUser</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// Enter concurrent mark phase and enable</span>    <span class="token comment">// write barriers.</span>    <span class="token comment">//</span>    <span class="token comment">// Because the world is stopped, all Ps will</span>    <span class="token comment">// observe that write barriers are enabled by</span>    <span class="token comment">// the time we start the world and begin</span>    <span class="token comment">// scanning.</span>    <span class="token comment">//</span>    <span class="token comment">// Write barriers must be enabled before assists are</span>    <span class="token comment">// enabled because they must be enabled before</span>    <span class="token comment">// any non-leaf heap objects are marked. Since</span>    <span class="token comment">// allocations are blocked until assists can</span>    <span class="token comment">// happen, we want enable assists as early as</span>    <span class="token comment">// possible.</span>    <span class="token function">setGCPhase</span><span class="token punctuation">(</span>_GCmark<span class="token punctuation">)</span>    <span class="token function">gcBgMarkPrepare</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// Must happen before assist enable.</span>    <span class="token function">gcMarkRootPrepare</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment">// Mark all active tinyalloc blocks. Since we're</span>    <span class="token comment">// allocating from these, they need to be black like</span>    <span class="token comment">// other allocations. The alternative is to blacken</span>    <span class="token comment">// the tiny block on every allocation from it, which</span>    <span class="token comment">// would slow down the tiny allocator.</span>    <span class="token function">gcMarkTinyAllocs</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment">// At this point all Ps have enabled the write</span>    <span class="token comment">// barrier, thus maintaining the no white to</span>    <span class="token comment">// black invariant. Enable mutator assists to</span>    <span class="token comment">// put back-pressure on fast allocating</span>    <span class="token comment">// mutators.</span>    atomic<span class="token punctuation">.</span><span class="token function">Store</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>gcBlackenEnabled<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token comment">// Assists and workers can start the moment we start</span>    <span class="token comment">// the world.</span>    gcController<span class="token punctuation">.</span>markStartTime <span class="token operator">=</span> now    <span class="token comment">// In STW mode, we could block the instant systemstack</span>    <span class="token comment">// returns, so make sure we're not preemptible.</span>    mp <span class="token operator">=</span> <span class="token function">acquirem</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment">// Concurrent mark.</span>    <span class="token function">systemstack</span><span class="token punctuation">(</span><span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        now <span class="token operator">=</span> <span class="token function">startTheWorldWithSema</span><span class="token punctuation">(</span>trace<span class="token punctuation">.</span>enabled<span class="token punctuation">)</span>        work<span class="token punctuation">.</span>pauseNS <span class="token operator">+=</span> now <span class="token operator">-</span> work<span class="token punctuation">.</span>pauseStart        work<span class="token punctuation">.</span>tMark <span class="token operator">=</span> now        memstats<span class="token punctuation">.</span>gcPauseDist<span class="token punctuation">.</span><span class="token function">record</span><span class="token punctuation">(</span>now <span class="token operator">-</span> work<span class="token punctuation">.</span>pauseStart<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>    <span class="token comment">// Release the world sema before Gosched() in STW mode</span>    <span class="token comment">// because we will need to reacquire it later but before</span>    <span class="token comment">// this goroutine becomes runnable again, and we could</span>    <span class="token comment">// self-deadlock otherwise.</span>    <span class="token function">semrelease</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>worldsema<span class="token punctuation">)</span>    <span class="token function">releasem</span><span class="token punctuation">(</span>mp<span class="token punctuation">)</span>    <span class="token comment">// Make sure we block instead of returning to user code</span>    <span class="token comment">// in STW mode.</span>    <span class="token keyword">if</span> mode <span class="token operator">!=</span> gcBackgroundMode <span class="token punctuation">&#123;</span>        <span class="token function">Gosched</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    <span class="token function">semrelease</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>work<span class="token punctuation">.</span>startSema<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="findRunnableGCWorker-源码剖析"><a href="#findRunnableGCWorker-源码剖析" class="headerlink" title="findRunnableGCWorker 源码剖析"></a>findRunnableGCWorker 源码剖析</h2><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// findRunnableGCWorker returns a background mark worker for _p_ if it</span><span class="token comment">// should be run. This must only be called when gcBlackenEnabled != 0.</span><span class="token comment">// 只有在 gc 开启的时候才会执行，gcStart 中设置为 1</span><span class="token keyword">func</span> <span class="token punctuation">(</span>c <span class="token operator">*</span>gcControllerState<span class="token punctuation">)</span> <span class="token function">findRunnableGCWorker</span><span class="token punctuation">(</span>_p_ <span class="token operator">*</span>p<span class="token punctuation">)</span> <span class="token operator">*</span>g <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> gcBlackenEnabled <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>        <span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">"gcControllerState.findRunnable: blackening not enabled"</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token operator">!</span><span class="token function">gcMarkWorkAvailable</span><span class="token punctuation">(</span>_p_<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// No work to be done right now. This can happen at</span>        <span class="token comment">// the end of the mark phase when there are still</span>        <span class="token comment">// assists tapering off. Don't bother running a worker</span>        <span class="token comment">// now because it'll just return immediately.</span>        <span class="token keyword">return</span> <span class="token boolean">nil</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// Grab a worker before we commit to running below.</span>    <span class="token comment">// 从 workpool 中弹出一个 gcMarkWorker</span>    node <span class="token operator">:=</span> <span class="token punctuation">(</span><span class="token operator">*</span>gcBgMarkWorkerNode<span class="token punctuation">)</span><span class="token punctuation">(</span>gcBgMarkWorkerPool<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> node <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// There is at least one worker per P, so normally there are</span>        <span class="token comment">// enough workers to run on all Ps, if necessary. However, once</span>        <span class="token comment">// a worker enters gcMarkDone it may park without rejoining the</span>        <span class="token comment">// pool, thus freeing a P with no corresponding worker.</span>        <span class="token comment">// gcMarkDone never depends on another worker doing work, so it</span>        <span class="token comment">// is safe to simply do nothing here.</span>        <span class="token comment">//</span>        <span class="token comment">// If gcMarkDone bails out without completing the mark phase,</span>        <span class="token comment">// it will always do so with queued global work. Thus, that P</span>        <span class="token comment">// will be immediately eligible to re-run the worker G it was</span>        <span class="token comment">// just using, ensuring work can complete.</span>        <span class="token keyword">return</span> <span class="token boolean">nil</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 用于计算该 markNode 的工作模式</span>    <span class="token comment">// >  0 dedicatedMode</span>    <span class="token comment">// &lt;= 0 fractionalMode</span>    decIfPositive <span class="token operator">:=</span> <span class="token keyword">func</span><span class="token punctuation">(</span>ptr <span class="token operator">*</span><span class="token builtin">int64</span><span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">&#123;</span>            v <span class="token operator">:=</span> atomic<span class="token punctuation">.</span><span class="token function">Loadint64</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span>            <span class="token keyword">if</span> v <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">return</span> <span class="token boolean">false</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">if</span> atomic<span class="token punctuation">.</span><span class="token function">Casint64</span><span class="token punctuation">(</span>ptr<span class="token punctuation">,</span> v<span class="token punctuation">,</span> v<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">return</span> <span class="token boolean">true</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token function">decIfPositive</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>c<span class="token punctuation">.</span>dedicatedMarkWorkersNeeded<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// This P is now dedicated to marking until the end of</span>        <span class="token comment">// the concurrent mark phase.</span>        _p_<span class="token punctuation">.</span>gcMarkWorkerMode <span class="token operator">=</span> gcMarkWorkerDedicatedMode    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> c<span class="token punctuation">.</span>fractionalUtilizationGoal <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// No need for fractional workers.</span>        gcBgMarkWorkerPool<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>node<span class="token punctuation">.</span>node<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token boolean">nil</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// Is this P behind on the fractional utilization</span>        <span class="token comment">// goal?</span>        <span class="token comment">//</span>        <span class="token comment">// This should be kept in sync with pollFractionalWorkerExit.</span>        delta <span class="token operator">:=</span> <span class="token function">nanotime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> c<span class="token punctuation">.</span>markStartTime        <span class="token keyword">if</span> delta <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token function">float64</span><span class="token punctuation">(</span>_p_<span class="token punctuation">.</span>gcFractionalMarkTime<span class="token punctuation">)</span><span class="token operator">/</span><span class="token function">float64</span><span class="token punctuation">(</span>delta<span class="token punctuation">)</span> <span class="token operator">></span> c<span class="token punctuation">.</span>fractionalUtilizationGoal <span class="token punctuation">&#123;</span>            <span class="token comment">// Nope. No need to run a fractional worker.</span>            gcBgMarkWorkerPool<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>node<span class="token punctuation">.</span>node<span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token boolean">nil</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// Run a fractional worker.</span>        _p_<span class="token punctuation">.</span>gcMarkWorkerMode <span class="token operator">=</span> gcMarkWorkerFractionalMode    <span class="token punctuation">&#125;</span>    <span class="token comment">// Run the background mark worker.</span>    <span class="token comment">// 修改 workerg 的状态并返回</span>    gp <span class="token operator">:=</span> node<span class="token punctuation">.</span>gp<span class="token punctuation">.</span><span class="token function">ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token function">casgstatus</span><span class="token punctuation">(</span>gp<span class="token punctuation">,</span> _Gwaiting<span class="token punctuation">,</span> _Grunnable<span class="token punctuation">)</span>    <span class="token keyword">if</span> trace<span class="token punctuation">.</span>enabled <span class="token punctuation">&#123;</span>        <span class="token function">traceGoUnpark</span><span class="token punctuation">(</span>gp<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> gp<span class="token punctuation">&#125;</span><span class="token comment">// gcMarkWorkAvailable reports whether executing a mark worker</span><span class="token comment">// on p is potentially useful. p may be nil, in which case it only</span><span class="token comment">// checks the global sources of work.</span><span class="token comment">/*该函数主要作用：返回是否有标记工作可以干gcw p的队列work 全局队列*/</span><span class="token keyword">func</span> <span class="token function">gcMarkWorkAvailable</span><span class="token punctuation">(</span>p <span class="token operator">*</span>p<span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> p <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>p<span class="token punctuation">.</span>gcw<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token operator">!</span>work<span class="token punctuation">.</span>full<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span> <span class="token comment">// global work available</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> work<span class="token punctuation">.</span>markrootNext <span class="token operator">&lt;</span> work<span class="token punctuation">.</span>markrootJobs <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span> <span class="token comment">// root scan work available</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="剖析-gcBgMarkWorker-创建过程"><a href="#剖析-gcBgMarkWorker-创建过程" class="headerlink" title="剖析 gcBgMarkWorker 创建过程"></a>剖析 gcBgMarkWorker 创建过程</h2><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// gcBgMarkStartWorkers prepares background mark worker goroutines. These</span><span class="token comment">// goroutines will not run until the mark phase, but they must be started while</span><span class="token comment">// the work is not stopped and from a regular G stack. The caller must hold</span><span class="token comment">// worldsema.</span><span class="token keyword">func</span> <span class="token function">gcBgMarkStartWorkers</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// Background marking is performed by per-P G's. Ensure that each P has</span>    <span class="token comment">// a background GC G.</span>    <span class="token comment">//</span>    <span class="token comment">// Worker Gs don't exit if gomaxprocs is reduced. If it is raised</span>    <span class="token comment">// again, we can reuse the old workers; no need to create new workers.</span>    <span class="token keyword">for</span> gcBgMarkWorkerCount <span class="token operator">&lt;</span> gomaxprocs <span class="token punctuation">&#123;</span>        <span class="token keyword">go</span> <span class="token function">gcBgMarkWorker</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token function">notetsleepg</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>work<span class="token punctuation">.</span>bgMarkReady<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token function">noteclear</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>work<span class="token punctuation">.</span>bgMarkReady<span class="token punctuation">)</span>        <span class="token comment">// The worker is now guaranteed to be added to the pool before</span>        <span class="token comment">// its P's next findRunnableGCWorker.</span>        gcBgMarkWorkerCount<span class="token operator">++</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>由上可知，所有 gcMarkWorker 都是通过该函数创建的，我们需要关注的是 <code>notesleepg()</code> 和 <code>go gcBgMarkWorker</code> 这两行代码</li></ul><h3 id="notesleepg"><a href="#notesleepg" class="headerlink" title="notesleepg"></a><code>notesleepg</code></h3><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// same as runtime·notetsleep, but called on user g (not g0)</span><span class="token comment">// calls only nosplit functions between entersyscallblock/exitsyscall</span><span class="token keyword">func</span> <span class="token function">notetsleepg</span><span class="token punctuation">(</span>n <span class="token operator">*</span>note<span class="token punctuation">,</span> ns <span class="token builtin">int64</span><span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">&#123;</span>    gp <span class="token operator">:=</span> <span class="token function">getg</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> gp <span class="token operator">==</span> gp<span class="token punctuation">.</span>m<span class="token punctuation">.</span>g0 <span class="token punctuation">&#123;</span>        <span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">"notetsleepg on g0"</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 这个我们在学习 timer 的时候已经看过了</span>    <span class="token comment">// 主要就是执行 handoff</span>    <span class="token function">entersyscallblock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment">// 这里才是真正进行系统调用的地方，ns = -1，会无休止的休眠</span>    <span class="token comment">// 直到通过 wakeup 唤醒</span>    ok <span class="token operator">:=</span> <span class="token function">notetsleep_internal</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> ns<span class="token punctuation">)</span>    <span class="token comment">// 上述，通过 wakeup 唤醒后会继续执行这块代码</span>    <span class="token comment">// 该函数主要是给刚刚剥离的 GM 找一个 P</span>    <span class="token comment">// 找到了，执行</span>    <span class="token comment">// 没找到，把 g 放到全局队列</span>    <span class="token function">exitsyscall</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> ok<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="go-gcBgMarkWorker"><a href="#go-gcBgMarkWorker" class="headerlink" title="go gcBgMarkWorker"></a><code>go gcBgMarkWorker</code></h3><ul><li>这里应用到 MPG 调度的知识点，我们通过 go 关键字新建一个 goroutine，放入 runnext 等待被调度。</li></ul><h3 id="结合着看"><a href="#结合着看" class="headerlink" title="结合着看"></a>结合着看</h3><p>我们假设现在只有一个 P，即 <code>runtime.GOMAXPROCS(1)</code> 。这时我们来看上述代码，其执行过程为：</p><ul><li>1.通过 <code>gcBgMarkStartWorkers</code> 创建 worker</li><li>2.worker 被放入 runnext 等待被调度</li><li>3.执行 <code>notesleepg</code><ul><li>handoffp</li><li>futex &amp;&amp; timeout = -1</li><li>第 3 步执行完成后，GM 已经从 P 上剥离</li></ul></li><li>4.handoffp 中会启动一个 M 继续执行调度循环</li><li>5.newM 从 P 上找 G 执行</li><li>6.拿到我们刚刚创建的 newg</li><li>7.进入到 <code>gcBgMarkWorker()</code> 中执行<ul><li>新建 node &amp;&amp; <strong>wakeup</strong> 休眠的 GM</li><li>然后 <code>gopark</code> 挂起 worker 等待唤醒</li></ul></li><li>8.休眠的 GM 醒来后<ul><li>尝试获取 oldp</li><li>如果获取不到则，尝试获取 idlep</li><li>如果获取不到则，将 g 放入全局队列</li></ul></li><li>9.第 8 步中的 g 被调度后，会继续执行 create worker 的工作，回到第 1 步 继续执行</li></ul><h2 id="gcMarkWorker-执行过程"><a href="#gcMarkWorker-执行过程" class="headerlink" title="gcMarkWorker 执行过程"></a>gcMarkWorker 执行过程</h2><h3 id="gcBgMarkWorker-源码剖析"><a href="#gcBgMarkWorker-源码剖析" class="headerlink" title="gcBgMarkWorker 源码剖析"></a>gcBgMarkWorker 源码剖析</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">gcBgMarkWorker</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    gp <span class="token operator">:=</span> <span class="token function">getg</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment">// We pass node to a gopark unlock function, so it can't be on</span>    <span class="token comment">// the stack (see gopark). Prevent deadlock from recursively</span>    <span class="token comment">// starting GC by disabling preemption.</span>    gp<span class="token punctuation">.</span>m<span class="token punctuation">.</span>preemptoff <span class="token operator">=</span> <span class="token string">"GC worker init"</span>    node <span class="token operator">:=</span> <span class="token function">new</span><span class="token punctuation">(</span>gcBgMarkWorkerNode<span class="token punctuation">)</span>    gp<span class="token punctuation">.</span>m<span class="token punctuation">.</span>preemptoff <span class="token operator">=</span> <span class="token string">""</span>    node<span class="token punctuation">.</span>gp<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>gp<span class="token punctuation">)</span>    node<span class="token punctuation">.</span>m<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token function">acquirem</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token function">notewakeup</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>work<span class="token punctuation">.</span>bgMarkReady<span class="token punctuation">)</span>    <span class="token comment">// After this point, the background mark worker is generally scheduled</span>    <span class="token comment">// cooperatively by gcController.findRunnableGCWorker. While performing</span>    <span class="token comment">// work on the P, preemption is disabled because we are working on</span>    <span class="token comment">// P-local work buffers. When the preempt flag is set, this puts itself</span>    <span class="token comment">// into _Gwaiting to be woken up by gcController.findRunnableGCWorker</span>    <span class="token comment">// at the appropriate time.</span>    <span class="token comment">//</span>    <span class="token comment">// When preemption is enabled (e.g., while in gcMarkDone), this worker</span>    <span class="token comment">// may be preempted and schedule as a _Grunnable G from a runq. That is</span>    <span class="token comment">// fine; it will eventually gopark again for further scheduling via</span>    <span class="token comment">// findRunnableGCWorker.</span>    <span class="token comment">//</span>    <span class="token comment">// Since we disable preemption before notifying bgMarkReady, we</span>    <span class="token comment">// guarantee that this G will be in the worker pool for the next</span>    <span class="token comment">// findRunnableGCWorker. This isn't strictly necessary, but it reduces</span>    <span class="token comment">// latency between _GCmark starting and the workers starting.</span>    <span class="token keyword">for</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// Go to sleep until woken by</span>        <span class="token comment">// gcController.findRunnableGCWorker.</span>        <span class="token function">gopark</span><span class="token punctuation">(</span><span class="token keyword">func</span><span class="token punctuation">(</span>g <span class="token operator">*</span>g<span class="token punctuation">,</span> nodep unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">&#123;</span>            node <span class="token operator">:=</span> <span class="token punctuation">(</span><span class="token operator">*</span>gcBgMarkWorkerNode<span class="token punctuation">)</span><span class="token punctuation">(</span>nodep<span class="token punctuation">)</span>            <span class="token keyword">if</span> mp <span class="token operator">:=</span> node<span class="token punctuation">.</span>m<span class="token punctuation">.</span><span class="token function">ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> mp <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// The worker G is no longer running; release</span>                <span class="token comment">// the M.</span>                <span class="token comment">//</span>                <span class="token comment">// N.B. it is _safe_ to release the M as soon</span>                <span class="token comment">// as we are no longer performing P-local mark</span>                <span class="token comment">// work.</span>                <span class="token comment">//</span>                <span class="token comment">// However, since we cooperatively stop work</span>                <span class="token comment">// when gp.preempt is set, if we releasem in</span>                <span class="token comment">// the loop then the following call to gopark</span>                <span class="token comment">// would immediately preempt the G. This is</span>                <span class="token comment">// also safe, but inefficient: the G must</span>                <span class="token comment">// schedule again only to enter gopark and park</span>                <span class="token comment">// again. Thus, we defer the release until</span>                <span class="token comment">// after parking the G.</span>                <span class="token function">releasem</span><span class="token punctuation">(</span>mp<span class="token punctuation">)</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">// Release this G to the pool.</span>            gcBgMarkWorkerPool<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>node<span class="token punctuation">.</span>node<span class="token punctuation">)</span>            <span class="token comment">// Note that at this point, the G may immediately be</span>            <span class="token comment">// rescheduled and may be running.</span>            <span class="token keyword">return</span> <span class="token boolean">true</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">,</span> waitReasonGCWorkerIdle<span class="token punctuation">,</span> traceEvGoBlock<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token comment">/*        以上代码都已经解释过了        */</span>        <span class="token comment">/*        TODO 关于在 GC 期间什么时候可以抢占，什么时候禁止抢占        还需要进一步研究，目前可以先把整个流程梳理下来        */</span>        <span class="token comment">// Preemption must not occur here, or another G might see</span>        <span class="token comment">// p.gcMarkWorkerMode.</span>        <span class="token comment">// Disable preemption so we can use the gcw. If the</span>        <span class="token comment">// scheduler wants to preempt us, we'll stop draining,</span>        <span class="token comment">// dispose the gcw, and then preempt.</span>        node<span class="token punctuation">.</span>m<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token function">acquirem</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        pp <span class="token operator">:=</span> gp<span class="token punctuation">.</span>m<span class="token punctuation">.</span>p<span class="token punctuation">.</span><span class="token function">ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// P can't change with preemption disabled.</span>        <span class="token comment">// 是否已开启标记</span>        <span class="token keyword">if</span> gcBlackenEnabled <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>            <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"worker mode"</span><span class="token punctuation">,</span> pp<span class="token punctuation">.</span>gcMarkWorkerMode<span class="token punctuation">)</span>            <span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">"gcBgMarkWorker: blackening not enabled"</span><span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 检查 markworker 的 Mode</span>        <span class="token keyword">if</span> pp<span class="token punctuation">.</span>gcMarkWorkerMode <span class="token operator">==</span> gcMarkWorkerNotWorker <span class="token punctuation">&#123;</span>            <span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">"gcBgMarkWorker: mode not set"</span><span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 记录 worker 标记的开始时间</span>        startTime <span class="token operator">:=</span> <span class="token function">nanotime</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        pp<span class="token punctuation">.</span>gcMarkWorkerStartTime <span class="token operator">=</span> startTime        <span class="token comment">// 将等待执行的 worker 数量减一</span>        decnwait <span class="token operator">:=</span> atomic<span class="token punctuation">.</span><span class="token function">Xadd</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>work<span class="token punctuation">.</span>nwait<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> decnwait <span class="token operator">==</span> work<span class="token punctuation">.</span>nproc <span class="token punctuation">&#123;</span>            <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"runtime: work.nwait="</span><span class="token punctuation">,</span> decnwait<span class="token punctuation">,</span> <span class="token string">"work.nproc="</span><span class="token punctuation">,</span> work<span class="token punctuation">.</span>nproc<span class="token punctuation">)</span>            <span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">"work.nwait was > work.nproc"</span><span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span>        <span class="token function">systemstack</span><span class="token punctuation">(</span><span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// Mark our goroutine preemptible so its stack</span>            <span class="token comment">// can be scanned. This lets two mark workers</span>            <span class="token comment">// scan each other (otherwise, they would</span>            <span class="token comment">// deadlock). We must not modify anything on</span>            <span class="token comment">// the G stack. However, stack shrinking is</span>            <span class="token comment">// disabled for mark workers, so it is safe to</span>            <span class="token comment">// read from the G stack.</span>            <span class="token comment">// 关于这里为什么把 G 的 running 状态修改为 waiting 状态</span>            <span class="token comment">// TODO 需要进一步的研究，曹大说要结合 suspendG 来看</span>            <span class="token function">casgstatus</span><span class="token punctuation">(</span>gp<span class="token punctuation">,</span> _Grunning<span class="token punctuation">,</span> _Gwaiting<span class="token punctuation">)</span>            <span class="token keyword">switch</span> pp<span class="token punctuation">.</span>gcMarkWorkerMode <span class="token punctuation">&#123;</span>                <span class="token keyword">default</span><span class="token punctuation">:</span>                <span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">"gcBgMarkWorker: unexpected gcMarkWorkerMode"</span><span class="token punctuation">)</span>                <span class="token keyword">case</span> gcMarkWorkerDedicatedMode<span class="token punctuation">:</span>                <span class="token function">gcDrain</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pp<span class="token punctuation">.</span>gcw<span class="token punctuation">,</span> gcDrainUntilPreempt<span class="token operator">|</span>gcDrainFlushBgCredit<span class="token punctuation">)</span>                    <span class="token keyword">if</span> gp<span class="token punctuation">.</span>preempt <span class="token punctuation">&#123;</span>                        <span class="token comment">// We were preempted. This is</span>                        <span class="token comment">// a useful signal to kick</span>                        <span class="token comment">// everything out of the run</span>                        <span class="token comment">// queue so it can run</span>                        <span class="token comment">// somewhere else.</span>                        <span class="token keyword">if</span> drainQ<span class="token punctuation">,</span> n <span class="token operator">:=</span> <span class="token function">runqdrain</span><span class="token punctuation">(</span>pp<span class="token punctuation">)</span><span class="token punctuation">;</span> n <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>                            <span class="token function">lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sched<span class="token punctuation">.</span>lock<span class="token punctuation">)</span>                            <span class="token function">globrunqputbatch</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>drainQ<span class="token punctuation">,</span> <span class="token function">int32</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span>                            <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sched<span class="token punctuation">.</span>lock<span class="token punctuation">)</span>                        <span class="token punctuation">&#125;</span>                    <span class="token punctuation">&#125;</span>                    <span class="token comment">// Go back to draining, this time</span>                    <span class="token comment">// without preemption.</span>                    <span class="token function">gcDrain</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pp<span class="token punctuation">.</span>gcw<span class="token punctuation">,</span> gcDrainFlushBgCredit<span class="token punctuation">)</span>                <span class="token keyword">case</span> gcMarkWorkerFractionalMode<span class="token punctuation">:</span>                <span class="token function">gcDrain</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pp<span class="token punctuation">.</span>gcw<span class="token punctuation">,</span> gcDrainFractional<span class="token operator">|</span>gcDrainUntilPreempt<span class="token operator">|</span>gcDrainFlushBgCredit<span class="token punctuation">)</span>                <span class="token keyword">case</span> gcMarkWorkerIdleMode<span class="token punctuation">:</span>                <span class="token function">gcDrain</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pp<span class="token punctuation">.</span>gcw<span class="token punctuation">,</span> gcDrainIdle<span class="token operator">|</span>gcDrainUntilPreempt<span class="token operator">|</span>gcDrainFlushBgCredit<span class="token punctuation">)</span>            <span class="token punctuation">&#125;</span>            <span class="token function">casgstatus</span><span class="token punctuation">(</span>gp<span class="token punctuation">,</span> _Gwaiting<span class="token punctuation">,</span> _Grunning<span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>        <span class="token comment">// Account for time.</span>        duration <span class="token operator">:=</span> <span class="token function">nanotime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> startTime        <span class="token keyword">switch</span> pp<span class="token punctuation">.</span>gcMarkWorkerMode <span class="token punctuation">&#123;</span>            <span class="token keyword">case</span> gcMarkWorkerDedicatedMode<span class="token punctuation">:</span>                atomic<span class="token punctuation">.</span><span class="token function">Xaddint64</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>gcController<span class="token punctuation">.</span>dedicatedMarkTime<span class="token punctuation">,</span> duration<span class="token punctuation">)</span>                atomic<span class="token punctuation">.</span><span class="token function">Xaddint64</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>gcController<span class="token punctuation">.</span>dedicatedMarkWorkersNeeded<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>            <span class="token keyword">case</span> gcMarkWorkerFractionalMode<span class="token punctuation">:</span>                atomic<span class="token punctuation">.</span><span class="token function">Xaddint64</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>gcController<span class="token punctuation">.</span>fractionalMarkTime<span class="token punctuation">,</span> duration<span class="token punctuation">)</span>                atomic<span class="token punctuation">.</span><span class="token function">Xaddint64</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pp<span class="token punctuation">.</span>gcFractionalMarkTime<span class="token punctuation">,</span> duration<span class="token punctuation">)</span>            <span class="token keyword">case</span> gcMarkWorkerIdleMode<span class="token punctuation">:</span>                atomic<span class="token punctuation">.</span><span class="token function">Xaddint64</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>gcController<span class="token punctuation">.</span>idleMarkTime<span class="token punctuation">,</span> duration<span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// Was this the last worker and did we run out</span>        <span class="token comment">// of work?</span>        incnwait <span class="token operator">:=</span> atomic<span class="token punctuation">.</span><span class="token function">Xadd</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>work<span class="token punctuation">.</span>nwait<span class="token punctuation">,</span> <span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> incnwait <span class="token operator">></span> work<span class="token punctuation">.</span>nproc <span class="token punctuation">&#123;</span>            <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"runtime: p.gcMarkWorkerMode="</span><span class="token punctuation">,</span> pp<span class="token punctuation">.</span>gcMarkWorkerMode<span class="token punctuation">,</span>                    <span class="token string">"work.nwait="</span><span class="token punctuation">,</span> incnwait<span class="token punctuation">,</span> <span class="token string">"work.nproc="</span><span class="token punctuation">,</span> work<span class="token punctuation">.</span>nproc<span class="token punctuation">)</span>            <span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">"work.nwait > work.nproc"</span><span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// We'll releasem after this point and thus this P may run</span>        <span class="token comment">// something else. We must clear the worker mode to avoid</span>        <span class="token comment">// attributing the mode to a different (non-worker) G in</span>        <span class="token comment">// traceGoStart.</span>        pp<span class="token punctuation">.</span>gcMarkWorkerMode <span class="token operator">=</span> gcMarkWorkerNotWorker        <span class="token comment">// If this worker reached a background mark completion</span>        <span class="token comment">// point, signal the main GC goroutine.</span>        <span class="token keyword">if</span> incnwait <span class="token operator">==</span> work<span class="token punctuation">.</span>nproc <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">gcMarkWorkAvailable</span><span class="token punctuation">(</span><span class="token boolean">nil</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// We don't need the P-local buffers here, allow</span>            <span class="token comment">// preemption becuse we may schedule like a regular</span>            <span class="token comment">// goroutine in gcMarkDone (block on locks, etc).</span>            <span class="token function">releasem</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>m<span class="token punctuation">.</span><span class="token function">ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            node<span class="token punctuation">.</span>m<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token boolean">nil</span><span class="token punctuation">)</span>            <span class="token function">gcMarkDone</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>gcMarkWorker 的状态（dedicated, fraction）这个状态是绑定在 P 上，并不是 G 的状态。</li></ul><h3 id="GC-标记的几个工作模式"><a href="#GC-标记的几个工作模式" class="headerlink" title="GC 标记的几个工作模式"></a>GC 标记的几个工作模式</h3><ol><li>gcDrainFlushBgCredit: 把 bgMarkWorker 积累的 credit 刷新到全局的 gcController 中。</li><li>gcDrainFractional: self-preempt 表示在达到 fractional 后自动退出。</li><li>gcDrainUntilPreempt: 一直执行，直到被抢占。</li><li>gcDrainIdle: 一直执行，直到其他任务要做。</li></ol><h3 id="bitmap-与-ha-的映射关系（标记过程用到的位图）"><a href="#bitmap-与-ha-的映射关系（标记过程用到的位图）" class="headerlink" title="bitmap 与 ha 的映射关系（标记过程用到的位图）"></a>bitmap 与 ha 的映射关系（标记过程用到的位图）</h3><h4 id="bitmap-的使用"><a href="#bitmap-的使用" class="headerlink" title="bitmap 的使用"></a>bitmap 的使用</h4><p>两个比特表示一个字</p><p>ha 64 M，bitmap 2 M，bitmap 中的一个字节可以表示ha连续4个指针的内存大小。</p><p>0-4，1-5， 2-6， 3-7 </p><p>低位 bit 用于表示是否为指针，0 为非指针，1 为指针。</p><p>高位 bit 用于表示是否要继续扫描该对象中后续的内容，0 为不需要，1 为需要。</p><p><img src="https://blogstatic.haohtml.com/uploads/2021/04/d2b5ca33bd970f64a6301fa75ae2eb22-6.png?x-oss-process=image/format,webp" alt="img"></p><h4 id="heapBitsForAddr"><a href="#heapBitsForAddr" class="headerlink" title="heapBitsForAddr"></a>heapBitsForAddr</h4><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// heapBitsForAddr returns the heapBits for the address addr.</span><span class="token comment">// The caller must ensure addr is in an allocated span.</span><span class="token comment">// In particular, be careful not to point past the end of an object.</span><span class="token comment">//</span><span class="token comment">// nosplit because it is used during write barriers and must not be preempted.</span><span class="token comment">//go:nosplit</span><span class="token keyword">func</span> <span class="token function">heapBitsForAddr</span><span class="token punctuation">(</span>addr <span class="token builtin">uintptr</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>h heapBits<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 2 bits per word, 4 pairs per byte, and a mask is hard coded.</span>    <span class="token comment">// 如注释所说，两个比特可以用来表示一个字的大小</span>    arena <span class="token operator">:=</span> <span class="token function">arenaIndex</span><span class="token punctuation">(</span>addr<span class="token punctuation">)</span>    ha <span class="token operator">:=</span> mheap_<span class="token punctuation">.</span>arenas<span class="token punctuation">[</span>arena<span class="token punctuation">.</span><span class="token function">l1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">[</span>arena<span class="token punctuation">.</span><span class="token function">l2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span>    <span class="token comment">// The compiler uses a load for nil checking ha, but in this</span>    <span class="token comment">// case we'll almost never hit that cache line again, so it</span>    <span class="token comment">// makes more sense to do a value check.</span>    <span class="token keyword">if</span> ha <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// addr is not in the heap. Return nil heapBits, which</span>        <span class="token comment">// we expect to crash in the caller.</span>        <span class="token keyword">return</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 笔者理解：之所以要 *4，就是因为 bitmap 与 ha 的映射关系</span>    <span class="token comment">// 一字节可以表示堆上 4 个连续的指针内存</span>    h<span class="token punctuation">.</span>bitp <span class="token operator">=</span> <span class="token operator">&amp;</span>ha<span class="token punctuation">.</span>bitmap<span class="token punctuation">[</span><span class="token punctuation">(</span>addr<span class="token operator">/</span><span class="token punctuation">(</span>sys<span class="token punctuation">.</span>PtrSize<span class="token operator">*</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">%</span>heapArenaBitmapBytes<span class="token punctuation">]</span>    <span class="token comment">// 笔者理解：shift 就像掩码一样，用来计算低位与高位比特的位置</span>    <span class="token comment">// &amp;3 的运算也能说明这一点，&amp;3 的结果只能是 0 1 2 3，</span>    <span class="token comment">// 这里就对应上了 8 比特的低四位</span>    h<span class="token punctuation">.</span>shift <span class="token operator">=</span> <span class="token function">uint32</span><span class="token punctuation">(</span><span class="token punctuation">(</span>addr <span class="token operator">/</span> sys<span class="token punctuation">.</span>PtrSize<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">3</span><span class="token punctuation">)</span>    <span class="token comment">// 记录当前 arena 的位置</span>    h<span class="token punctuation">.</span>arena <span class="token operator">=</span> <span class="token function">uint32</span><span class="token punctuation">(</span>arena<span class="token punctuation">)</span>    <span class="token comment">// 记录当前 arena 对应的 bitmap 中的最后一字节</span>    h<span class="token punctuation">.</span>last <span class="token operator">=</span> <span class="token operator">&amp;</span>ha<span class="token punctuation">.</span>bitmap<span class="token punctuation">[</span><span class="token function">len</span><span class="token punctuation">(</span>ha<span class="token punctuation">.</span>bitmap<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>    <span class="token keyword">return</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// next returns the heapBits describing the next pointer-sized word in memory.</span><span class="token comment">// That is, if h describes address p, h.next() describes p+ptrSize.</span><span class="token comment">// Note that next does not modify h. The caller must record the result.</span><span class="token comment">//</span><span class="token comment">// 如注释所描述的，next 函数，返回描述了在内存中下一个指针类型的word的heapBits</span><span class="token comment">// 如果 h 表示的是指针 p 的地址，那么 h.next() 表示的就是 p+ptrSize 的heapBits</span><span class="token comment">// nosplit because it is used during write barriers and must not be preempted.</span><span class="token comment">//go:nosplit</span><span class="token keyword">func</span> <span class="token punctuation">(</span>h heapBits<span class="token punctuation">)</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> heapBits <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> h<span class="token punctuation">.</span>shift <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token operator">*</span>heapBitsShift <span class="token punctuation">&#123;</span> <span class="token comment">// 在同一字节上扫描，四个连续的ptr还没扫描完</span>        h<span class="token punctuation">.</span>shift <span class="token operator">+=</span> heapBitsShift    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> h<span class="token punctuation">.</span>bitp <span class="token operator">!=</span> h<span class="token punctuation">.</span>last <span class="token punctuation">&#123;</span><span class="token comment">// 如果没扫描到该 bitmap 的最后一字节，那么扫描下一个byte</span>        h<span class="token punctuation">.</span>bitp<span class="token punctuation">,</span> h<span class="token punctuation">.</span>shift <span class="token operator">=</span> <span class="token function">add1</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>bitp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span><span class="token comment">// 此时，当前已经扫描完了当前 ha 的所有内容，移动到下一个 ha 进行扫描</span>        <span class="token comment">// Move to the next arena.</span>        <span class="token keyword">return</span> h<span class="token punctuation">.</span><span class="token function">nextArena</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> h<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="gcDrain-标记过程"><a href="#gcDrain-标记过程" class="headerlink" title="gcDrain 标记过程"></a>gcDrain 标记过程</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// gcDrain 扫描 work buffer 中的根节点和对象，</span><span class="token comment">// gcDrain 会将队列中所有的对象标记为灰色。</span><span class="token comment">// gcDrain 可能在 GC 结束前返回。</span><span class="token comment">// gcDrain 的调用者负责平衡当前 P 与 其他 P 的标记工作。</span><span class="token comment">//go:nowritebarrier</span><span class="token keyword">func</span> <span class="token function">gcDrain</span><span class="token punctuation">(</span>gcw <span class="token operator">*</span>gcWork<span class="token punctuation">,</span> flags gcDrainFlags<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token operator">!</span>writeBarrier<span class="token punctuation">.</span>needed <span class="token punctuation">&#123;</span>        <span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">"gcDrain phase incorrect"</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    gp <span class="token operator">:=</span> <span class="token function">getg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>m<span class="token punctuation">.</span>curg    preemptible <span class="token operator">:=</span> flags<span class="token operator">&amp;</span>gcDrainUntilPreempt <span class="token operator">!=</span> <span class="token number">0</span>    flushBgCredit <span class="token operator">:=</span> flags<span class="token operator">&amp;</span>gcDrainFlushBgCredit <span class="token operator">!=</span> <span class="token number">0</span>    idle <span class="token operator">:=</span> flags<span class="token operator">&amp;</span>gcDrainIdle <span class="token operator">!=</span> <span class="token number">0</span>    initScanWork <span class="token operator">:=</span> gcw<span class="token punctuation">.</span>scanWork    <span class="token comment">// checkWork is the scan work before performing the next</span>    <span class="token comment">// self-preempt check.</span>    checkWork <span class="token operator">:=</span> <span class="token function">int64</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">63</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">var</span> check <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">bool</span>    <span class="token keyword">if</span> flags<span class="token operator">&amp;</span><span class="token punctuation">(</span>gcDrainIdle<span class="token operator">|</span>gcDrainFractional<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>        checkWork <span class="token operator">=</span> initScanWork <span class="token operator">+</span> drainCheckThreshold        <span class="token keyword">if</span> idle <span class="token punctuation">&#123;</span>            check <span class="token operator">=</span> pollWork        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> flags<span class="token operator">&amp;</span>gcDrainFractional <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>            check <span class="token operator">=</span> pollFractionalWorkerExit        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// Drain root marking jobs.</span>    <span class="token comment">// 判断当前标记的位置是否超出了总的标记数量</span>    <span class="token keyword">if</span> work<span class="token punctuation">.</span>markrootNext <span class="token operator">&lt;</span> work<span class="token punctuation">.</span>markrootJobs <span class="token punctuation">&#123;</span>        <span class="token comment">// Stop if we're preemptible or if someone wants to STW.</span>        <span class="token keyword">for</span> <span class="token operator">!</span><span class="token punctuation">(</span>gp<span class="token punctuation">.</span>preempt <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>preemptible <span class="token operator">||</span> atomic<span class="token punctuation">.</span><span class="token function">Load</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sched<span class="token punctuation">.</span>gcwaiting<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            job <span class="token operator">:=</span> atomic<span class="token punctuation">.</span><span class="token function">Xadd</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>work<span class="token punctuation">.</span>markrootNext<span class="token punctuation">,</span> <span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>            <span class="token keyword">if</span> job <span class="token operator">>=</span> work<span class="token punctuation">.</span>markrootJobs <span class="token punctuation">&#123;</span>                <span class="token keyword">break</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">// 对 job 索引位置的 root 进行标记工作</span>            <span class="token function">markroot</span><span class="token punctuation">(</span>gcw<span class="token punctuation">,</span> job<span class="token punctuation">)</span>            <span class="token comment">// 完成一个根的标记工作，就去检查</span>            <span class="token comment">// TODO 是否达到了 fractional 或者 其他</span>            <span class="token keyword">if</span> check <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token operator">&amp;&amp;</span> <span class="token function">check</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">goto</span> done            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// Drain heap marking jobs.</span>    <span class="token comment">// Stop if we're preemptible or if someone wants to STW.</span>    <span class="token keyword">for</span> <span class="token operator">!</span><span class="token punctuation">(</span>gp<span class="token punctuation">.</span>preempt <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>preemptible <span class="token operator">||</span> atomic<span class="token punctuation">.</span><span class="token function">Load</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sched<span class="token punctuation">.</span>gcwaiting<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// Try to keep work available on the global queue. We used to</span>        <span class="token comment">// check if there were waiting workers, but it's better to</span>        <span class="token comment">// just keep work available than to make workers wait. In the</span>        <span class="token comment">// worst case, we'll do O(log(_WorkbufSize)) unnecessary</span>        <span class="token comment">// balances.</span>        <span class="token comment">// 平衡标记工作，让它有活可干比让它等着要好</span>        <span class="token keyword">if</span> work<span class="token punctuation">.</span>full <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>            gcw<span class="token punctuation">.</span><span class="token function">balance</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 从 gcw 队列中取值</span>        b <span class="token operator">:=</span> gcw<span class="token punctuation">.</span><span class="token function">tryGetFast</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> b <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>            b <span class="token operator">=</span> gcw<span class="token punctuation">.</span><span class="token function">tryGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> b <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// Flush the write barrier</span>                <span class="token comment">// buffer; this may create</span>                <span class="token comment">// more work.</span>                如果说 wbuf 中都没有，将                <span class="token function">wbBufFlush</span><span class="token punctuation">(</span><span class="token boolean">nil</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>                b <span class="token operator">=</span> gcw<span class="token punctuation">.</span><span class="token function">tryGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> b <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// Unable to get work.</span>            <span class="token keyword">break</span>        <span class="token punctuation">&#125;</span>        <span class="token function">scanobject</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> gcw<span class="token punctuation">)</span>        <span class="token comment">// Flush background scan work credit to the global</span>        <span class="token comment">// account if we've accumulated enough locally so</span>        <span class="token comment">// mutator assists can draw on it.</span>        <span class="token keyword">if</span> gcw<span class="token punctuation">.</span>scanWork <span class="token operator">>=</span> gcCreditSlack <span class="token punctuation">&#123;</span>            atomic<span class="token punctuation">.</span><span class="token function">Xaddint64</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>gcController<span class="token punctuation">.</span>scanWork<span class="token punctuation">,</span> gcw<span class="token punctuation">.</span>scanWork<span class="token punctuation">)</span>            <span class="token keyword">if</span> flushBgCredit <span class="token punctuation">&#123;</span>                <span class="token function">gcFlushBgCredit</span><span class="token punctuation">(</span>gcw<span class="token punctuation">.</span>scanWork <span class="token operator">-</span> initScanWork<span class="token punctuation">)</span>                initScanWork <span class="token operator">=</span> <span class="token number">0</span>            <span class="token punctuation">&#125;</span>            checkWork <span class="token operator">-=</span> gcw<span class="token punctuation">.</span>scanWork            gcw<span class="token punctuation">.</span>scanWork <span class="token operator">=</span> <span class="token number">0</span>            <span class="token keyword">if</span> checkWork <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>                checkWork <span class="token operator">+=</span> drainCheckThreshold                <span class="token keyword">if</span> check <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token operator">&amp;&amp;</span> <span class="token function">check</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">break</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    done<span class="token punctuation">:</span>    <span class="token comment">// Flush remaining scan work credit.</span>    <span class="token keyword">if</span> gcw<span class="token punctuation">.</span>scanWork <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>        atomic<span class="token punctuation">.</span><span class="token function">Xaddint64</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>gcController<span class="token punctuation">.</span>scanWork<span class="token punctuation">,</span> gcw<span class="token punctuation">.</span>scanWork<span class="token punctuation">)</span>        <span class="token keyword">if</span> flushBgCredit <span class="token punctuation">&#123;</span>            <span class="token function">gcFlushBgCredit</span><span class="token punctuation">(</span>gcw<span class="token punctuation">.</span>scanWork <span class="token operator">-</span> initScanWork<span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span>        gcw<span class="token punctuation">.</span>scanWork <span class="token operator">=</span> <span class="token number">0</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="标记工作的平衡"><a href="#标记工作的平衡" class="headerlink" title="标记工作的平衡"></a>标记工作的平衡</h4><h5 id="balance"><a href="#balance" class="headerlink" title="balance"></a>balance</h5><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// balance moves some work that's cached in this gcWork back on the</span><span class="token comment">// global queue.</span><span class="token comment">// 将缓存在 P gcw 上的标记任务，适当的移动到全局queue中</span><span class="token comment">//go:nowritebarrierrec</span><span class="token keyword">func</span> <span class="token punctuation">(</span>w <span class="token operator">*</span>gcWork<span class="token punctuation">)</span> <span class="token function">balance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 如果 P 的本地 wbf 没有标记任务，直接返回</span>    <span class="token keyword">if</span> w<span class="token punctuation">.</span>wbuf1 <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/*   1.先处理 wbuf2 中的数据，如果有，将数据放入到   全局 work full 队列中   2.查看 wbuf1 中对象数量，超过四个，执行 handoff   */</span>    <span class="token keyword">if</span> wbuf <span class="token operator">:=</span> w<span class="token punctuation">.</span>wbuf2<span class="token punctuation">;</span> wbuf<span class="token punctuation">.</span>nobj <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>        <span class="token function">putfull</span><span class="token punctuation">(</span>wbuf<span class="token punctuation">)</span>        w<span class="token punctuation">.</span>flushedWork <span class="token operator">=</span> <span class="token boolean">true</span>        w<span class="token punctuation">.</span>wbuf2 <span class="token operator">=</span> <span class="token function">getempty</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> wbuf <span class="token operator">:=</span> w<span class="token punctuation">.</span>wbuf1<span class="token punctuation">;</span> wbuf<span class="token punctuation">.</span>nobj <span class="token operator">></span> <span class="token number">4</span> <span class="token punctuation">&#123;</span>        w<span class="token punctuation">.</span>wbuf1 <span class="token operator">=</span> <span class="token function">handoff</span><span class="token punctuation">(</span>wbuf<span class="token punctuation">)</span>        w<span class="token punctuation">.</span>flushedWork <span class="token operator">=</span> <span class="token boolean">true</span> <span class="token comment">// handoff did putfull</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// We flushed a buffer to the full list, so wake a worker.</span>    <span class="token keyword">if</span> gcphase <span class="token operator">==</span> _GCmark <span class="token punctuation">&#123;</span>        gcController<span class="token punctuation">.</span><span class="token function">enlistWorker</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="enlistWorker"><a href="#enlistWorker" class="headerlink" title="enlistWorker"></a>enlistWorker</h5><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// enlistWorker encourages another dedicated mark worker to start on</span><span class="token comment">// another P if there are spare worker slots. It is used by putfull</span><span class="token comment">// when more work is made available.</span><span class="token comment">//</span><span class="token comment">//go:nowritebarrier</span><span class="token keyword">func</span> <span class="token punctuation">(</span>c <span class="token operator">*</span>gcControllerState<span class="token punctuation">)</span> <span class="token function">enlistWorker</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// If there are idle Ps, wake one so it will run an idle worker.</span>    <span class="token comment">// NOTE: This is suspected of causing deadlocks. See golang.org/issue/19112.</span>    <span class="token comment">//</span>    <span class="token comment">// if atomic.Load(&amp;sched.npidle) != 0 &amp;&amp; atomic.Load(&amp;sched.nmspinning) == 0 &#123;</span>    <span class="token comment">//    wakep()</span>    <span class="token comment">//    return</span>    <span class="token comment">// &#125;</span>    <span class="token comment">// There are no idle Ps. If we need more dedicated workers,</span>    <span class="token comment">// try to preempt a running P so it will switch to a worker.</span>    <span class="token keyword">if</span> c<span class="token punctuation">.</span>dedicatedMarkWorkersNeeded <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// Pick a random other P to preempt.</span>    <span class="token keyword">if</span> gomaxprocs <span class="token operator">&lt;=</span> <span class="token number">1</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span>    <span class="token punctuation">&#125;</span>    gp <span class="token operator">:=</span> <span class="token function">getg</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> gp <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token operator">||</span> gp<span class="token punctuation">.</span>m <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token operator">||</span> gp<span class="token punctuation">.</span>m<span class="token punctuation">.</span>p <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span>    <span class="token punctuation">&#125;</span>    myID <span class="token operator">:=</span> gp<span class="token punctuation">.</span>m<span class="token punctuation">.</span>p<span class="token punctuation">.</span><span class="token function">ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>id    <span class="token keyword">for</span> tries <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> tries <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> tries<span class="token operator">++</span> <span class="token punctuation">&#123;</span>        id <span class="token operator">:=</span> <span class="token function">int32</span><span class="token punctuation">(</span><span class="token function">fastrandn</span><span class="token punctuation">(</span><span class="token function">uint32</span><span class="token punctuation">(</span>gomaxprocs <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> id <span class="token operator">>=</span> myID <span class="token punctuation">&#123;</span>            id<span class="token operator">++</span>        <span class="token punctuation">&#125;</span>        p <span class="token operator">:=</span> allp<span class="token punctuation">[</span>id<span class="token punctuation">]</span>        <span class="token keyword">if</span> p<span class="token punctuation">.</span>status <span class="token operator">!=</span> _Prunning <span class="token punctuation">&#123;</span>            <span class="token keyword">continue</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 执行抢占</span>        <span class="token keyword">if</span> <span class="token function">preemptone</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    不知道你们想没想过这样一个问题，通过 preemptone 函数进行抢占，是怎么做到去启动一个 gcMarkWorker 的？</p><p>​    如果你没想到的话，给你一点提示，和调度循环相关。</p><h5 id="handoff"><a href="#handoff" class="headerlink" title="handoff"></a>handoff</h5><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// 在 wbuf 中对象数量大于 4 时，将前一半放入到全局 work full 队列中</span><span class="token comment">//go:nowritebarrier</span><span class="token keyword">func</span> <span class="token function">handoff</span><span class="token punctuation">(</span>b <span class="token operator">*</span>workbuf<span class="token punctuation">)</span> <span class="token operator">*</span>workbuf <span class="token punctuation">&#123;</span>    <span class="token comment">// Make new buffer with half of b's pointers.</span>    b1 <span class="token operator">:=</span> <span class="token function">getempty</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    n <span class="token operator">:=</span> b<span class="token punctuation">.</span>nobj <span class="token operator">/</span> <span class="token number">2</span>    b<span class="token punctuation">.</span>nobj <span class="token operator">-=</span> n    b1<span class="token punctuation">.</span>nobj <span class="token operator">=</span> n    <span class="token comment">// 通过获取一个新的 empty workbuf</span>    <span class="token comment">// 将前一半放进去</span>    <span class="token function">memmove</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>b1<span class="token punctuation">.</span>obj<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>b<span class="token punctuation">.</span>obj<span class="token punctuation">[</span>b<span class="token punctuation">.</span>nobj<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token operator">*</span>unsafe<span class="token punctuation">.</span><span class="token function">Sizeof</span><span class="token punctuation">(</span>b1<span class="token punctuation">.</span>obj<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment">// Put b on full list - let first half of b get stolen.</span>    <span class="token function">putfull</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>    <span class="token keyword">return</span> b1<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="GC-过程中-P-的-gcw-队列"><a href="#GC-过程中-P-的-gcw-队列" class="headerlink" title="GC 过程中 P 的 gcw 队列"></a>GC 过程中 P 的 gcw 队列</h4><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> P <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">)</span>    <span class="token comment">// gcw is this P's GC work buffer cache. The work buffer is</span>    <span class="token comment">// filled by write barriers, drained by mutator assists, and</span>    <span class="token comment">// disposed on certain GC state transitions.</span>    gcw gcWork    <span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以下是 Go 官方对 gcw 的描述：</p><p>为灰色指针对象实现了一个生产者/消费者模型。对象被标记为灰色后，放入到队列中。对象被标记为黑色后，会在队列中移除。</p><p>写屏障，根节点扫描，栈扫描和对象扫描过程会产生灰色对象。scanning 过程会消费灰色对象的指针并且有可能产生新的灰色对象指针。</p><p>gcWork 为垃圾回收器提供了一个生产和消费的接口。</p><p>可以在 stack 上这样使用 gcWork：</p><ul><li>调用 gcw.Put() 进行生产，调用 gcw.tryGet() 进行消费。</li></ul><p>重要的是，在 mark phase 使用 gcWork 可以阻止垃圾回收器从 transitioning 转变为 mark termination 因为 gcWork 可能在本地保存 GC work buffers。这可以通过禁用抢占来完成。</p><h5 id="wbuf1-和-wbuf2"><a href="#wbuf1-和-wbuf2" class="headerlink" title="wbuf1 和 wbuf2"></a>wbuf1 和 wbuf2</h5><p>可以将 wbuf1 和 wbuf2 想象成一块栈空间，然后这俩轮流使用。</p><p>当我们弹出队列中最后一个指针时，我们通过引入一个新的缓冲区并丢弃一个空缓冲区（交换这两个缓冲区），然后将 stack 向上移动一个新 buffer。 当我们将buffers都填满了，我们通过引入一个新的空缓冲区并丢弃那个满的缓冲区，然后将stack向下移动一个新 buffer。</p><p>这样我们就有了一个缓冲区的滞后值，它可以将获取或放置工作缓冲区的成本分摊到至少一个工作缓冲区上，并减少全局工作列表上的争用。</p><p>wbuf1 永远都是我们正在操作的那个 buffer，wbuf2 是接下来要丢弃的缓冲区。</p><p>总结：</p><p>wbuf1 和 wbuf2 都是用来存储灰色指针的，wbuf1 是我们真正操作的那个队列，入队出队操作的都是它，wbuf2 起到的是替换作用，当 wbuf1 空了，替换 wbuf2，当 wbuf1 满了，替换 wbuf2。</p><h5 id="work-full-和-work-empty"><a href="#work-full-和-work-empty" class="headerlink" title="work.full 和 work.empty"></a>work.full 和 work.empty</h5><p>全局 work 中有两个队列，full 和 empty，灰色对象入队过程：</p><p>fastPath: 检查 wbuf1 是否为空，是否满了，是就返回；都不是，将灰色对象入队。<br>slowPath：检查 wbuf1 是否为 nil，为 nil，执行初始化。否则，判断是否满了，满了，交换 wbuf1 和 wbuf2，再次判断 wbuf1 是否满了，满了加入到全局 full 队列中，然后从 empty 队列获取一个空的并赋值给 wbuf1，最后把这个灰色对象入队。</p><h4 id="GC-过程中负责标记的函数"><a href="#GC-过程中负责标记的函数" class="headerlink" title="GC 过程中负责标记的函数"></a>GC 过程中负责标记的函数</h4><h5 id="markroot"><a href="#markroot" class="headerlink" title="markroot"></a>markroot</h5><p>markroot 主要是根据不同的 i 来定位要扫描哪些区域，当 i == 0 ，i == 1 时，对应到以下两种情况，具体的含义暂时还不清晰。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// TODO 了解这两种分别是什么</span><span class="token keyword">case</span> i <span class="token operator">==</span> fixedRootFinalizers<span class="token punctuation">:</span>   <span class="token keyword">for</span> fb <span class="token operator">:=</span> allfin<span class="token punctuation">;</span> fb <span class="token operator">!=</span> <span class="token boolean">nil</span><span class="token punctuation">;</span> fb <span class="token operator">=</span> fb<span class="token punctuation">.</span>alllink <span class="token punctuation">&#123;</span>      cnt <span class="token operator">:=</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>atomic<span class="token punctuation">.</span><span class="token function">Load</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>fb<span class="token punctuation">.</span>cnt<span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token function">scanblock</span><span class="token punctuation">(</span><span class="token function">uintptr</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>fb<span class="token punctuation">.</span>fin<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> cnt<span class="token operator">*</span>unsafe<span class="token punctuation">.</span><span class="token function">Sizeof</span><span class="token punctuation">(</span>fb<span class="token punctuation">.</span>fin<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>finptrmask<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> gcw<span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">)</span>   <span class="token punctuation">&#125;</span><span class="token keyword">case</span> i <span class="token operator">==</span> fixedRootFreeGStacks<span class="token punctuation">:</span>   <span class="token comment">// Switch to the system stack so we can call</span>   <span class="token comment">// stackfree.</span>   <span class="token function">systemstack</span><span class="token punctuation">(</span>markrootFreeGStacks<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="scanobject"><a href="#scanobject" class="headerlink" title="scanobject"></a>scanobject</h5><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// scanobject scans the object starting at b, adding pointers to gcw.</span><span class="token comment">// b must point to the beginning of a heap object or an oblet.</span><span class="token comment">// scanobject consults the GC bitmap for the pointer mask and the</span><span class="token comment">// spans for the size of the object.</span><span class="token comment">//</span><span class="token comment">// 如注释所写，scanobject 扫描从 b 为起始地址的对象，并添加指针到 gcw 队列中。</span><span class="token comment">// b 必须指向堆对象的起始地址，或者一个 oblet。</span><span class="token comment">//go:nowritebarrier</span><span class="token keyword">func</span> <span class="token function">scanobject</span><span class="token punctuation">(</span>b <span class="token builtin">uintptr</span><span class="token punctuation">,</span> gcw <span class="token operator">*</span>gcWork<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// Find the bits for b and the size of the object at b.</span>    <span class="token comment">//</span>    <span class="token comment">// b is either the beginning of an object, in which case this</span>    <span class="token comment">// is the size of the object to scan, or it points to an</span>    <span class="token comment">// oblet, in which case we compute the size to scan below.</span>    <span class="token comment">// 这个函数前边已经详细的分析过了，没啥好说的</span>    hbits <span class="token operator">:=</span> <span class="token function">heapBitsForAddr</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>    <span class="token comment">// 找到指针 b 对应的 mspan</span>    s <span class="token operator">:=</span> <span class="token function">spanOfUnchecked</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>    <span class="token comment">// s.elemsize 表示的是一个 object 的大小</span>    n <span class="token operator">:=</span> s<span class="token punctuation">.</span>elemsize    <span class="token keyword">if</span> n <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>        <span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">"scanobject n == 0"</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/*这里对大对象（这里的大对象与内存分配的有些许差异内存分配大对象指的是大于32KB的，这里指的是大于 128KB的）进行了进一步的区分maxobletBytes = 128 &lt;&lt; 10 = 128 KB意味着，当前 obj 的大小超过了 128 KB要进行一些优化操作*/</span>    <span class="token keyword">if</span> n <span class="token operator">></span> maxObletBytes <span class="token punctuation">&#123;</span>        <span class="token comment">// Large object. Break into oblets for better</span>        <span class="token comment">// parallelism and lower latency.</span>        <span class="token keyword">if</span> b <span class="token operator">==</span> s<span class="token punctuation">.</span><span class="token function">base</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// It's possible this is a noscan object (not</span>            <span class="token comment">// from greyobject, but from other code</span>            <span class="token comment">// paths), in which case we must *not* enqueue</span>            <span class="token comment">// oblets since their bitmaps will be</span>            <span class="token comment">// uninitialized.</span>            <span class="token keyword">if</span> s<span class="token punctuation">.</span>spanclass<span class="token punctuation">.</span><span class="token function">noscan</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// Bypass the whole scan.</span>                gcw<span class="token punctuation">.</span>bytesMarked <span class="token operator">+=</span> <span class="token function">uint64</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span>                <span class="token keyword">return</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">// Enqueue the other oblets to scan later.</span>            <span class="token comment">// Some oblets may be in b's scalar tail, but</span>            <span class="token comment">// these will be marked as "no more pointers",</span>            <span class="token comment">// so we'll drop out immediately when we go to</span>            <span class="token comment">// scan those.</span>            <span class="token keyword">for</span> oblet <span class="token operator">:=</span> b <span class="token operator">+</span> maxObletBytes<span class="token punctuation">;</span> oblet <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">base</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span>s<span class="token punctuation">.</span>elemsize<span class="token punctuation">;</span> oblet <span class="token operator">+=</span> maxObletBytes <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token operator">!</span>gcw<span class="token punctuation">.</span><span class="token function">putFast</span><span class="token punctuation">(</span>oblet<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    gcw<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>oblet<span class="token punctuation">)</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// Compute the size of the oblet. Since this object</span>        <span class="token comment">// must be a large object, s.base() is the beginning</span>        <span class="token comment">// of the object.</span>        n <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">base</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> s<span class="token punctuation">.</span>elemsize <span class="token operator">-</span> b        <span class="token keyword">if</span> n <span class="token operator">></span> maxObletBytes <span class="token punctuation">&#123;</span>            n <span class="token operator">=</span> maxObletBytes        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">var</span> i <span class="token builtin">uintptr</span>    <span class="token comment">// i &lt; n 说明 mspan 中，只对当前这个对象进行扫描</span>    <span class="token comment">// 执行完一次 for 循环，并不意味着扫描完当前这个对象了</span>    <span class="token comment">// 只是检查了当前两个比特对应的一个字</span>    <span class="token comment">// 除非当前这个对象是不需要扫描的即，bits&amp;bitScan == 0</span>    <span class="token keyword">for</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token punctuation">,</span> hbits <span class="token operator">=</span> i<span class="token operator">+</span>sys<span class="token punctuation">.</span>PtrSize<span class="token punctuation">,</span> hbits<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// Load bits once. See CL 22712 and issue 16973 for discussion.</span>        bits <span class="token operator">:=</span> hbits<span class="token punctuation">.</span><span class="token function">bits</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment">// 这里的两个 if 判断就好像两个卡尺</span>        <span class="token comment">// 分别对高位和低位进行检查</span>        <span class="token keyword">if</span> bits<span class="token operator">&amp;</span>bitScan <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">break</span> <span class="token comment">// no more pointers in this object</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> bits<span class="token operator">&amp;</span>bitPointer <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">continue</span> <span class="token comment">// not a pointer</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// Work here is duplicated in scanblock and above.</span>        <span class="token comment">// If you make changes here, make changes there too.</span>        <span class="token comment">/*设 fakeObj = (*uintptr)(unsafe.Pointer(b + i))对 fakeObj 解引用 --> *fakeObj            1.解出来结果 != 0，说明是一个指针            2.解出来结果 == 0，说明结果为 nil        */</span>        obj <span class="token operator">:=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token builtin">uintptr</span><span class="token punctuation">)</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>b <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment">// At this point we have extracted the next potential pointer.</span>        <span class="token comment">// Quickly filter out nil and pointers back to the current object.</span>        <span class="token comment">// 如果 obj 是一个指针，并且指向的不是当前 object</span>        <span class="token comment">// 笔者理解：之所以要过滤掉当前的 object，</span>        <span class="token comment">// 是因为当前这个 object 就是从 gcw 队列中取出来的</span>        <span class="token comment">// 所以也就不需要再对该 obj 进行标记（入队）</span>        <span class="token keyword">if</span> obj <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> obj<span class="token operator">-</span>b <span class="token operator">>=</span> n <span class="token punctuation">&#123;</span>            <span class="token comment">// Test if obj points into the Go heap and, if so,</span>            <span class="token comment">// mark the object.</span>            <span class="token comment">// 检查 obj 是否指向了 Go 的堆，如果是，对这个 obj 进行标记</span>            <span class="token comment">//</span>            <span class="token comment">// Note that it's possible for findObject to</span>            <span class="token comment">// fail if obj points to a just-allocated heap</span>            <span class="token comment">// object because of a race with growing the</span>            <span class="token comment">// heap. In this case, we know the object was</span>            <span class="token comment">// just allocated and hence will be marked by</span>            <span class="token comment">// allocation itself.</span>            <span class="token keyword">if</span> obj<span class="token punctuation">,</span> span<span class="token punctuation">,</span> objIndex <span class="token operator">:=</span> <span class="token function">findObject</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> b<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span> obj <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>                <span class="token function">greyobject</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> b<span class="token punctuation">,</span> i<span class="token punctuation">,</span> span<span class="token punctuation">,</span> gcw<span class="token punctuation">,</span> objIndex<span class="token punctuation">)</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 记录刚刚被扫描的 obj 大小</span>    gcw<span class="token punctuation">.</span>bytesMarked <span class="token operator">+=</span> <span class="token function">uint64</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span>    <span class="token comment">// 积累 credit，到了 2000 就更新到全局 gcCrontroller 中</span>    gcw<span class="token punctuation">.</span>scanWork <span class="token operator">+=</span> <span class="token function">int64</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="findObject"><a href="#findObject" class="headerlink" title="findObject"></a>findObject</h5><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">/*参数解释：refBase, refOff 主要 panic 用返回值解释：base: 表示 p 指针所在对象，在堆中的起始地址s: 表示 p 指针所在的 mspanobjIndex: 表示包含 p 指针的对象在 mspan 中的位置*/</span><span class="token comment">//go:nosplit</span><span class="token keyword">func</span> <span class="token function">findObject</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> refBase<span class="token punctuation">,</span> refOff <span class="token builtin">uintptr</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>base <span class="token builtin">uintptr</span><span class="token punctuation">,</span> s <span class="token operator">*</span>mspan<span class="token punctuation">,</span> objIndex <span class="token builtin">uintptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    s <span class="token operator">=</span> <span class="token function">spanOf</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">)</span> <span class="token comment">// 省略检查代码</span>        objIndex <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">objIndex</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span>    base <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">base</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> objIndex<span class="token operator">*</span>s<span class="token punctuation">.</span>elemsize    <span class="token keyword">return</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="markrootBlock"><a href="#markrootBlock" class="headerlink" title="markrootBlock"></a>markrootBlock</h5><h5 id="markrootFreeGStacks"><a href="#markrootFreeGStacks" class="headerlink" title="markrootFreeGStacks"></a>markrootFreeGStacks</h5><h5 id="markrootSpans"><a href="#markrootSpans" class="headerlink" title="markrootSpans"></a>markrootSpans</h5><h5 id="scanstack"><a href="#scanstack" class="headerlink" title="scanstack"></a>scanstack</h5><p>扫描 goroutine 栈</p><h5 id="scanblock"><a href="#scanblock" class="headerlink" title="scanblock"></a>scanblock</h5><h5 id="gcmarknewobject"><a href="#gcmarknewobject" class="headerlink" title="gcmarknewobject"></a>gcmarknewobject</h5><h5 id="gcMarkTinyAllocs"><a href="#gcMarkTinyAllocs" class="headerlink" title="gcMarkTinyAllocs"></a>gcMarkTinyAllocs</h5><h2 id="番外篇"><a href="#番外篇" class="headerlink" title="番外篇"></a>番外篇</h2><h3 id="suspendG"><a href="#suspendG" class="headerlink" title="suspendG"></a>suspendG</h3><ul><li>从全局 g 队列中获取一个，这个 g 有可能是一下几种情况<ul><li>正在别的 P 上运行</li><li>正在进行系统调用</li><li>正在某个地方等待</li><li>已经是可执行状态</li><li>正在发生抢占</li><li>也可能是当前这个 gcMarkWorker</li></ul></li></ul><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">/*    suspendG 在一个安全时刻暂停 goroutine 并且返回被挂起 goroutine 的状态。    suspendG 的调用者拥有该 goroutine 的读权限直到调用的 resumeG。    多个调用者在同一时刻想挂起同一个 goroutine 是安全的。    The goroutine may execute between subsequent successful suspend operations.    当前的实现为互斥访问 goroutine，因此多个调用者的访问会被串行化。    然而，这样的目的是为了读共享，所以请不要依赖互斥访问。    suspendG 一定要在 system stack 上调用并且当前 M 上的 goroutine 一定是可以被抢占的状态。这阻止了两个 goroutine 尝试相互挂起但是他们都处在非抢占状态下发生死锁的情况。虽然还有其他的方式可以解决死锁，但是这种是最简单的方式。*/</span><span class="token comment">//go:systemstack</span><span class="token keyword">func</span> <span class="token function">suspendG</span><span class="token punctuation">(</span>gp <span class="token operator">*</span>g<span class="token punctuation">)</span> suspendGState <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> mp <span class="token operator">:=</span> <span class="token function">getg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>m<span class="token punctuation">;</span> mp<span class="token punctuation">.</span>curg <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token operator">&amp;&amp;</span> <span class="token function">readgstatus</span><span class="token punctuation">(</span>mp<span class="token punctuation">.</span>curg<span class="token punctuation">)</span> <span class="token operator">==</span> _Grunning <span class="token punctuation">&#123;</span>        <span class="token comment">// Since we're on the system stack of this M, the user</span>        <span class="token comment">// G is stuck at an unsafe point. If another goroutine</span>        <span class="token comment">// were to try to preempt m.curg, it could deadlock.</span>        <span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">"suspendG from non-preemptible goroutine"</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// See https://golang.org/cl/21503 for justification of the yield delay.</span>    <span class="token keyword">const</span> yieldDelay <span class="token operator">=</span> <span class="token number">10</span> <span class="token operator">*</span> <span class="token number">1000</span>    <span class="token keyword">var</span> nextYield <span class="token builtin">int64</span>    <span class="token comment">// Drive the goroutine to a preemption point.</span>    stopped <span class="token operator">:=</span> <span class="token boolean">false</span>    <span class="token keyword">var</span> asyncM <span class="token operator">*</span>m    <span class="token keyword">var</span> asyncGen <span class="token builtin">uint32</span>    <span class="token keyword">var</span> nextPreemptM <span class="token builtin">int64</span>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">switch</span> s <span class="token operator">:=</span> <span class="token function">readgstatus</span><span class="token punctuation">(</span>gp<span class="token punctuation">)</span><span class="token punctuation">;</span> s <span class="token punctuation">&#123;</span>            <span class="token keyword">default</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> s<span class="token operator">&amp;</span>_Gscan <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// Someone else is suspending it. Wait</span>                <span class="token comment">// for them to finish.</span>                <span class="token comment">//</span>                <span class="token comment">// TODO: It would be nicer if we could</span>                <span class="token comment">// coalesce suspends.</span>                <span class="token keyword">break</span>            <span class="token punctuation">&#125;</span>            <span class="token function">dumpgstatus</span><span class="token punctuation">(</span>gp<span class="token punctuation">)</span>            <span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">"invalid g status"</span><span class="token punctuation">)</span>            <span class="token keyword">case</span> _Gdead<span class="token punctuation">:</span>            <span class="token comment">// Nothing to suspend.</span>            <span class="token comment">//</span>            <span class="token comment">// preemptStop may need to be cleared, but</span>            <span class="token comment">// doing that here could race with goroutine</span>            <span class="token comment">// reuse. Instead, goexit0 clears it.</span>            <span class="token keyword">return</span> suspendGState<span class="token punctuation">&#123;</span>dead<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">&#125;</span>            <span class="token keyword">case</span> _Gcopystack<span class="token punctuation">:</span>            <span class="token comment">// The stack is being copied. We need to wait</span>            <span class="token comment">// until this is done.</span>            <span class="token keyword">case</span> _Gpreempted<span class="token punctuation">:</span>            <span class="token comment">// We (or someone else) suspended the G. Claim</span>            <span class="token comment">// ownership of it by transitioning it to</span>            <span class="token comment">// _Gwaiting.</span>            <span class="token keyword">if</span> <span class="token operator">!</span><span class="token function">casGFromPreempted</span><span class="token punctuation">(</span>gp<span class="token punctuation">,</span> _Gpreempted<span class="token punctuation">,</span> _Gwaiting<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">break</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">// We stopped the G, so we have to ready it later.</span>            stopped <span class="token operator">=</span> <span class="token boolean">true</span>            s <span class="token operator">=</span> _Gwaiting            <span class="token keyword">fallthrough</span>            <span class="token keyword">case</span> _Grunnable<span class="token punctuation">,</span> _Gsyscall<span class="token punctuation">,</span> _Gwaiting<span class="token punctuation">:</span>            <span class="token comment">// Claim goroutine by setting scan bit.</span>            <span class="token comment">// This may race with execution or readying of gp.</span>            <span class="token comment">// The scan bit keeps it from transition state.</span>            <span class="token keyword">if</span> <span class="token operator">!</span><span class="token function">castogscanstatus</span><span class="token punctuation">(</span>gp<span class="token punctuation">,</span> s<span class="token punctuation">,</span> s<span class="token operator">|</span>_Gscan<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">break</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">// Clear the preemption request. It's safe to</span>            <span class="token comment">// reset the stack guard because we hold the</span>            <span class="token comment">// _Gscan bit and thus own the stack.</span>            gp<span class="token punctuation">.</span>preemptStop <span class="token operator">=</span> <span class="token boolean">false</span>            gp<span class="token punctuation">.</span>preempt <span class="token operator">=</span> <span class="token boolean">false</span>            gp<span class="token punctuation">.</span>stackguard0 <span class="token operator">=</span> gp<span class="token punctuation">.</span>stack<span class="token punctuation">.</span>lo <span class="token operator">+</span> _StackGuard            <span class="token comment">// The goroutine was already at a safe-point</span>            <span class="token comment">// and we've now locked that in.</span>            <span class="token comment">//</span>            <span class="token comment">// TODO: It would be much better if we didn't</span>            <span class="token comment">// leave it in _Gscan, but instead gently</span>            <span class="token comment">// prevented its scheduling until resumption.</span>            <span class="token comment">// Maybe we only use this to bump a suspended</span>            <span class="token comment">// count and the scheduler skips suspended</span>            <span class="token comment">// goroutines? That wouldn't be enough for</span>            <span class="token comment">// &#123;_Gsyscall,_Gwaiting&#125; -> _Grunning. Maybe</span>            <span class="token comment">// for all those transitions we need to check</span>            <span class="token comment">// suspended and deschedule?</span>            <span class="token keyword">return</span> suspendGState<span class="token punctuation">&#123;</span>g<span class="token punctuation">:</span> gp<span class="token punctuation">,</span> stopped<span class="token punctuation">:</span> stopped<span class="token punctuation">&#125;</span>            <span class="token keyword">case</span> _Grunning<span class="token punctuation">:</span>            <span class="token comment">// Optimization: if there is already a pending preemption request</span>            <span class="token comment">// (from the previous loop iteration), don't bother with the atomics.</span>            <span class="token keyword">if</span> gp<span class="token punctuation">.</span>preemptStop <span class="token operator">&amp;&amp;</span> gp<span class="token punctuation">.</span>preempt <span class="token operator">&amp;&amp;</span> gp<span class="token punctuation">.</span>stackguard0 <span class="token operator">==</span> stackPreempt <span class="token operator">&amp;&amp;</span> asyncM <span class="token operator">==</span> gp<span class="token punctuation">.</span>m <span class="token operator">&amp;&amp;</span> atomic<span class="token punctuation">.</span><span class="token function">Load</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>asyncM<span class="token punctuation">.</span>preemptGen<span class="token punctuation">)</span> <span class="token operator">==</span> asyncGen <span class="token punctuation">&#123;</span>                <span class="token keyword">break</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">// Temporarily block state transitions.</span>            <span class="token keyword">if</span> <span class="token operator">!</span><span class="token function">castogscanstatus</span><span class="token punctuation">(</span>gp<span class="token punctuation">,</span> _Grunning<span class="token punctuation">,</span> _Gscanrunning<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">break</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">// Request synchronous preemption.</span>            gp<span class="token punctuation">.</span>preemptStop <span class="token operator">=</span> <span class="token boolean">true</span>            gp<span class="token punctuation">.</span>preempt <span class="token operator">=</span> <span class="token boolean">true</span>            gp<span class="token punctuation">.</span>stackguard0 <span class="token operator">=</span> stackPreempt            <span class="token comment">// Prepare for asynchronous preemption.</span>            asyncM2 <span class="token operator">:=</span> gp<span class="token punctuation">.</span>m            asyncGen2 <span class="token operator">:=</span> atomic<span class="token punctuation">.</span><span class="token function">Load</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>asyncM2<span class="token punctuation">.</span>preemptGen<span class="token punctuation">)</span>            needAsync <span class="token operator">:=</span> asyncM <span class="token operator">!=</span> asyncM2 <span class="token operator">||</span> asyncGen <span class="token operator">!=</span> asyncGen2            asyncM <span class="token operator">=</span> asyncM2            asyncGen <span class="token operator">=</span> asyncGen2            <span class="token function">casfrom_Gscanstatus</span><span class="token punctuation">(</span>gp<span class="token punctuation">,</span> _Gscanrunning<span class="token punctuation">,</span> _Grunning<span class="token punctuation">)</span>            <span class="token comment">// Send asynchronous preemption. We do this</span>            <span class="token comment">// after CASing the G back to _Grunning</span>            <span class="token comment">// because preemptM may be synchronous and we</span>            <span class="token comment">// don't want to catch the G just spinning on</span>            <span class="token comment">// its status.</span>            <span class="token keyword">if</span> preemptMSupported <span class="token operator">&amp;&amp;</span> debug<span class="token punctuation">.</span>asyncpreemptoff <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> needAsync <span class="token punctuation">&#123;</span>                <span class="token comment">// Rate limit preemptM calls. This is</span>                <span class="token comment">// particularly important on Windows</span>                <span class="token comment">// where preemptM is actually</span>                <span class="token comment">// synchronous and the spin loop here</span>                <span class="token comment">// can lead to live-lock.</span>                now <span class="token operator">:=</span> <span class="token function">nanotime</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token keyword">if</span> now <span class="token operator">>=</span> nextPreemptM <span class="token punctuation">&#123;</span>                    nextPreemptM <span class="token operator">=</span> now <span class="token operator">+</span> yieldDelay<span class="token operator">/</span><span class="token number">2</span>                    <span class="token function">preemptM</span><span class="token punctuation">(</span>asyncM<span class="token punctuation">)</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// TODO: Don't busy wait. This loop should really only</span>        <span class="token comment">// be a simple read/decide/CAS loop that only fails if</span>        <span class="token comment">// there's an active race. Once the CAS succeeds, we</span>        <span class="token comment">// should queue up the preemption (which will require</span>        <span class="token comment">// it to be reliable in the _Grunning case, not</span>        <span class="token comment">// best-effort) and then sleep until we're notified</span>        <span class="token comment">// that the goroutine is suspended.</span>        <span class="token keyword">if</span> i <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>            nextYield <span class="token operator">=</span> <span class="token function">nanotime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> yieldDelay        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token function">nanotime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> nextYield <span class="token punctuation">&#123;</span>            <span class="token function">procyield</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token function">osyield</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            nextYield <span class="token operator">=</span> <span class="token function">nanotime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> yieldDelay<span class="token operator">/</span><span class="token number">2</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="resumeG"><a href="#resumeG" class="headerlink" title="resumeG"></a>resumeG</h3>]]></content>
    
    
    <summary type="html">&lt;p&gt;Golang GC 垃圾回收知识点总结，有些内容还没有完成，只是抛出了问题.. &lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>GC from go comments</title>
    <link href="https://bqyang.top/2021/GCComments/"/>
    <id>https://bqyang.top/2021/GCComments/</id>
    <published>2021-11-25T11:02:41.887Z</published>
    <updated>2021-11-25T11:10:16.064Z</updated>
    
    <content type="html"><![CDATA[<p>来自 Go 官方对 GC 的解释。</p><span id="more"></span><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// Garbage collector (GC).</span><span class="token comment">//</span><span class="token comment">// The GC runs concurrently with mutator threads, is type accurate (aka precise), allows multiple</span><span class="token comment">// GC thread to run in parallel. It is a concurrent mark and sweep that uses a write barrier. It is</span><span class="token comment">// non-generational and non-compacting. Allocation is done using size segregated per P allocation</span><span class="token comment">// areas to minimize fragmentation while eliminating locks in the common case.</span><span class="token comment">//</span><span class="token comment">// The algorithm decomposes into several steps.</span><span class="token comment">// This is a high level description of the algorithm being used. For an overview of GC a good</span><span class="token comment">// place to start is Richard Jones' gchandbook.org.</span><span class="token comment">//</span><span class="token comment">// The algorithm's intellectual heritage includes Dijkstra's on-the-fly algorithm, see</span><span class="token comment">// Edsger W. Dijkstra, Leslie Lamport, A. J. Martin, C. S. Scholten, and E. F. M. Steffens. 1978.</span><span class="token comment">// On-the-fly garbage collection: an exercise in cooperation. Commun. ACM 21, 11 (November 1978),</span><span class="token comment">// 966-975.</span><span class="token comment">// For journal quality proofs that these steps are complete, correct, and terminate see</span><span class="token comment">// Hudson, R., and Moss, J.E.B. Copying Garbage Collection without stopping the world.</span><span class="token comment">// Concurrency and Computation: Practice and Experience 15(3-5), 2003.</span><span class="token comment">//</span><span class="token comment">// 1. GC performs sweep termination.</span><span class="token comment">//</span><span class="token comment">//    a. Stop the world. This causes all Ps to reach a GC safe-point.</span><span class="token comment">//</span><span class="token comment">//    b. Sweep any unswept spans. There will only be unswept spans if</span><span class="token comment">//    this GC cycle was forced before the expected time.</span><span class="token comment">//</span><span class="token comment">// 2. GC performs the mark phase.</span><span class="token comment">//</span><span class="token comment">//    a. Prepare for the mark phase by setting gcphase to _GCmark</span><span class="token comment">//    (from _GCoff), enabling the write barrier, enabling mutator</span><span class="token comment">//    assists, and enqueueing root mark jobs. No objects may be</span><span class="token comment">//    scanned until all Ps have enabled the write barrier, which is</span><span class="token comment">//    accomplished using STW.</span><span class="token comment">//</span><span class="token comment">//    b. Start the world. From this point, GC work is done by mark</span><span class="token comment">//    workers started by the scheduler and by assists performed as</span><span class="token comment">//    part of allocation. The write barrier shades both the</span><span class="token comment">//    overwritten pointer and the new pointer value for any pointer</span><span class="token comment">//    writes (see mbarrier.go for details). Newly allocated objects</span><span class="token comment">//    are immediately marked black.</span><span class="token comment">//</span><span class="token comment">//    c. GC performs root marking jobs. This includes scanning all</span><span class="token comment">//    stacks, shading all globals, and shading any heap pointers in</span><span class="token comment">//    off-heap runtime data structures. Scanning a stack stops a</span><span class="token comment">//    goroutine, shades any pointers found on its stack, and then</span><span class="token comment">//    resumes the goroutine.</span><span class="token comment">//</span><span class="token comment">//    d. GC drains the work queue of grey objects, scanning each grey</span><span class="token comment">//    object to black and shading all pointers found in the object</span><span class="token comment">//    (which in turn may add those pointers to the work queue).</span><span class="token comment">//</span><span class="token comment">//    e. Because GC work is spread across local caches, GC uses a</span><span class="token comment">//    distributed termination algorithm to detect when there are no</span><span class="token comment">//    more root marking jobs or grey objects (see gcMarkDone). At this</span><span class="token comment">//    point, GC transitions to mark termination.</span><span class="token comment">//</span><span class="token comment">// 3. GC performs mark termination.</span><span class="token comment">//</span><span class="token comment">//    a. Stop the world.</span><span class="token comment">//</span><span class="token comment">//    b. Set gcphase to _GCmarktermination, and disable workers and</span><span class="token comment">//    assists.</span><span class="token comment">//</span><span class="token comment">//    c. Perform housekeeping like flushing mcaches.</span><span class="token comment">//</span><span class="token comment">// 4. GC performs the sweep phase.</span><span class="token comment">//</span><span class="token comment">//    a. Prepare for the sweep phase by setting gcphase to _GCoff,</span><span class="token comment">//    setting up sweep state and disabling the write barrier.</span><span class="token comment">//</span><span class="token comment">//    b. Start the world. From this point on, newly allocated objects</span><span class="token comment">//    are white, and allocating sweeps spans before use if necessary.</span><span class="token comment">//</span><span class="token comment">//    c. GC does concurrent sweeping in the background and in response</span><span class="token comment">//    to allocation. See description below.</span><span class="token comment">//</span><span class="token comment">// 5. When sufficient allocation has taken place, replay the sequence</span><span class="token comment">// starting with 1 above. See discussion of GC rate below.</span><span class="token comment">// Concurrent sweep.</span><span class="token comment">//</span><span class="token comment">// The sweep phase proceeds concurrently with normal program execution.</span><span class="token comment">// The heap is swept span-by-span both lazily (when a goroutine needs another span)</span><span class="token comment">// and concurrently in a background goroutine (this helps programs that are not CPU bound).</span><span class="token comment">// At the end of STW mark termination all spans are marked as "needs sweeping".</span><span class="token comment">//</span><span class="token comment">// The background sweeper goroutine simply sweeps spans one-by-one.</span><span class="token comment">//</span><span class="token comment">// To avoid requesting more OS memory while there are unswept spans, when a</span><span class="token comment">// goroutine needs another span, it first attempts to reclaim that much memory</span><span class="token comment">// by sweeping. When a goroutine needs to allocate a new small-object span, it</span><span class="token comment">// sweeps small-object spans for the same object size until it frees at least</span><span class="token comment">// one object. When a goroutine needs to allocate large-object span from heap,</span><span class="token comment">// it sweeps spans until it frees at least that many pages into heap. There is</span><span class="token comment">// one case where this may not suffice: if a goroutine sweeps and frees two</span><span class="token comment">// nonadjacent one-page spans to the heap, it will allocate a new two-page</span><span class="token comment">// span, but there can still be other one-page unswept spans which could be</span><span class="token comment">// combined into a two-page span.</span><span class="token comment">//</span><span class="token comment">// It's critical to ensure that no operations proceed on unswept spans (that would corrupt</span><span class="token comment">// mark bits in GC bitmap). During GC all mcaches are flushed into the central cache,</span><span class="token comment">// so they are empty. When a goroutine grabs a new span into mcache, it sweeps it.</span><span class="token comment">// When a goroutine explicitly frees an object or sets a finalizer, it ensures that</span><span class="token comment">// the span is swept (either by sweeping it, or by waiting for the concurrent sweep to finish).</span><span class="token comment">// The finalizer goroutine is kicked off only when all spans are swept.</span><span class="token comment">// When the next GC starts, it sweeps all not-yet-swept spans (if any).</span><span class="token comment">// GC rate.</span><span class="token comment">// Next GC is after we've allocated an extra amount of memory proportional to</span><span class="token comment">// the amount already in use. The proportion is controlled by GOGC environment variable</span><span class="token comment">// (100 by default). If GOGC=100 and we're using 4M, we'll GC again when we get to 8M</span><span class="token comment">// (this mark is tracked in next_gc variable). This keeps the GC cost in linear</span><span class="token comment">// proportion to the allocation cost. Adjusting GOGC just changes the linear constant</span><span class="token comment">// (and also the amount of extra memory used).</span><span class="token comment">// Oblets</span><span class="token comment">//</span><span class="token comment">// In order to prevent long pauses while scanning large objects and to</span><span class="token comment">// improve parallelism, the garbage collector breaks up scan jobs for</span><span class="token comment">// objects larger than maxObletBytes into "oblets" of at most</span><span class="token comment">// maxObletBytes. When scanning encounters the beginning of a large</span><span class="token comment">// object, it scans only the first oblet and enqueues the remaining</span><span class="token comment">// oblets as new scan jobs.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;来自 Go 官方对 GC 的解释。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>第一次 pr</title>
    <link href="https://bqyang.top/2021/contributeToYunion/"/>
    <id>https://bqyang.top/2021/contributeToYunion/</id>
    <published>2021-11-22T12:57:58.886Z</published>
    <updated>2021-11-23T01:41:45.975Z</updated>
    
    <content type="html"><![CDATA[<p>所有工作时间加起来也有一年多快两年的时间了，实习了 8 个月，正式工作也有 10 个月了，加起来有一年半的工作经验了。</p><span id="more"></span> <p>事实一次又一次的证明了去大公司的必要性，就算没有办法去大公司，也要多接触在大厂上班的人，这就有点近朱者赤近墨者黑的意思。</p><p>大厂程序员能接触的面实在是太多了，他们带给我的感受就好像，井底之蛙。每天我所接触到的东西只有那么一点，或者说工作所能涉及到内容，再多也不会多到哪去。久而久之，与人家的差距自然就被拉开了。</p><p>说了点废话，只想和大家共勉，一定要好好学习，曹大说了，混几个你所在工作的领域相关的 commit 哈哈，对自己来说简历上还是能挂得住的，我们公司用的代码是一套开源的云管理平台，据说是买的人家商业版，在人家代码基础上做的二次开发。</p><p>二次开发做的真的是惨不忍睹，没有把人家的代码研究明白就开始在上边迭代，导致现在的代码维护成本非常高，再加上这套代码本身就非常复杂，各种高度抽象，各种回调、异步任务。我入职有快四个月了，还是有很多不明白的地方。</p><p>上个周五，2021-11-19，那天调试一个bug，当时就是跟自己较真，过不去这个坎，觉得今天要是解决不了这个问题，真的是太没用了。。所以周五到家后，又一直研究，trace代码，最后还是找到了问题出现的地方，跟这些异步任务属实是费劲。可能自己对这个bug的偏执，也说明了自己能力不足。</p><p>以前看到过一句话，不要对年轻人讲经验，他该走的弯路一个不会少。我其实是认同的，虽然在某些时候，前辈们的经验可以帮助我们减轻一些心理负担，但是真正需要自己站出来的时候，一个弯路都不会少的。</p><p>这次排查 bug 给我带来的收获，不仅仅是一个提 pr 的机会，更是一次开拓眼界的机会，或许也是迈向开源的一个机会。</p><p>贴上两张提 pr 的图片吧哈哈，相关的 reviewer 还没有 review 代码，希望可以顺利的被 merge！</p><p><img src="https://gitee.com/yangbaoqiang/images/raw/master/blogpics/pr1.png" alt="image"></p><p><img src="https://gitee.com/yangbaoqiang/images/raw/master/blogpics/pr2.png" alt="image"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;所有工作时间加起来也有一年多快两年的时间了，实习了 8 个月，正式工作也有 10 个月了，加起来有一年半的工作经验了。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>知识点准备</title>
    <link href="https://bqyang.top/2021/planB/"/>
    <id>https://bqyang.top/2021/planB/</id>
    <published>2021-11-22T12:48:56.495Z</published>
    <updated>2021-12-05T12:20:38.002Z</updated>
    
    <content type="html"><![CDATA[<p>整理一下看过的和没看过的知识点..</p><span id="more"></span><h2 id="语言方向："><a href="#语言方向：" class="headerlink" title="语言方向："></a>语言方向：</h2><h3 id="Golang"><a href="#Golang" class="headerlink" title="Golang"></a>Golang</h3><ul><li><p><input checked="" disabled="" type="checkbox">  timer</p></li><li><p><input disabled="" type="checkbox">  channel</p></li><li><p><input disabled="" type="checkbox">  map</p></li><li><p><input disabled="" type="checkbox">  slice</p></li><li><p><input disabled="" type="checkbox">  在 21 年结束的前，把 go 程序启动过程重新梳理一遍</p></li><li><p><input disabled="" type="checkbox">  在春节前，把 GMP 模型重新梳理</p></li><li><p><input disabled="" type="checkbox">  在元宵节前，内存分配模型重新梳理</p></li><li><p><input disabled="" type="checkbox">  在3月底之前完成上述任务，并完成 GC 内容的梳理</p></li></ul><p>目前 GC 的优先级排的比较高，现在已经梳理完了 GC 的启动过程，GC 的标记过程。</p><p>GC 的清扫逻辑还没看。</p><h3 id="Rust"><a href="#Rust" class="headerlink" title="Rust"></a>Rust</h3><ul><li><p><input disabled="" type="checkbox">  不做时间限制，了解一下 rust 的特性，以及语法</p><h2 id="数据库方向："><a href="#数据库方向：" class="headerlink" title="数据库方向："></a>数据库方向：</h2><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3></li><li><p><input disabled="" type="checkbox">  redis aof rdb</p></li><li><p><input disabled="" type="checkbox">  redis 的优缺点</p></li><li><p><input disabled="" type="checkbox">  redis 提供的数据结构以及底层实现</p></li><li><p><input disabled="" type="checkbox">  …</p><h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3></li><li><p><input disabled="" type="checkbox">  mysql 索引内容整理</p></li><li><p><input disabled="" type="checkbox">  mysql 语句的执行过程，select 举例</p></li><li><p><input disabled="" type="checkbox">  mysql 事务的隔离级别以及底层实现</p><h2 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h2><h3 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h3><h3 id="计算机操作系统"><a href="#计算机操作系统" class="headerlink" title="计算机操作系统"></a>计算机操作系统</h3><h3 id="计算机组成原理"><a href="#计算机组成原理" class="headerlink" title="计算机组成原理"></a>计算机组成原理</h3><h3 id="编译原理"><a href="#编译原理" class="headerlink" title="编译原理"></a>编译原理</h3></li><li><p><input disabled="" type="checkbox">  了解语法分析，词法分析，编译前端、中断、后端都做了什么</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;整理一下看过的和没看过的知识点..&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>一次上线故事</title>
    <link href="https://bqyang.top/2021/%E4%B8%80%E6%AC%A1%E4%B8%8A%E7%BA%BF%E6%95%85%E4%BA%8B/"/>
    <id>https://bqyang.top/2021/%E4%B8%80%E6%AC%A1%E4%B8%8A%E7%BA%BF%E6%95%85%E4%BA%8B/</id>
    <published>2021-11-20T02:20:21.369Z</published>
    <updated>2021-12-05T12:22:36.428Z</updated>
    
    <content type="html"><![CDATA[<p>人在北京，刚上线到家。由于时间比较晚了，也没必要带电脑回家，用手机备忘录记录下这愉快的一晚。</p><span id="more"></span><p>本次上线内容是另外两位同事的功能点，我心思应该没我啥事，就在工位上改 bug，没错又臭又长的 bug 哈哈。</p><p>就顺着时间轴记录一下吧，六点是上线时间，大家可以提前去填饱肚子，备足精力，回来就直接开整。我想等组内同事一起去吃，后来发现好像都不饿，等上线完事，都到家门口了，又跑回公司门口的兰州拉面点了一碗。您说说这，这不闲的难受么..</p><p>主要上线流程就是，后端、前端发版，测试测试，有问题修复，不可修复回滚.. 提前准备好回滚镜像，版本控制工具的重要性由此可见，就像程序员的左膀右臂。回想起实习的时候，干的第一件事情就是合代码，卧槽别提了，硬生生合了tm一个多小时，后来还是在同事帮助下搞定的。不过此时此刻，已是今非昔比哈哈。</p><p>今天晚上带给我感受最深的是工作氛围，那种紧而不乱，忙中带闲，出现问题大家都积极的去解决，没有命令，只有协商，那种互相尊重的感觉。不知道的就抛出问题，肯定会有人帮你想，帮你出主意，那种互帮互助的感觉。感觉这种东西并不长久，特此用文字的方式简单记录一下。</p><p>对了，最开始想着是没我啥事，后来真的有个bug是我之前处理过的，排查起来并不难，有意思的是在更新镜像的时候，张冠李戴了哈哈哈，这个确实有吓一跳。</p><p>杨宝强不强</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;人在北京，刚上线到家。由于时间比较晚了，也没必要带电脑回家，用手机备忘录记录下这愉快的一晚。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>工作现状</title>
    <link href="https://bqyang.top/2021/%E8%81%8A%E8%81%8A%E5%B7%A5%E4%BD%9C%E4%B8%8A%E7%9A%84%E5%B0%8F%E4%BA%8B/"/>
    <id>https://bqyang.top/2021/%E8%81%8A%E8%81%8A%E5%B7%A5%E4%BD%9C%E4%B8%8A%E7%9A%84%E5%B0%8F%E4%BA%8B/</id>
    <published>2021-11-17T01:34:27.819Z</published>
    <updated>2021-11-17T12:17:32.657Z</updated>
    
    <content type="html"><![CDATA[<p>今天要聊的与技术无关，简单聊聊最近。<br>闲聊工作，最近有点迷，每天也不知道在忙啥，除了改bug还是改bug，还不是我写的bug，给上一任擦屁股，感觉永远都擦不干净。（说起来挺恶心，事实就是很恶心）</p><span id="more"></span><p>我没什么职业规划，不知道该干啥，学习也不是因为感兴趣，只是单单觉得作为一个程序员，要有基本的职业素养。就像一名司机，虽然你日常开自动挡，但是学驾照依然考的手动挡。不为别的，多一手准备。</p><p>关于职业规划，我的想法是，刚毕业基础一定要打牢，还有我觉得职业规划更重要的是机遇，某个时间点你接触到了某个领域遇到了对的人，没有必要花费过多的时间在这上，有些事情就是船到桥头自然直，把握好当下。</p><p>从毕业到工作，有很多事情是现在的我不能理解的。或许这是不成熟的表现，也有些人将之称为特立独行。</p><p>上学时被老师管教，回家后被家长管教，走到哪里都有条条框框约束着。俗话有国有国法，家有家规，没有规矩不成方圆。但是你有没有想过，什么东西可以穿透这些条条框框的限制？</p><p>我认为是人情与压力。不喜欢谈人情，简单聊聊压力给我们带来的影响。</p><p>有时候你按照约定，符合规矩，可是还会遭受到心灵上的拷问。举个例子，你身边三个人，每个人有八个苹果，工作内容把八个苹果削皮，期限是从早上到晚上八小时，中午休息一小时。ABC都是一小时削一个，但是区别就是AB利用中午休息时间削了一个。C 老老实实按规矩办事，上午四个，下午四个。那么问题就来了，C 有打破边框吗？C 应该被谴责吗？此时此刻，所有的压力都在 C 身上。但是 C 真的什么都没做啊，只是个老老实实的打工人。</p><p>C 如果也开始利用休息时间去工作，这就叫内卷了。C 如果还是按规矩办事，C 这就叫特立独行了。C 处在这种尴尬的环境中，自然要做出某些决定。</p><hr><p>以上举的例子并不是想说明谁是对的，或者说谁做错了。真正想告诉大家的是，做任何事情都要遵从自己的内心。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天要聊的与技术无关，简单聊聊最近。&lt;br&gt;闲聊工作，最近有点迷，每天也不知道在忙啥，除了改bug还是改bug，还不是我写的bug，给上一任擦屁股，感觉永远都擦不干净。（说起来挺恶心，事实就是很恶心）&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>timer 优化</title>
    <link href="https://bqyang.top/2021/timer%20%E4%BC%98%E5%8C%96/"/>
    <id>https://bqyang.top/2021/timer%20%E4%BC%98%E5%8C%96/</id>
    <published>2021-11-14T14:47:26.661Z</published>
    <updated>2021-12-06T01:15:50.594Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们已经知道了，老版本 timer 的性能瓶颈主要是在那把全局锁以及频繁的上下文切换上，今天我们看看 go 大佬们通过哪种方式进行优化的。<br>​</p><p>在这里解释一下为什么选择这几个版本，据我所知啊，从 1.10 版本以前都是像上一篇文中所描述的那样，在 1.10 版本开始就做了这个优化，但从 1.14 开始又对 timer 进行了优化，所以我选择了 1.8， 1.13， 1.14 这几个邻近的作为参考。</p><span id="more"></span><h2 id="go-1-13-中的优化"><a href="#go-1-13-中的优化" class="headerlink" title="go 1.13 中的优化"></a>go 1.13 中的优化</h2><h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3><ul><li>go version: go1.13</li><li>compute: linux, centos7</li></ul><h3 id="timer-结构的变化"><a href="#timer-结构的变化" class="headerlink" title="timer 结构的变化"></a>timer 结构的变化</h3><h5 id="go1-8"><a href="#go1-8" class="headerlink" title="go1.8"></a>go1.8</h5><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> timer <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>i <span class="token builtin">int</span> <span class="token comment">// heap index</span>when   <span class="token builtin">int64</span>period <span class="token builtin">int64</span>f      <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token builtin">uintptr</span><span class="token punctuation">)</span>arg    <span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>seq    <span class="token builtin">uintptr</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="go1-13"><a href="#go1-13" class="headerlink" title="go1.13"></a>go1.13</h5><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> timer <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>tb <span class="token operator">*</span>timersBucket <span class="token comment">// the bucket the timer lives in</span>i  <span class="token builtin">int</span>           <span class="token comment">// heap index</span>when   <span class="token builtin">int64</span>period <span class="token builtin">int64</span>f      <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token builtin">uintptr</span><span class="token punctuation">)</span>arg    <span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>seq    <span class="token builtin">uintptr</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在go1.13版本中添加了一个 tb 字段，表示当前这个 timer 是在哪个 bucket 中的，其余字段含义还是和老版本中的一致。<br>​</p><p>还记得老版本把新建的 <code>timer</code> 对象都放在哪里了吗？<code>一个全局的 timers 中</code> go1.13版本中将的 timers 拆分成了 64 个大小的 timers 数组，每一个里边包含了一个 bucket ，bucket 中再存放 timer 对象，至于为什么是 64 官方的解释如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// timersLen is the length of timers array.</span><span class="token comment">//</span><span class="token comment">// Ideally, this would be set to GOMAXPROCS, but that would require</span><span class="token comment">// dynamic reallocation</span><span class="token comment">//</span><span class="token comment">// The current value is a compromise between memory usage and performance</span><span class="token comment">// that should cover the majority of GOMAXPROCS values used in the wild.</span><span class="token keyword">const</span> timersLen <span class="token operator">=</span> <span class="token number">64</span><span class="token comment">// timersLen is the length of timers array.</span><span class="token comment">//</span><span class="token comment">// Ideally, this would be set to GOMAXPROCS, but that would require</span><span class="token comment">// dynamic reallocation</span><span class="token comment">//</span><span class="token comment">// The current value is a compromise between memory usage and performance</span><span class="token comment">// that should cover the majority of GOMAXPROCS values used in the wild.</span><span class="token keyword">var</span> timers <span class="token punctuation">[</span>timersLen<span class="token punctuation">]</span><span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>timersBucket<span class="token comment">// The padding should eliminate false sharing</span><span class="token comment">// between timersBucket values.</span>pad <span class="token punctuation">[</span>cpu<span class="token punctuation">.</span>CacheLinePadSize <span class="token operator">-</span> unsafe<span class="token punctuation">.</span><span class="token function">Sizeof</span><span class="token punctuation">(</span>timersBucket<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token operator">%</span>cpu<span class="token punctuation">.</span>CacheLinePadSize<span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">&#125;</span><span class="token comment">//go:notinheap</span><span class="token keyword">type</span> timersBucket <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>lock         mutexgp           <span class="token operator">*</span>gcreated      <span class="token builtin">bool</span>sleeping     <span class="token builtin">bool</span>rescheduling <span class="token builtin">bool</span>sleepUntil   <span class="token builtin">int64</span>waitnote     notet            <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>timer<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在添加 timer 对象时逻辑变成了，根据当前 p 的 id 对 timersLen 取模，得到了 p 对应的 timersBucket <code>id := uint8(getg().m.p.ptr().id) % _timersLen_</code><br>从这个优化的方法来看，以前是每个p去抢同一把锁，现在变成，每个p只会操作对应的 timersBucket（大多数情况下）。</p><ul><li><input disabled="" type="checkbox"> <strong>在超过 64 个 p 的时候，就会出现取模到同一个 bucket 中，这种情况在多核 cpu &gt; 64 上是没办法避免的</strong></li><li><input disabled="" type="checkbox"> <strong>可能还有 p 从别的 p 上偷 timer 的情况</strong></li></ul><p>接下里我们看下执行 timer 的 <code>timerproc</code><br>1.8 版本中，全局只有一个执行 timer 的 timerproc，可以理解为只有一个消费者。1.13 中修改为每个不同的 bucket 都会有一个对应的 bucket。举个例子，比如我们有 4 个 P，就说明我们会有 4 个 bucket 和 4 个 timerproc，每当通过 addtimer 添加时，都会往 p 对应的 bucket 中添加任务，timerproc 作为消费者从中找可执行的timer，如下图：<br><img src="https://gitee.com/yangbaoqiang/images/raw/master/blogpics/1636033788855-ece14ebf-e72d-4851-9a75-de7cd60d59ba.png" alt="image.png"></p><h3 id="timer-的“生产者”"><a href="#timer-的“生产者”" class="headerlink" title="timer 的“生产者”"></a>timer 的“生产者”</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// 如前所述，每个p对应不同的 timersBucket，那么在创建之前我们是不是应该先找到在哪个 p 上执行</span><span class="token keyword">func</span> <span class="token punctuation">(</span>t <span class="token operator">*</span>timer<span class="token punctuation">)</span> <span class="token function">assignBucket</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span>timersBucket <span class="token punctuation">&#123;</span>id <span class="token operator">:=</span> <span class="token function">uint8</span><span class="token punctuation">(</span><span class="token function">getg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>m<span class="token punctuation">.</span>p<span class="token punctuation">.</span><span class="token function">ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>id<span class="token punctuation">)</span> <span class="token operator">%</span> timersLent<span class="token punctuation">.</span>tb <span class="token operator">=</span> <span class="token operator">&amp;</span>timers<span class="token punctuation">[</span>id<span class="token punctuation">]</span><span class="token punctuation">.</span>timersBucket<span class="token keyword">return</span> t<span class="token punctuation">.</span>tb<span class="token punctuation">&#125;</span><span class="token comment">// 将 timer 添加到对应的 timersBucket 中</span><span class="token keyword">func</span> <span class="token function">addtimer</span><span class="token punctuation">(</span>t <span class="token operator">*</span>timer<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>tb <span class="token operator">:=</span> t<span class="token punctuation">.</span><span class="token function">assignBucket</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tb<span class="token punctuation">.</span>lock<span class="token punctuation">)</span>ok <span class="token operator">:=</span> tb<span class="token punctuation">.</span><span class="token function">addtimerLocked</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tb<span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token keyword">if</span> <span class="token operator">!</span>ok <span class="token punctuation">&#123;</span><span class="token function">badTimer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 咱们只把重点放在与以前不同的地方上</span><span class="token keyword">func</span> <span class="token punctuation">(</span>tb <span class="token operator">*</span>timersBucket<span class="token punctuation">)</span> <span class="token function">addtimerLocked</span><span class="token punctuation">(</span>t <span class="token operator">*</span>timer<span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> t<span class="token punctuation">.</span>when <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>t<span class="token punctuation">.</span>when <span class="token operator">=</span> <span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">63</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">&#125;</span>t<span class="token punctuation">.</span>i <span class="token operator">=</span> <span class="token function">len</span><span class="token punctuation">(</span>tb<span class="token punctuation">.</span>t<span class="token punctuation">)</span>tb<span class="token punctuation">.</span>t <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>tb<span class="token punctuation">.</span>t<span class="token punctuation">,</span> t<span class="token punctuation">)</span> <span class="token comment">// 添加到p对应的timersBucket中，而不是全局的 timers 中了</span><span class="token keyword">if</span> <span class="token operator">!</span><span class="token function">siftupTimer</span><span class="token punctuation">(</span>tb<span class="token punctuation">.</span>t<span class="token punctuation">,</span> t<span class="token punctuation">.</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> t<span class="token punctuation">.</span>i <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span><span class="token comment">// siftup moved to top: new earliest deadline.</span><span class="token keyword">if</span> tb<span class="token punctuation">.</span>sleeping <span class="token operator">&amp;&amp;</span> tb<span class="token punctuation">.</span>sleepUntil <span class="token operator">></span> t<span class="token punctuation">.</span>when <span class="token punctuation">&#123;</span>tb<span class="token punctuation">.</span>sleeping <span class="token operator">=</span> <span class="token boolean">false</span><span class="token function">notewakeup</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tb<span class="token punctuation">.</span>waitnote<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> tb<span class="token punctuation">.</span>rescheduling <span class="token punctuation">&#123;</span>tb<span class="token punctuation">.</span>rescheduling <span class="token operator">=</span> <span class="token boolean">false</span><span class="token function">goready</span><span class="token punctuation">(</span>tb<span class="token punctuation">.</span>gp<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token operator">!</span>tb<span class="token punctuation">.</span>created <span class="token punctuation">&#123;</span><span class="token comment">// 判断属于这个 tb 的 timerproc 是否启动了，</span><span class="token comment">// 区别于1.8版本是一个全局变量控制的，只有一个消费者，这里是每一个 tb 都有一个消费者</span>tb<span class="token punctuation">.</span>created <span class="token operator">=</span> <span class="token boolean">true</span><span class="token keyword">go</span> <span class="token function">timerproc</span><span class="token punctuation">(</span>tb<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="timer-的“消费者”"><a href="#timer-的“消费者”" class="headerlink" title="timer 的“消费者”"></a>timer 的“消费者”</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// 主要的逻辑还是同 1.8 版本中一致的，不同的地方就是针对每个tb进行的操作，不是全局的 timers</span><span class="token keyword">func</span> <span class="token function">timerproc</span><span class="token punctuation">(</span>tb <span class="token operator">*</span>timersBucket<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>tb<span class="token punctuation">.</span>gp <span class="token operator">=</span> <span class="token function">getg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">for</span> <span class="token punctuation">&#123;</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tb<span class="token punctuation">.</span>lock<span class="token punctuation">)</span>tb<span class="token punctuation">.</span>sleeping <span class="token operator">=</span> <span class="token boolean">false</span>now <span class="token operator">:=</span> <span class="token function">nanotime</span><span class="token punctuation">(</span><span class="token punctuation">)</span>delta <span class="token operator">:=</span> <span class="token function">int64</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">for</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>tb<span class="token punctuation">.</span>t<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>delta <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token keyword">break</span><span class="token punctuation">&#125;</span>t <span class="token operator">:=</span> tb<span class="token punctuation">.</span>t<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>delta <span class="token operator">=</span> t<span class="token punctuation">.</span>when <span class="token operator">-</span> now<span class="token keyword">if</span> delta <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">&#123;</span><span class="token keyword">break</span><span class="token punctuation">&#125;</span>ok <span class="token operator">:=</span> <span class="token boolean">true</span><span class="token keyword">if</span> t<span class="token punctuation">.</span>period <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">&#123;</span><span class="token comment">// leave in heap but adjust next time to fire</span>t<span class="token punctuation">.</span>when <span class="token operator">+=</span> t<span class="token punctuation">.</span>period <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">+</span> <span class="token operator">-</span>delta<span class="token operator">/</span>t<span class="token punctuation">.</span>period<span class="token punctuation">)</span><span class="token keyword">if</span> <span class="token operator">!</span><span class="token function">siftdownTimer</span><span class="token punctuation">(</span>tb<span class="token punctuation">.</span>t<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>ok <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span><span class="token comment">// remove from heap</span>last <span class="token operator">:=</span> <span class="token function">len</span><span class="token punctuation">(</span>tb<span class="token punctuation">.</span>t<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token keyword">if</span> last <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>tb<span class="token punctuation">.</span>t<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> tb<span class="token punctuation">.</span>t<span class="token punctuation">[</span>last<span class="token punctuation">]</span>tb<span class="token punctuation">.</span>t<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">&#125;</span>tb<span class="token punctuation">.</span>t<span class="token punctuation">[</span>last<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">nil</span>tb<span class="token punctuation">.</span>t <span class="token operator">=</span> tb<span class="token punctuation">.</span>t<span class="token punctuation">[</span><span class="token punctuation">:</span>last<span class="token punctuation">]</span><span class="token keyword">if</span> last <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token operator">!</span><span class="token function">siftdownTimer</span><span class="token punctuation">(</span>tb<span class="token punctuation">.</span>t<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>ok <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>t<span class="token punctuation">.</span>i <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token comment">// mark as removed</span><span class="token punctuation">&#125;</span>f <span class="token operator">:=</span> t<span class="token punctuation">.</span>farg <span class="token operator">:=</span> t<span class="token punctuation">.</span>argseq <span class="token operator">:=</span> t<span class="token punctuation">.</span>seq<span class="token function">unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tb<span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token keyword">if</span> <span class="token operator">!</span>ok <span class="token punctuation">&#123;</span><span class="token function">badTimer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> raceenabled <span class="token punctuation">&#123;</span><span class="token function">raceacquire</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token function">f</span><span class="token punctuation">(</span>arg<span class="token punctuation">,</span> seq<span class="token punctuation">)</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tb<span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> delta <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> faketime <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">&#123;</span><span class="token comment">// No timers left - put goroutine to sleep.</span>tb<span class="token punctuation">.</span>rescheduling <span class="token operator">=</span> <span class="token boolean">true</span><span class="token function">goparkunlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tb<span class="token punctuation">.</span>lock<span class="token punctuation">,</span> waitReasonTimerGoroutineIdle<span class="token punctuation">,</span> traceEvGoBlock<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">continue</span><span class="token punctuation">&#125;</span><span class="token comment">// At least one timer pending. Sleep until then.</span>tb<span class="token punctuation">.</span>sleeping <span class="token operator">=</span> <span class="token boolean">true</span>tb<span class="token punctuation">.</span>sleepUntil <span class="token operator">=</span> now <span class="token operator">+</span> delta<span class="token function">noteclear</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tb<span class="token punctuation">.</span>waitnote<span class="token punctuation">)</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tb<span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token function">notetsleepg</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tb<span class="token punctuation">.</span>waitnote<span class="token punctuation">,</span> delta<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>相比于 1.8，1.13版本中还添加了一个 <code>modtimer(t *timer, when, period int64, f func(interface&#123;&#125;, uintptr), arg interface&#123;&#125;, seq uintptr)</code><br>modtimer 函数主要做了，将 t 从 tb 中删除，然后有 重新给它 加入进去</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">modtimer</span><span class="token punctuation">(</span>t <span class="token operator">*</span>timer<span class="token punctuation">,</span> when<span class="token punctuation">,</span> period <span class="token builtin">int64</span><span class="token punctuation">,</span> f <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token builtin">uintptr</span><span class="token punctuation">)</span><span class="token punctuation">,</span> arg <span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> seq <span class="token builtin">uintptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>tb <span class="token operator">:=</span> t<span class="token punctuation">.</span>tb<span class="token function">lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tb<span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token boolean">_</span><span class="token punctuation">,</span> ok <span class="token operator">:=</span> tb<span class="token punctuation">.</span><span class="token function">deltimerLocked</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token keyword">if</span> ok <span class="token punctuation">&#123;</span>t<span class="token punctuation">.</span>when <span class="token operator">=</span> whent<span class="token punctuation">.</span>period <span class="token operator">=</span> periodt<span class="token punctuation">.</span>f <span class="token operator">=</span> ft<span class="token punctuation">.</span>arg <span class="token operator">=</span> argt<span class="token punctuation">.</span>seq <span class="token operator">=</span> seqok <span class="token operator">=</span> tb<span class="token punctuation">.</span><span class="token function">addtimerLocked</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tb<span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token keyword">if</span> <span class="token operator">!</span>ok <span class="token punctuation">&#123;</span><span class="token function">badTimer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 netpoll 中，有两处地方调用了这个函数，主要就是给 fd 调整超时处理使用的。</p><p>总的来说这个版本中的优化只是做了全局锁粒度的拆分，上下文切换带来额外的性能开销仍然没有得到优化，不过不要着急，1.14 版本中针对这个问题已经做了妥善的处理，我们马上就来看一下。<br>​</p><h2 id="go-1-14-中的优化"><a href="#go-1-14-中的优化" class="headerlink" title="go 1.14 中的优化"></a>go 1.14 中的优化</h2><h3 id="环境信息-1"><a href="#环境信息-1" class="headerlink" title="环境信息"></a>环境信息</h3><p>go version: go1.14.1<br>compute: linux, centos7</p><h3 id="timer-结构的变化-1"><a href="#timer-结构的变化-1" class="headerlink" title="timer 结构的变化"></a>timer 结构的变化</h3><p>以前的结构体都是全局变量，在 1.14 版本开始，timer 结构体就内嵌到了 P 中。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// Package time knows the layout of this structure.</span><span class="token comment">// If this struct changes, adjust ../time/sleep.go:/runtimeTimer.</span><span class="token keyword">type</span> timer <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span><span class="token comment">// If this timer is on a heap, which P's heap it is on.</span><span class="token comment">// puintptr rather than *p to match uintptr in the versions</span><span class="token comment">// of this struct defined in other packages.</span>pp puintptr<span class="token comment">// Timer wakes up at when, and then at when+period, ... (period > 0 only)</span><span class="token comment">// each time calling f(arg, now) in the timer goroutine, so f must be</span><span class="token comment">// a well-behaved function and not block.</span>when   <span class="token builtin">int64</span>period <span class="token builtin">int64</span>f      <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token builtin">uintptr</span><span class="token punctuation">)</span>arg    <span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>seq    <span class="token builtin">uintptr</span><span class="token comment">// What to set the when field to in timerModifiedXX status.</span>nextwhen <span class="token builtin">int64</span><span class="token comment">// The status field holds one of the values below.</span>status <span class="token builtin">uint32</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> p <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>id          <span class="token builtin">int32</span>        <span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">)</span>    <span class="token comment">// Lock for timers. We normally access the timers while running</span><span class="token comment">// on this P, but the scheduler can also do it from a different P.</span><span class="token comment">// 讲道理，你p处理本地的 timer 用锁干什么？</span><span class="token comment">// 1.14 是可以偷 timer 的，这时候就变成了共享资源，访问的时候是一定要加锁的。</span><span class="token comment">// 上边注释（英文）说的也很清楚，这个是官方的解释</span>timersLock mutex<span class="token comment">// Actions to take at some time. This is used to implement the</span><span class="token comment">// standard library's time package.</span><span class="token comment">// Must hold timersLock to access.</span>timers <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>timer<span class="token comment">// Number of timers in P's heap.</span><span class="token comment">// Modified using atomic instructions.</span><span class="token comment">// 记录当前 p 中 timer的总数量</span>numTimers <span class="token builtin">uint32</span><span class="token comment">// Number of timerModifiedEarlier timers on P's heap.</span><span class="token comment">// This should only be modified while holding timersLock,</span><span class="token comment">// or while the timer status is in a transient state</span><span class="token comment">// such as timerModifying.</span><span class="token comment">// P 中 调整 when 的时间提前了的 timer 数量</span>adjustTimers <span class="token builtin">uint32</span><span class="token comment">// Number of timerDeleted timers in P's heap.</span><span class="token comment">// Modified using atomic instructions.</span><span class="token comment">// 记录 p 中被删除的 timer 数量</span>deletedTimers <span class="token builtin">uint32</span><span class="token comment">// Race context used while executing timer functions.</span>timerRaceCtx <span class="token builtin">uintptr</span>        <span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="timer-的“生产者”-1"><a href="#timer-的“生产者”-1" class="headerlink" title="timer 的“生产者”"></a>timer 的“生产者”</h3><p><code>... 基本上大同小异，只不过是加了一些状态</code><br>不过需要注意的一点是，1.14 中有了 timer 和 netpoll 的结合。我的理解是：<br>findrunnable 最后没有找到可执行的 g 的时候会再检查 netpoll。这个调用过程是阻塞的，阻塞 delta 这段时间，然后这时候比如说我通过 addtimer 加入新timer，就是假设哈，1s 后要执行，然后你那个阻塞过程要阻塞 3s，但这是在阻塞没有办法执行我们的 timer，然后这时候 addtimer 中的 wakenetpoller 就派上用场，通过 <code>netpollbreak</code> 中断那个阻塞调用，然后就回到 <code>findrunnable</code> 继续执行，及时响应那个近期的 timer 对象。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// addtimer:</span><span class="token comment">//   timerNoStatus   -> timerWaiting</span><span class="token comment">//   anything else   -> panic: invalid value</span><span class="token comment">// deltimer:</span><span class="token comment">//   timerWaiting         -> timerModifying -> timerDeleted</span><span class="token comment">//   timerModifiedEarlier -> timerModifying -> timerDeleted</span><span class="token comment">//   timerModifiedLater   -> timerModifying -> timerDeleted</span><span class="token comment">//   timerNoStatus        -> do nothing</span><span class="token comment">//   timerDeleted         -> do nothing</span><span class="token comment">//   timerRemoving        -> do nothing</span><span class="token comment">//   timerRemoved         -> do nothing</span><span class="token comment">//   timerRunning         -> wait until status changes</span><span class="token comment">//   timerMoving          -> wait until status changes</span><span class="token comment">//   timerModifying       -> wait until status changes</span><span class="token comment">// modtimer:</span><span class="token comment">//   timerWaiting    -> timerModifying -> timerModifiedXX</span><span class="token comment">//   timerModifiedXX -> timerModifying -> timerModifiedYY</span><span class="token comment">//   timerNoStatus   -> timerModifying -> timerWaiting</span><span class="token comment">//   timerRemoved    -> timerModifying -> timerWaiting</span><span class="token comment">//   timerDeleted    -> timerModifying -> timerModifiedXX</span><span class="token comment">//   timerRunning    -> wait until status changes</span><span class="token comment">//   timerMoving     -> wait until status changes</span><span class="token comment">//   timerRemoving   -> wait until status changes</span><span class="token comment">//   timerModifying  -> wait until status changes</span><span class="token comment">// cleantimers (looks in P's timer heap):</span><span class="token comment">//   timerDeleted    -> timerRemoving -> timerRemoved</span><span class="token comment">//   timerModifiedXX -> timerMoving -> timerWaiting</span><span class="token comment">// adjusttimers (looks in P's timer heap):</span><span class="token comment">//   timerDeleted    -> timerRemoving -> timerRemoved</span><span class="token comment">//   timerModifiedXX -> timerMoving -> timerWaiting</span><span class="token comment">// runtimer (looks in P's timer heap):</span><span class="token comment">//   timerNoStatus   -> panic: uninitialized timer</span><span class="token comment">//   timerWaiting    -> timerWaiting or</span><span class="token comment">//   timerWaiting    -> timerRunning -> timerNoStatus or</span><span class="token comment">//   timerWaiting    -> timerRunning -> timerWaiting</span><span class="token comment">//   timerModifying  -> wait until status changes</span><span class="token comment">//   timerModifiedXX -> timerMoving -> timerWaiting</span><span class="token comment">//   timerDeleted    -> timerRemoving -> timerRemoved</span><span class="token comment">//   timerRunning    -> panic: concurrent runtimer calls</span><span class="token comment">//   timerRemoved    -> panic: inconsistent timer heap</span><span class="token comment">//   timerRemoving   -> panic: inconsistent timer heap</span><span class="token comment">//   timerMoving     -> panic: inconsistent timer heap</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="timer-的“消费者”-1"><a href="#timer-的“消费者”-1" class="headerlink" title="timer 的“消费者”"></a>timer 的“消费者”</h3><p>新版本中的“消费者”有着非常重要的改变，<code>timerproc</code> 没了，首先我们要明确：<br>timerproc 不仅仅是一个函数，它是 runtime 创建的一个 goroutine，因此可知，以前的“消费者”就是一个 goroutine， 它并没有什么不同，同样被 <code>scheduler</code>调度。</p><p>1.14 中，直接给“消费者”升到“头等舱”，看你小子干活勤勤恳恳，scheduler说，你来我这上班吧，结果人家就去了。</p><p>1.14 中，timer 的消费者就是在调度循环的 <code>schedule</code> 中，其次就是 <code>sysmon</code> （sysmon作为兜底），我们看下源码，看看新版本的消费者是怎么“晋升”的。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">schedule</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">)</span> <span class="token comment">// 省略安全检查</span>    <span class="token comment">// 看看人家 timer 直接被安排到顶级位置</span><span class="token comment">// 调度循环上来就是先检查 timer</span><span class="token function">checkTimers</span><span class="token punctuation">(</span>pp<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> gp <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>gp<span class="token punctuation">,</span> inheritTime <span class="token operator">=</span> <span class="token function">findrunnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// blocks until work is available</span><span class="token punctuation">&#125;</span>    <span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">)</span>    <span class="token function">execute</span><span class="token punctuation">(</span>gp<span class="token punctuation">,</span> inheritTime<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以得出结论，新版本的“消费者” 从 goroutine 级别 转变到 函数级别。</p><h4 id="checkTimers"><a href="#checkTimers" class="headerlink" title="checkTimers()"></a>checkTimers()</h4><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// checkTimers runs any timers for the P that are ready.</span><span class="token comment">// If now is not 0 it is the current time.</span><span class="token comment">// It returns the current time or 0 if it is not known,</span><span class="token comment">// and the time when the next timer should run or 0 if there is no next timer,</span><span class="token comment">// and reports whether it ran any timers.</span><span class="token comment">// If the time when the next timer should run is not 0,</span><span class="token comment">// it is always larger than the returned time.</span><span class="token comment">// We pass now in and out to avoid extra calls of nanotime.</span><span class="token comment">//go:yeswritebarrierrec</span><span class="token comment">// rnow</span><span class="token comment">// pollUntil0 表示没有下一个 timer，非 0 表示下一个timer的等待时间</span><span class="token comment">// ran表示是否执行了 timer</span><span class="token keyword">func</span> <span class="token function">checkTimers</span><span class="token punctuation">(</span>pp <span class="token operator">*</span>p<span class="token punctuation">,</span> now <span class="token builtin">int64</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>rnow<span class="token punctuation">,</span> pollUntil <span class="token builtin">int64</span><span class="token punctuation">,</span> ran <span class="token builtin">bool</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// If there are no timers to adjust, and the first timer on</span><span class="token comment">// the heap is not yet ready to run, then there is nothing to do.</span><span class="token keyword">if</span> atomic<span class="token punctuation">.</span><span class="token function">Load</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pp<span class="token punctuation">.</span>adjustTimers<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>next <span class="token operator">:=</span> <span class="token function">int64</span><span class="token punctuation">(</span>atomic<span class="token punctuation">.</span><span class="token function">Load64</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pp<span class="token punctuation">.</span>timer0When<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">if</span> next <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> now<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> now <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>now <span class="token operator">=</span> <span class="token function">nanotime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> now <span class="token operator">&lt;</span> next <span class="token punctuation">&#123;</span><span class="token comment">// Next timer is not ready to run.</span><span class="token comment">// But keep going if we would clear deleted timers.</span><span class="token comment">// This corresponds to the condition below where</span><span class="token comment">// we decide whether to call clearDeletedTimers.</span><span class="token comment">// 尽可能找机会清理 timer</span><span class="token keyword">if</span> pp <span class="token operator">!=</span> <span class="token function">getg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>m<span class="token punctuation">.</span>p<span class="token punctuation">.</span><span class="token function">ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">int</span><span class="token punctuation">(</span>atomic<span class="token punctuation">.</span><span class="token function">Load</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pp<span class="token punctuation">.</span>deletedTimers<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token function">int</span><span class="token punctuation">(</span>atomic<span class="token punctuation">.</span><span class="token function">Load</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pp<span class="token punctuation">.</span>numTimers<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> now<span class="token punctuation">,</span> next<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pp<span class="token punctuation">.</span>timersLock<span class="token punctuation">)</span><span class="token function">adjusttimers</span><span class="token punctuation">(</span>pp<span class="token punctuation">)</span>rnow <span class="token operator">=</span> now<span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>pp<span class="token punctuation">.</span>timers<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> rnow <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>rnow <span class="token operator">=</span> <span class="token function">nanotime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span> <span class="token function">len</span><span class="token punctuation">(</span>pp<span class="token punctuation">.</span>timers<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">&#123;</span><span class="token comment">// Note that runtimer may temporarily unlock</span><span class="token comment">// pp.timersLock.</span><span class="token keyword">if</span> tw <span class="token operator">:=</span> <span class="token function">runtimer</span><span class="token punctuation">(</span>pp<span class="token punctuation">,</span> rnow<span class="token punctuation">)</span><span class="token punctuation">;</span> tw <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> tw <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>pollUntil <span class="token operator">=</span> tw<span class="token punctuation">&#125;</span><span class="token keyword">break</span><span class="token punctuation">&#125;</span>ran <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// If this is the local P, and there are a lot of deleted timers,</span><span class="token comment">// clear them out. We only do this for the local P to reduce</span><span class="token comment">// lock contention on timersLock.</span><span class="token keyword">if</span> pp <span class="token operator">==</span> <span class="token function">getg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>m<span class="token punctuation">.</span>p<span class="token punctuation">.</span><span class="token function">ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">int</span><span class="token punctuation">(</span>atomic<span class="token punctuation">.</span><span class="token function">Load</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pp<span class="token punctuation">.</span>deletedTimers<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token function">len</span><span class="token punctuation">(</span>pp<span class="token punctuation">.</span>timers<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">4</span> <span class="token punctuation">&#123;</span><span class="token function">clearDeletedTimers</span><span class="token punctuation">(</span>pp<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pp<span class="token punctuation">.</span>timersLock<span class="token punctuation">)</span><span class="token keyword">return</span> rnow<span class="token punctuation">,</span> pollUntil<span class="token punctuation">,</span> ran<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上述 <code>checkTimers</code> 中，通过 <code>adjusttimers</code> 调整当前 p 的 timers 数组，我们看一下它的实现</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// adjusttimers looks through the timers in the current P's heap for</span><span class="token comment">// any timers that have been modified to run earlier, and puts them in</span><span class="token comment">// the correct place in the heap. While looking for those timers,</span><span class="token comment">// it also moves timers that have been modified to run later,</span><span class="token comment">// and removes deleted timers. The caller must have locked the timers for pp.</span><span class="token keyword">func</span> <span class="token function">adjusttimers</span><span class="token punctuation">(</span>pp <span class="token operator">*</span>p<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// 判断当前 p 是否有 timer</span><span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>pp<span class="token punctuation">.</span>timers<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> atomic<span class="token punctuation">.</span><span class="token function">Load</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pp<span class="token punctuation">.</span>adjustTimers<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> verifyTimers <span class="token punctuation">&#123;</span><span class="token function">verifyTimerHeap</span><span class="token punctuation">(</span>pp<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span><span class="token punctuation">&#125;</span><span class="token comment">// 存放需要移动的 timer</span><span class="token keyword">var</span> moved <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>timerloop<span class="token punctuation">:</span><span class="token comment">// 遍历当前 p 的 timers</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token function">len</span><span class="token punctuation">(</span>pp<span class="token punctuation">.</span>timers<span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>t <span class="token operator">:=</span> pp<span class="token punctuation">.</span>timers<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token keyword">if</span> t<span class="token punctuation">.</span>pp<span class="token punctuation">.</span><span class="token function">ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> pp <span class="token punctuation">&#123;</span><span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">"adjusttimers: bad p"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">// 判断当前 timer 的状态</span><span class="token keyword">switch</span> s <span class="token operator">:=</span> atomic<span class="token punctuation">.</span><span class="token function">Load</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t<span class="token punctuation">.</span>status<span class="token punctuation">)</span><span class="token punctuation">;</span> s <span class="token punctuation">&#123;</span><span class="token comment">// 表示 timer 需要删除，但是还没有删除呢</span><span class="token keyword">case</span> timerDeleted<span class="token punctuation">:</span><span class="token comment">// 修改 timer 的状态为，正在删除中 timerRemoving</span><span class="token keyword">if</span> atomic<span class="token punctuation">.</span><span class="token function">Cas</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t<span class="token punctuation">.</span>status<span class="token punctuation">,</span> s<span class="token punctuation">,</span> timerRemoving<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// 执行删除操作</span><span class="token function">dodeltimer</span><span class="token punctuation">(</span>pp<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token comment">// 修改 timer 的状态为，已删除 timerRemoved</span><span class="token keyword">if</span> <span class="token operator">!</span>atomic<span class="token punctuation">.</span><span class="token function">Cas</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t<span class="token punctuation">.</span>status<span class="token punctuation">,</span> timerRemoving<span class="token punctuation">,</span> timerRemoved<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">badTimer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">// 修改待删除 timer 的数量 pp.deletedTimers - 1</span>atomic<span class="token punctuation">.</span><span class="token function">Xadd</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pp<span class="token punctuation">.</span>deletedTimers<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">// Look at this heap position again.</span><span class="token comment">// 思考一下就可以知道，为什么需要再次检查当前这个位置的 timer</span><span class="token comment">// 通过 dodeltimer 将索引为 i 的 timer 删除后，我们知道的是</span><span class="token comment">// 假设总数量为 n, [0, i) 之前的元素不需要改变，删掉第 I 个后</span><span class="token comment">// 需要在 [i,n-1) 里边中选一个填补 i 的位置，所以需要重新检查一次</span>i<span class="token operator">--</span><span class="token punctuation">&#125;</span><span class="token comment">// 表示 timer 的等待时间被调整了</span><span class="token comment">// timerModifiedEarlier 向前调整</span><span class="token comment">// timerModifiedLater 向后调整</span><span class="token keyword">case</span> timerModifiedEarlier<span class="token punctuation">,</span> timerModifiedLater<span class="token punctuation">:</span><span class="token comment">// 因为调整了 timer 的时间点，所以需要重新调整该 timer 在堆中的位置</span><span class="token comment">// 修改 timer 状态为，移动中 timerMoving</span><span class="token keyword">if</span> atomic<span class="token punctuation">.</span><span class="token function">Cas</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t<span class="token punctuation">.</span>status<span class="token punctuation">,</span> s<span class="token punctuation">,</span> timerMoving<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// Now we can change the when field.</span>t<span class="token punctuation">.</span>when <span class="token operator">=</span> t<span class="token punctuation">.</span>nextwhen<span class="token comment">// Take t off the heap, and hold onto it.</span><span class="token comment">// We don't add it back yet because the</span><span class="token comment">// heap manipulation could cause our</span><span class="token comment">// loop to skip some other timer.</span><span class="token function">dodeltimer</span><span class="token punctuation">(</span>pp<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token comment">// 将这个 timer 加入到需要移动的 timer 当中</span>moved <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>moved<span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token keyword">if</span> s <span class="token operator">==</span> timerModifiedEarlier <span class="token punctuation">&#123;</span><span class="token keyword">if</span> n <span class="token operator">:=</span> atomic<span class="token punctuation">.</span><span class="token function">Xadd</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pp<span class="token punctuation">.</span>adjustTimers<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">int32</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span><span class="token keyword">break</span> loop<span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// Look at this heap position again.</span>i<span class="token operator">--</span><span class="token punctuation">&#125;</span><span class="token keyword">case</span> timerNoStatus<span class="token punctuation">,</span> timerRunning<span class="token punctuation">,</span> timerRemoving<span class="token punctuation">,</span> timerRemoved<span class="token punctuation">,</span> timerMoving<span class="token punctuation">:</span><span class="token function">badTimer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">case</span> timerWaiting<span class="token punctuation">:</span><span class="token comment">// OK, nothing to do.</span><span class="token keyword">case</span> timerModifying<span class="token punctuation">:</span><span class="token comment">// Check again after modification is complete.</span><span class="token function">osyield</span><span class="token punctuation">(</span><span class="token punctuation">)</span>i<span class="token operator">--</span><span class="token keyword">default</span><span class="token punctuation">:</span><span class="token function">badTimer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>moved<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">&#123;</span><span class="token comment">// 将 timer 重新加入到当前 p 的 timers 中</span><span class="token comment">// 并且按照小顶堆进行排序</span><span class="token function">addAdjustedTimers</span><span class="token punctuation">(</span>pp<span class="token punctuation">,</span> moved<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> verifyTimers <span class="token punctuation">&#123;</span><span class="token function">verifyTimerHeap</span><span class="token punctuation">(</span>pp<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后我们再看一下 <code>checkTimers</code> 函数末尾的位置，就是要真正执行 timer 的时候了，通过 <code>runtimer</code> 来执行 p 中的 timer</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// runtimer examines the first timer in timers. If it is ready based on now,</span><span class="token comment">// it runs the timer and removes or updates it.</span><span class="token comment">// Returns 0 if it ran a timer, -1 if there are no more timers, or the time</span><span class="token comment">// when the first timer should run.</span><span class="token comment">// The caller must have locked the timers for pp.</span><span class="token comment">// If a timer is run, this will temporarily unlock the timers.</span><span class="token comment">/*根据上述注释可以了解到:返回值 = 0;  表示执行了一个 timer返回值 = -1; 表示 p 中没有 timer 了返回值 > 0;  表示第一个 timer 要执行的时间点（这里的源码就不做过多分析了，没有什么可说的，基本上都覆盖到了）*/</span><span class="token comment">//go:systemstack</span><span class="token keyword">func</span> <span class="token function">runtimer</span><span class="token punctuation">(</span>pp <span class="token operator">*</span>p<span class="token punctuation">,</span> now <span class="token builtin">int64</span><span class="token punctuation">)</span> <span class="token builtin">int64</span> <span class="token punctuation">&#123;</span><span class="token keyword">for</span> <span class="token punctuation">&#123;</span>t <span class="token operator">:=</span> pp<span class="token punctuation">.</span>timers<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token keyword">if</span> t<span class="token punctuation">.</span>pp<span class="token punctuation">.</span><span class="token function">ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> pp <span class="token punctuation">&#123;</span><span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">"runtimer: bad p"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">switch</span> s <span class="token operator">:=</span> atomic<span class="token punctuation">.</span><span class="token function">Load</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t<span class="token punctuation">.</span>status<span class="token punctuation">)</span><span class="token punctuation">;</span> s <span class="token punctuation">&#123;</span><span class="token keyword">case</span> timerWaiting<span class="token punctuation">:</span><span class="token keyword">if</span> t<span class="token punctuation">.</span>when <span class="token operator">></span> now <span class="token punctuation">&#123;</span><span class="token comment">// Not ready to run.</span><span class="token keyword">return</span> t<span class="token punctuation">.</span>when<span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token operator">!</span>atomic<span class="token punctuation">.</span><span class="token function">Cas</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t<span class="token punctuation">.</span>status<span class="token punctuation">,</span> s<span class="token punctuation">,</span> timerRunning<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">continue</span><span class="token punctuation">&#125;</span><span class="token comment">// Note that runOneTimer may temporarily unlock</span><span class="token comment">// pp.timersLock.</span><span class="token function">runOneTimer</span><span class="token punctuation">(</span>pp<span class="token punctuation">,</span> t<span class="token punctuation">,</span> now<span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token keyword">case</span> timerDeleted<span class="token punctuation">:</span><span class="token keyword">if</span> <span class="token operator">!</span>atomic<span class="token punctuation">.</span><span class="token function">Cas</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t<span class="token punctuation">.</span>status<span class="token punctuation">,</span> s<span class="token punctuation">,</span> timerRemoving<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">continue</span><span class="token punctuation">&#125;</span><span class="token function">dodeltimer0</span><span class="token punctuation">(</span>pp<span class="token punctuation">)</span><span class="token keyword">if</span> <span class="token operator">!</span>atomic<span class="token punctuation">.</span><span class="token function">Cas</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t<span class="token punctuation">.</span>status<span class="token punctuation">,</span> timerRemoving<span class="token punctuation">,</span> timerRemoved<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">badTimer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span>atomic<span class="token punctuation">.</span><span class="token function">Xadd</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pp<span class="token punctuation">.</span>deletedTimers<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>pp<span class="token punctuation">.</span>timers<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token keyword">case</span> timerModifiedEarlier<span class="token punctuation">,</span> timerModifiedLater<span class="token punctuation">:</span><span class="token keyword">if</span> <span class="token operator">!</span>atomic<span class="token punctuation">.</span><span class="token function">Cas</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t<span class="token punctuation">.</span>status<span class="token punctuation">,</span> s<span class="token punctuation">,</span> timerMoving<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">continue</span><span class="token punctuation">&#125;</span>t<span class="token punctuation">.</span>when <span class="token operator">=</span> t<span class="token punctuation">.</span>nextwhen<span class="token function">dodeltimer0</span><span class="token punctuation">(</span>pp<span class="token punctuation">)</span><span class="token function">doaddtimer</span><span class="token punctuation">(</span>pp<span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token keyword">if</span> s <span class="token operator">==</span> timerModifiedEarlier <span class="token punctuation">&#123;</span>atomic<span class="token punctuation">.</span><span class="token function">Xadd</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pp<span class="token punctuation">.</span>adjustTimers<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token operator">!</span>atomic<span class="token punctuation">.</span><span class="token function">Cas</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t<span class="token punctuation">.</span>status<span class="token punctuation">,</span> timerMoving<span class="token punctuation">,</span> timerWaiting<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">badTimer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">case</span> timerModifying<span class="token punctuation">:</span><span class="token comment">// Wait for modification to complete.</span><span class="token function">osyield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">case</span> timerNoStatus<span class="token punctuation">,</span> timerRemoved<span class="token punctuation">:</span><span class="token comment">// Should not see a new or inactive timer on the heap.</span><span class="token function">badTimer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">case</span> timerRunning<span class="token punctuation">,</span> timerRemoving<span class="token punctuation">,</span> timerMoving<span class="token punctuation">:</span><span class="token comment">// These should only be set when timers are locked,</span><span class="token comment">// and we didn't do it.</span><span class="token function">badTimer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">default</span><span class="token punctuation">:</span><span class="token function">badTimer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>截止到目前为止，我们已经把 <code>checkTimers</code> 给分析完了。</p><h3 id="偷-timer"><a href="#偷-timer" class="headerlink" title="偷 timer"></a>偷 timer</h3><p>这里的偷 timer 不是说把 另一个 p 的 timer 偷到我本地后再执行，而是在当前这个 p ，执行其他 p timer。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// 截取部分 findrunnable 代码</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span><span class="token keyword">for</span> enum <span class="token operator">:=</span> stealOrder<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token function">fastrand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">!</span>enum<span class="token punctuation">.</span><span class="token function">done</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> enum<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">)</span>                        <span class="token keyword">if</span> i <span class="token operator">></span> <span class="token number">2</span> <span class="token operator">&amp;&amp;</span> <span class="token function">shouldStealTimers</span><span class="token punctuation">(</span>p2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>tnow<span class="token punctuation">,</span> w<span class="token punctuation">,</span> ran <span class="token operator">:=</span> <span class="token function">checkTimers</span><span class="token punctuation">(</span>p2<span class="token punctuation">,</span> now<span class="token punctuation">)</span>                <span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">)</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="后语"><a href="#后语" class="headerlink" title="后语"></a>后语</h2><p>给大家分享一下我在整理过程中的参考资料吧：<br><em>1.luozhiyun Go中定时器实现原理及源码解析</em><br>   <a href="https://www.cnblogs.com/luozhiyun/p/14494540.html"><em>https://www.cnblogs.com/luozhiyun/p/14494540.html</em></a><br><em>2.猪吃鱼 Netpoll 解析</em><br>   <a href="https://www.pefish.club/2020/05/04/Golang/1011Netpoll%E8%A7%A3%E6%9E%90/"><em>https://www.pefish.club/2020/05/04/Golang/1011Netpoll%E8%A7%A3%E6%9E%90/</em></a><br><em>3.issues<br>   <a href="https://github.com/golang/go/issues/6239"><em>https://github.com/golang/go/issues/6239</em></a><br>4.峰云就她了  go1.14基于netpoll定时器实现原理</em><br>   <a href="http://xiaorui.cc/archives/6483"><em>http://xiaorui.cc/archives/6483</em></a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;我们已经知道了，老版本 timer 的性能瓶颈主要是在那把全局锁以及频繁的上下文切换上，今天我们看看 go 大佬们通过哪种方式进行优化的。&lt;br&gt;​&lt;/p&gt;
&lt;p&gt;在这里解释一下为什么选择这几个版本，据我所知啊，从 1.10 版本以前都是像上一篇文中所描述的那样，在 1.10 版本开始就做了这个优化，但从 1.14 开始又对 timer 进行了优化，所以我选择了 1.8， 1.13， 1.14 这几个邻近的作为参考。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>timer 源码分析</title>
    <link href="https://bqyang.top/2021/timer%20%E6%B5%85%E6%9E%90/"/>
    <id>https://bqyang.top/2021/timer%20%E6%B5%85%E6%9E%90/</id>
    <published>2021-11-14T14:46:05.911Z</published>
    <updated>2021-12-05T12:21:28.432Z</updated>
    
    <content type="html"><![CDATA[<p>golang timer 的优化过程以及底层实现。</p><span id="more"></span><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>buzhidaoxieshenme</p><h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3><ul><li>go version：go1.8</li><li>compute: linux, centos7</li></ul><h3 id="带着问题出发"><a href="#带着问题出发" class="headerlink" title="带着问题出发"></a>带着问题出发</h3><p>1.数据结构-堆，有什么特征？<br>2.timer 在执行用户函数的时候是否新建了 goroutine？<br>3.当 timer 需要阻塞时，g 被谁接管了？<br>4.timer 中有两种不同的挂起方式分别是？</p><h3 id="timer-中的“增删改查”"><a href="#timer-中的“增删改查”" class="headerlink" title="timer 中的“增删改查”"></a>timer 中的“增删改查”</h3><h4 id="timer-的创建"><a href="#timer-的创建" class="headerlink" title="timer 的创建"></a>timer 的创建</h4><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// 可以理解为 timer 的入口</span><span class="token keyword">func</span> <span class="token function">startTimer</span><span class="token punctuation">(</span>t <span class="token operator">*</span>timer<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> raceenabled <span class="token punctuation">&#123;</span>        <span class="token function">racerelease</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 将新的 timer 加入到全局的 timers 中</span>    <span class="token function">addtimer</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="addtimer"><a href="#addtimer" class="headerlink" title="addtimer"></a>addtimer</h4><p>了解添加 timer 的过程：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">/*    再次说明版本!! go1.8 !!*/</span><span class="token comment">// 向全局 timers 中添加 timer</span><span class="token keyword">func</span> <span class="token function">addtimer</span><span class="token punctuation">(</span>t <span class="token operator">*</span>timer<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 要访问全局的 timers 加锁</span>    <span class="token function">lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>timers<span class="token punctuation">.</span>lock<span class="token punctuation">)</span>    <span class="token comment">// 将 t 加入到 timers 中</span>    <span class="token function">addtimerLocked</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span>    <span class="token comment">// 添加完成，释放锁</span>    <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>timers<span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">addtimerLocked</span><span class="token punctuation">(</span>t <span class="token operator">*</span>timer<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// when must never be negative; otherwise timerproc will overflow</span>    <span class="token comment">// during its delta calculation and never expire other runtime timers.</span>    <span class="token keyword">if</span> t<span class="token punctuation">.</span>when <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>        t<span class="token punctuation">.</span>when <span class="token operator">=</span> <span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">63</span> <span class="token operator">-</span> <span class="token number">1</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 计算 t 在 timers 中的索引</span>    t<span class="token punctuation">.</span>i <span class="token operator">=</span> <span class="token function">len</span><span class="token punctuation">(</span>timers<span class="token punctuation">.</span>t<span class="token punctuation">)</span>    timers<span class="token punctuation">.</span>t <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>timers<span class="token punctuation">.</span>t<span class="token punctuation">,</span> t<span class="token punctuation">)</span>    <span class="token comment">// 对小顶堆重新排列</span>    <span class="token function">siftupTimer</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>i<span class="token punctuation">)</span>    <span class="token comment">// 如果说 t.i == 0，意味着在所有等待执行的 timer 中，这个 timer 的值最小，排在了堆顶</span>    <span class="token keyword">if</span> t<span class="token punctuation">.</span>i <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// siftup moved to top: new earliest deadline.</span>        <span class="token comment">// 如果 timers 处于 sleeping 状态，则通过 notewakeup 进行唤醒</span>        <span class="token keyword">if</span> timers<span class="token punctuation">.</span>sleeping <span class="token punctuation">&#123;</span>            timers<span class="token punctuation">.</span>sleeping <span class="token operator">=</span> <span class="token boolean">false</span>            <span class="token function">notewakeup</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>timers<span class="token punctuation">.</span>waitnote<span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 如果 timers 处于 rescheduling 状态，则通过 goready 进行唤醒</span>        <span class="token keyword">if</span> timers<span class="token punctuation">.</span>rescheduling <span class="token punctuation">&#123;</span>            timers<span class="token punctuation">.</span>rescheduling <span class="token operator">=</span> <span class="token boolean">false</span>            <span class="token function">goready</span><span class="token punctuation">(</span>timers<span class="token punctuation">.</span>gp<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 检查全局唯一的 timerproc 是否已经创建，没有则启动</span>    <span class="token keyword">if</span> <span class="token operator">!</span>timers<span class="token punctuation">.</span>created <span class="token punctuation">&#123;</span>        timers<span class="token punctuation">.</span>created <span class="token operator">=</span> <span class="token boolean">true</span>        <span class="token keyword">go</span> <span class="token function">timerproc</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们暂时可以不用理解为什么有 sleeping, rescheduling 两种状态，先掌握整体的执行过程，再深入的去看细节。<br>​</p><h4 id="timer-的删除"><a href="#timer-的删除" class="headerlink" title="timer 的删除"></a>timer 的删除</h4><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// Delete timer t from the heap.</span><span class="token comment">// Do not need to update the timerproc: if it wakes up early, no big deal.</span><span class="token keyword">func</span> <span class="token function">deltimer</span><span class="token punctuation">(</span>t <span class="token operator">*</span>timer<span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// Dereference t so that any panic happens before the lock is held.</span>    <span class="token comment">// Discard result, because t might be moving in the heap.</span>    <span class="token boolean">_</span> <span class="token operator">=</span> t<span class="token punctuation">.</span>i    <span class="token function">lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>timers<span class="token punctuation">.</span>lock<span class="token punctuation">)</span>    <span class="token comment">// t may not be registered anymore and may have</span>    <span class="token comment">// a bogus i (typically 0, if generated by Go).</span>    <span class="token comment">// Verify it before proceeding.</span>    i <span class="token operator">:=</span> t<span class="token punctuation">.</span>i    last <span class="token operator">:=</span> <span class="token function">len</span><span class="token punctuation">(</span>timers<span class="token punctuation">.</span>t<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>    <span class="token keyword">if</span> i <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> i <span class="token operator">></span> last <span class="token operator">||</span> timers<span class="token punctuation">.</span>t<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> t <span class="token punctuation">&#123;</span> <span class="token comment">// 边界检查，校验 timer 是否有效</span>        <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>timers<span class="token punctuation">.</span>lock<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token boolean">false</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> i <span class="token operator">!=</span> last <span class="token punctuation">&#123;</span>    <span class="token comment">// 如果要删除的 timer 不是堆中的 最后一个 timer</span>        timers<span class="token punctuation">.</span>t<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> timers<span class="token punctuation">.</span>t<span class="token punctuation">[</span>last<span class="token punctuation">]</span>    <span class="token comment">// 堆顶元素与堆尾元素进行互换</span>        timers<span class="token punctuation">.</span>t<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>i <span class="token operator">=</span> i    <span class="token punctuation">&#125;</span>    timers<span class="token punctuation">.</span>t<span class="token punctuation">[</span>last<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">nil</span>        <span class="token comment">// 上述操作已经将要删除的元素放到堆的末尾，直接通过置为 nil 的方式进行删除</span>    timers<span class="token punctuation">.</span>t <span class="token operator">=</span> timers<span class="token punctuation">.</span>t<span class="token punctuation">[</span><span class="token punctuation">:</span>last<span class="token punctuation">]</span>    <span class="token keyword">if</span> i <span class="token operator">!=</span> last <span class="token punctuation">&#123;</span>              <span class="token comment">// 重新对堆进行排列</span>        <span class="token function">siftupTimer</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>        <span class="token function">siftdownTimer</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>timers<span class="token punctuation">.</span>lock<span class="token punctuation">)</span>        <span class="token comment">// 删除并重排序完成，释放掉timer的全局锁</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="timerproc"><a href="#timerproc" class="headerlink" title="timerproc"></a>timerproc</h4><p>addtimer 是生产者的话，我们可以把 timerproc 理解为消费者。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">timerproc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 注意这里！将执行timerproc的 goroutine 赋值给了 timers 中的 gp 字段。</span>    timers<span class="token punctuation">.</span>gp <span class="token operator">=</span> <span class="token function">getg</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> <span class="token punctuation">&#123;</span>        <span class="token function">lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>timers<span class="token punctuation">.</span>lock<span class="token punctuation">)</span>         <span class="token comment">// 当前执行 timerproc 所以不再是 sleeping 状态，置为 false</span>        timers<span class="token punctuation">.</span>sleeping <span class="token operator">=</span> <span class="token boolean">false</span>        now <span class="token operator">:=</span> <span class="token function">nanotime</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment">// delta 表示 timer 要执行的时间与当前时间的差值，</span>        <span class="token comment">// 如果 delta > 0 说明还没有到 timer 的执行时间</span>        delta <span class="token operator">:=</span> <span class="token function">int64</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 判断 timers 中是否有要执行的 timer</span>            <span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>timers<span class="token punctuation">.</span>t<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>                delta <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span>                <span class="token keyword">break</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">// 有要执行的，直接获取堆顶元素，小顶堆嘛，堆顶的肯定是最小的</span>            t <span class="token operator">:=</span> timers<span class="token punctuation">.</span>t<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>            <span class="token comment">// 计算 delta 差值</span>            delta <span class="token operator">=</span> t<span class="token punctuation">.</span>when <span class="token operator">-</span> now            <span class="token keyword">if</span> delta <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">break</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">// 如果是一个要周期执行的 timer，计算下次执行时间，并重新排列堆</span>            <span class="token keyword">if</span> t<span class="token punctuation">.</span>period <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// leave in heap but adjust next time to fire</span>                t<span class="token punctuation">.</span>when <span class="token operator">+=</span> t<span class="token punctuation">.</span>period <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">+</span> <span class="token operator">-</span>delta<span class="token operator">/</span>t<span class="token punctuation">.</span>period<span class="token punctuation">)</span>                <span class="token function">siftdownTimer</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// remove from heap</span>                last <span class="token operator">:=</span> <span class="token function">len</span><span class="token punctuation">(</span>timers<span class="token punctuation">.</span>t<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>                <span class="token keyword">if</span> last <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>                    timers<span class="token punctuation">.</span>t<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> timers<span class="token punctuation">.</span>t<span class="token punctuation">[</span>last<span class="token punctuation">]</span>                    timers<span class="token punctuation">.</span>t<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>i <span class="token operator">=</span> <span class="token number">0</span>                <span class="token punctuation">&#125;</span>                timers<span class="token punctuation">.</span>t<span class="token punctuation">[</span>last<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">nil</span>                timers<span class="token punctuation">.</span>t <span class="token operator">=</span> timers<span class="token punctuation">.</span>t<span class="token punctuation">[</span><span class="token punctuation">:</span>last<span class="token punctuation">]</span>                <span class="token keyword">if</span> last <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>                    <span class="token function">siftdownTimer</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>                <span class="token punctuation">&#125;</span>                t<span class="token punctuation">.</span>i <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token comment">// mark as removed</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">// 获取该 timer 中的函数</span>            f <span class="token operator">:=</span> t<span class="token punctuation">.</span>f            arg <span class="token operator">:=</span> t<span class="token punctuation">.</span>arg            seq <span class="token operator">:=</span> t<span class="token punctuation">.</span>seq            <span class="token comment">// 因为执行用户的代码并不需要加锁，所以在此处对锁进行释放，防止其他获取锁的g阻塞太久时间</span>            <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>timers<span class="token punctuation">.</span>lock<span class="token punctuation">)</span>            <span class="token keyword">if</span> raceenabled <span class="token punctuation">&#123;</span>                <span class="token function">raceacquire</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">// 执行用户函数</span>            <span class="token function">f</span><span class="token punctuation">(</span>arg<span class="token punctuation">,</span> seq<span class="token punctuation">)</span>            <span class="token function">lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>timers<span class="token punctuation">.</span>lock<span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> delta <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> faketime <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// No timers left - put goroutine to sleep.</span>            <span class="token comment">// 这种情况意味着 timers 中没有任何可以执行的 timer，gopark挂起，后面goready唤醒</span>            timers<span class="token punctuation">.</span>rescheduling <span class="token operator">=</span> <span class="token boolean">true</span>            <span class="token function">goparkunlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>timers<span class="token punctuation">.</span>lock<span class="token punctuation">,</span> <span class="token string">"timer goroutine (idle)"</span><span class="token punctuation">,</span> traceEvGoBlock<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>            <span class="token comment">// 恢复回来回到头部执行</span>            <span class="token keyword">continue</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// At least one timer pending. Sleep until then. timers 中至少有一个可以执行的 timer</span>        <span class="token comment">// 设置为 sleeping 我们不使用 gopark 挂起是因为，可能某个timer要执行了，但是你 goready 后重新调度后，会导致这个timer超时</span>        timers<span class="token punctuation">.</span>sleeping <span class="token operator">=</span> <span class="token boolean">true</span>        <span class="token function">noteclear</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>timers<span class="token punctuation">.</span>waitnote<span class="token punctuation">)</span>        <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>timers<span class="token punctuation">.</span>lock<span class="token punctuation">)</span>        <span class="token comment">// 通过 futex 系统调用，让这个 timerproc 睡一会，醒来之后继续干活</span>        <span class="token comment">// 该过程涉及到 handoffp，文章末尾做了简要总结</span>        <span class="token function">notetsleepg</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>timers<span class="token punctuation">.</span>waitnote<span class="token punctuation">,</span> delta<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>至此我们已经解答了文章开头的一部分问题。<br>​</p><ul><li>1.在堆的小节去了解</li><li>2.创建 timer 的时<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> runtimeTimer <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>    i      <span class="token builtin">int</span>    <span class="token comment">// 在堆中的位置</span>    when   <span class="token builtin">int64</span><span class="token comment">// 某个时间点</span>    period <span class="token builtin">int64</span><span class="token comment">// 周期</span>    f      <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token builtin">uintptr</span><span class="token punctuation">)</span> <span class="token comment">// NOTE: must not be closure go的封装的一些函数</span>    arg    <span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token comment">// 这个才是我们自己的函数</span>    seq    <span class="token builtin">uintptr</span><span class="token comment">// 这个好像是没用到</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">goFunc</span><span class="token punctuation">(</span>arg <span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> seq <span class="token builtin">uintptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">go</span> arg<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>我们如果写了一个死循环并不会影响timerproc的执行，底层为我们新建了一个 goroutine 去执行。<br>​</li></ul><ul><li>3.g 被谁接管了？我在一开始看的时候也有点迷惑，要是能被接管肯定是放在某个地方了，看的时候就是没找到，后来再梳理的时候发现，在 timerproc 函数开始的第一行代码就是 把 g 放入了 timer.gp 字段。</li><li>4.timer中的两种挂起方式，这个在代码中注释的已经很详细了</li></ul><p>1&gt; futex syscall<br>2&gt; gopark</p><p>我们已经看完了整个 创建 timer 的过程，并且知道了 timerproc 就是用来真正执行 timer 的函数。总结一下现在的 timer 有什么问题：<br>​</p><p><strong>全局只有一把锁，只要对四叉堆修改，必须要加锁，所以怎么做优化才能降低锁的竞争，与此同时，一个非常隐蔽的，也是至关重要的问题正在发生。当我们 timers 中有待执行的对象时，在 timerproc 中通过 syscall 使当前 M 进入阻塞，调度模型中的 handoffp 会将 M 从当前 P 上剥离，然后找一个空闲的 M 或 新建一个 M 执行本地队列中的 g。当进入阻塞的 syscall 调用完成了的时候，需要把 timerproc 重新放回队列进行调度。这种频繁的上下文切换白白浪费了资源。</strong>（在 1.14 版本中去掉了 timerproc 把执行 timer 的逻辑嵌入到调度循环，sysmon等函数中）</p><h3 id="实际开发中的-timer"><a href="#实际开发中的-timer" class="headerlink" title="实际开发中的 timer"></a>实际开发中的 timer</h3><h4 id="time-Sleep-后发生了什么？"><a href="#time-Sleep-后发生了什么？" class="headerlink" title="time.Sleep() 后发生了什么？"></a>time.Sleep() 后发生了什么？</h4><p>日常的开发工作中，或者是写 demo 的时候，经常会用到 time.Sleep()，会让当前的 goroutine 睡一会，等到满足某个 condition 的时候再醒来继续工作。<br>废话不多说，直接上源码。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// timeSleep puts the current goroutine to sleep for at least ns nanoseconds.</span><span class="token comment">//go:linkname timeSleep time.Sleep 可以看到当我们使用 time.Sleep 的时候实际上底层调用的是 timeSleep() 这个函数</span><span class="token keyword">func</span> <span class="token function">timeSleep</span><span class="token punctuation">(</span>ns <span class="token builtin">int64</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> ns <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 新建一个 timer 对象</span>    t <span class="token operator">:=</span> <span class="token function">new</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span>    <span class="token comment">// 计算要让这个 goroutine 休眠的时间</span>    t<span class="token punctuation">.</span>when <span class="token operator">=</span> <span class="token function">nanotime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> ns    <span class="token comment">// t.f 前文中有提到过，是到时后要执行的那个 function</span>    t<span class="token punctuation">.</span>f <span class="token operator">=</span> goroutineReady    <span class="token comment">// 上述 function 的 arg，把执行 timeSleep 的 goroutine 存储到 t.arg 中</span>    t<span class="token punctuation">.</span>arg <span class="token operator">=</span> <span class="token function">getg</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment">// 新的 timer 封装好了，要把新 timer 加入到 堆中，保证并发安全，上锁！</span>    <span class="token function">lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>timers<span class="token punctuation">.</span>lock<span class="token punctuation">)</span>    <span class="token function">addtimerLocked</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span>    <span class="token comment">// 挂起当前的 goroutine</span>    <span class="token function">goparkunlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>timers<span class="token punctuation">.</span>lock<span class="token punctuation">,</span> <span class="token string">"sleep"</span><span class="token punctuation">,</span> traceEvGoSleep<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="time-AfterFunc-后发生了什么？"><a href="#time-AfterFunc-后发生了什么？" class="headerlink" title="time.AfterFunc() 后发生了什么？"></a>time.AfterFunc() 后发生了什么？</h4><p>经过上述的分析是不是已经很简单了，不过我们还是来看一下源码。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// AfterFunc waits for the duration to elapse and then calls f</span><span class="token comment">// in its own goroutine. It returns a Timer that can</span><span class="token comment">// be used to cancel the call using its Stop method.</span><span class="token keyword">func</span> <span class="token function">AfterFunc</span><span class="token punctuation">(</span>d Duration<span class="token punctuation">,</span> f <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">*</span>Timer <span class="token punctuation">&#123;</span>    t <span class="token operator">:=</span> <span class="token operator">&amp;</span>Timer<span class="token punctuation">&#123;</span>    <span class="token comment">// 封装 timer</span>        r<span class="token punctuation">:</span> runtimeTimer<span class="token punctuation">&#123;</span>            when<span class="token punctuation">:</span> <span class="token function">when</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">,</span>            f<span class="token punctuation">:</span>    goFunc<span class="token punctuation">,</span>            arg<span class="token punctuation">:</span>  f<span class="token punctuation">,</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// startTimer 前文中提到过，内部就是将新的timer加入到堆中，其中逻辑前文都覆盖到了</span>    <span class="token function">startTimer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t<span class="token punctuation">.</span>r<span class="token punctuation">)</span>    <span class="token keyword">return</span> t<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="堆的简单了解"><a href="#堆的简单了解" class="headerlink" title="堆的简单了解"></a>堆的简单了解</h3><p>go1.8 版本的 timers 结构如下图所示，全局共享一个四叉堆，那么当访问这个数据结构的时候，为了保证并发的安全性，一定是要获取到锁的。<br>也正是因此锁成了 go1.8 中 timer 主要的性能瓶颈。<br><img src="https://gitee.com/yangbaoqiang/images/raw/f4fa80bedef662b0abaf2a695cefcc0658c83439/blogpics/1635754910137-44029b08-6db8-4417-a709-0ff8b7b38a24.png" alt="image.png"></p><p>我们简单说一下堆这个数据结构，二叉树大家都很了解，那怎么把一颗二叉树转换成一个二叉堆呢？go 中存储 timer 的数据结构就是一个切片，那什么样的树结构能够使用数组进行存储呢？<br>​</p><p>这里先给出结论：<br>1.完全二叉树可以使用数组来存储。<br>2.当一颗二叉树满足完全二叉树的性质，并且满足每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆，大顶堆概念相反。</p><p>如上图所示，四叉堆，各个元素存储在数组中，如果想得到子节点的父节点，设子节点索引为 i，那么父节点 p = (i - 1) / 4 (图上的n画错了应该是 i，懒得改了）。<br>​</p><h4 id="timer-四叉堆排序算法"><a href="#timer-四叉堆排序算法" class="headerlink" title="timer 四叉堆排序算法"></a>timer 四叉堆排序算法</h4><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// Heap maintenance algorithms.</span><span class="token comment">// 由下向上</span><span class="token comment">// 主要的算法思想是：用索引为 i 的timer，不断地找到该 timer 的 parent，并比较两者的 when 进行交换</span><span class="token keyword">func</span> <span class="token function">siftupTimer</span><span class="token punctuation">(</span>i <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    t <span class="token operator">:=</span> timers<span class="token punctuation">.</span>t    when <span class="token operator">:=</span> t<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>when    tmp <span class="token operator">:=</span> t<span class="token punctuation">[</span>i<span class="token punctuation">]</span>    <span class="token keyword">for</span> i <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>        p <span class="token operator">:=</span> <span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">4</span> <span class="token comment">// parent</span>        <span class="token keyword">if</span> when <span class="token operator">>=</span> t<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">.</span>when <span class="token punctuation">&#123;</span>            <span class="token keyword">break</span>        <span class="token punctuation">&#125;</span>        t<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token punctuation">[</span>p<span class="token punctuation">]</span>        t<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>i <span class="token operator">=</span> i        t<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">=</span> tmp        t<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">.</span>i <span class="token operator">=</span> p        i <span class="token operator">=</span> p    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 由上向下</span><span class="token keyword">func</span> <span class="token function">siftdownTimer</span><span class="token punctuation">(</span>i <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    t <span class="token operator">:=</span> timers<span class="token punctuation">.</span>t    n <span class="token operator">:=</span> <span class="token function">len</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span>    <span class="token comment">// 堆中总的元素数量</span>    when <span class="token operator">:=</span> t<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>when    tmp <span class="token operator">:=</span> t<span class="token punctuation">[</span>i<span class="token punctuation">]</span>    <span class="token keyword">for</span> <span class="token punctuation">&#123;</span>        c <span class="token operator">:=</span> i<span class="token operator">*</span><span class="token number">4</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token comment">// left child</span>        c3 <span class="token operator">:=</span> c <span class="token operator">+</span> <span class="token number">2</span>  <span class="token comment">// mid child</span>        <span class="token keyword">if</span> c <span class="token operator">>=</span> n <span class="token punctuation">&#123;</span><span class="token comment">// 判断 i 的四个子节点中的第一个是否超过了总节点个数</span>            <span class="token keyword">break</span>        <span class="token punctuation">&#125;</span>        w <span class="token operator">:=</span> t<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">.</span>when         <span class="token keyword">if</span> c<span class="token operator">+</span><span class="token number">1</span> <span class="token operator">&lt;</span> n <span class="token operator">&amp;&amp;</span> t<span class="token punctuation">[</span>c<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>when <span class="token operator">&lt;</span> w <span class="token punctuation">&#123;</span> <span class="token comment">// 找到前两个子节点中最小的</span>            w <span class="token operator">=</span> t<span class="token punctuation">[</span>c<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>when            c<span class="token operator">++</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> c3 <span class="token operator">&lt;</span> n <span class="token punctuation">&#123;</span>            w3 <span class="token operator">:=</span> t<span class="token punctuation">[</span>c3<span class="token punctuation">]</span><span class="token punctuation">.</span>when            <span class="token keyword">if</span> c3<span class="token operator">+</span><span class="token number">1</span> <span class="token operator">&lt;</span> n <span class="token operator">&amp;&amp;</span> t<span class="token punctuation">[</span>c3<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>when <span class="token operator">&lt;</span> w3 <span class="token punctuation">&#123;</span><span class="token comment">// 找到后两个子节点中最小的</span>                w3 <span class="token operator">=</span> t<span class="token punctuation">[</span>c3<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>when                c3<span class="token operator">++</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">if</span> w3 <span class="token operator">&lt;</span> w <span class="token punctuation">&#123;</span> <span class="token comment">// 找到这两组子结点中最小的</span>                w <span class="token operator">=</span> w3                c <span class="token operator">=</span> c3            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> w <span class="token operator">>=</span> when <span class="token punctuation">&#123;</span><span class="token comment">// 判断子节点中的值是否大于父节点，是就不需要交换</span>            <span class="token keyword">break</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 由此开始，是把子节点与父节点进行互换</span>        t<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token punctuation">[</span>c<span class="token punctuation">]</span>        t<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>i <span class="token operator">=</span> i        t<span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">=</span> tmp        t<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">.</span>i <span class="token operator">=</span> c        i <span class="token operator">=</span> c    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><p>如果完全二叉树，采用数组进行存储，索引从 0 开始存储和索引从 1 开始存储有什么区别？可以动手画一下。</p><h3 id="timer-中的上下文切换"><a href="#timer-中的上下文切换" class="headerlink" title="timer 中的上下文切换"></a>timer 中的上下文切换</h3><h4 id="notesleepg"><a href="#notesleepg" class="headerlink" title="notesleepg"></a>notesleepg</h4><p>在 timers 中没有任何将要执行的 timer 时，会通过 futex 这个系统调用将当前这个 M 挂起，看看代码中是怎么做的。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">notetsleepg</span><span class="token punctuation">(</span>n <span class="token operator">*</span>note<span class="token punctuation">,</span> ns <span class="token builtin">int64</span><span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">&#123;</span>    gp <span class="token operator">:=</span> <span class="token function">getg</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> gp <span class="token operator">==</span> gp<span class="token punctuation">.</span>m<span class="token punctuation">.</span>g0 <span class="token punctuation">&#123;</span>        <span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">"notetsleepg on g0"</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 进入系统调用</span>    <span class="token function">entersyscallblock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment">// 阻塞当前线程</span>    ok <span class="token operator">:=</span> <span class="token function">notetsleep_internal</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> ns<span class="token punctuation">)</span>    <span class="token comment">// 退出系统调用</span>    <span class="token function">exitsyscall</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> ok<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">entersyscallblock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">)</span> <span class="token comment">// 省略了一些处理 g 状态的代码</span>    <span class="token comment">// 切换到 g0 栈，执行 handoff 操作</span>    <span class="token function">systemstack</span><span class="token punctuation">(</span>entersyscallblock_handoff<span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">entersyscallblock_handoff</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">)</span> <span class="token comment">// 省略 trace</span>    <span class="token comment">// releasep 中解绑了 M 与 P 的关系</span>    <span class="token comment">// handoffp 中会获取线程</span>    <span class="token function">handoffp</span><span class="token punctuation">(</span><span class="token function">releasep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// 上述函数将 M 与 P 解绑之后，M 通过 futex 系统调用休眠 ns </span><span class="token keyword">func</span> <span class="token function">notetsleep_internal</span><span class="token punctuation">(</span>n <span class="token operator">*</span>note<span class="token punctuation">,</span> ns <span class="token builtin">int64</span><span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">&#123;</span>    gp <span class="token operator">:=</span> <span class="token function">getg</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> ns <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token operator">*</span>cgo_yield <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// Sleep for an arbitrary-but-moderate interval to poll libc interceptors.</span>            ns <span class="token operator">=</span> <span class="token number">10e6</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">for</span> atomic<span class="token punctuation">.</span><span class="token function">Load</span><span class="token punctuation">(</span><span class="token function">key32</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>n<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>            gp<span class="token punctuation">.</span>m<span class="token punctuation">.</span>blocked <span class="token operator">=</span> <span class="token boolean">true</span>            <span class="token function">futexsleep</span><span class="token punctuation">(</span><span class="token function">key32</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>n<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> ns<span class="token punctuation">)</span>            <span class="token keyword">if</span> <span class="token operator">*</span>cgo_yield <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>                <span class="token function">asmcgocall</span><span class="token punctuation">(</span><span class="token operator">*</span>cgo_yield<span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">)</span>            <span class="token punctuation">&#125;</span>            gp<span class="token punctuation">.</span>m<span class="token punctuation">.</span>blocked <span class="token operator">=</span> <span class="token boolean">false</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> atomic<span class="token punctuation">.</span><span class="token function">Load</span><span class="token punctuation">(</span><span class="token function">key32</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>n<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span>    <span class="token punctuation">&#125;</span>    deadline <span class="token operator">:=</span> <span class="token function">nanotime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> ns    <span class="token keyword">for</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token operator">*</span>cgo_yield <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token operator">&amp;&amp;</span> ns <span class="token operator">></span> <span class="token number">10e6</span> <span class="token punctuation">&#123;</span>            ns <span class="token operator">=</span> <span class="token number">10e6</span>        <span class="token punctuation">&#125;</span>        gp<span class="token punctuation">.</span>m<span class="token punctuation">.</span>blocked <span class="token operator">=</span> <span class="token boolean">true</span><span class="token comment">// 表示当前 M 正在阻塞</span>        <span class="token function">futexsleep</span><span class="token punctuation">(</span><span class="token function">key32</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>n<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> ns<span class="token punctuation">)</span><span class="token comment">// 让 M 睡一会</span>        <span class="token keyword">if</span> <span class="token operator">*</span>cgo_yield <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>            <span class="token function">asmcgocall</span><span class="token punctuation">(</span><span class="token operator">*</span>cgo_yield<span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span>        gp<span class="token punctuation">.</span>m<span class="token punctuation">.</span>blocked <span class="token operator">=</span> <span class="token boolean">false</span><span class="token comment">// 休眠完成，修改回 M 的阻塞状态</span>        <span class="token keyword">if</span> atomic<span class="token punctuation">.</span><span class="token function">Load</span><span class="token punctuation">(</span><span class="token function">key32</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>n<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">break</span>        <span class="token punctuation">&#125;</span>        now <span class="token operator">:=</span> <span class="token function">nanotime</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> now <span class="token operator">>=</span> deadline <span class="token punctuation">&#123;</span>            <span class="token keyword">break</span>        <span class="token punctuation">&#125;</span>        ns <span class="token operator">=</span> deadline <span class="token operator">-</span> now    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> atomic<span class="token punctuation">.</span><span class="token function">Load</span><span class="token punctuation">(</span><span class="token function">key32</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>n<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>M 从系统调用中恢复过来，在缺少 P 的情况下是怎么个执行过程</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">exitsyscall</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">)</span>    oldp <span class="token operator">:=</span> _g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>oldp<span class="token punctuation">.</span><span class="token function">ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment">// 获取之前执行这个 M 的 P</span>    _g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>oldp <span class="token operator">=</span> <span class="token number">0</span>    <span class="token comment">// fast path，如果能获取到之前的 P 还是放在原来的 P 上进行调度，否则看看有没有空闲的 P</span>    <span class="token keyword">if</span> <span class="token function">exitsyscallfast</span><span class="token punctuation">(</span>oldp<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> _g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>mcache <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>            <span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">"lost mcache"</span><span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> trace<span class="token punctuation">.</span>enabled <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> oldp <span class="token operator">!=</span> _g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>p<span class="token punctuation">.</span><span class="token function">ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> _g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>syscalltick <span class="token operator">!=</span> _g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>p<span class="token punctuation">.</span><span class="token function">ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>syscalltick <span class="token punctuation">&#123;</span>                <span class="token function">systemstack</span><span class="token punctuation">(</span>traceGoStart<span class="token punctuation">)</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// There's a cpu for us, so we can run.</span>        _g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>p<span class="token punctuation">.</span><span class="token function">ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>syscalltick<span class="token operator">++</span>        <span class="token comment">// We need to cas the status and scan before resuming...</span>        <span class="token function">casgstatus</span><span class="token punctuation">(</span>_g_<span class="token punctuation">,</span> _Gsyscall<span class="token punctuation">,</span> _Grunning<span class="token punctuation">)</span>        <span class="token comment">// Garbage collector isn't running (since we are),</span>        <span class="token comment">// so okay to clear syscallsp.</span>        _g_<span class="token punctuation">.</span>syscallsp <span class="token operator">=</span> <span class="token number">0</span>        _g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>locks<span class="token operator">--</span>        <span class="token keyword">if</span> _g_<span class="token punctuation">.</span>preempt <span class="token punctuation">&#123;</span>            <span class="token comment">// restore the preemption request in case we've cleared it in newstack</span>            _g_<span class="token punctuation">.</span>stackguard0 <span class="token operator">=</span> stackPreempt        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// otherwise restore the real _StackGuard, we've spoiled it in entersyscall/entersyscallblock</span>            _g_<span class="token punctuation">.</span>stackguard0 <span class="token operator">=</span> _g_<span class="token punctuation">.</span>stack<span class="token punctuation">.</span>lo <span class="token operator">+</span> _StackGuard        <span class="token punctuation">&#125;</span>        _g_<span class="token punctuation">.</span>throwsplit <span class="token operator">=</span> <span class="token boolean">false</span>        <span class="token keyword">if</span> sched<span class="token punctuation">.</span>disable<span class="token punctuation">.</span>user <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">schedEnabled</span><span class="token punctuation">(</span>_g_<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// Scheduling of this goroutine is disabled.</span>            <span class="token function">Gosched</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span>    <span class="token punctuation">&#125;</span>    <span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">)</span>    <span class="token comment">// Call the scheduler.</span>    <span class="token function">mcall</span><span class="token punctuation">(</span>exitsyscall0<span class="token punctuation">)</span> <span class="token comment">// slow path put g to globalrunq</span>    <span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>感谢你能够看完，笔者能力有限，有问题的地方欢迎大家指出，共同探讨，一起学习、进步！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;golang timer 的优化过程以及底层实现。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://bqyang.top/2021/hello-world/"/>
    <id>https://bqyang.top/2021/hello-world/</id>
    <published>2021-11-14T14:46:05.909Z</published>
    <updated>2021-11-22T12:55:42.311Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><span id="more"></span><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
</feed>
