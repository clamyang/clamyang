<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>杨宝强的技术笔记</title>
  
  <subtitle>Gopher Watcher</subtitle>
  <link href="https://bqyang.top/atom.xml" rel="self"/>
  
  <link href="https://bqyang.top/"/>
  <updated>2022-07-11T10:41:29.671Z</updated>
  <id>https://bqyang.top/</id>
  
  <author>
    <name>bqyang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>组合模式</title>
    <link href="https://bqyang.top/2022/design-pattern/Structural/composite/"/>
    <id>https://bqyang.top/2022/design-pattern/Structural/composite/</id>
    <published>2022-07-10T16:00:00.000Z</published>
    <updated>2022-07-11T10:41:29.671Z</updated>
    
    <content type="html"><![CDATA[<p>设计模式的学习逐渐变成了一周一次，一次一周。不求一天之内学多少，重要的是真正了解到模式适用的场景，一味的图快，可能有点狗熊掰棒子那味了。那这周的主要内容是<strong>组合模式</strong>。</p><span id="more"></span><h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><p>主要思想：<strong>整体与部分可以被一致对待</strong></p><p>组合模式（Composite），将对象组合成树形结构以表示‘部分-整体’的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。</p><h3 id="透明方式-与-安全方式"><a href="#透明方式-与-安全方式" class="headerlink" title="透明方式 与 安全方式"></a>透明方式 与 安全方式</h3><p><strong>透明方式</strong></p><p><strong>安全方式</strong></p><h3 id="何时使用？"><a href="#何时使用？" class="headerlink" title="何时使用？"></a>何时使用？</h3><p>需求中是体现<strong>部分与整体</strong>层次的结构时，以及希望用户可以忽略组合对象与单个对象的不同，统一地使用组合结构中的所有对象时，就应该考虑用组合模式。形如总部与分部，文件与文件夹这种形式。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3>]]></content>
    
    
    <summary type="html">&lt;p&gt;设计模式的学习逐渐变成了一周一次，一次一周。不求一天之内学多少，重要的是真正了解到模式适用的场景，一味的图快，可能有点狗熊掰棒子那味了。那这周的主要内容是&lt;strong&gt;组合模式&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>简易版 pstree</title>
    <link href="https://bqyang.top/2022/os/pstree/"/>
    <id>https://bqyang.top/2022/os/pstree/</id>
    <published>2022-07-10T12:26:34.198Z</published>
    <updated>2022-07-11T03:57:27.625Z</updated>
    
    <content type="html"><![CDATA[<p>最近在学习 C 语言的相关知识，想通过 C 语言实现一个简易版的 <code>pstree</code> 命令行工具，我认为对 C 新手来说还是有一定难度的，最后只通过 C 实现了一半功能，但是实践的过程让我印象深刻。现代程序员使用着便捷的开发工具，输入几个首字母就能打印出自己想调用的库函数。</p><span id="more"></span><p>我想几十年前的编程，是不是还挺麻烦的，或许跟我使用的环境有关，我在虚机上使用 VIM 写的，没有快捷键，更没有代码自动补全。 想知道一个库函数怎么用、怎么传参都需要通过手册查询，在某些程度上，这个过程也锻炼了自己查阅资料的能力。</p><p>一般，我是通过 <code>tmux</code> 开两个 session，一个用来敲代码，另一个查手册。最后卡在 C 上的原因是：</p><p>N 叉树实现问题，不知道怎么初始化结构体，又不想把每个节点中的子节点数量写死，所以就通过 Go 实现了后半部分。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 子节点硬编码</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> Id;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">Child</span>[10];</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这种在通过 malloc 初始化的时候，存在问题</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> Id;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">Child</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还没有看学到 C struct 中的内容（大学学的早就还给老师了），待我学成归来，一定把这块好好补上。</p><p>另一个在 C 中比较难的是，不知道怎么处理字符串，不知道哪些库函数可以做我想做的事。就比如拆分字符串，如果说每次通过 split 拆分一个太复杂了，它有个 strtok 更方便..不过这些问题还好，是自己对语言的不熟悉。</p><p>实现 <code>pstree</code> 过程中花了较多时间的点：</p><ul><li>如何找到进程的相关信息，父进程ID，当前进程的名称</li><li>如何过滤非进程目录</li><li>如何存储父进程及其子进程</li><li>如何以缩进的方式输出</li></ul><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sort&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;path/filepath&quot;</span></span><br><span class="line">    <span class="string">&quot;strconv&quot;</span></span><br><span class="line">    <span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// init root node</span></span><br><span class="line"><span class="keyword">var</span> Root = &amp;Node&#123;Id: <span class="number">1</span>, Child: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">uint</span>]*Node)&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123;</span><br><span class="line">    Id    <span class="keyword">uint</span></span><br><span class="line">    Name  <span class="keyword">string</span></span><br><span class="line">    Child <span class="keyword">map</span>[<span class="keyword">uint</span>]*Node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n Node)</span> <span class="title">GetName</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> n.Name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *Node)</span> <span class="title">InsertChild</span><span class="params">(id <span class="keyword">uint</span>, childName <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n.Child == <span class="literal">nil</span> &#123;</span><br><span class="line">        n.Child = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">uint</span>]*Node)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    n.Child[id] = &amp;Node&#123;</span><br><span class="line">        Id:    id,</span><br><span class="line">        Name:  childName,</span><br><span class="line">        Child: <span class="literal">nil</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pre-traverse</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TraverseTree</span><span class="params">(root *Node, indent <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%s%d-%s\n&quot;</span>, strings.Repeat(<span class="string">&quot; &quot;</span>, indent), root.Id, root.GetName())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> root.Child == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, child := <span class="keyword">range</span> root.Child &#123;</span><br><span class="line">        TraverseTree(child, indent+<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FindParent</span><span class="params">(parentId <span class="keyword">uint</span>, root *Node)</span> *<span class="title">Node</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> parentId == <span class="number">0</span> || parentId == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Root</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the last node</span></span><br><span class="line">    <span class="keyword">if</span> root.Child == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> parent, ok := root.Child[parentId]; ok &amp;&amp; parent.Id == parentId &#123;</span><br><span class="line">        <span class="keyword">return</span> parent</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, node := <span class="keyword">range</span> root.Child &#123;</span><br><span class="line">        <span class="keyword">if</span> parent := FindParent(parentId, node); parent != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> parent</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetProcs</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fps, err := filepath.Glob(<span class="string">&quot;/proc/[0-9]*&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalln(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort.Slice(fps, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">        one := strings.TrimPrefix(fps[i], <span class="string">&quot;/proc/&quot;</span>)</span><br><span class="line">        two := strings.TrimPrefix(fps[j], <span class="string">&quot;/proc/&quot;</span>)</span><br><span class="line"></span><br><span class="line">        num1, _ := strconv.Atoi(one)</span><br><span class="line">        num2, _ := strconv.Atoi(two)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> num1 &lt; num2 &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, procFile := <span class="keyword">range</span> fps &#123;</span><br><span class="line">        stat, err := os.ReadFile(filepath.Join(procFile, <span class="string">&quot;/stat&quot;</span>))</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Println(err)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pid, parentId, processName := GetInfoFromStat(<span class="keyword">string</span>(stat))</span><br><span class="line">        <span class="keyword">if</span> pid == <span class="number">1</span> &#123;</span><br><span class="line">            Root.Name = processName</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// after find parent, insert to proc tree</span></span><br><span class="line">        <span class="comment">// because the proc dir order by pid</span></span><br><span class="line">        <span class="comment">// so parent always insert to tree before child</span></span><br><span class="line">        parentNode := FindParent(parentId, Root)</span><br><span class="line">        <span class="keyword">if</span> parentNode == <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Fatalln(<span class="string">&quot;parent doesn&#x27;t in tree&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        parentNode.InsertChild(pid, processName)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetInfoFromStat</span><span class="params">(stat <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">uint</span>, <span class="keyword">uint</span>, <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        procName <span class="keyword">string</span></span><br><span class="line">        pid      <span class="keyword">int</span></span><br><span class="line">        ppid     <span class="keyword">int</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    tokens := strings.FieldsFunc(stat, <span class="function"><span class="keyword">func</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">        <span class="keyword">return</span> r == <span class="string">&#x27;(&#x27;</span> || r == <span class="string">&#x27;)&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(tokens) != <span class="number">3</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    procName = tokens[<span class="number">1</span>]</span><br><span class="line">    pid, _ = strconv.Atoi(strings.TrimSuffix(tokens[<span class="number">0</span>], <span class="string">&quot; &quot;</span>))</span><br><span class="line">    ppid, _ = strconv.Atoi(strings.Split(strings.TrimPrefix(tokens[<span class="number">2</span>], <span class="string">&quot; &quot;</span>), <span class="string">&quot; &quot;</span>)[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">uint</span>(pid), <span class="keyword">uint</span>(ppid), procName</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// populate N Tree</span></span><br><span class="line">    GetProcs()</span><br><span class="line">    <span class="comment">// printf tree</span></span><br><span class="line">    TraverseTree(Root, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码如上，用 Go 实现也遇到了与上述一样的问题，过滤目录，处理字符串。</p><p>新学到了 <code>filepath.Glob()</code> 还是比较好用的，直接通过正则的方式就将所有进程相关的目录输出了。</p><p>以及 <code>strings.FieldFunc()</code> 每次可以使用不通过分隔符进行过滤跟 C 中 <code>strtok</code> 类似。</p><p>最难的就是如何输出这棵树，先把当前实现的输出放出来（是不是挺像那么回事）：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> pid-process_name</span></span><br><span class="line"></span><br><span class="line">1-systemd</span><br><span class="line"> 19-systemd-journal</span><br><span class="line"> 29-systemd-udevd</span><br><span class="line">  9405-systemd-udevd</span><br><span class="line">  9402-systemd-udevd</span><br><span class="line">  9403-systemd-udevd</span><br><span class="line">  9404-systemd-udevd</span><br><span class="line"> 76-sshd</span><br><span class="line">  86-sshd</span><br><span class="line">   88-bash</span><br><span class="line">    9406-pstree</span><br><span class="line"> 81-systemd-logind</span><br><span class="line"> 82-dbus-daemon</span><br><span class="line"> 84-agetty</span><br></pre></td></tr></table></figure><p>通过前序遍历的方式就能输出这个方式但是输出内容都是齐刷刷的，难的地方在于如何考虑缩进的长度。</p><p>最后实在是想不出来了，上 Github 看了一下，我的方向没错，需要在前序遍历过程中加上一个缩进长度，每往下遍历一层缩进长度就加一，最后就可以输出上述的样子。</p><p>另外，我们还可以通过命令行的方式，指定一些输出格式，具体可以参考手册中的 <code>pstree</code> 就比如：</p><ul><li>按照特定顺序输出</li></ul><blockquote><p>上述实现方式，每次输出的顺序都是不同的，因为 map 的遍历是无序的。</p></blockquote><p>总的来说，对自己理解进程，任务管理器是有很大帮助的，还是要<strong>敢于动手</strong>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近在学习 C 语言的相关知识，想通过 C 语言实现一个简易版的 &lt;code&gt;pstree&lt;/code&gt; 命令行工具，我认为对 C 新手来说还是有一定难度的，最后只通过 C 实现了一半功能，但是实践的过程让我印象深刻。现代程序员使用着便捷的开发工具，输入几个首字母就能打印出自己想调用的库函数。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>k8s 存储内容</title>
    <link href="https://bqyang.top/2022/k8s/k8s-storage/"/>
    <id>https://bqyang.top/2022/k8s/k8s-storage/</id>
    <published>2022-07-05T10:43:10.520Z</published>
    <updated>2022-07-11T10:50:26.875Z</updated>
    
    <content type="html"><![CDATA[<p>概述 k8s 存储相关知识点。</p><span id="more"></span><h2 id="Volume-概念"><a href="#Volume-概念" class="headerlink" title="Volume 概念"></a>Volume 概念</h2><p>物理机上大家共用同一套文件系统，但是在容器内，每个容器的镜像都提供了一套文件系统，它们之间之相互独立的。容器运行时可以对系统中的文件进行修改，但是当他们运行结束后，container 被销毁了（进程没了，进程中的内容也不会存在了），他修改的东西也就都没了</p><p>想让数据持久存储的方法就是给 POD 挂载卷，绑定到 POD 内的容器中。所以不要再傻傻的以为卷是挂给 POD 的，严格的说是挂载给运行中的容器。</p><img src="https://s2.loli.net/2022/07/04/ybZlBV1AJSiQv7R.png" style="zoom:80%;" /><p>目前为止我们提到的都是容器重启，现有的方案可以解决容器重启后数据丢失的问题，那么如上图中的结构，Pod 进行重启后，数据还可以进行持久化存储吗？</p><p><strong>不能的</strong> ，在上图中，Volume 和 Pod 是共享生命周期的，我们需要一种能够独立于 Pod  生命周期的存储类别。</p><h2 id="External-Storage-Volume"><a href="#External-Storage-Volume" class="headerlink" title="External Storage Volume"></a>External Storage Volume</h2><p>外部存储，独立于 Pod 的生命周期。即使 Pod 被调度到了其他的工作节点，依然可以连接到我们的外部存储卷，相比于 hostpath 的好处。</p><p><img src="https://s2.loli.net/2022/07/04/2a1bxNSVTweWKns.png"></p><p>常见的卷类型：</p><ul><li>hostPath 独立于 Pod 生命周期</li><li>emptyDir 与 Pod 生命周期相同</li><li>gcePersistentDisk Google 的持久卷</li><li>cephfs </li><li>configMap 一般用于挂载文件的，通常是配置文件</li><li>secret 一般用于存储重要信息</li></ul><p>问题： <strong>当以 read/write 模式挂载卷的时候</strong>，这时需要扩展到多个 Pod，新的 Pod 创建不出来的。read/write 模式下的卷只能给一个 Pod 挂载， read-only 可以同事挂载给多个 Pod。</p><h2 id="PV"><a href="#PV" class="headerlink" title="PV"></a>PV</h2><p>顾名思义，PersistentVolume 对象代表一个用于持久化应用程序数据的存储卷。没有讲 PV 对象前，我们挂载外部存储的的时候，需要指定具体的存储类别，比如使用 Google 的存储卷，当我们需要将 Pod 部署到 AWS 中的集群时，就需要重新修改这个 YAML 文件。</p><p><img src="https://s2.loli.net/2022/07/04/DhfS5CRILcmW9se.png"></p><p>PV 是 K8s 提供给我们的抽象，在 Pod 和底层存储技术之间解耦。</p><p><img src="https://s2.loli.net/2022/07/04/71qz5ZdxpjWGIeF.png"></p><h3 id="手动配置的-PV-的生命周期"><a href="#手动配置的-PV-的生命周期" class="headerlink" title="手动配置的 PV 的生命周期"></a>手动配置的 PV 的生命周期</h3><p><img src="https://s2.loli.net/2022/07/05/I8RzS5uBNakKAs3.png"></p><ol><li>现有配置好底层存储</li><li>创建 PV 对象，指向底层存储，PV 状态为 Available</li><li>创建 PVC 指向刚刚创建的 PV, PVC – PV 绑定到一起</li><li>删除 PVC， PVC – PV 之间解绑，PV 状态为 Released</li><li>重新创建 PV 可使 PV 状态变成 Available</li></ol><h2 id="PVC"><a href="#PVC" class="headerlink" title="PVC"></a>PVC</h2><p>Pod 并不会直接引用 PV，而是通过 PVC ，然后 PVC 再对应一个 PV 的方式，正如上图描述的，使用 PV PVC 的最大好处就是将特定于底层存储的细节与 pod 所代表的应用程序分离。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p><img src="https://s2.loli.net/2022/07/04/dMFyi8ncsQLl3o6.png"></p><p>从这张图可以看出，PV 是给集群管理员使用的，PVC 是给用户使用的。如果安装了动态分配的插件，那我们就可以直接通过创建 PVC 的方式。</p><p>卷的访问方式：</p><table><thead><tr><th>Access Mode</th><th>Abbr.</th><th>Description</th></tr></thead><tbody><tr><td><code>ReadWriteOnce </code></td><td><code>RWO </code></td><td>The volume can be mounted by a single worker node in read/write mode. While it’s mounted to the node, other nodes can’t mount the volume.</td></tr><tr><td><code>ReadOnlyMany </code></td><td><code>ROX </code></td><td>The volume can be mounted on multiple worker nodes simultaneously in read-only mode.</td></tr><tr><td><code>ReadWriteMany </code></td><td><code>RWX </code></td><td>The volume can be mounted in read/write mode on multiple worker nodes at the same time.</td></tr></tbody></table><blockquote><p>这里指的是 Node</p></blockquote><p>PV 的回收策略：</p><table><thead><tr><th>Reclaim policy</th><th>Description</th></tr></thead><tbody><tr><td><code>Retain </code></td><td>When the persistent volume is released (this happens when you delete the claim that’s bound to it), Kubernetes <em>retains</em> the volume. The cluster administrator must manually reclaim the volume. This is the default policy for manually created persistent volumes.</td></tr><tr><td><code>Delete </code></td><td>The PersistentVolume object and the underlying storage are automatically deleted upon release. This is the default policy for dynamically provisioned persistent volumes, which are discussed in the next section.</td></tr><tr><td><code>Recycle </code></td><td>This option is deprecated and shouldn’t be used as it may not be supported by the underlying volume plugin. This policy typically causes all files on the volume to be deleted and makes the persistent volume available again without the need to delete and recreate it.</td></tr></tbody></table><p>动态分配默认回收策略是：delete</p><p>手动创建 PV 时默认回收策略是：retain</p><p>我们在任何时候都可以修改 PV 的回收策略，比如使用动态分配时，默认回收策略是 delete ，但是我们中途不想删除PVC的时候删除这个卷，可以将其修改为 retain。</p><blockquote><p>如果是 Released 状态的 PV，我们修改其回收策略为 delete 时，保存退出后，PV 对象和底层的卷都会被删除。</p></blockquote><p><img src="https://s2.loli.net/2022/07/05/TPmMsjYJBEdbHqw.png"></p><p>上图中我将 PVC 删掉了，现在策略是 Retain 这时候 <code>kubectl edit </code> 一下修改为 Delete。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">persistentVolumeReclaimPolicy: Retain --&gt; persistentVolumeReclaimPolicy: Delete</span><br></pre></td></tr></table></figure><p>PV 的删除</p><p>除了上述情况，假如我们想在 PV 是 Bound 状态下删除，PV 可以被删掉吗？</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">[root@k8s]#</span><span class="bash"> kubectl delete pv hostvol</span></span><br><span class="line">persistentvolume &quot;hostvol&quot; deleted</span><br></pre></td></tr></table></figure><p>会一直卡在这里，Ctrl-C 取消这次操作，再次获取 PV 发现已经是 <code>Terminating</code> 状态了。尽管刚刚取消delete命令的执行，但是这个 delete 的操作会被记录在 K8S 中（被释放后仍然会被删除）。</p><p>同样的，我们看看删除某个被 POD 引用的 PVC 是什么情况。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@k8s]<span class="comment"># kubectl delete pvc hostpvc</span></span><br><span class="line">persistentvolumeclaim <span class="string">&quot;hostpvc&quot;</span> deleted</span><br></pre></td></tr></table></figure><p>依然会一直卡在这里，同删除 PV 一样。</p><h2 id="多个-POD-挂载-ReadWriteOnce-卷"><a href="#多个-POD-挂载-ReadWriteOnce-卷" class="headerlink" title="多个 POD 挂载 ReadWriteOnce 卷"></a>多个 POD 挂载 ReadWriteOnce 卷</h2><p>这两天脑子里也一直在想这件事，我们挂载一个可读可写的卷给 POD，如果说这时候需要增加这个 POD  的副本，多个 POD 挂载同一个可读可写的卷，是否可以支持？</p><p><strong>答案是支持的</strong> ，但是有前提，  <strong>扩展出来的POD都必须在同一个 NODE 上</strong> ，Once 指的是挂载到的 Node，只能给 Node 挂载一次，如果扩展的 POD 调度到其他 NODE，POD 是起不来的，会报如下错误：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl describe po data-writer-97t9j</span></span><br><span class="line">...</span><br><span class="line">  Warning  FailedAttachVolume   ...   attachdetach-controller  AttachVolume.Attach failed </span><br><span class="line">for volume &quot;other-data&quot; : googleapi: Error 400: RESOURCE_IN_USE_BY_ANOTHER_RESOURCE -</span><br><span class="line">The disk resource &#x27;projects/.../disks/other-data&#x27; is already being used by</span><br><span class="line">&#x27;projects/.../instances/gkdp-r6j4&#x27;</span><br></pre></td></tr></table></figure><p>由于我这里机器就俩节点，复现不出来，直接把书中内容粘贴出来了。</p><h2 id="动态配置持久卷"><a href="#动态配置持久卷" class="headerlink" title="动态配置持久卷"></a>动态配置持久卷</h2><p>先创建 PV ，再创建 PVC 的方式有些繁琐，我这里遇到过一个问题，在对接 ceph 的过程中，我想创建一个 PV 对象指向这个底层的卷，当时需要填一个 <code>volumeHandle</code> 对应的值，是 ceph 卷的 ID。对于并不知道怎么操作 ceph 的我来说是比较困难的，需要先创建好底层卷，然后在PV中指定才可以。</p><p>但是，通过动态配置的方式就可以解决这个问题，我们不再需要手动准备好存储卷以及PV对象，只需写一个“需求文档”。</p><h3 id="动态配置流程"><a href="#动态配置流程" class="headerlink" title="动态配置流程"></a>动态配置流程</h3><p><img src="https://s2.loli.net/2022/07/05/rkYKoNBRMi3nUjV.png"></p><h3 id="StorageClass-与-PVC-的关系"><a href="#StorageClass-与-PVC-的关系" class="headerlink" title="StorageClass 与 PVC 的关系"></a>StorageClass 与 PVC 的关系</h3><p><img src="https://s2.loli.net/2022/07/11/dQRJFDbnCAuyk5x.png"></p><p>通常来讲，不同卷类型对应的不同的底层存储技术。</p><h3 id="卷绑定模式"><a href="#卷绑定模式" class="headerlink" title="卷绑定模式"></a>卷绑定模式</h3><p>讲的就是我们创建 PVC 对象后，PV  何时被创建。</p><table><thead><tr><th>Volume binding mode</th><th>Description</th></tr></thead><tbody><tr><td><code>Immediate </code></td><td>The provision and binding of the persistent volume takes place immediately after the claim is created. Because the consumer of the claim is unknown at this point, this mode is only applicable to volumes that are can be accessed from any cluster node.</td></tr><tr><td><code>WaitForFirstConsumer </code></td><td>The volume is provisioned and bound to the claim when the first pod that uses this claim is created. This mode is used for topology-constrained volume types.</td></tr></tbody></table><p>需要 <code>WaitForFirstConsumer </code> 的原因是，使用 Local 这种卷类型的时候，不知道 POD 被调度到哪里，所以需要确定好 POD 位置后再创建 PV。</p><h3 id="动态绑定的声明周期"><a href="#动态绑定的声明周期" class="headerlink" title="动态绑定的声明周期"></a>动态绑定的声明周期</h3><p><img src="https://s2.loli.net/2022/07/06/5ABInxbTrwCLl7v.png"></p><h3 id="卷扩容"><a href="#卷扩容" class="headerlink" title="卷扩容"></a>卷扩容</h3><p>需要 POD 配合（重启）来完成。</p><h3 id="Retain-状态的-PV-怎么恢复为-Available"><a href="#Retain-状态的-PV-怎么恢复为-Available" class="headerlink" title="Retain 状态的 PV 怎么恢复为 Available"></a>Retain 状态的 PV 怎么恢复为 Available</h3><p>本来以为 k8s 对接持久化存储已经结束了，突然发现 Rancher 上并不支持，修改 PV 的属性。想要从 Retain 状态修改为 Available 有两种方式：</p><ul><li>重新创建这个 PV 对象</li><li>edit 这个 PV 对象删除 claimref 部分</li></ul><p><img src="https://s2.loli.net/2022/07/11/4JN2AMPanYqQ3bV.png"></p><p> 将 PVC 对象释放后，获取到的 PV 列表，既然 Rancher 不支持，只能另寻他路了。</p><blockquote><p><strong>delete and recreate pv object 会导致底层卷被删除吗？</strong></p><p>先创建 PV 再创建 PVC 的方式并不会删除，底层存储。</p><p>动态创建的情况下，需要根据不同的回收策略区分：</p><ul><li>delete，pvc 被删除后 pv 和底层存储卷都被删除</li><li>retain，pvc 被删除后，pv 是 released 状态 （TODO 需要调研一下）</li></ul></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;概述 k8s 存储相关知识点。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>门面模式（外观模式）</title>
    <link href="https://bqyang.top/2022/design-pattern/Structural/facade/"/>
    <id>https://bqyang.top/2022/design-pattern/Structural/facade/</id>
    <published>2022-07-05T10:42:54.266Z</published>
    <updated>2022-07-05T11:00:54.885Z</updated>
    
    <content type="html"><![CDATA[<p>有两周时间没看设计模式内容了，前边学的都忘记差不多了..今天要学的是外观模式。（总感觉将这个英文翻译过来有点词不达意）</p><span id="more"></span><h2 id="门面模式"><a href="#门面模式" class="headerlink" title="门面模式"></a>门面模式</h2><p>门面模式（Facade），为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。体现了<strong>依赖倒转</strong>与<strong>迪米特法则</strong>，抽象出来一个中间层。</p><p><img src="https://s2.loli.net/2022/07/05/2WPfhFCj6yUpIHV.png"></p><p>最近在学习 K8S 持久化存储的相关内容，这之中也有一个类似的实现。K8S 的 PV 对象对底层实际的存储技术进行封装，再通过 PVC 对 PV 对象进行引用，达到了 K8S 与底层存储技术的解耦。</p><p>用一个用户的登录注册的例子可能比较形象，假设现在如左边一样，登录时候调用登录接口，注册时候调用注册接口。现在要增加一个功能，使用手机号的登录时候检查是否存在，存在直接登录，不存在自动注册再登录，例子来源 [<a href="https://github.com/mohuishou/go-design-pattern/tree/master/09_facade">这里</a>]：</p><p><img src="https://s2.loli.net/2022/07/05/78QuU9nEI6HPFco.png"></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">    username <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *user)</span> <span class="title">Login</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;user login&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *user)</span> <span class="title">Register</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;user register&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> facadeUser <span class="keyword">struct</span> &#123;</span><br><span class="line">    user</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *facadeUser)</span> <span class="title">LoginOrRegister</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// check user exist</span></span><br><span class="line">    <span class="keyword">var</span> exist <span class="keyword">bool</span></span><br><span class="line">    <span class="keyword">if</span> !exist &#123;</span><br><span class="line">        f.user.Register()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    f.user.Login()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里实现与上述链接中的些许不同，区别在于<strong>facade 的职责</strong>， <strong>facade 负责的是中转，他的方法中最好不要有具体实现，通过 facade 调用子类的方法或者是将子类的方法再进行封装使其更容易复用。</strong> 通过结构体内嵌可以实现，也可以将user抽象出来一个接口：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> IUser <span class="keyword">interface</span> &#123;</span><br><span class="line">    Login()</span><br><span class="line">    register</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再将这个接口内嵌到 facade 中：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> facadeUser <span class="keyword">struct</span> &#123;</span><br><span class="line">    user IUser</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一个更详细的例子请看这里 [<a href="https://golangbyexample.com/facade-design-pattern-in-golang/">facade</a>]。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;有两周时间没看设计模式内容了，前边学的都忘记差不多了..今天要学的是外观模式。（总感觉将这个英文翻译过来有点词不达意）&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>内存相关 API</title>
    <link href="https://bqyang.top/2022/os/memory-api/"/>
    <id>https://bqyang.top/2022/os/memory-api/</id>
    <published>2022-06-29T13:19:58.377Z</published>
    <updated>2022-07-02T05:46:13.074Z</updated>
    
    <content type="html"><![CDATA[<p>这两天在学习内存虚拟化的过程中，发现两个查看内存的两个工具 <code>free</code> <code>pmap</code> 关于他们的详细描述可以在手册上查阅，这里举两个小例子玩一玩。</p><span id="more"></span><h2 id="free"><a href="#free" class="headerlink" title="free"></a>free</h2><p>这个比较简单，可以查看当前系统中的内存使用情况：</p><p><img src="https://s2.loli.net/2022/07/01/uCGFEikarR4WAJQ.png"></p><h2 id="pmap"><a href="#pmap" class="headerlink" title="pmap"></a>pmap</h2><p>这个比较有意思，我们可以查看运行中进程的内存布局，<code>CODE HEAP STACK</code> ，暂时将布局简单的分成以上三个部分，运行如下代码（采用静待链接的方式编译）：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 变换这个数组的大小查看有什么不同</span></span><br><span class="line">    <span class="keyword">int</span> *p = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="number">100000</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>, *p);</span><br><span class="line">    sleep(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 变换这个数组的大小查看有什么不同</span></span><br><span class="line">    <span class="keyword">int</span> *p = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="number">100000</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>, *p);</span><br><span class="line">    sleep(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中声明了一个包含<strong>100000</strong>个元素的数组，即使我们现在不知道 <code>malloc</code> 会将这个数组分配到哪里也没关系，通过 <code>pmap</code> 查看：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">~ # pmap 457</span><br><span class="line">457: ./a.out</span><br><span class="line">0000000000400000       4K r--p  /root/a.out</span><br><span class="line">0000000000401000      12K r-xp  /root/a.out</span><br><span class="line">0000000000404000       4K r--p  /root/a.out</span><br><span class="line">0000000000405000       8K rw-p  /root/a.out</span><br><span class="line">0000000000ab4000     392K rw-p  [heap]</span><br><span class="line">00007fff65583000     132K rw-p  [stack]</span><br><span class="line">00007fff655f3000      16K r--p  [vvar]</span><br><span class="line">00007fff655f7000       4K r-xp  [vdso]</span><br><span class="line">mapped: 572K</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">~ # pmap 457</span><br><span class="line">457: ./a.out</span><br><span class="line">0000000000400000       4K r--p  /root/a.out</span><br><span class="line">0000000000401000      12K r-xp  /root/a.out</span><br><span class="line">0000000000404000       4K r--p  /root/a.out</span><br><span class="line">0000000000405000       8K rw-p  /root/a.out</span><br><span class="line">0000000000ab4000     392K rw-p  [heap]</span><br><span class="line">00007fff65583000     132K rw-p  [stack]</span><br><span class="line">00007fff655f3000      16K r--p  [vvar]</span><br><span class="line">00007fff655f7000       4K r-xp  [vdso]</span><br><span class="line">mapped: 572K</span><br></pre></td></tr></table></figure><p>通过观察堆栈的起始地址，可以得出他们的相对位置，看到这个输出就能知道进程内存是如何布局的</p><ul><li>在最开始的位置就是需要执行的指令，<code>CODE</code>，通过前面的 ELF 知识的学习，这里又可以分为 .text .data .bss 段等</li><li>然后是堆，<code>HEAP</code></li><li>其次是栈，<code>STACK</code></li><li><code>VVAR</code> <code>VDSO</code> 放在下面分开讲</li></ul><p>如果说这时候我们还是不清楚数组被分配到了哪里，我们可以尝试减少数组中的元素，然后再查看占用的内存大小。</p><blockquote><p>修改后输出的内容都是相同的话，可以尝试禁用优化，在编译的时候加上 <code>-O0</code>。</p></blockquote><h2 id="VDSO"><a href="#VDSO" class="headerlink" title="VDSO"></a>VDSO</h2><p>VDSO (Virtual dynamic shared object) ，虚拟动态共享对象，名字就给人一种很难理解的假象。手册中一句话就概述了这个特性是用来做什么的：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The &quot;vDSO&quot; (virtual dynamic shared object) is a small shared</span><br><span class="line">library that the kernel automatically maps into the address space</span><br><span class="line">of all user-space applications.</span><br></pre></td></tr></table></figure><p><strong>系统调用一定要陷入内核吗？</strong>  VDSO 告诉你不是的，操作系统内核会将某些共享库自动的映射到进程的地址空间。比如在业务逻辑中，很多情况下是需要获取当前时间戳：</p><p><img src="https://s2.loli.net/2022/07/01/bBUahRS2ZyrwFu3.png"></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1017: /root/a.out</span><br><span class="line">Address           Kbytes     PSS   Dirty    Swap  Mode  Mapping</span><br><span class="line">000055d54f219000       4       4       0       0  r--p  /root/a.out</span><br><span class="line">000055d54f21a000       4       4       4       0  r-xp  /root/a.out</span><br><span class="line">000055d54f21b000       4       0       0       0  r--p  /root/a.out</span><br><span class="line">000055d54f21c000       4       4       4       0  r--p  /root/a.out</span><br><span class="line">000055d54f21d000       4       4       4       0  rw-p  /root/a.out</span><br><span class="line">000055d550af4000       4       0       0       0  ---p  [heap]</span><br><span class="line">000055d550af5000       4       4       4       0  rw-p  [heap]</span><br><span class="line">00007fc662f2e000      84       3       0       0  r--p  /lib/ld-musl-x86_64.so.1</span><br><span class="line">00007fc662f43000     288      18       8       0  r-xp  /lib/ld-musl-x86_64.so.1</span><br><span class="line">00007fc662f8b000     216       3       0       0  r--p  /lib/ld-musl-x86_64.so.1</span><br><span class="line">00007fc662fc1000       4       4       4       0  r--p  /lib/ld-musl-x86_64.so.1</span><br><span class="line">00007fc662fc2000       4       4       4       0  rw-p  /lib/ld-musl-x86_64.so.1</span><br><span class="line">00007fc662fc3000      12       8       8       0  rw-p    [ anon ]</span><br><span class="line">00007ffe9782e000     132      12      12       0  rw-p  [stack]</span><br><span class="line">00007ffe978e5000      16       0       0       0  r--p  [vvar]</span><br><span class="line">00007ffe978e9000       4       0       0       0  r-xp  [vdso]</span><br><span class="line">----------------  ------  ------  ------  ------</span><br><span class="line">total                788      72      52       0</span><br></pre></td></tr></table></figure><p><code>00007ffe978e9733</code> 正好在 VDSO 的地址范围内，说明这里直接访问了 VDSO 的映射，没有通过系统调用。</p><h2 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 映射，addr 进程中地址，length 区间长度，prot 和 flags 与权限有关，fd 文件描述符</span></span><br><span class="line"><span class="comment">// offset 偏移量；意味着可以把文件的某部分内容映射到进程中。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mmap</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> length, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">munmap</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> length)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改映射权限</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mprotect</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> length, <span class="keyword">int</span> prot)</span></span>;</span><br></pre></td></tr></table></figure><p>文档中有个关于 mmap 的例子还挺不错的 <a href="https://man7.org/linux/man-pages/man2/mmap.2.html">code example</a></p><h2 id="malloc-amp-free"><a href="#malloc-amp-free" class="headerlink" title="malloc &amp;free"></a>malloc &amp;free</h2><p><code>malloc</code> 用于在堆空间上分配内存的 API，在 C 中堆上的内存分配和释放有开发者来维护。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *x = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br></pre></td></tr></table></figure><h2 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h2><p>针对 <code>malloc</code> 和 <code>free</code> 的常见问题：</p><p><strong>忘记分配内存</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *src = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> *dst; <span class="comment">// oops! unallocated</span></span><br><span class="line"><span class="built_in">strcpy</span>(dst, src); <span class="comment">// segfault and die</span></span><br></pre></td></tr></table></figure><p>将字符串 <code>hello</code> 赋值给变量 dst 时，由于dst指针为指向任何可用的内存，导致失败，正确的做法如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *src = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> *dst = (<span class="keyword">char</span> *) <span class="built_in">malloc</span>(<span class="built_in">strlen</span>(src)+<span class="number">1</span>); <span class="comment">// +1 是给 \0 准备的</span></span><br><span class="line"><span class="built_in">strcpy</span>(dst, src);</span><br></pre></td></tr></table></figure><p><strong>编译通过并运行不代表是正确的</strong></p><p>虽然我们在控制台看到了正确的输出结果，但也不代表我们的程序是正确的，看下面这个例子：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *src = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> *dst = (<span class="keyword">char</span> *) <span class="built_in">malloc</span>(<span class="built_in">strlen</span>(src)); <span class="comment">// too small!</span></span><br><span class="line"><span class="built_in">strcpy</span>(dst, src); <span class="comment">// work properly</span></span><br></pre></td></tr></table></figure><p>输出 dst 中的内容时，可以看到 hello 被打印出来了。但是我们分配给变量 dst 的内存大小装不下 src 中的内容。这就会导致，它覆盖了不属于它自己部分。</p><p><strong>忘记初始化刚分配的内存</strong></p><p>C 并不会帮你初始化内存，很有可能你声明了一个整型变量没有进行赋值操作，但当你读他的时候发现是一个神奇怪的数字。</p><p><strong>忘记释放内存</strong></p><p>分配和释放应该成对的出现，这就好像 Go 中打开了一个 response.body 要记得关闭一个道理。如果是一个长时间运行的服务，最终可能把所有的内存耗光，导致 OOM。如果是一个一次性运行的服务，不是放也没什么关系，进程退出了自动会把占有的资源释放了。</p><blockquote><p>为什么进程退出了，相关的内存会得到释放？</p></blockquote><p><strong>还没有使用完内存，就提前释放了</strong></p><p>dangling pointer 问题</p><p><strong>释放已经释放的内存</strong></p><p>double free 的结果是未被定义的，不知道会产生什么结果</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这两天在学习内存虚拟化的过程中，发现两个查看内存的两个工具 &lt;code&gt;free&lt;/code&gt; &lt;code&gt;pmap&lt;/code&gt; 关于他们的详细描述可以在手册上查阅，这里举两个小例子玩一玩。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>misuse init func</title>
    <link href="https://bqyang.top/2022/language/golang/100-go-mistaks/2-misuse-init/"/>
    <id>https://bqyang.top/2022/language/golang/100-go-mistaks/2-misuse-init/</id>
    <published>2022-06-29T13:19:32.315Z</published>
    <updated>2022-06-30T13:23:55.896Z</updated>
    
    <content type="html"><![CDATA[<p>今天这篇讲的是 <code>init</code> 函数使用技巧，平时在人家封装好的代码框架中进行开发，很少独立用到 <code>init</code> 函数的地方，其实不小心使用的话坑还是比较多的。</p><ul><li>一个包中能不能拥有多个 <code>init</code> </li><li><code>init</code> 与全局变量的初始化哪个先执行</li><li>一个包被导入多次 <code>init</code> 是否会执行多次</li></ul><span id="more"></span><p>参考如下代码，你能否说出输出的顺序：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;var&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;init&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;main&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">output:</span></span><br><span class="line"><span class="comment">  var</span></span><br><span class="line"><span class="comment">  init</span></span><br><span class="line"><span class="comment">  main</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>我是倒在了这上边，不过还好，借这个机会来好好了解一下。我们先看下不包含全局变量的情况，在 main 包中引用 redis 包：</p><p><img src="https://s2.loli.net/2022/06/29/3BlmuwZKvqONH9s.png"></p><p><code>init </code> 函数的执行顺序如上述标号所示，这时候如果一个 package 中有多个 <code>init</code> 函数需要执行时，他们的顺序是什么呢？</p><p>假设我们有如下的目录结构，每个文件中都有 <code>init</code> 函数：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">hello</span><br><span class="line">|--a.<span class="keyword">go</span></span><br><span class="line">|--b.<span class="keyword">go</span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;a.go&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;b.go&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.go package main</span></span><br><span class="line"><span class="keyword">import</span> _ <span class="string">&quot;hello&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;main.go&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候是先执行 <code>a.go</code> 中的 <code>init</code> 还是 <code>b.go</code> 中的呢？ **答案是文件名称排序，谁在前边就先执行谁的 <code>init</code>**。</p><blockquote><p>所以这里警示我们，务必不能通过文件名称的方式确定 <code>init</code> 函数的执行顺序，在不断迭代的过程中文件名称很有可能会被修改。</p></blockquote><p>另一个有意思的地方是，可以在一个文件中写多个 <code>init</code> 函数：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;first init&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;second init&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure><p> <code>init</code> 会带来什么样的问题呢？</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> db *sql.DB</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    dataSourceName := os.Getenv(<span class="string">&quot;MYSQL_DATA_SOURCE_NAME&quot;</span>)</span><br><span class="line">    d, err := sql.Open(<span class="string">&quot;mysql&quot;</span>, dataSourceName)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Panic(err)</span><br><span class="line">    &#125;</span><br><span class="line">    err = d.Ping()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Panic(err)</span><br><span class="line">    &#125;</span><br><span class="line">    db = d</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 <code>init</code> 进行数据库连接的初始化，这里存在至少三个问题：</p><ul><li>错误处理的局限性，因为 <code>init</code> 是没有参数和返回值的。</li><li>全局变量的可能会在其它的package中被修改。</li><li>单元测试的局限性，针对这种 <code>init</code> 函数，我们想进行单元测试不太可能，在执行用例的时候 <code>init</code> 函数已经执行完成了。</li></ul><p><strong>疑问</strong></p><p>假设我们有 <code>package A</code>，<code>package B</code>，<code>package main</code> 每个包都有自己的  <code>init</code> 函数，那么他们被导入多次的时候  <code>init</code> 会被执行多次吗？</p><p>B 中引用了 A，main 中引用了 B，A；我以为 A 的 <code>init</code> 会被执行两次，又 tm 被打脸了。 不过比较及时，要不面试的时候就尴尬了。</p><h2 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// An initTask represents the set of initializations that need to be done for a package.</span></span><br><span class="line"><span class="comment">// Keep in sync with ../../test/initempty.go:initTask</span></span><br><span class="line"><span class="keyword">type</span> initTask <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> pack the first 3 fields more tightly?</span></span><br><span class="line">    state <span class="keyword">uintptr</span> <span class="comment">// 0 = uninitialized, 1 = in progress, 2 = done</span></span><br><span class="line">    ndeps <span class="keyword">uintptr</span></span><br><span class="line">    nfns  <span class="keyword">uintptr</span></span><br><span class="line">    <span class="comment">// followed by ndeps instances of an *initTask, one per package depended on</span></span><br><span class="line">    <span class="comment">// followed by nfns pcs, one per init function to run</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:linkname runtime_inittask runtime..inittask</span></span><br><span class="line"><span class="keyword">var</span> runtime_inittask initTask</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:linkname main_inittask main..inittask</span></span><br><span class="line"><span class="keyword">var</span> main_inittask initTask</span><br></pre></td></tr></table></figure><p>这里我理解 <code>runtime_inittask</code> <code>main_inittask</code> 一个是 runtime 需要用到的初始化函数，一个是 user program 用到的 init 函数，原因如下：cmd/compile/internal/gc/init.go 文件中有关于 init 的代码（省略了部分代码）：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fninit makes an initialization record for the package.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fninit</span><span class="params">(n []*Node)</span></span> &#123;</span><br><span class="line">    nf := initOrder(n)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> deps []*obj.LSym <span class="comment">// initTask records for packages the current package depends on</span></span><br><span class="line">    <span class="keyword">var</span> fns []*obj.LSym  <span class="comment">// functions to call for package initialization</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find imported packages with init tasks.</span></span><br><span class="line">    <span class="keyword">for</span> _, s := <span class="keyword">range</span> types.InitSyms &#123;</span><br><span class="line">        deps = <span class="built_in">append</span>(deps, s.Linksym())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make a function that contains all the initialization statements.</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nf) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Record user init functions.</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; renameinitgen; i++ &#123;</span><br><span class="line">        s := lookupN(<span class="string">&quot;init.&quot;</span>, i)</span><br><span class="line">        fn := asNode(s.Def).Name.Defn</span><br><span class="line">        <span class="comment">// Skip init functions with empty bodies.</span></span><br><span class="line">        <span class="keyword">if</span> fn.Nbody.Len() == <span class="number">1</span> &amp;&amp; fn.Nbody.First().Op == OEMPTY &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        fns = <span class="built_in">append</span>(fns, s.Linksym())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有 init 函数需要执行</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(deps) == <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(fns) == <span class="number">0</span> &amp;&amp; localpkg.Name != <span class="string">&quot;main&quot;</span> &amp;&amp; localpkg.Name != <span class="string">&quot;runtime&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="comment">// nothing to initialize</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make an .inittask structure.</span></span><br><span class="line">    sym := lookup(<span class="string">&quot;.inittask&quot;</span>)</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    ot := <span class="number">0</span></span><br><span class="line">    <span class="comment">// 最初状态：未初始化</span></span><br><span class="line">    ot = duintptr(lsym, ot, <span class="number">0</span>) <span class="comment">// state: not initialized yet</span></span><br><span class="line">    ot = duintptr(lsym, ot, <span class="keyword">uint64</span>(<span class="built_in">len</span>(deps)))</span><br><span class="line">    ot = duintptr(lsym, ot, <span class="keyword">uint64</span>(<span class="built_in">len</span>(fns)))</span><br><span class="line">    <span class="keyword">for</span> _, d := <span class="keyword">range</span> deps &#123;</span><br><span class="line">        ot = dsymptr(lsym, ot, d, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// An initTask has pointers, but none into the Go heap.</span></span><br><span class="line">    <span class="comment">// It&#x27;s not quite read only, the state field must be modifiable.</span></span><br><span class="line">    ggloblsym(lsym, <span class="keyword">int32</span>(ot), obj.NOPTR)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在初始化的过程中是怎么保证一个包不被执行多次的？</p><p>inittask 中有一个表示 init 函数状态的变量，0 代表<em>未执行</em>， 1 代表<em>执行中</em>， 2代表<em>已完成</em>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天这篇讲的是 &lt;code&gt;init&lt;/code&gt; 函数使用技巧，平时在人家封装好的代码框架中进行开发，很少独立用到 &lt;code&gt;init&lt;/code&gt; 函数的地方，其实不小心使用的话坑还是比较多的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个包中能不能拥有多个 &lt;code&gt;init&lt;/code&gt; &lt;/li&gt;
&lt;li&gt;&lt;code&gt;init&lt;/code&gt; 与全局变量的初始化哪个先执行&lt;/li&gt;
&lt;li&gt;一个包被导入多次 &lt;code&gt;init&lt;/code&gt; 是否会执行多次&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>参数是怎么传给 goroutine 的</title>
    <link href="https://bqyang.top/2022/language/golang/go-params-to-goroutine/"/>
    <id>https://bqyang.top/2022/language/golang/go-params-to-goroutine/</id>
    <published>2022-06-28T11:06:28.302Z</published>
    <updated>2022-06-28T11:05:02.712Z</updated>
    
    <content type="html"><![CDATA[<p><em>go version: 1.16</em></p><p><img src="https://s2.loli.net/2022/06/27/j7xI9vwEdRF8eTB.png"></p><p>文章内容接之前的 <code>variable shadowing</code>  做了一些延伸，在批量创建 <code>goroutine</code> 时，避免不了参数传递，通常的做法如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span> <span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="built_in">println</span>(i)</span><br><span class="line">    &#125;(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// wait all g done</span></span><br></pre></td></tr></table></figure><span id="more"></span><p>其实也可以通过 <code>variable shadowing</code> 来解决，这两种方法达到的效果是一样的，如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">    i := i</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span> <span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">println</span>(i)</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// wait all g done</span></span><br></pre></td></tr></table></figure><h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><p><strong>由此，我产生了一个疑问，参数是如何传递给 <code>goroutine</code> 的</strong>。</p><h2 id="寻找答案"><a href="#寻找答案" class="headerlink" title="寻找答案"></a>寻找答案</h2><p>我们使用上述代码调试，在源码中寻找答案，其实关键的代码就这两行：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newproc</span><span class="params">(siz <span class="keyword">int32</span>, fn *funcval)</span></span> &#123;</span><br><span class="line">    <span class="comment">// fn 地址 再加 8 个字节（跟机器有关，32位4字节），</span></span><br><span class="line">    <span class="comment">// 就是第一个参数的位置，siz 代表字节数，传进来的参数大小</span></span><br><span class="line">    argp := add(unsafe.Pointer(&amp;fn), sys.PtrSize)</span><br><span class="line">    <span class="comment">// ommit</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>栈是由<em>高</em>地址向<em>低</em>地址增长的，有时候不好确定这个增长方向，因为 x86 代码和 go 的汇编存在差异，区分不好应该是从左往右看，还是从右往左，既然这该死的脑子记不住，就找到一个窍门，每次先找 sub 或者 add 指令，通过这种方式来区分从哪边看起。</p><p>还有一点需要我们注意的就是，如何理解 <code>go func()&#123;&#125;()</code> 的这个函数地址与参数位置的关系，是谁把参数放在了与这个函数位置挨着的地方？为什么要挨着放在别的地方行不行？常规情况下，函数的参数传递形式如下图所示：</p><p><img src="https://s2.loli.net/2022/06/27/QgtHDkSq75E9sGJ.png"></p><p>这里涉及到调用规约的内容，可以参考曹大的文章（文末引路），主要讲的就是函数间参数传递的方式以及返回值放在哪里等。</p><p>查看创建 goroutine 的源码，注释中有关于调用规约的描述：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The stack layout of this call is unusual: it assumes that the</span></span><br><span class="line"><span class="comment">// arguments to pass to fn are on the stack sequentially immediately</span></span><br><span class="line"><span class="comment">// after &amp;fn.</span></span><br></pre></td></tr></table></figure><p>首先提到的就是这里的的栈传参形式与平常是不一样的，这里的 <code>fn</code> 指的就是 go 关键字后面的 func，<code>&amp;fn</code> 的意思就是 fn 函数的地址（一开始以为在执行这个取址操作后..）。</p><p>在 <code>fn</code> 函数地址后面，就是传递给它的参数。有意思的地方来了，<strong>goroutine 的参数是借用 newproc 传递给了 fn 函数，但是在 newproc 函数签名中只有两个参数</strong>，如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newproc</span><span class="params">(siz <span class="keyword">int32</span>, fn *funcval)</span></span> &#123;</span><br><span class="line">    <span class="comment">// ommit</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/06/27/VNzjKJUTlZWnf13.png"></p><p>这里通过汇编代码验证下，我们增加传递给 goroutine 参数，加到 3 个：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 第一个参数 siz 代表所有参数占用的字节数</span><br><span class="line">mov dword ptr [rsp], 0x18</span><br><span class="line"># 把 fn 的地址 load 出来</span><br><span class="line">lea rbx, ptr [rip+0x2b572]</span><br><span class="line"># 第二个参数 fn</span><br><span class="line">mov qword ptr [rsp+0x8], rbx</span><br><span class="line"># fn 的第一个参数</span><br><span class="line">mov qword ptr [rsp+0x10], rdx</span><br><span class="line"># fn 的第二个参数</span><br><span class="line">mov qword ptr [rsp+0x18], rax</span><br><span class="line"># fn 的第三个参数</span><br><span class="line">mov qword ptr [rsp+0x20], rcx</span><br><span class="line"># 调用 newproc</span><br><span class="line">call $runtime.newproc</span><br></pre></td></tr></table></figure><blockquote><p>虽然计算机的世界没有 magic，但是感觉是真 tmd 神奇。</p></blockquote><p>最后在创建新 goroutine 的时候，把参数拷贝到当前 goroutine 的栈地址空间。分析的过程没什么难度，死记硬背并不是什么秘诀，掌握寻找答案的方法更重要。</p><p>最后，关于调用规约的相关内容，指路[ <a href="https://www.xargin.com/go1-17-new-calling-convention/">曹大博客</a> ]。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;em&gt;go version: 1.16&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2022/06/27/j7xI9vwEdRF8eTB.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;文章内容接之前的 &lt;code&gt;variable shadowing&lt;/code&gt;  做了一些延伸，在批量创建 &lt;code&gt;goroutine&lt;/code&gt; 时，避免不了参数传递，通常的做法如下：&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i := &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;; i++ &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;(i &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;println&lt;/span&gt;(i)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;(i)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// wait all g done&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Variable shadowing</title>
    <link href="https://bqyang.top/2022/language/golang/100-go-mistaks/1-variable-shadowing/"/>
    <id>https://bqyang.top/2022/language/golang/100-go-mistaks/1-variable-shadowing/</id>
    <published>2022-06-26T08:46:56.077Z</published>
    <updated>2022-06-26T12:15:33.120Z</updated>
    
    <content type="html"><![CDATA[<p>本文中的内容来自《100 Go Mistakes and How to Avoid Them》，作者总结了常见、易犯的错误，比较适合刚学习 Go 的同学。</p><p>这个问题我最开始实习的时候还真遇到过，不过经历一次之后就记住了。主要问题在于对变量作用域以及 <code>:=</code> 的理解：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> client *http.Client</span><br><span class="line"><span class="keyword">if</span> tracing &#123;</span><br><span class="line">    <span class="comment">// 这个 client 是一个新的变量</span></span><br><span class="line">    client, err := createClientWithTracing()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果这里不打印的话，会报 declared but not use 的错误</span></span><br><span class="line">    log.Println(client)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    client, err := createDefaultClient()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    log.Println(client)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Use client</span></span><br></pre></td></tr></table></figure><span id="more"></span><p>解决方案这里一共有两种：</p><ul><li><p>在 if 语句代码块外部声明好（err 也要声明）使用 <code>=</code> 号赋值；</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> client *http.Client</span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> xx &#123;</span><br><span class="line">    client, err = xx()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    client, err = xx1()   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代码更加简洁</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在 if 语句代码块中使用额外的变量接收返回值，然后对 client 进行赋值</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">c, err := createClientWithTracing()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">client = c</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure></li></ul><p>这两种方法都是对的，拿第一种来说，我们减少了额外的变量声明，只执行了一次变量分配，而且在进行错误处理时进行统一。我以前写的代码是第一种，不过针对错误处理，我是在每个代码块中都写了，确实有些啰嗦，这下以后就可以写出更简洁的代码了hh。</p><h2 id="发生场景"><a href="#发生场景" class="headerlink" title="发生场景"></a>发生场景</h2><p>那么我们什么时候会遇到这个问题呢？</p><p><strong>当一个变量的名称，在内部代码块重新声明的时候会发生。</strong>正如我们在上述示例代码中看到的，client 在 if 的代码块又被声明了。</p><h2 id="如何避免"><a href="#如何避免" class="headerlink" title="如何避免"></a>如何避免</h2><p>其实说到这里应该能反应过来，一般这种代码检查工具，go vet 中都应该有，就算没有可能有类似的 linter，通过 <code>go help vet</code> 我们就可以看到这样一句话 <code>For example, the &#39;shadow&#39; analyzer can be built and run using these commands</code></p><p>然后我们可以通过 <code>go install</code> 命令安装到自己的 GOPATH/bin 路径下，通过 <code>go vet -vettool=（可执行文件路径）</code> 就可以检查出来。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">go vet -vettool=C:\Users\bqYang\go\bin\shadow.exe .\main.go</span><br><span class="line"></span><br><span class="line">.\main.go:24:3: declaration of &quot;x&quot; shadows declaration at line 22</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文中的内容来自《100 Go Mistakes and How to Avoid Them》，作者总结了常见、易犯的错误，比较适合刚学习 Go 的同学。&lt;/p&gt;
&lt;p&gt;这个问题我最开始实习的时候还真遇到过，不过经历一次之后就记住了。主要问题在于对变量作用域以及 &lt;code&gt;:=&lt;/code&gt; 的理解：&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; client *http.Client&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; tracing &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 这个 client 是一个新的变量&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    client, err := createClientWithTracing()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; err != &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; err&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 如果这里不打印的话，会报 declared but not use 的错误&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    log.Println(client)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    client, err := createDefaultClient()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; err != &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; err&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    log.Println(client)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Use client&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>操作系统进程</title>
    <link href="https://bqyang.top/2022/os/process/process/"/>
    <id>https://bqyang.top/2022/os/process/process/</id>
    <published>2022-06-24T13:49:47.178Z</published>
    <updated>2022-06-26T05:46:10.078Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2022/06/24/kjNFfKicts1XbDZ.png"></p><p>读了几章关于操作系统进程的相关内容，看几个简单的课后习题，从实际代码中去体会进程的特性。</p><span id="more"></span><p>1.在父进程中声明一个变量，然后创建子进程，两个进程都去修改这个变量会是什么结果？</p><p>哇，不动手实践一下是还真是没搞清楚，虽然在理论部分说到了，fork() 其实就是对父进程进行了拷贝操作。没有实践时以为会像多线程共享变量那样，真正敲过代码后发现，每个进程内的变量都是独立于父进程的，所以对本进程中数据的修改并不会影响父进程中的数据。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> child = fork();</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (child &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fork child err\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (child == <span class="number">0</span>) &#123;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;after exec count++ %d \n&quot;</span>, count);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (child &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        count = <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;the count is %d\n&quot;</span>, count);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.多进程操作同一个文件</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// file.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;i am parent, my pid is %d\n&quot;</span>, (<span class="keyword">int</span>)getpid());</span><br><span class="line">    FILE *fd = fopen(<span class="string">&quot;./info.txt&quot;</span>, <span class="string">&quot;a+&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> rc = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;new process failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rc == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="built_in">fputs</span>(<span class="string">&quot;STFW....\n\n&quot;</span>, fd);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child write finished\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rc &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="built_in">fputs</span>(<span class="string">&quot;hello RTFMMM\n\n&quot;</span>, fd);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent write finished\n&quot;</span>);</span><br><span class="line">        <span class="comment">//int data = wait(NULL);</span></span><br><span class="line">        <span class="comment">//printf(&quot;%d\n&quot;, data);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如程序中看到的，我们在两个进程中操作同一个文件描述符，讲道理这种没加约束的并发写操作都是存在问题的。但是我这里看文件中的内容有点过于正确。。</p><p>3.这题不让我们使用wait实现，子进程先完成某些打印，没明白想具体考察什么..</p><p>4.尝试不同的 <code>exec execl execle execlp execv execvp execvpe</code> 并思考为什么要有这么多的变种？</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rc = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rc == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> *myargs[<span class="number">3</span>];</span><br><span class="line">        myargs[<span class="number">0</span>] = strdup(<span class="string">&quot;ls&quot;</span>);</span><br><span class="line">        myargs[<span class="number">1</span>] = strdup(<span class="string">&quot;-la&quot;</span>);</span><br><span class="line">        myargs[<span class="number">2</span>] = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">int</span> result = execvp(myargs[<span class="number">0</span>], myargs);</span><br><span class="line">        <span class="comment">// can not reach</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, result);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rc &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> childs = wait(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, childs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 execl 时，第一个和第二个参数都是可执行文件的路径，第三个参数开始就是自带的一些参数比如 <code>-la</code>，最后一个参数需要传 NULL 而且要转成 char * 类型的空指针：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *myargs[<span class="number">3</span>];</span><br><span class="line">myargs[<span class="number">0</span>] = strdup(<span class="string">&quot;/bin/ls&quot;</span>);</span><br><span class="line">myargs[<span class="number">1</span>] = strdup(<span class="string">&quot;-la&quot;</span>);</span><br><span class="line">myargs[<span class="number">2</span>] = strdup(<span class="string">&quot;/root&quot;</span>);</span><br><span class="line"><span class="keyword">int</span> result = execl(myargs[<span class="number">0</span>], myargs[<span class="number">0</span>], myargs[<span class="number">1</span>], myargs[<span class="number">2</span>], (<span class="keyword">char</span> *) <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>后续就不一一举例了，具体内容可以参考 [<a href="https://linuxhint.com/exec_linux_system_call_c/">这里</a>]。</p><p>5.double wait 在父进程中执行 wait 函数，在子进程中也执行 wait 函数，这时会发生什么？</p><p>没有实践时，我认为会直接卡死，产生相互等待的情况，正如 go 中 all goroutine asleep.</p><p>但是，神奇的事情又发生了，这个程序不但没卡死，还正确的执行了。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// doubleWait.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rc = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rc == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;start exec child %d proces\n&quot;</span>, (<span class="keyword">int</span>)getpid());</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="number">111</span>);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rc &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;start wait child&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> childs = wait(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, childs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很意外，当这个 <code>111</code> 打印出来后恍然大悟，我们在父进程中执行了 fork 这时候调用 wait 可以得到返回的子进程 pid。但是当你在子进程中执行 wait 时，是没有任何子进程的子进程，所以 wait 会直接返回。（还是要多动手实践呀..自己这个脑子..并不靠谱）</p><h2 id="进程相关-API"><a href="#进程相关-API" class="headerlink" title="进程相关 API"></a>进程相关 API</h2><ul><li>创建进程 – fork()，fork() 执行的是状态机的复制；<strong>状态机的复制</strong><ul><li>fork 的返回值，如果是父进程执行，返回的是子进程的Pid；如果是子进程执行，返回的是 0；</li></ul></li></ul><p>画出下面的状态机：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pid_1 = fork();</span><br><span class="line">    <span class="keyword">int</span> pid_2 = fork();</span><br><span class="line">    <span class="keyword">int</span> pid_3 = fork();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>, pid_1, pid_2, pid_3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>printf 缓冲区与 fork 复制：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">        fork();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Hello\n&quot;</span>);        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">        wait(<span class="literal">NULL</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>fork 会将 printf 的缓冲区也复制</p></blockquote><ul><li>execve()， fork() 只能对父进程执行拷贝，exec 可以启动一个子进程执行另一段代码；<strong>状态机的重置</strong>；</li><li>exit(); 销毁进程；<strong>状态机的销毁</strong>；</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2022/06/24/kjNFfKicts1XbDZ.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;读了几章关于操作系统进程的相关内容，看几个简单的课后习题，从实际代码中去体会进程的特性。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>linker and loader</title>
    <link href="https://bqyang.top/2022/os/linker&amp;loader/"/>
    <id>https://bqyang.top/2022/os/linker&amp;loader/</id>
    <published>2022-06-23T10:30:51.735Z</published>
    <updated>2022-06-24T15:12:45.640Z</updated>
    
    <content type="html"><![CDATA[<p>学习下 linker 和 loader 中的内容，记录一下学习过程遇到的笔记以及知识点。主要的内容来自 csapp。</p><span id="more"></span><h3 id="为什么要学链接"><a href="#为什么要学链接" class="headerlink" title="为什么要学链接"></a>为什么要学链接</h3><ul><li>理解链接器能帮助我构造大型程序</li><li>理解链接器能帮助我避免一些危险的编程错误</li><li>理解链接器能帮助我理解语言中作用域规则的实现</li><li>理解链接器能帮助我理解其他系统概念</li><li>理解链接器能帮助我利用共享库</li></ul><p>这是文中提到的一些关键点，我个人更想了解的是，linker 和 loader 的执行过程，毕竟 Go 是编译类型的语言，还是有必要去了解一下其底层的编译的内容的。</p><p>书中的例子都是 C 语言实现的，只需要你简单了解一下语法即可，很简单。</p><h3 id="编译器驱动程序"><a href="#编译器驱动程序" class="headerlink" title="编译器驱动程序"></a>编译器驱动程序</h3><p>一个编译的过程有以下几个步骤：（一个 gcc 可以拆成以下四步）</p><ul><li>语言预处理器</li><li>编译器</li><li>汇编器</li><li>链接器</li></ul><p>（这个就像 Go 语言中，一个 go build 可以拆分成 compile 和 link 的过程。）</p><p>比如要编译 main.c 和 sum.c 文件， 通过 <code>gcc -Og -o prog main.c sum.c</code> 即可输出 prog 可执行文件。也可以一步一步拆解进行，如下：</p><ul><li>预处理器： <code>cpp main.c ./main.i</code>  翻译成一个 ASCII 码的中间文件</li><li>编译器： <code>cc1 ./main.i -Og -o ./main.s</code>  翻译成一个ASCII 码的<strong>汇编语言文件</strong></li><li>汇编器： <code>as -o ./main.o ./main.s</code>  翻译成一个<strong>可重定位目标文件</strong></li><li>链接器： <code>ld -o prog ./main.o ./sum.o</code> 生成一个<strong>可重定位目标文件</strong></li></ul><p>通过 gcc 的方式</p><ul><li>gcc -E hello.c -o hello.i</li><li>gcc –S hello.i –o hello.s</li><li>gcc –c hello.s –o hello.o</li><li>gcc hello.o –o hello</li></ul><h3 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h3><ul><li>符号解析<ul><li>目的是将每个符号引用正好和一个符号定义关联起来，比如将符号对应到函数、全局变量等。</li></ul></li><li>重定位<ul><li>把每个符号定义与一个内存位置关联起来。</li></ul></li></ul><h3 id="目标文件"><a href="#目标文件" class="headerlink" title="目标文件"></a>目标文件</h3><p><a href="https://www.bqyang.top/2021/elf">点我跳转到 ELF</a></p><h3 id="可重定位目标文件"><a href="#可重定位目标文件" class="headerlink" title="可重定位目标文件"></a>可重定位目标文件</h3><p><a href="https://www.bqyang.top/2021/elf">点我跳转到 ELF</a></p><h3 id="符号和符号表"><a href="#符号和符号表" class="headerlink" title="符号和符号表"></a>符号和符号表</h3><ul><li>由模块 m 定义并能被其他模块引用的<strong>全局符号</strong>。<ul><li>C 语言：全局链接器符号对应于非静态的C函数和全局变量。</li><li>Go语言：可以理解为在 util 包下定义的全局函数或全局变量。</li></ul></li><li>由其他模块定义并被模块 m 引用的<strong>全局符号</strong>。这些符号称为外部符号。<ul><li>C 语言：对应于在其他模块中定义的非静态 C 函数和全局变量。</li><li>Go 语言： 可以理解为在 util 包下引用了  time 包中的内容。</li></ul></li><li>只被模块 m 定义和引用的<strong>局部符号</strong>。<ul><li>C 语言：对应于带 static 属性的 C 函数和全局变量。</li><li>可以理解为在 Go util 包中定义的不可导出的函数或变量。</li></ul></li></ul><p>注意：C 语言中使用 static 关键字，隐藏模块内部的变量和函数声明，就像 Java 中的 private 和 public。在 C 中，任何带有 static 属性声明的全局变量或函数都是模块私有的。类似的，任何不带 static 属性的全局变量和函数都是公共的，可以被其他模块访问。</p><p>符号表是如何记录一个函数的：</p><p><img src="https://s2.loli.net/2022/06/23/D84UqxfTuAZneNS.png"></p><p>如上图中所示，一个函数在符号表中被称为条目，该条目中包括了函数的名称，函数的位置，函数是局部的还是全局的。</p><ul><li>name 表示字符串表中的字节偏移，指向符号的以 null 结尾的字符串名字。<ul><li>可以理解为函数名或者变量名字。</li></ul></li><li>value 表示符号的地址。<ul><li>对于可重定位的模块来说，value 是距定义目标的节的起始位置的偏移。</li><li>对于可执行目标文件来说，该值是一个绝对运行时地址。</li></ul></li><li>size 表示目标的大小。</li><li>type 表示要么是数据，要么是函数。</li><li>binding 表示是局部的，还是全局的。</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.c 文件</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> n)</span></span>;      </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">2</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;       </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;                 </span><br><span class="line">    <span class="keyword">int</span> val = sum(<span class="built_in">array</span>, <span class="number">2</span>); </span><br><span class="line">    <span class="keyword">return</span> val;              </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>乍一看是不是感觉很熟悉，Go 看起来也差不多的哈哈。通过上述的<strong>预处理-编译-汇编-链接</strong>这三步，将 main.c 文件编译成 main.o 文件。然后再查看 main.o 文件的符号表，如下图所示：</p><p><img src="https://s2.loli.net/2022/06/23/SzdTlrF6DXu2aUQ.png"></p><p>可以看到我们在 main.c 中定义的全局变量 array，sum 和 main。</p><p>Ndx 表示所在的 section，.text 索引为 1，以此类推。</p><p>再来看个简单的例子，以下内容来自 csapp 的课后习题。代码如下所示，</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// swap.c</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> buf[];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *bufp0 = &amp;buf[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">int</span> *bufp1;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下过程就是将 buf 中的两个元素进行交换</span></span><br><span class="line">    bufp1 = &amp;buf[<span class="number">1</span>];</span><br><span class="line">    temp = *bufp0;</span><br><span class="line">    *bufp0 = *bufp1;</span><br><span class="line">    *bufp1 = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// m.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> buf[<span class="number">2</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    swap();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样通过<strong>预处理-编译-汇编-链接</strong>的前三步，输出 swap.o 和 m.o 文件。按部就班的来，我们再看看 swap.o 的符号表长什么样。</p><p><img src="https://s2.loli.net/2022/06/23/UQ593ENuTzKrZMk.png"></p><table><thead><tr><th align="center">符号</th><th align="center">.symtab 条目？</th><th align="center">符号类型</th><th align="center">在哪个模块定义</th><th align="center">节</th></tr></thead><tbody><tr><td align="center">buf</td><td align="center">是</td><td align="center">外部</td><td align="center">m.o</td><td align="center">可以自行查看 m.o 确定</td></tr><tr><td align="center">bufp0</td><td align="center">是</td><td align="center">全局</td><td align="center">swap.o</td><td align="center">.data</td></tr><tr><td align="center">bufp1</td><td align="center">是</td><td align="center">全局</td><td align="center">swap.o</td><td align="center">COM</td></tr><tr><td align="center">swap</td><td align="center">是</td><td align="center">全局</td><td align="center">swap.o</td><td align="center">.text</td></tr><tr><td align="center">temp</td><td align="center">否</td><td align="center">-</td><td align="center">-</td><td align="center">都不在（栈分配）</td></tr></tbody></table><ul><li>.symtab 填是否</li><li>符号类型填全局、局部、外部</li><li>在哪个模块定义，即为在哪个文件中定义的</li><li>节，Ndx 对应的 section</li></ul><p>可以简单的做一下，看看你是否真的能够读懂 .symtab（符号表）。笔者一开始理解的符号表，只是其字面意思，以为就是用来存储符号的表，在网上查阅相关资料后，知道他存储的是函数和变量，在阅读 csapp 相关章节后，对于符号表的内容又有了进一步认识。</p><p>注：关于 COM、UND、ABS 的相关内容，请移步到 <a href="https://www.bqyang.top/2021/elf">ELF</a> 中进行查阅。</p><h3 id="符号解析"><a href="#符号解析" class="headerlink" title="符号解析"></a>符号解析</h3><h4 id="链接器如何解析多重定义的全局符号"><a href="#链接器如何解析多重定义的全局符号" class="headerlink" title="链接器如何解析多重定义的全局符号"></a>链接器如何解析多重定义的全局符号</h4><ul><li><p>强符号</p><p>函数和已初始化的全局变量是强符号。</p></li><li><p>弱符号</p><p>未初始化的全局变量是弱符号。</p></li></ul><p>规则如下：</p><ol><li>不允许有多个同名的强符号</li><li>如果有一个强符号和多个弱符号同名，那么选择强符号</li><li>如果有多个弱符号同名，那么从这些弱符号中任意选择一个</li></ol><h4 id="与静态库链接"><a href="#与静态库链接" class="headerlink" title="与静态库链接"></a>与静态库链接</h4><p>将所有相关的目标模块打包成为一个单独的文件，称为静态库（static library）。</p><p>在 linux 系统中，静态库以一种称为存档（archive）的特殊文件格式存放在磁盘中。存档文件是一组连接起来的可重定位目标文件的集合，有一个头部用来描述每个成员目标文件的大小和位置。archive 文件名后缀未 .a 标识。</p><h4 id="链接器如何使用静态库来解析引用"><a href="#链接器如何使用静态库来解析引用" class="headerlink" title="链接器如何使用静态库来解析引用"></a>链接器如何使用静态库来解析引用</h4><p>注：</p><p>​    1.在这里抛出一个问题， Go 语言中，我们在 main 包中调用了一个库函数，比如 <code>math.Max(1, 2)</code> ，请你思考一下，在程序编译过程中是把整个 math 模块都编译了进来，还是说只会将 main 包中用到的库函数编译进来？</p><p>​    2.如题，链接器如何使用静态库解析引用</p><p>在解析过程中要维护三个集合</p><ul><li>一个可重定位目标文件的集合 E，这个集合中的文件会被合并起来形成可执行文件</li><li>一个未解析的符号集合 U</li><li>一个在前面输入文件中已定义的符号集合 D</li></ul><p><img src="https://s2.loli.net/2022/06/23/oTYf4JLwVx3X6KU.png">注意：如果最后集合 U 是不为空的，说明有的符号未能在可执行目标文件或者静态库中找到 <code>symbol not found</code> 。</p><p>小结：至此我们已经学习过了，符号的定义，符号的解析过程。把代码中每个符号的引用和确切的一个符号定义关联了起来。</p><h3 id="重定位"><a href="#重定位" class="headerlink" title="重定位"></a>重定位</h3><p>重定位是由两步组成的：</p><ul><li>重定位 section 和 符号定义。在这一步中，链接器将所有相同类型的节合并为同一类型的新的聚合节。比如讲所有目标文件中的 <code>.data</code> section 合并成一个 <code>.data</code> section 并且这个 section 最后就是可执行目标文件的section。</li><li>重定位 section 中的符号引用。在这一步中，链接器修改 <code>.text</code> 和 <code>.data</code> 中对每个符号的引用，使得它们指向正确的运行时地址。</li></ul><h4 id="重定位条目"><a href="#重定位条目" class="headerlink" title="重定位条目"></a>重定位条目</h4><p>为什么需要重定位条目？</p><ul><li>因为汇编器生成一个目标文件的时候，并不知道该文件中 <code>.data</code> 和 <code>.text</code> section 最终要在内存的什么位置，与此同时，汇编器也不知道这个模块引用的任何外部定义的函数或者全局变量的位置。</li><li>所以汇编器在遇到一个最终位置未知的符号引用，它就会生成一个重定位条目。告诉链接器将目标文件合并成可执行文件时如何修改这个引用。</li></ul><p><strong>代码重定位条目放在 <code>.rel.text</code> 中</strong></p><p><strong>已初始化数据的重定位条目放在 <code>.rel.data</code> 中</strong></p><p>什么是重定位条目？</p><p><img src="https://s2.loli.net/2022/06/23/uZaVLfQmcbBEP9v.png"></p><p>参数解释：</p><ul><li>offset 需要被修改的引用的偏移</li><li>表示被修改引用应该指向的符号，在 symtab 中的位置</li><li>type 告知链接器如何修改引用</li><li>addend 是一个有符号常数，一些类型的重定位要使用它对被修改引用的值做偏移调整。</li></ul><p>注：我们只需要关注两个最基本的重定位条目</p><ul><li><p>R_X86_64_PC32 重定位一个使用 32 位 PC 相对地址的引用。在指令中编码的 32 位值加上 PC 的当前运</p><p>行时值，得到有效地址。</p></li><li><p>R_X86_64_32 重定位一个使用 32 位绝对地址的引用。</p></li></ul><h4 id="重定位符号引用"><a href="#重定位符号引用" class="headerlink" title="重定位符号引用"></a>重定位符号引用</h4><p>1.重定位 PC 相对引用</p><p>2.重定位 PC 绝对引用    </p><p><img src="https://s2.loli.net/2022/06/23/vcVxoFJTnpdyabQ.png"></p><p>这张图主要讲了，针对相对或绝对的不同类型，对应到不同的计算方式。</p><h3 id="加载可执行目标文件"><a href="#加载可执行目标文件" class="headerlink" title="加载可执行目标文件"></a>加载可执行目标文件</h3><p>当我们通过命令行调用我们的可执行文件时 <code>./prog</code> shell 会认为这是一个可执行目标文件，然后通过某个在内存中称为加载器（loader） 的操作系统代码来运行 <code>./prog</code> 。</p><p>加载器将可执行目标文件中的代码和数据从磁盘加载到内存，然后通过跳转到程序的第一条指令或入口来运行该程序。程序被复制到内存并运行的过程称为<strong>加载</strong>。</p><h4 id="加载器实际上是如何工作的："><a href="#加载器实际上是如何工作的：" class="headerlink" title="加载器实际上是如何工作的："></a>加载器实际上是如何工作的：</h4><p>书中提到，这里只是一个简单的概述。</p><p>Linux 系统中的每个程序都运行在一个进程上下文中，有自己的虚拟地址空间。当 shell 运行一个程序时，父 shell 进程生成一个子进程，它是父进程的一个复制。子进程通过 execve 系统调用启动加载器。加栽器删除子进程现有的虚拟内存段，并创建一组新的代码、数据、堆和栈段。新的栈和堆段被初始化为零 通过将虚拟地址空间中的页映射到可执行文件的页大小的片 (chunk), 新的代码和数据段袚初始化为可执行文件的内容。最后，加载器跳转到 _start地址，它最终会调用应用程序的 main 函数。除了一些头部信息，在加栽过程中没有任何从磁盘到内存的数据复制 直到 CPU 引用一个被映射的虚拟页时才会进行复制，此时，操作系统利用它的页面调度机制自动将页面从磁盘传送到内存。</p><h3 id="动态链接共享库"><a href="#动态链接共享库" class="headerlink" title="动态链接共享库"></a>动态链接共享库</h3><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><p><a href="https://stackoverflow.com/questions/6687630/how-to-remove-unused-c-c-symbols-with-gcc-and-ld">https://stackoverflow.com/questions/6687630/how-to-remove-unused-c-c-symbols-with-gcc-and-ld</a></p></li><li><p>简书-图解静态库链接过程-<a href="https://www.jianshu.com/p/4510b47ecd8a">https://www.jianshu.com/p/4510b47ecd8a</a></p></li><li><p>csapp 第七章</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;学习下 linker 和 loader 中的内容，记录一下学习过程遇到的笔记以及知识点。主要的内容来自 csapp。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>DDIA 读书笔记</title>
    <link href="https://bqyang.top/2022/DDIA/"/>
    <id>https://bqyang.top/2022/DDIA/</id>
    <published>2022-06-23T10:30:51.729Z</published>
    <updated>2022-07-05T11:01:58.273Z</updated>
    
    <content type="html"><![CDATA[<p>Designing Data-intensive Applications</p><span id="more"></span><h2 id="CH1：-Reliable-Scalable-Maintainable"><a href="#CH1：-Reliable-Scalable-Maintainable" class="headerlink" title="CH1： Reliable, Scalable, Maintainable"></a>CH1： Reliable, Scalable, Maintainable</h2><p>主要解释这三个词是什么意思，以及从哪些角度进行思考。</p><p><strong>影响设计数据系统的多个因素</strong></p><ul><li>遗留系统的依赖问题</li><li>设计这个系统的人的经验和技能</li><li>要交付的时间</li><li>对风险的容忍度</li><li>监管限制？ 这个没搞懂，是权限的意思么？</li></ul><p>在 DDIA 中主要关注三个方面</p><ul><li><p>Reliability 可靠性</p><p>即使遇到硬件或软件的 fault，人为的 error 系统应该正常工作。</p></li><li><p>Scalability 可扩展性</p></li></ul><p>​        随着系统的增长（规模上），能够妥善的处理增长带来的问题。</p><ul><li><p>Maintainablity 可维护性</p><p>人员变动随着时间变化着，不同的人维护着同一套代码。</p></li></ul><p><strong>Reliablity</strong></p><ul><li>应用程序像用户期待的那样执行函数</li><li>可以容忍用户错误的操作或非常规的操作</li><li>性能可以满足日常需求，并且足以应对突发的负载</li><li>能够阻止未授权的请求</li></ul><p>作者给我们总结了，如果上述的这些条件都满足了，意味着正常工作，我们可以粗略的认为可靠性就是，在系统出错的时候，仍然能正常工作。</p><p>这里对错误和失败又进行了区分，有哪些是可以容忍的，哪些是不行的。</p><p>错误通常被定义为系统中的一个组件偏离了最初的规范。比如一个接口本应该返回A，但是返回B了。失败通常表示整个系统宕机了，不能正常提供服务。</p><p>硬件错误</p><ul><li>硬盘故障，RAM 故障，电源被关闭了，插错网口了</li></ul><p>软件错误</p><ul><li>软件失控了，把所有计算资源都消耗了。</li><li>Linux 内核错误，导致程序都 hang 住了。</li><li>系统依赖的服务挂掉了，变成无响应的或者返回错误的响应。</li><li>Cascading failures 这种不知道中文怎么翻译，不过大概意思就是扇面的那种，一个错误导致多个，多个错误导致更多的错误。</li></ul><p>​    没有快捷的方法来解决这些系统性的错误在软件中，只能做好监控，识别差异（未能达到预期）</p><p>人为错误</p><ul><li>在某种程度上，最小化系统犯错的机会。</li><li>在出错最多的地方与引起错误的地方进行解耦。使用与生产环境一样的配置，来探索发现问题。</li><li>详细的测试工作，单元测试，系统测试，手动测试，自动测试等。</li><li>能够从人为制造的错误中快速进行恢复，最小化其带来的影响。比如，具备快速回滚的能力</li><li>配置好详细清晰的监控，比如性能监控和错误比率。当出错的时候，监控数据以及日志对于我们排查问题来说是无价的。</li><li>对员工有一个完整，良好的培训过程。</li></ul><p>总而言之，可靠性会关乎到公司，部门的信誉，和用户的体验也有很大联系。</p><p><strong>可扩展性</strong></p><p>可扩展性是用来描述系统在面对突发负载的能力。当讨论扩展性的使用，其实就是在考虑如下的两个问题：</p><ul><li>如果系统以某种特别的方式进行增长，我们可以采取什么措施来应对？</li><li>我们应该怎么增加计算资源来处理额外的负载？</li></ul><p><em>负载</em></p><p>负载可以用一些参数来表述：数据库的读写比，同一时间在线的用户数量，缓存的命中率..</p><p>作者以 Twitter 为例，具体描述了<em>负载</em>。</p><p><em>性能</em></p><p>在网络应用中，性能更多的意味着响应时间。</p><p>是什么导致了每次响应时间都不相同？</p><ul><li>后台进程的上下文切换</li><li>网络丢包，TCP 重传</li><li>GC pause</li><li>页缺失导致从磁盘重新加载</li><li>等等</li></ul><p><strong>可维护性</strong></p><p>广为人知的是，软件中的主要开销是维护工作，而不是起初开发。比如，修 Bug，保证系统运行，调研失败原因，适应新的平台，偿还技术债务，添加新的特性等。</p><p>三个软件涉及原则：</p><ul><li><p>可操作性，Operability</p><p>能使运维团队很容易操作。</p></li><li><p>简易性，Simplicity</p><p>能让新的工程师很容易明白，尽量设计的简洁。</p></li><li><p>可进行性，Evolvability</p><p>能让工程师在修改的时候很方便，可以应对未被考虑到的需求变化，也可以用这几个词来形容，<em>extensibility</em>, <em>modifiability</em>, or <em>plasticity</em>.</p></li></ul><p>（上述的名词翻译都是我自己凭感觉搞得，不存在普遍性）</p><p>作者简述了一个好的运维团队应该要做的事情..</p><h2 id="CH2：Data-Models-And-Query-Languages"><a href="#CH2：Data-Models-And-Query-Languages" class="headerlink" title="CH2：Data Models And Query Languages"></a>CH2：Data Models And Query Languages</h2><p>数据模型是按照每一层进行分布的，关键的问题在于每一层是如何表示的？</p><ul><li>实际生活中，有组织，商品，现金流，传感器，等。我们以对象或者数据结构的方式对其进行建模。可以理解为数据表达方式</li><li>这些数据是以哪种结构进行存储的，JSON\XML\数据库中的表结构，等等。</li><li>这些数据是存储在哪种物理器件上的，内存，磁盘，网络中。</li><li>在更底层，这些内容以电子，脉冲信号的形式存在。</li></ul><p>万变不离其宗，每一层都是对底层的封装，提供更简洁接口。</p><p><strong>NoSQL 数据库的诞生</strong></p><p>采纳 NoSQL 数据库的几个驱动力：</p><ul><li>需要比关系数据库更容易实现的可扩展性，包括非常大的数据集或非常高的写入吞吐量</li><li>免费开源的软件</li><li>关系型数据模型并不支持的查询</li><li>对关系模式的不看好，渴望一个更加动态和富有表达力的数据模型</li></ul><p><strong>Many-to-One and Many-to-Many</strong></p><p>作者在这里探讨了一个点，在多对一或多对多的关系中，为什么存储另一个字段的 ID，二不是值。</p><p>举个例子，用户对应的地区，职业，一个用户可以对应到多个地区，工作，家庭住址等，也可以对应到多个职业。</p><p>所以，在存储用户对应的这些信息的时候，如果说在页面上需要用户自己输入，那存储用户的具体信息是有意义的。如果在页面上呈现出来的是一个标准的下拉列表，让用户去选择，有很多的好处：</p><ul><li>一致的格式和拼写</li><li>避免歧义，比如重名问题</li><li>利于更新 – 因为名称仅存在了一个地方，其他都是对它 ID 的引用</li><li>本地化支持 – 作者想表达的是国际化时候很方便</li><li>利于搜索</li></ul><p><strong>网络模型</strong>（The network model）</p><p>太复杂不够灵活。</p><p><strong>关系模型</strong></p><p>即使索引改变了，也不需要我们在代码中手动调整指定，查询优化器会自定的帮我们做这些事情。</p><p><strong>文档模型与关系模型</strong></p><p>有利于文档模型的一点就是灵活性，更好的局部性（可以理解为相关的信息都在一起），关系模型中支持连表查询，多对一，多对多的关系。</p><p>文档模型中的限制：</p><ul><li>不能直接引用文档中嵌套的数据，取而代之的是需要说明那个引用在文档中的路径。作者提到只要嵌套不是很深，都不是问题。</li><li>对 Join 这类查询，无法提供良好的支持，但主要取决于应用。作者提到，比如在用于分析的应用中，可能永远用不到多对多的关系，这时采用文档数据库来存储更合适，比如什么时间发生了什么时间。</li></ul><p>文档模型的灵活性</p><p>有一点被误解的是，文档数据库是<em>无模式的</em>。但是，当代码从数据库中读取数据的时候，通常会假设某种结构用于接收读到的数据，这种模式是隐式的，也不是由数据库强迫加上的。</p><p>对于上述情况，有一个更专业的术语 <em>schema-on-read</em> ， 还有一种 <em>schema-on-write</em> 在写入数据库的时候就已经明确了</p><p><em>schema-on-read</em> 像动态类型语言（python），<em>schema-on-write</em> 像强类型的语言。</p><p>这两种模型的区别在应用想要修改数据格式的时候非常明显：</p><p>作者通过修改名称举例，目前采用一个字段进行存储名称，但是现在想通过 <em>first name</em> 和 <em>last name</em> 的模式进行存储。</p><p>文档模型</p><ul><li>直接在代码中做处理即可</li></ul><p>关系模型</p><ul><li>需要在数据库中添加列</li><li>然后更新那一列的值</li></ul><blockquote><p>在数据库中添加列的操作会使数据库停机，大多数数据库执行 Alter 语句通常在几毫秒内就可以完成，但是 MySQL 中会复制整张表，当处理一张拥有很多数据的表时，这可能会执行几分钟甚至几小时</p></blockquote><p>什么时候使用文档模型最合适？作者给出了两点参考</p><ul><li>一个对象有很多种类型，把每种类型的对象放在单独的表中不切合实际。</li><li>外部系统决定数据结构，可能随时改变。</li></ul><p>数据库未来的发展：作者提到的是数据库会结合这两者的优点，让应用从中受益。</p><p><strong>图状数据模型</strong></p><p>关系模型的数据库虽然支持多对多的关系，如果应用中存在大量的多对多映射，应考虑使用图来建模。</p><p>图由两种对象组成： 顶点（也称为结点或实体）和边（也称为关系或弧）。 很多数据</p><p>可以建模为图。 典型的例子包括：</p><ul><li><p>社交网络</p><p>顶点是人，边表示哪些人相互认识</p></li><li><p>网络图</p></li><li><p>公路或铁路网</p><p>顶点是交叉路口，边表示公路或铁路</p></li></ul><p><em>属性图</em> 的几个重要方面</p><ul><li>一个顶点可以通过任意一边连接到其他顶点。没有模式限制哪个类型可以连接哪个类型或者不可以连接。</li><li>给定一个顶点，可以很高效的找出进来的边，和出去的边。因此可以遍历整张图。</li><li>使用不同的标签代表不同的关系，可以存储各种各样的信息在一张图中，并且可以维护一个整洁的数据模型。</li></ul><blockquote><p>选择性跳过一些内容，不是很感兴趣.. 主要是关于图的查询，比如在关系型数据库中如何使用 SQL 等，还介绍了其他几种不同的图查询语言。</p></blockquote><p><strong>总结</strong></p><p>这一节主要学到了，document，graph，relational，三种数据模型，</p><ul><li><p>document 的使用场景主要是，各个数据之间都是独立，一条数据不存在（几乎不）与另一条的关联关系。</p></li><li><p>graph 与 document 相反，在图模型中，任何事物都有可能与其他事物关联到一起。</p></li><li><p>relational 关系模型是我们接触最频繁的..</p></li></ul><p>突然想到一个问题，要设计某些东西的时候，我们好像没有去发散的思考，这个场景下，是否真的适合使用 MySQL，取而代之的是，为了往 MySQL 上套，强行这样思考。</p><p>确实这是一个值得深思的问题，研究问题要从问题的本质出发，而不要被工具束缚。</p><h2 id="CH3：Store-and-Retrieval"><a href="#CH3：Store-and-Retrieval" class="headerlink" title="CH3：Store and Retrieval"></a>CH3：Store and Retrieval</h2><p>通过标题来看应该是讲，数据的存储和检索。</p><p><em>作为一个应用开发者，为什么需要关心数据库是如何存储和检索数据的？</em></p><ul><li>虽然我们不需要从头开始实现一个数据库，但是我们需要知道如何进行选择一种最适合我们的</li></ul><p>作者通过一个文件进行举例，文件中的每一行都是一个 k-v 形式的键值对。当前这种情况也会遇到很多问题，比如控制并发写入，怎样进行错误处理等..</p><p>另外，性能也存在一定的问题，想要寻找某个 Key 对应的 Value 时，只能从头到尾进行遍历，作者由此引出<strong>索引</strong></p><p>不同类型索引之间的共同点：</p><ul><li>都需要额外增加元数据信息来提高搜索速度</li></ul><p>索引的添加和删除并不会影响数据本身的内容，只会影响查询数据的性能。</p><p><strong>Hash Indexes</strong></p><p>作者最开始还是通过文件进行举例，文件还是存储在磁盘上，然后在内存中存储一个 <em>Hash Map</em> ， Map 中存储了 key value 是 真正的 val 在 磁盘中的位置。</p><p><img src="https://s2.loli.net/2022/06/23/sHOQul1pcin5vVW.png">为了防止 log 文件过大的解决办法：</p><ul><li>设定某一个阈值，当 log 文件达到这个值的时候，就把他拆分成几份。</li><li>后续的写操作都在另一个新的文件中进行写入。</li><li>压缩 log 文件，只保留对 key 的最新一次更新，如下。</li></ul><p><img src="https://s2.loli.net/2022/06/23/vlzUqd79fyIbaRo.png"></p><ul><li>通过压缩后，可能会导致某一段的文件过小，这里也可以进行段的合并操作，如下。</li></ul><p><img src="https://s2.loli.net/2022/06/23/Fryci6t4GCm7JIK.png"></p><p>正如之前看到的，所有对 log 文件的操作都基于 append 的，为什么不能直接更新之前的操作呢？使用 append-only 的好处是：</p><ul><li>append 的操作是顺序写，而不是随机写，速度快</li><li>如果 log 文件是 append-only 的，并发和崩溃恢复很容易实现</li><li>合并之前被拆分的 log 文件，有助于防止 log 文件的碎片化</li></ul><p><em>Hash Map</em> 带来的限制：</p><ul><li>hash map 不能太大，必须保证内存可以装下</li><li>范围查询效率不高</li></ul><p><strong>SSTable and LSM-Trees</strong></p><p>SSTable (Sorted String Table) 按照 Key 进行排序，如下。</p><p><img src="https://s2.loli.net/2022/06/23/sJRpG2EBAkNMuqC.png"></p><p>看的过程中我想到一个问题，不同的 key 在不同的 log 文件中都有存在，是怎么在合并后的 log 文件中进行存储的呢？难道是每次读取到同样的 key 的时候都要再进行一次更新操作吗？</p><p>紧接着，作者在下文中就提到了这个问题：</p><p><code>What if the same key appears in several input segments?</code></p><p>在看“答案”的时候，作者提到了一点，当出现这种情况的时候，以最新的 log 文件中的数据为准，忽略旧的（在这之前操作）log 文件。</p><p>作者简述了一个采用 SSTable 和平衡树（红黑，AVL）作为底层数据结构的存储引擎，工作流程大致如下：</p><ul><li>当有写操作时，将写操作的内容加入到内存中的平衡树，这种结构也被称为 <code>memtable</code></li><li>当 <code>memtable</code> 超过某个阈值的时候，将其以 SSTable 的形式写入到磁盘中。如果这个时候有新的写操作，可以在一个新的 memtable 中进行插入。</li><li>当有读操作的时候，会从 memtable 中进行查找，然后在最近的 SSTable 中进行查找，直至找到最后一个</li><li>后台程序会将 log 文件进行合并、压缩操作。</li></ul><p>上述存储引擎存在一个问题，内存作为易失型存储，所以存在 memtable 中的数据是有可能丢失，为了解决这类问题，作者随后提到</p><ul><li>用一个存储在 disk 中的 log 文件用来存储操作日志，比如写操作发生时，不仅仅在 memtable 中进行插入，也在 log 文件中插入</li></ul><blockquote><p>该 log 文件是无序的，因为它只有在宕机等情况发生时才会用到，如果与之对应的 memtable 写入disk后，这个 log 文件也就变成无用的，可以删除掉。</p></blockquote><p><em>LSM-tree</em></p><p>LSM - log structured merge</p><p>当在 LSM-tree 中查找一个不存在的 key 时，需要从 memtable 找到最后一个 log 文件。为了优化这个问题，引入了 <code>Bloom Filter</code>。</p><p>LSM-tree 两种压缩策略</p><ul><li>size-tiered</li><li>leveled</li></ul><blockquote><p>以后有兴趣可以深入了解一下，这种存储的数据的策略，这里只是根据书中内容作为简要了解即可！</p></blockquote><p><em>B 树</em></p><p>学过很多次，看看作者是怎么结合实例进行讲解的。。</p><p>LSM 最后将数据划分到大小不一的 log 文件中（通常是 Mb）<strong>B</strong> 树采用的是，固定的块大小或页大小（通常大小为 4 KB）的方式进行存储。这样能更贴合硬件，因为磁盘也是采用这种固定大小块的方式进行数据的写入和存储。</p><p>B 树中，每一页都是存储在磁盘上，可以通过地址进行索引，并且页与页之间可以相互引用</p><p>分支因子：branch childs ，表示一个父节点拥有多少个子节点，实际使用中，分支因子的数量<em>取决于</em>存储页引用需要的空间大小和范围边界，通常来说是几百个。</p><p>在添加数据到叶子结点的时候，可能会导致页的拆分</p><p><img src="https://s2.loli.net/2022/06/23/nHFL8C3cNpUty5P.png"></p><p>假设当前page已经不能再容纳新的key时，在添加 key 334 后，进行了 page 的拆分。</p><p>平衡二叉树通过自旋算法，能想起来的有 LL，RR，LR，RL…保证了任意两个节点之间的只能有一个节点。我记得是有这么一条定义。。记不清楚了。。</p><p>作者举例，当 page = 4 KB，branching factor = 500 的时候，一个四层的 B 树可以容纳 250 TB 的数据。</p><p>如果在写入数据的时候，数据库崩溃了，会出现什么问题？</p><ul><li>比如，上述发生插入操作的时候，导致了 page 的分裂，这时候需要将当前这个 range 拆分成两个，并修改父节点对他们的引用。如果这时候数据库崩溃了，可能会出现类似<em>悬垂指针</em>的问题。为了解决这个问题，让数据库对崩溃有一定的容错能力，在实现 B-tree 的时候会额外在磁盘上添加一个数据结构，<em>write-ahead logging</em> (WAL, 也被称为 redo log)。</li></ul><blockquote><p>怪不得都说 DDIA 是必读书籍，读起来就是两个字，畅快。循序渐进，对我这种菜鸟来说太棒了！</p></blockquote><p>WAL ，append-only 的文件格式。<strong>在将修改操作实际应用到磁盘中数据的之前，必须将修改写入到这个文件中</strong>，恢复后，可以使用这个文件进行恢复。</p><p><strong>优化 B 树</strong></p><ul><li>copy-on-write</li><li>尽量减少key所占用的空间，可以通过缩写的方式，key 只是用来表明边界的。</li><li>保持相邻的key在磁盘上的位置也是相邻的，如果一个查询要查出一个很大范文的内容并要求是有序的，一页一页查找的效率十分低下。<ul><li>想法时候，但是随着数据的增长，很难维护一个这样的数据结构</li></ul></li><li>添加额外的指针，将兄弟节点连接起来，这样在遍历的时候就不需要回到父节点找到其他的兄弟节点。</li><li>从 B 树优化出来一个叫 <code>fractal tree</code> 听都没听过…</li></ul><p><strong>对比 B 树 和 LSM 树</strong></p><p>当我们评测存储引擎性能的时候有哪些事情是值得考虑的？</p><ul><li><em>write amplification</em>（写放大）<ul><li>在数据库的生命周期中，一次写入数据库的操作导致多次写入磁盘的操作被称为写放大。</li><li>注：SSD 被写入的次数是有限制的</li></ul></li></ul><p>LSM 优缺点：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TODO </span></span><br></pre></td></tr></table></figure><p><strong>索引</strong></p><ul><li>Secondary Index （二级索引）<ul><li>索引中 value 存储的是引用</li></ul></li><li>Clustered Index （聚簇索引）<ul><li>索引中 value 存储的是数据</li></ul></li><li>Covring Index （覆盖索引）<ul><li>是聚簇和非聚簇索引的一种折中方式</li><li>覆盖索引对应的 value 中可以包含多个列</li></ul></li></ul><p>注：MySQL 中，二级索引的 value 存储的是主键 id</p><p><strong>多列索引</strong></p><p>作者给我们做了一个科普吧算是，介绍了一维索引的局限性，已经多维索引可以在哪些场景中用到。</p><p><strong>全文搜索，模糊索引</strong></p><p>同上</p><p><strong>事务处理与分析处理</strong></p><p>作者对事务（transaction）进行了解释，并没有像教科书那种直接给出定义，而是结合历史告诉我们，事务一词的来源。以前在商业数据处理中， 一个往数据库中写入的操作往往意味着背后发生了一笔交易，或者是一笔订单，给员工汇款等操作。随着数据库不仅仅用于商业领域，transaction 这个词仍然延续使用。</p><p>其代表的是，一个逻辑单元中全部的写操作和读操作。</p><blockquote><p>事务并不一定要有 ACID （atomicity, consistency, isolation, durability）</p></blockquote><p>OLTP (online transaction processing)</p><p>OLAP (online analystic processing)</p><p><img src="https://s2.loli.net/2022/06/23/HfGSdbgCRA8rwsX.png"></p><p><em>数据仓库的由来</em></p><p>90 年左右，一些公司开始停止在 OLTP 中进行数据分析，而是在一个单独的数据库中进行分析，这种独立的数据库被称为：data warehouse. 数据仓库。</p><p><strong>数据仓库</strong></p><p>从 OLTP 提取数据到  OLAP 的过程被称为： ETL (extract-transform-load)</p><p><img src="https://gitee.com/yangbaoqiang/images/raw/master/blogpics/image-20220127205128006.png" alt="image-20220127205128006"></p><blockquote><p>作者提到。。小规模的公司可能都没听过数据仓库。。。身在其中啊。。</p></blockquote><p><strong>Stars schema and Snowflakes</strong></p><p>这一小节通读下来，可以学习到的是：</p><p>星模式-一个主表中存储的都是其他表（子表）的主键。比如，订单表中存储的商户id，商户表中存储了商户信息</p><p>雪花模式-星模式的一种变种，子表中存储的其他表的主键。订单表中存储的商户id，商户表中存储了商户信息，还存储了户主信息，户主表中存储了户主的信息。</p><p>可以理解为雪花模式是比星模式表达的更完整，拓展的更多的一种模式。</p><p><strong>面向列的存储</strong></p><p>row-oriented 和 column-oriented 存储方式上的区别</p><p><img src="https://s2.loli.net/2022/06/23/SYNihRLcZBml1gs.png"></p><p><em>采用位图压缩列</em></p><p><img src="https://gitee.com/yangbaoqiang/images/raw/master/blogpics/image-20220128102336567.png" alt="image-20220128102336567"></p><p>这里感觉书中描述的不是那么清晰（也可能是我自己翻译后理解的比较烂哈哈）：</p><ul><li>比如我们有 n 个列，但是经过去重后发现只有 m 个商品，可以通过，建立 m 个 bitmap 然后，每一个 bitmap 的长度是  n 的方式，来压缩列。</li><li>如果 bitmap 中，对应比特位为 1 说明该行有这个值，为 0，说明无。</li></ul><p><em>在 bitmap 中查找数据</em></p><p><img src="https://s2.loli.net/2022/06/23/BaonQTIzSVNw9WU.png"></p><p>这个地方确实是非常巧妙，比如要找 product_sk 的 id 在 30，68，69 这三个数之间的，直接把这三个对应的 bitmap 找出来，进行 OR 运算，bit 位 是 1 的就代表找到了。</p><p>第二个例子中展示了当进行 AND （与）运算的时候，直接将不同的 bitmap 进行 AND，可以这样做的根本原因是，虽然不同的数据在不同的 bitmap 中，但是 bitmap 中的每一位都是彼此对应的。</p><p><em>内存带宽和矢量化处理</em></p><p>内存带宽这里涉及到 SIMD 一个指令，包含多个数据。跟普通的三、四地址的指令好像还不太一样。。</p><p><em>data cube and materialized view</em></p><p><img src="https://s2.loli.net/2022/06/23/3E5U7zJTOHlusQS.png"></p><p>缓存聚合数据。</p><h2 id="CH4：-Encoding-and-Evolution"><a href="#CH4：-Encoding-and-Evolution" class="headerlink" title="CH4： Encoding and Evolution"></a>CH4： Encoding and Evolution</h2><p>Backward compatibility</p><p>​    Newer code can read data that was written by older code.</p><p>Forward compatibility</p><p>​    Older code can read data that was written by newer code.</p><p><strong>数据的编码方式</strong></p><p>程序处理的数据通常由两种（至少）表示方式：</p><ul><li>In memory</li><li>self-contained sequence of bytes （Json）</li></ul><p>encoding ： In memory —&gt; sequence</p><p><em>二进制编码</em></p><p>Facebook - Thirft </p><ul><li>Thrift 有两种压缩方式： <em>BinaryProtocol</em> and <em>CompactProtocol</em></li></ul><p>Google - Protobuf</p><ul><li>Protobuf 只有一种压缩方式，从书中结论来看，比 Thrift 压缩的要小一点，但是差别不大。</li></ul><p>Thrift 采用如下第一种的方式声明 schema</p><p><img src="https://s2.loli.net/2022/06/23/5DMGen3OPgULca9.png"></p><p>Thrift - BinaryProtocol</p><p><img src="https://s2.loli.net/2022/06/23/Xj38cVD1rpgG67z.png"></p><p>有数据类型标识，字段的 tag （表示字段名称），可以在图中看到有很多地方都是 00 ，这些未用到字节，如果可以进一步被压缩，仍然可以节省很多空间。</p><p>由此可以引出 Thrift 的第二种压缩方式：CompactProtocol ，它确实也是这么做的，通过把更多的信息<strong>pack到尽可能少的字节中</strong>，这是不是和 SIMD 的基本思想是相同的？从 59 字节压缩到 34 字节，优化了将近 50 %的size。</p><p>如下图，把数据类型和字段的tag, pack 到了一个字节。</p><p><img src="https://s2.loli.net/2022/06/23/TZsguR4KqAoweaD.png"></p><blockquote><p>这章节后半部分是在手机上阅读的。。没来得及做笔记整理，等我二刷中文版的时候，着重把这块补上。</p></blockquote><h2 id="CH5：Replication"><a href="#CH5：Replication" class="headerlink" title="CH5：Replication"></a>CH5：Replication</h2><p>从单一的数据系统转变为分布式的数据系统。</p><p>分布式系统有两种形式的存在方式</p><ul><li>Replication</li><li>Partitioning</li></ul><p>某些情况下，这两种模式会混合使用，下图中展示了，一个数据库分成了两个分片，又为两个分片搞了两个副本。</p><p><img src="https://s2.loli.net/2022/06/23/AgezPrCvyl1Nd3B.png"></p><p><em>为什么需要 replication</em></p><ul><li>在距离上离用户更近</li><li>当某部分出错时可以保证系统正常工作</li><li>水平扩展机器，增加吞吐量</li></ul><p><strong>Leaders And Followers</strong></p><p><em>如何却确保 master 的数据到达了所有的  slave 上？</em></p><p><img src="https://s2.loli.net/2022/06/23/SHL7jerUyf6pMq2.png"></p><p><em>Synchronous Versus Asynchronous Replication</em></p><p><img src="https://s2.loli.net/2022/06/23/CKQRLSyi1XpAtdU.png"></p><p>同步的优缺点</p><ul><li>slaves 一定是最新的副本，与 master 中保持一致</li></ul><p>缺点</p><ul><li>如果同步过程中 slave 没有响应，如上图 Follower 1 的处理时间会变成不可预测的。这时 master 不会处理任何写操作，直到收到 slave 的响应。</li></ul><p>异步的缺点：</p><ul><li>如果 master 崩溃了，可能会导致数据的丢失，即主从节点存储的数据不一致</li></ul><p><strong>配置新的 slave</strong></p><p>当一个 slave 加入到 cluster 中，slave 如何进行数据的同步。</p><ul><li>打快照</li><li>将快照发送到 slave</li><li>slave 连接到 master ，同步从 <em>打快照时间之后</em> 做的数据变更</li><li>上一步执行完成后，与其他的 slave 同步数据的方式就没有什么不同了</li></ul><p><strong>处理崩溃节点</strong></p><ul><li><p><strong>catch-up recovery</strong></p></li><li><p><strong>Failover</strong> 故障转移</p></li></ul><p><strong>replication logs 的实现</strong></p><p>用于slave同步数据的文件，是怎么存储 master 的操作日志的？</p><ul><li><p>基于语句的实现</p><ul><li>压缩性好</li><li>如果master 中用了 NOW() 这样的函数，这样在 slave 中执行会出问题的<ul><li>解决办法就是，计算出确定的值然后存储的 log 文件中</li></ul></li></ul></li><li><p>WAL</p><p>这里提到了怎样使用这个技术是实现数据库版本的升级，简而言之，先给 slave 节点进行升级，然后执行故障转移，让已经升级的 slave 成为 master 节点。</p><blockquote><p>这种方式的一个缺点就是，slave 和 存储引擎是紧耦合的</p></blockquote></li><li><p>基于行 row 的实现</p><ul><li>MySQL 触发器，逻辑日志</li></ul></li><li><p>基于 trigger 的实现</p><p>就是在执行相应语句时，执行特定的函数</p></li></ul><p><strong>slave 节点同步数据滞后的问题</strong></p><p>似乎每种高可用都有这类问题，如果在主库修改了一个数据，紧接着读取数据，这时候从节点去服务这个读请求，就会出现数据不一致的问题。</p><blockquote><p>第五章，一部分是在手机上读的没来得及做笔记。。二刷一定补上！</p></blockquote><h2 id="CH6：Partitioning"><a href="#CH6：Partitioning" class="headerlink" title="CH6：Partitioning"></a>CH6：Partitioning</h2><p>分布式数据库的另一种存储方式，分片，即每个地方只存储一部分数据，各个分片的内容合并起来才是一个完整的数据。</p><p>如何将一个大的数据库进行分片？</p><p>如何与分片进行交互，即数据的查询？</p><p>如何找到数据所在的正确的分片？</p><p><strong>分片和副本</strong></p><p>这俩通常会结合使用，如下：</p><p><img src="https://s2.loli.net/2022/06/23/5RDAsTzKv1um27e.png"></p><h4 id="Key-Value-类型数据的分片"><a href="#Key-Value-类型数据的分片" class="headerlink" title="Key-Value 类型数据的分片"></a>Key-Value 类型数据的分片</h4><p>学到了几个名词：</p><p>skewed 倾斜，某个分区的数据要多余其他分区，把这种情况称为倾斜。</p><p>hot pot 热点，某个分区的负载比其他分区都要高，把这种情况的分区叫做热点。</p><p>避免热点分区最简单的方法就是，插入记录的时候随机选择分区。</p><p><img src="https://s2.loli.net/2022/06/23/WtIMG4HnEqiV9O7.png"></p><p>图中索引为 12 的范围，包括了 T - Z，这种简单的将一本书包括两个字母索引，会导致其他的卷包含的索引不均匀。<em>为了使数据分布的更均匀，分区的边界需要适应数据。</em></p><h4 id="通过-key-的-hash-值进行分区"><a href="#通过-key-的-hash-值进行分区" class="headerlink" title="通过 key 的 hash 值进行分区"></a>通过 key 的 hash 值进行分区</h4><p><img src="https://s2.loli.net/2022/06/23/MOtpjgGC39NvHi8.png"></p><p>使用key的哈希值作为分区，给我们带来的一个损失就是：没办法执行高效的范围查询。</p><p><strong>Skewed Workloads and Relieving Hot Spots</strong></p><p>倾斜的工作负载指的是，某个分区的负载要明显高于其他分区。比如社交媒体中的明星有很多的粉丝，这种情况下很容易引起，瞬间大量操作同一个 key。</p><p>解决这种问题的办法就叫做：Relieving Hot Spots</p><p>就是让打在同一个分区上的请求，再次分布到别的分区之中。</p><p>作者提到的一个最简单的方法是：在 key 的开头或结尾添加随机数，这两个随机数可以将打在一个分区的请求均匀分布到 100 个 key 上，而不是只操作一个 key。</p><p>但是这又带来了另一个问题，就是读取数据的时候变得更加困难，需要将这100个key 都读取出来，再做汇总。</p><h4 id="Partitioning-and-Secondary-Indexes"><a href="#Partitioning-and-Secondary-Indexes" class="headerlink" title="Partitioning and Secondary Indexes"></a>Partitioning and Secondary Indexes</h4><p><strong>Partitioning Secondary Indexes by Document</strong></p><p>主要讲了分区和二级索引怎么搭配使用。</p><p><img src="https://s2.loli.net/2022/06/23/6ysve8u5AQb3GoZ.png"></p><p>基于文档的二级索引分区，每个分区中的二级索引都是独立的，各自维护各自的索引，也被称为本地索引。</p><p><strong>Partitioning Secondary Indexes by Term</strong></p><p>按术语划分二级索引</p><p><img src="https://s2.loli.net/2022/06/23/1K6k2lfeo5i8jbr.png"></p><p>与基于文档的方式相比，很容易看出，二级索引变成了全局索引。</p><p>但是也不能把索引全部放在一个分区上，会破坏分区的目的，也可能会成为性能的瓶颈。</p><h4 id="Rebalancing-Partitions"><a href="#Rebalancing-Partitions" class="headerlink" title="Rebalancing Partitions"></a>Rebalancing Partitions</h4><p>为什么我们需要对分区进行重平衡？</p><ul><li>查询吞吐量增加，需要添加 CPU 应对高负载。</li><li>数据规模增长，需要添加磁盘和 RAM 存储。</li><li>机器宕机的时候，其他的机器需要接管失败的机器。</li></ul><p><em>rebalancing</em> 的过程就是，将集群中一个节点负载转移到另一个。</p><p>期望 <em>rebalancing</em> 达到什么目的？</p><ul><li>在重平衡之后，负载能够均匀的分布在集群的节点上。</li><li>即发生了 rebalancing，也可以正常处理读、写请求。</li><li>不应该在节点间移动不必要的数据，快速重新平衡并最小化网络和磁盘 I/O 负载。</li></ul><p><strong>重平衡的策略</strong></p><p><em>hash mod N</em></p><p>对 N 取模带来的问题是，如果 node 数量 N 变化了，大多数 key 都需要从原 node 移动到另一个 node。</p><p><em>固定数量的 partitions</em></p><p>这里采用了一种在 node 上创建比 node 数量更多分区的方法，比如 node 数量是 10，一个 node 上创建 100 个分区，这样总数就是 1000 个分区。</p><p>按照上述的分配，如果这是新加入了一个 node ，这个新的 node 从那 10 个 node 上 steal 几个分区过来，如下图。</p><p><img src="https://s2.loli.net/2022/06/23/2NsHbOV91EWfJ38.png"></p><p>分区编号不会改变，分区中的 key 也不会改变。唯一改变的就是分区所在的 node，但是这个改变不是立即发生的，通过网络传输数据到另一个 node 需要花费很多时间。</p><p>这时，旧的分区在这个传输的过程中仍然用于处理读写请求。</p><p>这种模式在 ES 中有使用到。</p><p>一般是怎么确定固定数量的分区的数量呢？</p><ul><li>the number of partitions configured at the outset is the maximum number of nodes you can have</li></ul><blockquote><p>管理分区也是有开销的，所以选择了一个非常高的分区数量时，可能会适得其反。</p></blockquote><p><em>动态 partitions</em></p><p>大的会拆成小的，太小了会合并成一个。</p><p>动态分区的好处</p><ul><li>分区的数量可以适应数据的变化。</li></ul><blockquote><p>空的数据库会以一个唯一的分区开始，这时所有的读写操作只操作一个分区，直到达到了需要拆分的阈值。</p></blockquote><p><strong>Partitioning proportinally to nodes</strong></p><p><strong>自动或手动进行重平衡</strong></p><p>自动会很方便，运维只需要做很少的操作就能达到维护的目的。但是自动重平衡是不可预测的。</p><p>当自动重平衡和故障检测结合使用时会更加危险，比如某个 node 负载比较高，会时不时出现响应慢的问题。这时其他节点要是判定这个 node 崩溃了，开启了自动重平衡，这不是我们期待的结果。</p><p>所以，手动的可能没有自动的那么方便，但是可以阻止一些额外的问题。</p><h4 id="请求路由"><a href="#请求路由" class="headerlink" title="请求路由"></a>请求路由</h4><p>常见的三种方式：</p><ul><li>直接访问一个node 如果有就返回，没有就找下一个node</li><li>通过路由的方式，在 client 和 node 中间套一层。</li><li>第三种需要客户端进行配合，客户端对哪些分区存储了哪些key是有感知的。</li></ul><p><img src="https://s2.loli.net/2022/06/23/FUslPBcKGLAHT2R.png"></p><p>另一种方式为，分布式系统以来一个独立的服务，比如 ZooKeeper 来跟踪集群中的元数据。</p><p><img src="https://s2.loli.net/2022/06/23/WwbyJRN1YHX2eSp.png"></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>这章讲了几种将数据库拆成分区的方法，不过针对的好像都是 key-value 类型的数据库。</p><p>分区的目的：<strong>将数据和查询的负载更均匀的分配到多台机器上</strong></p><p>两种分区的方法：</p><ul><li>key range 的分区方法，将 key 排序后进行存储的一个好处是，支持更高效的范围查询，同时也会带来一种风险，就是 hot spot 的问题。这种分区方式通常结合<strong>动态分区</strong>进行使用，在达到某个阈值的时候进行分区的拆分。</li><li>hash 分区，通过散列函数将数据更均匀的分布在多台机器上。虽然损失了高效的范围查询，但是给我们带来了更均匀的数据分布和负载均衡。hash 分区的方式通常结合<strong>固定数量</strong>的分区进行使用。</li></ul><p><em>分区和二级索引</em>的结合</p><ul><li>基于文档的，也叫 local index</li><li>基于术语的，也叫 global index</li></ul><h2 id="Ch7：Transactions"><a href="#Ch7：Transactions" class="headerlink" title="Ch7：Transactions"></a>Ch7：Transactions</h2><p>循序渐进，介绍了一些会导致数据系统出错的几个问题</p><ul><li>数据库软件或者硬件可能会随时出错，也包括在写操作执行一般的过程中</li><li>应用可能会随时崩溃，包括一些逻辑只执行了一半</li><li>网络的不可靠，切断了应用和数据库之间的关系</li><li>客户端之间的并发操作</li><li>客户端可能读取到了无意义的数据（脏数据）</li></ul><p><strong>事务</strong></p><p>事务是简化上述问题的一种机制。<strong>事务是应用程序将多个读取和写入组合成一个逻辑单元的一种方式。</strong></p><p>概念上，所有的读写操作在一个事务中被看成是一个操作，要么整个事务成功（commit），要么全部失败（abort, rollback）。</p><p>这下我就有点明白了，总说的分布式事务是什么意思，比如一个写请求，需要多个服务进行协调，为了保证数据的可靠性，要么所有的服务都响应成功，要么就都失败。</p><h4 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h4><p>atomicity 原子性</p><p>consistency 一致性</p><p>isolation 隔离性</p><p>durability 持久性</p><p>是数据库中的容错机制建立精确的术语</p><p><strong>Atomicity</strong></p><p>atomic 这个词通常代表的意思是，一个不可再分的操作。</p><p>在计算机中，代表着一些其他的意思，比如多线程环境下，某个线程修改了某个值，由 1 改成 2，这时候其他线程是看不到的，其他线程看到的仍然是 1。</p><p><strong>但是在 ACID 中</strong>，A 代表的意思是和并发没有任何关系的！像上述这种问题，在 ACID 中 I isolation 中覆盖了这样的场景。</p><p>Atomicity 描述了如果客户端想要请求多个写操作，但是在一部分写操作执行完成后发生了错误。如果多个写操作聚合到一个 atomic 事务中，就说明这个事务是由于错误未完成的，然后这个事务就可以进行回滚，数据库必须忽略和恢复写入成功的值。</p><p><strong>发生错误时，有回滚事务的能力，并且这个事务中的所有写操作都应该被忽略。</strong>这是 ACID 中 A 的定义。</p><p>作者提到 abortability（可回滚能力）可能更适合这个 A。</p><p><strong>Consitency</strong></p><p>ACID中的一致性的主要是指对数据有特定的预期状态， 任何数据更改必须满足这些状态约束（或者恒等条件）。</p><blockquote><p>说实话，这句话有点难懂。。原文是这样的 <code>The idea of ACID consistency is that you have certain statements about your data (invariants) that must always be true</code></p></blockquote><p>关于一致性的描述确实很模糊，看完知乎上这个回答清晰了很多。</p><p><img src="E:/resource/myInfo/blogRes/images-master/blogpics/image-20220218100501876.png"></p><p><strong>通常，应用程序会依赖数据库的 A 和 I 来实现 C</strong></p><p><strong>Isolation</strong></p><p><img src="https://s2.loli.net/2022/06/23/P5oRqwhxXcZWnuT.png">这个就有点和一开始说的 atomic 并发访问类似了。</p><p><strong>Durability</strong></p><p>数据库系统的目的就是提供一个安全的地方，可以用来存放数据，并且不需要担心数据的丢失。</p><p>单节点中，持久性意味着数据成功的写入了。master - slave 中，意味着副本中的数据也成功写入了。</p><p>完美的持久性其实并不存在，如果存储数据的磁盘和存储副本数据的磁盘都坏了，这也是一种情况。</p><h4 id="单对象与多对象事务操作"><a href="#单对象与多对象事务操作" class="headerlink" title="单对象与多对象事务操作"></a>单对象与多对象事务操作</h4><p><img src="https://s2.loli.net/2022/06/23/2yncBqfrW1Ie6EU.png"></p><p>如果没有隔离性，user2 会看到一种非常诡异的现象，就是有未读邮件，但是未读邮件的数量显示为 0。</p><p><img src="https://s2.loli.net/2022/06/23/BzUa3sCGQqlfXxk.png"></p><p>如果没有原子性，这时候未读邮件和未读数量的显示就不一致了。这种情况下，第二个更新数量的操作失败了，那么第一个插入未读邮件的操作是需要回滚的。</p><p><strong>多对象事务的需求</strong></p><p>主要还是为了事务的  A 和 I</p><p><strong>错误处理和驳回</strong></p><p>事务一个非常重要的特点：当错误发生的时候，可以进行驳回（忽略已修改的内容）并且安全的重试。</p><p>ACID 的哲学：<strong>如果数据库违背了 AID ，那还不如摒弃 AID，这样也比把数据搞成半截子强。</strong></p><p>重试事务也会有很多问题：</p><ul><li>比如事务执行成功了，但是 commit 未返回给客户端，此时客户端会认为这个事务是失败的，这样就会导致事务执行多次。。除非有一种去重的机制。。</li><li>如果事务执行失败是由于过载导致，那么事务的重试会加重负载。这种情况下可以添加重试次数的限制。</li><li>只有在”可控的“错误发生时，事务重试才有意义。如果这个事务中本身就有错误，那么怎么重试都是无意义的。（这句话是我自己理解的）</li><li>如果事务的执行存在数据库之外的副作用，那么即使事务被驳回了，副作用仍然会发生。作者举了一个例子，特别好！如果这个事务的执行伴随着发送邮件，那么重试的时候仍然会发送邮件。。</li></ul><h4 id="弱隔离级别"><a href="#弱隔离级别" class="headerlink" title="弱隔离级别"></a>弱隔离级别</h4><h5 id="Read-committed"><a href="#Read-committed" class="headerlink" title="Read committed"></a>Read committed</h5><p>读提交是最基础的事务隔离级别，提供了两种保障：</p><ul><li>当从数据库读的时候，只能读到已经被 committed 的内容。<strong>No dirty reads</strong></li><li>当写操作发生时，只有在事务 committed 的时候，才会覆盖原数据。<strong>No dirty writes</strong></li></ul><p><strong>No dirty reads</strong></p><p>dirty reads （脏读）如果一个事务对数据库中的内容进行了修改，但是事务还没提交，这时候另一个事务要是读到了未提交的数据，称这种情况未脏读。</p><p>读提交的事务隔离级别，<strong>必须阻止脏读</strong>，意味着所有的写操作只有在 committed 后才能被看到，如下图：</p><p><img src="https://s2.loli.net/2022/06/23/a6pN7lZYxej2O5c.png"></p><p><strong>No dirty writes</strong></p><p>dirty writes （脏写）如果一个未提交的事务修改的内容，被另一个事务覆盖了，这种情况称为脏写。</p><p><img src="https://s2.loli.net/2022/06/23/8HPdxRcOYFwkts1.png"></p><h4 id="实现读提交隔离级别"><a href="#实现读提交隔离级别" class="headerlink" title="实现读提交隔离级别"></a>实现读提交隔离级别</h4><p>写 ： 大多数情况，数据库实现读提交隔离级别都是通过<strong>行级别</strong>的锁来实现的，如果某个事务想修改某个值，一定要先获取锁。</p><p>读 ： 要是不想脏读，也可以通过行级锁实现，但是可能会出现一个写事务，阻塞非常多的读事务。更普遍的方式是，通过上边的 7-4 图中那样的方法。</p><h4 id="Snapshot-Isolation-and-Repeatable-Read"><a href="#Snapshot-Isolation-and-Repeatable-Read" class="headerlink" title="Snapshot Isolation and Repeatable Read"></a>Snapshot Isolation and Repeatable Read</h4><p>快照隔离和可重复读。</p><p>读提交中存在的问题：</p><p><img src="https://gitee.com/yangbaoqiang/images/raw/master/blogpics/image-20220221151207197.png" alt="image-20220221151207197"></p><p>这个账户有 1000 ，分成两个账户，每个中有 500。这个用户账上发生了一笔交易，从一个账户转移到另一个账户 100。</p><p>两个事务，一个读的，一个写。她查询第一个账户是 500，但是读提交的事务只有在整个事务 commit 后才能被看到，所以在事务提交后，她再次查账户是 400，但是她本来是 1000 块钱，那 100 就莫名其妙消失了。。</p><p><strong>快照隔离的一个关键原则是：读不会阻塞写，写不会阻塞读</strong></p><p><strong>MVCC</strong></p><p>数据库必须保存某个对象的多个不同提交版本，因为不同的进行中事务需要在不同时间看到不同的数据库状态。<em>因为在同一时刻保存了某个对象的多个版本，这个技术被称为 MVCC</em></p><p><strong>快照隔离的实现</strong></p><p>当事务开始的时候，会给每个事务一个唯一且自增的事务 ID。</p><p><img src="https://s2.loli.net/2022/06/23/G2OBu1VwpkaWLNI.png"></p><p>如图所示，一个更新操作在内部被拆分成了删除和插入。事务13 要更新账户 1  的余额，把 created by = 3 的删除，插入了一条新的。</p><p><strong>一致性快照的可见性规则</strong></p><p><em>事务 ID 决定了他可以看到哪些对象，哪些看不到</em></p><ul><li>在事务开始的时候，数据库会创建一个在那个时刻其他正在执行的但是还没有提交或驳回的事务列表。</li><li>被驳回事务的写操作会被忽略。</li><li>事务 ID 更大的写操作会被忽略掉，尽管这些事务被提交了。</li><li><strong>所有其他写入对应用程序的查询都是可见的。</strong></li></ul><p>在快照隔离中，如果一个对象是可见的，必须满足以下两个条件：</p><ul><li>在读事务开启的时候，在另一个事务中创建的对象已经 commit 了。</li><li>对象没有被标记为删除，如果被删除了，当读事务开启的时候，请求删除的事务还没有提交。</li></ul><p><strong>索引在快照隔离中是怎样工作的</strong></p><p>主要是讲了两种建立索引树的方式。</p><ul><li>append-only<ul><li>有写事务的时候，会从某个特定的根创建一颗新的索引树</li></ul></li><li>copy-on-write<ul><li>写时复制，针对当前 page 进行操作的，如果想要更新的话，并不会覆盖当前页的内容，而是创建当前页的一个副本。</li></ul></li></ul><p><strong>可重复读和命名混乱</strong></p><p>MySQL 中把快照隔离称为<strong>可重复读</strong></p><h4 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h4><p>一个事务中的写操作影响了另一个事务中的查询操作。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Designing Data-intensive Applications&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>第一次 pr</title>
    <link href="https://bqyang.top/2022/contributeToYunion/"/>
    <id>https://bqyang.top/2022/contributeToYunion/</id>
    <published>2022-06-23T10:30:51.728Z</published>
    <updated>2022-07-05T10:42:25.928Z</updated>
    
    <content type="html"><![CDATA[<p>所有工作时间加起来也有一年多快两年的时间了，实习了 8 个月，正式工作也有 10 个月了，加起来有一年半的工作经验了。事实一次又一次的证明了去大公司的必要性，就算没有办法去大公司，也要多接触在大厂上班的人，这就有点近朱者赤近墨者黑的意思。</p><span id="more"></span> <p>大厂程序员能接触的面实在是太多了，他们带给我的感受就好像，井底之蛙。每天我所接触到的东西只有那么一点，或者说工作所能涉及到内容，再多也不会多到哪去。久而久之，与人家的差距自然就被拉开了。</p><p>说了点废话，只想和大家共勉，一定要好好学习，曹大说了，混几个你所在工作的领域相关的 commit 哈哈，对自己来说简历上还是能挂得住的，我们公司用的代码是一套开源的云管理平台，据说是买的人家商业版，在人家代码基础上做的二次开发。</p><p>二次开发做的真的是惨不忍睹，没有把人家的代码研究明白就开始在上边迭代，导致现在的代码维护成本非常高，再加上这套代码本身就非常复杂，各种高度抽象，各种回调、异步任务。我入职有快四个月了，还是有很多不明白的地方。</p><p>上个周五，2021-11-19，那天调试一个bug，当时就是跟自己较真，过不去这个坎，觉得今天要是解决不了这个问题，真的是太没用了。。所以周五到家后，又一直研究，trace代码，最后还是找到了问题出现的地方，跟这些异步任务属实是费劲。可能自己对这个bug的偏执，也说明了自己能力不足。</p><p>以前看到过一句话，不要对年轻人讲经验，他该走的弯路一个不会少。我其实是认同的，虽然在某些时候，前辈们的经验可以帮助我们减轻一些心理负担，但是真正需要自己站出来的时候，一个弯路都不会少的。</p><p>这次排查 bug 给我带来的收获，不仅仅是一个提 pr 的机会，更是一次开拓眼界的机会，或许也是迈向开源的一个机会。</p><p>贴上两张提 pr 的图片吧哈哈，相关的 reviewer 还没有 review 代码，希望可以顺利的被 merge！</p><p><img src="https://s2.loli.net/2022/06/23/eDXpEfKIgz3L95O.png"></p><p><img src="https://s2.loli.net/2022/06/23/76oCUmlOBHQJ25y.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;所有工作时间加起来也有一年多快两年的时间了，实习了 8 个月，正式工作也有 10 个月了，加起来有一年半的工作经验了。事实一次又一次的证明了去大公司的必要性，就算没有办法去大公司，也要多接触在大厂上班的人，这就有点近朱者赤近墨者黑的意思。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>根管治疗+全瓷冠</title>
    <link href="https://bqyang.top/2022/summary/about-0602/"/>
    <id>https://bqyang.top/2022/summary/about-0602/</id>
    <published>2022-06-23T10:30:51.724Z</published>
    <updated>2022-06-02T03:46:31.733Z</updated>
    
    <content type="html"><![CDATA[<p>从小就是牙口不好，小时候家里对这方面也没有过多关注过，自己也不注重口腔健康，当时爽了，现在完蛋了。</p><p>不仅钱花得多，还非常的折腾。</p><p>我是清明节回家补了一颗龋齿（蛀牙），那天补牙的时候，突然有一下特别疼（就是那个感觉一瞬间就布遍全身，我感觉不咋疼），医生在那一顿叹气，哎呀，露神经了，这就不好弄了。</p><span id="more"></span><p>就是龋齿太深了，已经到牙神经部分了，当时医生没有做过多的处理，问我是要盖上还是直接补，当时我也不明白啥意思，反正最后是听了医生的建议，直接补上了。</p><p>补上后感觉那个地方一直在跳动，别的感觉就没啥了，直到一个月后，就是四月底吧。那天吃午饭，明显的感觉咬到了像石子一样的东西，照镜子一看，补的那块牙掉了一块渣。</p><p>自打那天开始就一直疼，牙髓发炎了，但是当时上着班，而且也挂不上号，拖了两天没去。</p><blockquote><p>北京这边的医院挂号真的好复杂啊，我当时抢北京大学口腔医院的号，抢了两天都没有。而且就算你挂上了也不是当天的号，都是 N + 1 或者 N + 2 的这种。</p></blockquote><p>然后选了一个二甲的保底，挂到了某个首都医科大学附属的三甲医院。</p><p>去了那天就做了牙髓失活术（先打麻药，然后应该是往里放了点什么药），整个人感觉活过来了一样，完全没感觉了。</p><p>后续就是非常折腾，大概跑了 6 次，期间还因为政策原因推迟了很久。</p><p>这周一是最后一次去，把牙冠戴上了， 医生只给了我两个选项，一个是 5000 的，另一个是 6500 的。因为我这个颗牙参与咀嚼比较多，我选了一个质量更好的一点的。</p><p>现在唯一的感觉就是那个对牙咬合不齐，总感觉这个地方比较高。</p><p>于是又约了医生下周一还得再跑一趟.. 另外把别的蛀牙补一下。</p><p>感谢医保报销，感谢公司的医疗保险。。确确实实感受到了医疗方面的保障..</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;从小就是牙口不好，小时候家里对这方面也没有过多关注过，自己也不注重口腔健康，当时爽了，现在完蛋了。&lt;/p&gt;
&lt;p&gt;不仅钱花得多，还非常的折腾。&lt;/p&gt;
&lt;p&gt;我是清明节回家补了一颗龋齿（蛀牙），那天补牙的时候，突然有一下特别疼（就是那个感觉一瞬间就布遍全身，我感觉不咋疼），医生在那一顿叹气，哎呀，露神经了，这就不好弄了。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>关于 rpc 的那些事（一）</title>
    <link href="https://bqyang.top/2022/rpc/about-rpc-1/"/>
    <id>https://bqyang.top/2022/rpc/about-rpc-1/</id>
    <published>2022-06-23T10:30:51.721Z</published>
    <updated>2022-06-26T08:47:03.882Z</updated>
    
    <content type="html"><![CDATA[<p>该文是我学习 <code>rpc</code> 过程中的总结，初步了解到一个 <code>rpc </code> 框架是做什么的，以及为什么我们要使用 <code>rpc </code> 框架。结合当前工作中遇到的场景，对比思考。</p><p><img src="https://s2.loli.net/2022/06/22/8kZFXOu7yo6nfLJ.png"></p><span id="more"></span><h2 id="我遇到的"><a href="#我遇到的" class="headerlink" title="我遇到的"></a>我遇到的</h2><p>我们现在的后端服务，跑的是一套开源的云管代码 [<a href="https://github.com/yunionio/cloudpods">在这里</a>]，据不可靠消息透露，这套框架的源头是美团搞得，一开始貌似用的 Java 代码，后来用 Go 重写了。</p><p>八卦了一下，言归正传，这套代码主要由 keystone / apigateway / region / scheduler 组成，简单概述下他们的职责。</p><ol><li>keystone 负责认证。</li><li>apigateway 负责路由转发。</li><li>region 负责实际的业务逻辑。</li><li>scheduler 负责调度，根据库里数据选择某个最优解。</li></ol><p><strong>网络请求是怎么进行流转的呢？</strong></p><p>认证我们抛开不说，假设以下内容都是认证完成后的。</p><p>认证完成后，用户需要创建云主机，从页面点击创建后，请求走到 <code>apigateway</code>，<code>apigateway</code> 分析请求路径，找到对应的 <code>model</code>，进行路由转发，请求 <code>region</code>，<code>region</code> 处理完成后，返回给 <code>apigateway</code>，<code>apigateway</code> 拿到响应后返回给客户结果。</p><p><strong>这里是怎么拿到另一个服务的地址呢？</strong></p><p>将所有服务信息存储在 endpoint 表中，然后根据请求的相关信息拿到对应的 url，再把 path 拼上。</p><p>这个其实不重要，我最好奇的就是，新加了一些路由之后，<code>apigateway</code> 怎么感知呢？</p><p>调试代码后发现，<code>region</code> 服务和 <code>apigateway</code> 服务存在着某些程度上的耦合，我们在 <code>region</code> 中添加路由后，必须要“同步”给网关。在网关中添加个文件，如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    Disks modulebase.ResourceManager</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Disks = modules.NewComputeManager(</span><br><span class="line">        <span class="string">&quot;disk&quot;</span>,</span><br><span class="line">        <span class="string">&quot;disks&quot;</span>,</span><br><span class="line">        []<span class="keyword">string</span>&#123;<span class="string">&quot;ID&quot;</span>, <span class="string">&quot;Name&quot;</span>, <span class="string">&quot;Billing_type&quot;</span>,</span><br><span class="line">                 <span class="string">&quot;Guest_id&quot;</span>, <span class="string">&quot;Created_at&quot;</span>&#125;,</span><br><span class="line">        []<span class="keyword">string</span>&#123;<span class="string">&quot;Storage&quot;</span>, <span class="string">&quot;Tenant&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line">    modules.RegisterCompute(&amp;Disks)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这种方式，注册到全局变量中，后续根据请求的路径查询对应的模块。</p><blockquote><p>值得一提的是，<code>apigateway</code> 中使用的是正则路由。这样就可以根据请求方法进行抽象，所有的 Get 请求走的都是同一个 handler，其他也类似。</p></blockquote><p>所以，我们每次写新功能的时候都需要额外重启网关服务，个人感觉不是那么的优雅。</p><p>那么问题来了，rpc 能否解决这个问题？我写这篇文章的时候并不知道答案。</p><h2 id="rpc-是什么呢？"><a href="#rpc-是什么呢？" class="headerlink" title="rpc 是什么呢？"></a>rpc 是什么呢？</h2><p>虽然没用过微服务，但是听的耳朵都要起茧子了。这玩意应该没那么普及吧..</p><p>我认为 rpc 框架主要解决的是服务间调用的问题，如果每个接口都使用注册 handler 的方式实现，这个工作量很大并且很难维护。正如 rpc 名字的意思，调用远程接口和调用本地函数一样，rpc 框架封装了这些细节。</p><p>另一方面，grpc 通信摒弃了常规的序列化方式，《DDIA》 中有讲到几种压缩方式的对比。</p><p>看一个简单的例子就知道这个调用过程大致长什么样了，例子来自 [<a href="https://github.com/grpc/grpc-go/tree/master/examples/helloworld">grpc-go</a> ]</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// client</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    flag.Parse()</span><br><span class="line">    <span class="comment">// Set up a connection to the server.</span></span><br><span class="line">    conn, err := grpc.Dial(*addr, grpc.WithTransportCredentials(insecure.NewCredentials()))</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">&quot;did not connect: %v&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> conn.Close()</span><br><span class="line">    c := pb.NewGreeterClient(conn)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Contact the server and print out its response.</span></span><br><span class="line">    ctx, cancel := context.WithTimeout(context.Background(), time.Second)</span><br><span class="line">    <span class="keyword">defer</span> cancel()</span><br><span class="line">    r, err := c.SayHello(ctx, &amp;pb.HelloRequest&#123;Name: *name&#125;)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">&quot;could not greet: %v&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    log.Printf(<span class="string">&quot;Greeting: %s&quot;</span>, r.GetMessage())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// server</span></span><br><span class="line"><span class="comment">// server is used to implement helloworld.GreeterServer.</span></span><br><span class="line"><span class="keyword">type</span> server <span class="keyword">struct</span> &#123;</span><br><span class="line">    pb.UnimplementedGreeterServer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SayHello implements helloworld.GreeterServer</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *server)</span> <span class="title">SayHello</span><span class="params">(ctx context.Context, in *pb.HelloRequest)</span> <span class="params">(*pb.HelloReply, error)</span></span> &#123;</span><br><span class="line">    log.Printf(<span class="string">&quot;Received: %v&quot;</span>, in.GetName())</span><br><span class="line">    <span class="keyword">return</span> &amp;pb.HelloReply&#123;Message: <span class="string">&quot;Hello &quot;</span> + in.GetName()&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    flag.Parse()</span><br><span class="line">    lis, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, fmt.Sprintf(<span class="string">&quot;:%d&quot;</span>, *port))</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">&quot;failed to listen: %v&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    s := grpc.NewServer()</span><br><span class="line">    pb.RegisterGreeterServer(s, &amp;server&#123;&#125;)</span><br><span class="line">    log.Printf(<span class="string">&quot;server listening at %v&quot;</span>, lis.Addr())</span><br><span class="line">    <span class="keyword">if</span> err := s.Serve(lis); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">&quot;failed to serve: %v&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，我们在客户端通过调用函数的方式就实现了对服务端的调用。但是，重点也不是这些，这些内容大部分是通过 <code>.proto</code> 文件生成的，我们只是实现了相应的接口。</p><h2 id="proto-文件"><a href="#proto-文件" class="headerlink" title=".proto 文件"></a>.proto 文件</h2><p>生成 <code>.pb.go | _grpc.pb.go</code> 命令：</p><p><code> protoc --go_out=. --go_opt=paths=source_relative  --go-grpc_out=.  --go-grpc_opt=paths=source_relative .\forGen.proto</code></p><p>Google 官网的解释 [<a href="https://developers.google.com/protocol-buffers/docs/gotutorial">在这里</a>]，常用的几种数据类型：</p><ul><li>repeated</li><li>map&lt;string, int&gt;</li><li>oneof 结构体里面套了一个接口</li><li>单个结构体类型，<code>message Foo &#123;&#125;</code> </li></ul><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">message FooRepeated &#123;</span><br><span class="line">    <span class="comment">// []string</span></span><br><span class="line">    repeated <span class="keyword">string</span> Address = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message FooMap &#123;</span><br><span class="line">    <span class="comment">// map[string]int32</span></span><br><span class="line">    <span class="keyword">map</span>&lt;<span class="keyword">string</span>, <span class="keyword">int32</span>&gt; info = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message FooOneof &#123;</span><br><span class="line">    <span class="comment">// struct &#123;interface&#123;&#125;&#125;</span></span><br><span class="line">    oneof avatar &#123;</span><br><span class="line">        <span class="keyword">string</span> image_url = <span class="number">1</span>;</span><br><span class="line">        bytes image_data = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="grpc-流"><a href="#grpc-流" class="headerlink" title="grpc 流"></a>grpc 流</h2><p>从文档中不难发现，grpc 支持流式数据传输，流式传输应对的是上传和下载大量数据的场景。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 双向流，stream指定启用流特性</span></span><br><span class="line">service HelloService &#123;</span><br><span class="line">    rpc Channel (stream Foo) returns (stream Foo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和普通的差别也不大，只是从直接接收参数变成了，读取连接里的内容。我们实现的 Channel 方法如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> HelloServiceImpl <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 这就好像，pb 插件给我们提供一个抽象类</span></span><br><span class="line">    <span class="comment">// 我们自己去实现具体的内容</span></span><br><span class="line">    pb.UnimplementedHelloServiceServer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *HelloServiceImpl)</span> <span class="title">Channel</span><span class="params">(stream pb.HelloService_ChannelServer)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// 读取连接中的内容，</span></span><br><span class="line">        <span class="comment">// 读出来的最小单位就是我们在 service 中定义的</span></span><br><span class="line">        args, err := stream.Recv()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 输出从客户端都到的东西</span></span><br><span class="line">        fmt.Println(args.GetName())</span><br><span class="line">        reply := &amp;pb.Foo&#123;Name: args.GetName()&#125;</span><br><span class="line"></span><br><span class="line">        err = stream.Send(reply)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其余 server 端的代码类似，注册函数，启动服务。这里看下 client 实现：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">conn, err := grpc.Dial(<span class="string">&quot;:1234&quot;</span>, grpc.WithTransportCredentials(insecure.NewCredentials()))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br><span class="line"></span><br><span class="line">client := pb.NewHelloServiceClient(conn)</span><br><span class="line">s, err := client.Channel(context.Background())</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="comment">// 每隔一秒给 server 发个消息</span></span><br><span class="line">    err := s.Send(&amp;pb.Foo&#123;Name: <span class="string">&quot;bqyang-test&quot;</span>&#125;)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样既可实现 grpc 以流的方式通信。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>那么我们是否可以通过 rpc 的方式重写那个框架中的内容呢？答案是肯定的，可以通过基于HTTP的 rpc 服务，但是貌似仍然解决不了两个服务都重启的问题，而且维护路由的成本更高了。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AServer</span><span class="params">()</span></span> &#123;</span><br><span class="line">    rpc.RegisterName(<span class="string">&quot;HelloService&quot;</span>, <span class="built_in">new</span>(HelloService))</span><br><span class="line">    http.HandleFunc(<span class="string">&quot;/hello&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span>&#123;</span><br><span class="line">        <span class="keyword">var</span> conn io.ReadWriteCloser = <span class="keyword">struct</span> &#123;</span><br><span class="line">            io.Writer</span><br><span class="line">            io.ReadCloser</span><br><span class="line">        &#125; &#123;</span><br><span class="line">            Writer: w, </span><br><span class="line">            ReadCloser: r.Body,</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        rpc.ServeRequest(jsonrpc.NewServerCodec(conn))</span><br><span class="line">    &#125;)</span><br><span class="line">    http.ListenAndServe(<span class="string">&quot;:1234&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有没有更优解呢？或许可以通过服务发现进行实现，下篇文章的内容有了，了解下服务发现。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;该文是我学习 &lt;code&gt;rpc&lt;/code&gt; 过程中的总结，初步了解到一个 &lt;code&gt;rpc &lt;/code&gt; 框架是做什么的，以及为什么我们要使用 &lt;code&gt;rpc &lt;/code&gt; 框架。结合当前工作中遇到的场景，对比思考。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2022/06/22/8kZFXOu7yo6nfLJ.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>golang 中的抢占</title>
    <link href="https://bqyang.top/2022/language/golang/preemptSchedule/"/>
    <id>https://bqyang.top/2022/language/golang/preemptSchedule/</id>
    <published>2022-06-23T10:30:51.696Z</published>
    <updated>2022-06-04T07:37:40.468Z</updated>
    
    <content type="html"><![CDATA[<p>关于 go 1.13 协作式抢占的一点理解</p><span id="more"></span><p>基于协作式的抢占，要 goroutine 进行配合，在 G 执行的函数中添加栈的边界检查。</p><p>我一开始有一点没想明白，假设有个 G 正在 P 上执行，但是呢，抢占条件的检测是 false 不需要抢占，执行几行代码后，我又想抢占了。这时候怎么办？</p><p>需要知道的是，协作式一定需要 goroutine 进行配合，配合的意思就是：一定是栈边界检查为true。执行完第一个条件检查不要紧，你会发现只要是函数调用的地方（你的代码，println 也会检查）基本上都加入了栈边界检查。尽最大努力进行抢占。</p><p>如果说整个函数就一个简单的运算，没有别的任何函数调用，如果第一次边界检查为 false，后续想抢占应该也是不行的，只能等当前的 G 主动退出。</p><p>最近时间都花在 GC 上了，GC 和抢占的内容紧密关联。因为 STW 的时候就需要进行抢占，把 P 上执行的 G 都给挂起。</p><p>// TODO 立个 flag 一定把协作式抢占与基于信号的抢占整理出来。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;关于 go 1.13 协作式抢占的一点理解&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>go generic</title>
    <link href="https://bqyang.top/2022/language/golang/go-generic/"/>
    <id>https://bqyang.top/2022/language/golang/go-generic/</id>
    <published>2022-06-23T10:30:51.695Z</published>
    <updated>2022-06-24T12:47:08.644Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2022/06/06/LNYfsvCZwxeh3l9.png"></p><p>go 泛型学习，距离泛型的发布已经有很长一段时间了，之前大概看了下官方文档，说有些东西可能将来都会改变，不保证向前兼容，就没有具体了解，1.18也发了几个版本了，感觉再不努力又要被小伙伴们卷完了。</p><span id="more"></span><h2 id="困扰"><a href="#困扰" class="headerlink" title="困扰"></a>困扰</h2><p>没有泛型的时候带给我们的困扰（虽然没有亲身体会过，但是感觉很麻烦）</p><h3 id="Case-1"><a href="#Case-1" class="headerlink" title="Case 1"></a>Case 1</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Sum returns the sum of the provided arguments.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sum</span><span class="params">(args ...<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> sum <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(args); i++ &#123;</span><br><span class="line">        sum += args[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要计算 n 数之和，如上述例子，如果这时要计算 int32, float64 类型元素的和呢？</p><p>通常情况下，我们需要进行 asserting type，或者为每种类型写不同的函数 <code>sumInt</code> <code>sumInt32</code> <code>sumInt64</code> 等，在源码中就有类似的代码。</p><h3 id="Case-2"><a href="#Case-2" class="headerlink" title="Case 2"></a>Case 2</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Declare &quot;host&quot; and &quot;port&quot; in order to create pointers to satisfy the</span></span><br><span class="line">    <span class="comment">// fields in the &quot;request&quot; struct.</span></span><br><span class="line">    host, port := <span class="string">&quot;local&quot;</span>, <span class="number">80</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(request&#123;</span><br><span class="line">        host: &amp;host,</span><br><span class="line">        port: &amp;port,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>This leads to cluttered, hard-to-read code where the only purpose variables serve is for deriving pointers.</p></blockquote><p>对每个变量进行取址操作，<em>我之前就写过这样的代码</em> ，为了取址不得不声明一个变量。</p><p>针对这种情况，可以实现不同的函数进行取址操作。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// PtrInt returns *i.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PtrInt</span><span class="params">(i <span class="keyword">int</span>)</span> *<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PtrStr returns *s.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PtrStr</span><span class="params">(s <span class="keyword">string</span>)</span> *<span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Use the two helper functions that return pointers to their provided</span></span><br><span class="line">    <span class="comment">// values. Remember, this pattern must scale with the number of distinct,</span></span><br><span class="line">    <span class="comment">// defined types that need to be passed by pointer instead of value.</span></span><br><span class="line">    <span class="built_in">print</span>(request&#123;</span><br><span class="line">        host: PtrStr(<span class="string">&quot;local&quot;</span>),</span><br><span class="line">        port: PtrInt(<span class="number">80</span>),</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看起来可能比上边的优雅了一些，但是还不够，我们看下泛型。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Ptr returns *value.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Ptr</span>[<span class="title">T</span> <span class="title">any</span>]<span class="params">(value T)</span> *<span class="title">T</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// No local variables and the typed helper functions can be collapsed into</span></span><br><span class="line">    <span class="comment">// a single, generic function for getting a pointer to a value.</span></span><br><span class="line">    <span class="built_in">print</span>(request&#123;</span><br><span class="line">        host: Ptr(<span class="string">&quot;local&quot;</span>),</span><br><span class="line">        port: Ptr(<span class="number">80</span>),</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一方面是代码量减少了很多，另一方看是看起来更整洁。</p><h2 id="generic-语法"><a href="#generic-语法" class="headerlink" title="generic 语法"></a>generic 语法</h2><p>使用 <em>泛型</em> 重写这段代码</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Sum returns the sum of the provided arguments.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sum</span><span class="params">(args ...<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> sum <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(args); i++ &#123;</span><br><span class="line">        sum += args[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>泛型版本：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sum</span>[<span class="title">T</span> <span class="title">int</span>]<span class="params">(args ...T)</span> <span class="title">T</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> sum T</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(args); i++ &#123;</span><br><span class="line">        sum += args[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>[]</code> 是用来定义泛型的，常用的模式为 <code>[&lt;ID&gt; &lt;CONSTRAINT&gt;]</code></p><ul><li><code>&lt;ID&gt;</code> 是用来表示泛型的符号；</li><li><code>&lt;CONSTRAINT&gt;</code> 约束，表明可使用的具体类型，如上，只能使用 int；</li></ul><p>但是这时候我们想支持 int64 类型的 n 数和应该怎么办？</p><h3 id="Constraint"><a href="#Constraint" class="headerlink" title="Constraint"></a>Constraint</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sum</span>[<span class="title">T</span> <span class="title">int</span>|<span class="title">int64</span>]<span class="params">(args ...T)</span> <span class="title">T</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> sum T</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(args); i++ &#123;</span><br><span class="line">        sum += args[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>|</code> 运算符，这时，T 就可以满足 int 或者 int64，至于为什么使用 <code>|</code> 运算符不做过多考究。</p><p>但是这时还有一个小问题，如果说要支持更多的类型应该怎么做？难道要 <code>int|int32|int64</code> ? go 也给我们提供了相应的语法。</p><h4 id="any-constraint"><a href="#any-constraint" class="headerlink" title="any constraint"></a><code>any</code> constraint</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sum_any.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sum</span>[<span class="title">T</span> <span class="title">any</span>]<span class="params">(args ...T)</span> <span class="title">T</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> sum T</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(args); i++ &#123;</span><br><span class="line">        sum += args[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(Sum([]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;...))</span><br><span class="line">    fmt.Println(Sum([]<span class="keyword">int8</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;...))</span><br><span class="line">    fmt.Println(Sum([]<span class="keyword">uint32</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;...))</span><br><span class="line">    fmt.Println(Sum([]<span class="keyword">float64</span>&#123;<span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>&#125;...))      </span><br><span class="line">    fmt.Println(Sum([]<span class="keyword">complex128</span>&#123;<span class="number">1.1i</span>, <span class="number">2.2i</span>, <span class="number">3.3i</span>&#125;...))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>去执行试下，会意外的发现使用 <code>any</code> 其实行不通，原因是啥呢？</p><blockquote><p>./sum_any.go:11:3: invalid operation: operator + not defined on sum (variable of type T constrained by any)</p></blockquote><p> <code>+</code> 运算符并不是对所有的类型都生效。</p><p>既然这样，我们是不是可以声明一个东西，限定只能输数字类型的参数呢？</p><h4 id="Composite-constraints"><a href="#Composite-constraints" class="headerlink" title="Composite constraints"></a>Composite constraints</h4><p>复合类型</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Numeric expresses a type constraint satisfied by any numeric type.</span></span><br><span class="line"><span class="keyword">type</span> Numeric <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="keyword">uint</span> | <span class="keyword">uint8</span> | <span class="keyword">uint16</span> | <span class="keyword">uint32</span> | <span class="keyword">uint64</span> |</span><br><span class="line">    <span class="keyword">int</span> | <span class="keyword">int8</span> | <span class="keyword">int16</span> | <span class="keyword">int32</span> | <span class="keyword">int64</span> |</span><br><span class="line">    <span class="keyword">float32</span> | <span class="keyword">float64</span> |</span><br><span class="line">    <span class="keyword">complex64</span> | <span class="keyword">complex128</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sum returns the sum of the provided arguments.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sum</span>[<span class="title">T</span> <span class="title">Numeric</span>]<span class="params">(args ...T)</span> <span class="title">T</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> sum T</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(args); i++ &#123;</span><br><span class="line">        sum += args[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面这种情况如何处理？</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// id is a new type definition for an int64</span></span><br><span class="line"><span class="keyword">type</span> id <span class="keyword">int64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(Sum([]id&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;...))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们给 int64 起了个别名，这时候编译就会报错了，那我们应该怎样去识别别名呢？</p><h4 id="Tilde"><a href="#Tilde" class="headerlink" title="Tilde ~"></a>Tilde <code>~</code></h4><p>波浪号就是干这个事情的，举个例子，<code>~int</code> 表示：</p><ul><li>内置的 int 类型</li><li><code>type Integer int </code> 类型，起别名的类型</li></ul><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Numeric <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="keyword">uint</span> | <span class="keyword">uint8</span> | <span class="keyword">uint16</span> | <span class="keyword">uint32</span> | <span class="keyword">uint64</span> |</span><br><span class="line">    <span class="comment">// 调整如下</span></span><br><span class="line">    <span class="keyword">int</span> | <span class="keyword">int8</span> | <span class="keyword">int16</span> | <span class="keyword">int32</span> | ~<span class="keyword">int64</span> |</span><br><span class="line">    <span class="keyword">float32</span> | <span class="keyword">float64</span> |</span><br><span class="line">    <span class="keyword">complex64</span> | <span class="keyword">complex128</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Type-inference"><a href="#Type-inference" class="headerlink" title="Type inference"></a>Type inference</h3><ul><li><input disabled="" type="checkbox"> <a href="https://go.googlesource.com/proposal/+/refs/heads/master/design/43651-type-parameters.md">Type Parameters Proposal</a> 待阅读</li></ul><ul><li>Type inference is a convenience feature</li><li>The Go compiler tries <em>really</em> hard to infer the intended types, but it does not always work when you think it should</li><li>If you are not sure why something written generically is not working, try providing the types explicitly</li></ul><h3 id="Explicit-types"><a href="#Explicit-types" class="headerlink" title="Explicit types"></a>Explicit types</h3><p>显示指定类型</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(Sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line">    fmt.Println(Sum([]id&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;...))</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Generic types can be specified explicitly by invoking a function</span></span><br><span class="line">    <span class="comment">// with the bracket notation and the list of types to use. Because</span></span><br><span class="line">    <span class="comment">// the Sum function only has a single, generic type -- &quot;T&quot; -- the</span></span><br><span class="line">    <span class="comment">// call &quot;Sum[float64]&quot; means that &quot;T&quot; will be replaced by &quot;float64&quot;</span></span><br><span class="line">    <span class="comment">// when compiling the code. Since the values &quot;1&quot; and &quot;2&quot; can both</span></span><br><span class="line">    <span class="comment">// be treated as &quot;float64,&quot; the code is valid.</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// go 类型推断为 int 类型，但是后续出现了浮点数，导致失败。</span></span><br><span class="line">    <span class="comment">// 我们可以明确规定这个为 浮点数类型。</span></span><br><span class="line">    fmt.Println(Sum[<span class="keyword">float64</span>](<span class="number">1</span>, <span class="number">2</span>, <span class="number">3.0</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Multiple-generic-types"><a href="#Multiple-generic-types" class="headerlink" title="Multiple generic types"></a>Multiple generic types</h3><p>到这里为止，接触到的都是接收单一参数的函数，这里学习下怎么接收多个泛型参数。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// PrintIDAndSum prints the provided ID and sum of the given values to stdout.</span></span><br><span class="line"><span class="comment">// 应该还记得 ~ 的用法吧，适配类型别名</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PrintIDAndSum</span>[<span class="title">T</span> ~<span class="title">string</span>, <span class="title">K</span> <span class="title">Numeric</span>]<span class="params">(id T, sum SumFn[K], values ...K)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The format string uses &quot;%v&quot; to emit the sum since using &quot;%d&quot; would</span></span><br><span class="line">    <span class="comment">// be invalid if the value type was a float or complex variant.</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%s has a sum of %v\n&quot;</span>, id, sum(values...))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意</p></blockquote><p>在调用这个函数时仍需要显示指定 <code>sum</code> 的类型，<code>PrintIDAndSum(&quot;xx&quot;, Sum[int32], 1, 2, 3)</code> ，如果没有指定类型，就会报错：<code>./mulgen.go:12:22: cannot use generic function Sum without instantiation</code></p><h3 id="Declaring-a-new-instance-of-T-with-var"><a href="#Declaring-a-new-instance-of-T-with-var" class="headerlink" title="Declaring a new instance of T with var"></a>Declaring a new instance of <code>T</code> with <code>var</code></h3><p>这里跟在上述 sum 中声明变量没什么区别。</p><h3 id="Declaring-a-new-instance-of-T-with-new"><a href="#Declaring-a-new-instance-of-T-with-new" class="headerlink" title="Declaring a new instance of T with new"></a>Declaring a new instance of <code>T</code> with <code>new</code></h3><p>new 之后的变量会被分配地址，不再是 nil。</p><h3 id="Structs"><a href="#Structs" class="headerlink" title="Structs"></a>Structs</h3><p>将泛型和结构体结合使用，不难看出语法上和函数定义大差不差。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Ledger[T ~<span class="keyword">string</span>, K Numeric] <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID T</span><br><span class="line">    Amounts []k</span><br><span class="line">    SumFnSumFn[K]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为泛型结构体添加方法，正因为结构体中有泛型，所以在声明方法时也要导入<strong>相应的符号，约束不需要</strong>，因为是为了类型推断使用。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l Ledger[T, K])</span> <span class="title">PrintIDAndSum</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%s has a sum of %v\n&quot;</span>, l.ID, l.SumFn(l.Amounts...))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单示例：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// generic struct</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Numeric <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> | <span class="keyword">int32</span> | <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Ledger[T ~<span class="keyword">string</span>, K Numeric] <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID T</span><br><span class="line">    Amounts []K</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l Ledger[T, K])</span> <span class="title">PrintA</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(l.ID)</span><br><span class="line">    <span class="built_in">print</span>(l.Amounts)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Ledger[<span class="keyword">string</span>, <span class="keyword">int</span>]&#123;</span><br><span class="line">        ID: <span class="string">&quot;test-qq&quot;</span>,</span><br><span class="line">        Amounts: []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>,<span class="number">3</span>&#125;,</span><br><span class="line">    &#125;.PrintA()</span><br><span class="line"></span><br><span class="line">    Ledger[<span class="keyword">string</span>, <span class="keyword">int32</span>]&#123;</span><br><span class="line">        ID: <span class="string">&quot;test-qq&quot;</span>,</span><br><span class="line">        Amounts: []<span class="keyword">int32</span>&#123;<span class="number">1</span>, <span class="number">2</span>,<span class="number">3</span>&#125;,</span><br><span class="line">    &#125;.PrintA()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Structural-Constraints"><a href="#Structural-Constraints" class="headerlink" title="Structural Constraints"></a>Structural Constraints</h4><p>这个特性还存在一些问题，泛型的结构体暂时禁止访问字段，其实感觉挺一般的，既然更版本了为啥不做好、做完善呢？</p><p>…</p><p><strong>匿名结构体</strong></p><p>如果说要接收任意包含这三个字段的结构体（即 Ledger 的实例），需要像下面这样实现，<strong>所有的结构体都实现了匿名结构体</strong>。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SomeFunc</span>[</span></span><br><span class="line">    T ~<span class="keyword">string</span>,</span><br><span class="line">    K Numeric,</span><br><span class="line">    L ~<span class="keyword">struct</span> &#123;</span><br><span class="line">        ID      T</span><br><span class="line">        Amounts []K</span><br><span class="line">        SumFn   SumFn[K]</span><br><span class="line">    &#125;,</span><br><span class="line">](l L) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    SomeFunc[<span class="keyword">string</span>, <span class="keyword">int</span>, Ledger[<span class="keyword">string</span>, <span class="keyword">int</span>]](Ledger[<span class="keyword">string</span>, <span class="keyword">int</span>]&#123;</span><br><span class="line">        ID:      <span class="string">&quot;acct-1&quot;</span>,</span><br><span class="line">        Amounts: []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,</span><br><span class="line">        SumFn:   Sum[<span class="keyword">int</span>],</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Structural constraints must match the struct <em>exactly</em>, and this means even if all of the fields in the constraint are present, the presence of additional fields in the provided value means the type does not satisfy the constraint.</p></blockquote><p>这里可以暂时不考虑，后续待官方完善了再学也不迟，毕竟现在工作中用不到这些东西..</p><h3 id="Interface-constraints"><a href="#Interface-constraints" class="headerlink" title="Interface constraints"></a>Interface constraints</h3><p>接口约束之前已经见过了， <code>Numeric</code>  限制了类型只能是 <code>int int32 int64</code></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Numeric <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> | <span class="keyword">int32</span> | <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于结构体来说，想通过接口调用方法，需要在上述那样的基础上再添加上方法。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Ledgerish expresses a constraint that may be satisfied by types that have</span></span><br><span class="line"><span class="comment">// ledger-like qualities.</span></span><br><span class="line"><span class="keyword">type</span> Ledgerish[T ~<span class="keyword">string</span>, K Numeric] <span class="keyword">interface</span> &#123;</span><br><span class="line">    ~<span class="keyword">struct</span> &#123;</span><br><span class="line">        ID      T</span><br><span class="line">        Amounts []K</span><br><span class="line">        SumFn   SumFn[K]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PrintIDAndSum()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Careful-Constructs"><a href="#Careful-Constructs" class="headerlink" title="Careful Constructs"></a>Careful Constructs</h3><h3 id="Internals"><a href="#Internals" class="headerlink" title="Internals"></a>Internals</h3><h4 id="Type-erasure"><a href="#Type-erasure" class="headerlink" title="Type erasure"></a>Type erasure</h4><p>在了解 Go 中泛型是怎么做到运行时安全前，先了解一下类型擦除。</p><p>Wiki 上的定义是：<em>the load-time process by which explicit type annotations are removed from a program before it is executed at run-time</em></p><p>翻译过来就是，程序在运行时执行前，进程显示的将类型注解从程序中移除掉。（自己翻译的）</p><p>伪代码演示如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ints = List&lt;Int32&gt;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">var</span> strs = List&lt;String&gt;&#123;<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;world&quot;</span>&#125;</span><br></pre></td></tr></table></figure><p><strong>Type erasure</strong> 执行后</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ints = List&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">var</span> strs = List&#123;<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;world&quot;</span>&#125;</span><br></pre></td></tr></table></figure><p>这两个的唯一区别就是将类型擦除掉了，这个特性在很多流行的编程语言中都有。</p><h5 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h5><p>java 中 type erasure 的体现：<a href="https://github.com/akutz/go-generics-the-hard-way/blob/main/05-internals/01-type-erasure/02-java.md">java-type-erasure</a></p><h5 id="Net"><a href="#Net" class="headerlink" title=".Net"></a>.Net</h5><p>.Net 中 type erasure 的体现：<a href="https://github.com/akutz/go-generics-the-hard-way/blob/main/05-internals/01-type-erasure/03-dotnet.md">.Net-type-erasure</a></p><h5 id="Golang"><a href="#Golang" class="headerlink" title="Golang"></a>Golang</h5><p>Go 中 type erasure 的体现：<a href="https://github.com/akutz/go-generics-the-hard-way/blob/main/05-internals/01-type-erasure/04-golang.md">Golang-type-erasure</a> ，这里介绍到，Go中没有反省模板，list 中保留的仍是具体类型，不像 JAVA 中翻译成 object。</p><h4 id="Runtime-safety"><a href="#Runtime-safety" class="headerlink" title="Runtime-safety"></a>Runtime-safety</h4><p>关于泛型这里我一直有个疑问，比如我们定义了一个泛型数组，使用 Go 代码声明如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> List[T any] []T</span><br></pre></td></tr></table></figure><p>假设我们在初始化的时候使用 int，但是后续执行 append 操作的时候加一个 string 能不能行得通？<strong>显然在 Go  中并不行</strong>。那么在其他语言中呢？</p><h5 id="JAVA-1"><a href="#JAVA-1" class="headerlink" title="JAVA"></a>JAVA</h5><p><a href="https://github.com/akutz/go-generics-the-hard-way/blob/main/05-internals/02-runtime-type-safety/01-java.md">java-runtime-safety</a> 从这里不难看出，java 中擦出了初始化泛型的信息，很难保持在 runtime 时安全。</p><h5 id="NET"><a href="#NET" class="headerlink" title=".NET"></a>.NET</h5><p><a href="https://github.com/akutz/go-generics-the-hard-way/blob/main/05-internals/02-runtime-type-safety/02-dotnet.md">.NET-runtime-safety</a> 这里保持了泛型的相关信息，所以在运行时是安全的。</p><h5 id="Golang-1"><a href="#Golang-1" class="headerlink" title="Golang"></a>Golang</h5><p><a href="https://github.com/akutz/go-generics-the-hard-way/blob/main/05-internals/02-runtime-type-safety/03-golang.md">Golang-runtime-safety</a> 通过前面的内容我们知道，Go 中没有进行 type erasure，所以也可以做到 runtime 时安全。</p><h4 id="Runtime-instantiation"><a href="#Runtime-instantiation" class="headerlink" title="Runtime-instantiation"></a>Runtime-instantiation</h4><blockquote><p>The ability to instantiate new types using generics at runtime，在运行时使用泛型初始化的能力。</p></blockquote><p>我觉得，如果要支持运行时初始化的能力，需要具备动态推断类型的能力，在运行时检测泛型是哪种类型。</p><h5 id="JAVA-2"><a href="#JAVA-2" class="headerlink" title="JAVA"></a>JAVA</h5><p><a href="https://github.com/akutz/go-generics-the-hard-way/blob/main/05-internals/03-runtime-instantiation/01-java.md">java-runtime-instantiation</a> 不支持，Java中的泛型纯粹是编译时特性。</p><h5 id="NET-1"><a href="#NET-1" class="headerlink" title=".NET"></a>.NET</h5><p><a href="https://github.com/akutz/go-generics-the-hard-way/blob/main/05-internals/03-runtime-instantiation/02-dotnet.md">.NET-runtime-instantiation</a> 支持.. 这么一看.. .NET 还是牛逼..我有个大学同学人家都是 JAVA，Python，这兄弟学了两年 .NET 哈哈哈哈，后来由于比较冷门，也放弃了哈哈。</p><h5 id="Golang-2"><a href="#Golang-2" class="headerlink" title="Golang"></a>Golang</h5><p><a href="https://github.com/akutz/go-generics-the-hard-way/blob/main/05-internals/03-runtime-instantiation/03-golang.md">golang-runtime-instantiation</a> 不支持，Go 中的泛型同 java 一样都是编译时的特性，在编译时就确定好了类型。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><table><thead><tr><th></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th></tr></thead><tbody><tr><td></td><td align="center">Compile-time type safety</td><td align="center">Type erasure</td><td align="center">Runtime type safety</td><td align="center">Runtime instantiation</td></tr><tr><td>Java</td><td align="center">✓</td><td align="center">✓</td><td align="center"></td><td align="center"></td></tr><tr><td>.NET</td><td align="center">✓</td><td align="center"></td><td align="center">✓</td><td align="center">✓</td></tr><tr><td>Go</td><td align="center">✓</td><td align="center"></td><td align="center">✓</td><td align="center"></td></tr></tbody></table><p>至此，泛型的学习就告一段落了，学到了语法，如何使用，已经在某些简单的场景下使用泛型带来的便利性。也或多或少的了解到了其他语言的泛型特性。</p><p>参考链接：</p><ol><li><a href="https://github.com/akutz/go-generics-the-hard-way/">go-generics-the-hard-way</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2022/06/06/LNYfsvCZwxeh3l9.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;go 泛型学习，距离泛型的发布已经有很长一段时间了，之前大概看了下官方文档，说有些东西可能将来都会改变，不保证向前兼容，就没有具体了解，1.18也发了几个版本了，感觉再不努力又要被小伙伴们卷完了。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>go error handling</title>
    <link href="https://bqyang.top/2022/language/golang/go-errors/"/>
    <id>https://bqyang.top/2022/language/golang/go-errors/</id>
    <published>2022-06-23T10:30:51.694Z</published>
    <updated>2022-06-24T12:47:08.644Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2022/06/08/yfjlCg7NJxwhqbu.png"></p><p>这篇文章是我学习董哥发布的 <a href="https://mytechshares.com/2021/11/22/go-error-best-practice">错误处理</a> 文章的总结，好记性不如烂笔头，避坑啦！</p><span id="more"></span><p>通常情况下打印的错误信息是不包含堆栈的。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// %v 与 %s 相同</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, readFile())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readFile</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    _, err := ioutil.ReadFile(<span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output: open : The system cannot find the file specified.</span></span><br></pre></td></tr></table></figure><p>但是在很多情况下没有堆栈信息是很难定位问题的，除非是 panic 了，但是业务逻辑的代码不能直接 panic 可能会直接导致服务崩溃。</p><h2 id="官方方法-w"><a href="#官方方法-w" class="headerlink" title="官方方法 %w"></a>官方方法 %w</h2><p>还是上面那个例子：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readFile</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    _, err := ioutil.ReadFile(<span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="comment">// 这里只是简单了 wrap 错误信息，并不会增加调用栈的相关内容</span></span><br><span class="line">    <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;%w\n&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output: open : The system cannot find the file specified.</span></span><br></pre></td></tr></table></figure><h2 id="github-com-pkg-errors"><a href="#github-com-pkg-errors" class="headerlink" title="github.com/pkg/errors"></a>github.com/pkg/errors</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%s    print the error. If the error has a Cause it will be</span><br><span class="line">      printed recursively.</span><br><span class="line">%v    see %s</span><br><span class="line">%+v   extended format. Each Frame of the error&#x27;s StackTrace will</span><br><span class="line">      be printed in detail.</span><br></pre></td></tr></table></figure><h3 id="errors-Wrap"><a href="#errors-Wrap" class="headerlink" title="errors.Wrap"></a>errors.Wrap</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/pkg/errors&quot;</span></span><br><span class="line">    <span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%+v\n&quot;</span>, readFile())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readFile</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    _, err := ioutil.ReadFile(<span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> errors.Wrap(err, <span class="string">&quot;something failed&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">open : The system cannot find the file specified.</span></span><br><span class="line"><span class="comment">something failed</span></span><br><span class="line"><span class="comment">main.readFile</span></span><br><span class="line"><span class="comment">D:/program/code/newProject/errors-dev/main.go:15</span></span><br><span class="line"><span class="comment">main.main</span></span><br><span class="line"><span class="comment">D:/program/code/newProject/errors-dev/main.go:10</span></span><br><span class="line"><span class="comment">runtime.main</span></span><br><span class="line"><span class="comment">D:/program/language/go/go1.16.5/src/runtime/proc.go:225</span></span><br><span class="line"><span class="comment">runtime.goexit</span></span><br><span class="line"><span class="comment">D:/program/language/go/go1.16.5/src/runtime/asm_amd64.s:1371</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>使用 errors.Wrap 可以告诉我们堆栈信息，以及报错内容，还有一点需要注意的是：</p><blockquote><p>在调用 errors.Wrap() 时，<strong>最好判断一下 err 是不是 nil</strong>，之前在群里时候就有一个哥们遇到了这个问题，类型断言失败了，err 是 nil，然后进行了 wrap 操作，wrap 中判断 err 是 nil 会直接返回 nil，导致后续代码执行的时候拿到了一个 nil pointer。下图是他当时的场景。</p></blockquote><p><img src="https://s2.loli.net/2022/06/08/VBrMAkzKmLN6b5H.png" alt="断言失败，错误为 nil，return nil, nil"></p><p>董哥在文章中有提到这一点，自己现在还没遇到，既然有人已经在上边踩过坑了，需要引起注意！</p><p>还有一点需要注意的就是，<strong>不要过多使用 errors.Wrap</strong> 这样会输出重复的堆栈信息，可以试试下面这段代码：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readFile</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    _, err := ioutil.ReadFile(<span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="comment">// 会输出两次堆栈信息</span></span><br><span class="line">    <span class="keyword">return</span> errors.Wrap(errors.Wrap(err, <span class="string">&quot;something failed&quot;</span>), <span class="string">&quot;failed!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="error-级联问题"><a href="#error-级联问题" class="headerlink" title="error 级联问题"></a>error 级联问题</h2><p>这个是没接触过的问题，但是或多或少听说过 interface 赋值的问题（抓个时间把 interface 好好看看），在 Go 中，error 其实就是一个 interface。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The error built-in interface type is the conventional interface for</span></span><br><span class="line"><span class="comment">// representing an error condition, with the nil value representing no error.</span></span><br><span class="line"><span class="keyword">type</span> error <span class="keyword">interface</span> &#123;</span><br><span class="line">    Error() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  这时我们创建一个结构体，实现这个 interface</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> myError <span class="keyword">struct</span> &#123;</span><br><span class="line">    Info <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(my *myError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> my.Info</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整代码如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> myError <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i *myError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> i.<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Call1</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Call2</span><span class="params">()</span> *<span class="title">myError</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 在这个问题中我们需要知道的一点就是</span></span><br><span class="line">    <span class="comment">// err 是一个 interface</span></span><br><span class="line">    err := Call1()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;call1 is not nil: %v\n&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    err = Call2()</span><br><span class="line">    fmt.Println(err==<span class="literal">nil</span>)  <span class="comment">// false</span></span><br><span class="line">    fmt.Println(err)   <span class="comment">// nil</span></span><br><span class="line">    <span class="comment">// 上边这两个输出结果真的很矛盾。。</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;call2 err is not nil: %v\n&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案就是：**<a href="https://yourbasic.org/golang/gotcha-why-nil-error-not-equal-nil/">An interface value is equal to <code>nil</code> only if both its value and dynamic type are <code>nil</code>.</a> **接口类型的值只有在 type 和 value 都是空的时候才是 nil，这里我们调用 Call2() 函数后，nil 有了具体的类型，这才导致了后续判断的时候出现奇怪的现象。</p><p>不错，又是收获满满的一天，2022-06-08 22:42</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2022/06/08/yfjlCg7NJxwhqbu.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;这篇文章是我学习董哥发布的 &lt;a href=&quot;https://mytechshares.com/2021/11/22/go-error-best-practice&quot;&gt;错误处理&lt;/a&gt; 文章的总结，好记性不如烂笔头，避坑啦！&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>go context</title>
    <link href="https://bqyang.top/2022/language/golang/go-context/"/>
    <id>https://bqyang.top/2022/language/golang/go-context/</id>
    <published>2022-06-23T10:30:51.693Z</published>
    <updated>2022-06-24T12:47:08.643Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2022/06/15/4SjfIcJUAtRrigO.png"></p><p>这两天在看 Context 的最佳实践，在项目中有用到这个东西，但是又没有实际起作用，只是单纯的作为一个参数传来传去。这篇文章的目的就是学会使用 Context 以及阅读 Context 部分源码实现，还有在使用时需要注意的事项。</p><span id="more"></span><h2 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h2><h3 id="Background-amp-amp-TODO"><a href="#Background-amp-amp-TODO" class="headerlink" title="Background &amp;&amp; TODO"></a>Background &amp;&amp; TODO</h3><p><strong>Background</strong> 一般都是用来当作树的顶点来使用：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 使用 WithCancel 派生出一个子节点</span></span><br><span class="line">    <span class="comment">// 当前的 Context tree 为：</span></span><br><span class="line">    <span class="comment">// parent --&gt; ctx</span></span><br><span class="line">    ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line">    <span class="keyword">defer</span> cancel</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// use ctx do something..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>需要注意的是，Background 是永远都不会被取消的，这个我们稍后会看到为什么。</p></blockquote><p><strong>TODO</strong> 一般用在不清楚使用哪个 Context 时：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假设我们有个函数需要 context 作为参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DoSomething</span><span class="params">(ctx context.Context, args Args)</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>如果说这时候我们不知道要传给这个函数哪个具体的实参，可以使用 <code>context.TODO</code> 代替，将来有具体的 Contetxt 可以把这个替换掉。</p><h3 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h3><p>在底层这两个其实是同一个东西：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    background = <span class="built_in">new</span>(emptyCtx)</span><br><span class="line">    todo       = <span class="built_in">new</span>(emptyCtx)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>既然都说到这了，我们看下源码：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// context 在底层就是一个 interface</span></span><br><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">    Deadline() (deadline time.Time, ok <span class="keyword">bool</span>)</span><br><span class="line">    <span class="comment">// 采用了 lazy init 的方式进行初始化</span></span><br><span class="line">    Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">    Err() error</span><br><span class="line">    Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>emptyCtx 实现了这个接口，但是与其他 <code>ctx</code> 不同的是，emptyCtx 是不会被 cancel 的，也没有任何的 value 和 deadline。</p><p>另一个非常有意思的地方，<code>emptyCtx</code> 其实是 int 的一个别名，官方注释提到不使用 struct 的原因是<strong>需要不同的地址</strong>，可以动手实验一下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printAddr</span><span class="params">()</span></span> &#123;    </span><br><span class="line">    <span class="keyword">type</span> s <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">    a := <span class="built_in">new</span>(s)</span><br><span class="line">    b := <span class="built_in">new</span>(s)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%p, %p\n&quot;</span>, a, b)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">type</span> i <span class="keyword">int</span></span><br><span class="line">    i1 := <span class="built_in">new</span>(i)</span><br><span class="line">    i2 := <span class="built_in">new</span>(i)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%p, %p\n&quot;</span>, i1, i2)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    Output: </span></span><br><span class="line"><span class="comment">    address of a is 0x8cb1d0, address of b is 0x8cb1d0</span></span><br><span class="line"><span class="comment">    address of i1 is 0xc00000a0a8, address of i2 is 0xc00000a0e0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><blockquote><p>为什么不能使用相同的地址？</p><p>个人认为是为了区分 Background 和 TODO，在源码中我们能看到 emptyCtx 有一个方法叫做 String()</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *emptyCtx)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">   <span class="keyword">switch</span> e &#123;</span><br><span class="line">   <span class="keyword">case</span> background:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;context.Background&quot;</span></span><br><span class="line">   <span class="keyword">case</span> todo:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;context.TODO&quot;</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&quot;unknown empty Context&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果说我们使用 <code>type emptyCtx struct&#123;&#125;</code> 作为 Background 和 TODO 的底层实现，那么在这里打印的时候就会走同一个 case 不能显示正确的输出。</p><p>至于其他原因暂时没想到。</p></blockquote><p>同样的 WithCancel / WithValue 等在底层对应的结构体都实现了这个接口。</p><table><thead><tr><th>funcName</th><th>structName</th></tr></thead><tbody><tr><td>WithValue()</td><td><a href="https://cs.opensource.google/go/go/+/refs/tags/go1.18.3:src/context/context.go;drc=c29be2d41c6c3ed78a76b4d8d8c1c22d7e0ad5b7;l=538">valueCtx</a></td></tr><tr><td>WithDeadline() / WithTimeout()</td><td><a href="https://cs.opensource.google/go/go/+/refs/tags/go1.18.3:src/context/context.go;drc=c29be2d41c6c3ed78a76b4d8d8c1c22d7e0ad5b7;l=465">timerCtx</a></td></tr><tr><td>WithCancel()</td><td><a href="https://cs.opensource.google/go/go/+/refs/tags/go1.18.3:src/context/context.go;drc=c29be2d41c6c3ed78a76b4d8d8c1c22d7e0ad5b7;l=342">cancelCtx</a></td></tr><tr><td>Background() / TODO()</td><td><a href="https://cs.opensource.google/go/go/+/refs/tags/go1.18.3:src/context/context.go;drc=2580d0e08d5e9f979b943758d3c49877fb2324cb;l=171">emptyCtx</a></td></tr></tbody></table><blockquote><p>题外话，你看这种方式，像不像之前提到的工厂方法模式，上边表格中的 struct 就是工厂方法子类，如果说我们以后要添加一个新的 ctx 是不影响已存在的内容的，满足了开闭原则。</p></blockquote><h3 id="WithCancel"><a href="#WithCancel" class="headerlink" title="WithCancel"></a>WithCancel</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A cancelCtx can be canceled. When canceled, it also cancels any children</span></span><br><span class="line"><span class="comment">// that implement canceler.</span></span><br><span class="line"><span class="keyword">type</span> cancelCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">    Context</span><br><span class="line"></span><br><span class="line">    mu       sync.Mutex            <span class="comment">// protects following fields</span></span><br><span class="line">    done     <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;         <span class="comment">// created lazily, closed by first cancel call</span></span><br><span class="line">    children <span class="keyword">map</span>[canceler]<span class="keyword">struct</span>&#123;&#125; <span class="comment">// set to nil by the first cancel call</span></span><br><span class="line">    err      error                 <span class="comment">// set to non-nil by the first cancel call</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>看到这里有一把琐其实就明白为什么 context 可以并发访问</strong>。</p><p>cancelCtx 中还有个非常重要的点就是 <code>cancel</code> 取消当前的 ctx 以及对应的 child。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过 channel 告诉要 cancel 掉这个 ctx</span></span><br><span class="line"><span class="comment">// cancel 当前节点的子节点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span> <span class="title">cancel</span><span class="params">(removeFromParent <span class="keyword">bool</span>, err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;context: internal error: missing cancel error&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    c.mu.Lock()</span><br><span class="line">    <span class="keyword">if</span> c.err != <span class="literal">nil</span> &#123;</span><br><span class="line">        c.mu.Unlock()</span><br><span class="line">        <span class="keyword">return</span> <span class="comment">// already canceled</span></span><br><span class="line">    &#125;</span><br><span class="line">    c.err = err</span><br><span class="line">    <span class="keyword">if</span> c.done == <span class="literal">nil</span> &#123;</span><br><span class="line">        c.done = closedchan</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">close</span>(c.done)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> child := <span class="keyword">range</span> c.children &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span> acquiring the child&#x27;s lock while holding parent&#x27;s lock.</span></span><br><span class="line">        child.cancel(<span class="literal">false</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    c.children = <span class="literal">nil</span></span><br><span class="line">    c.mu.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> removeFromParent &#123;</span><br><span class="line">        removeChild(c.Context, c)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>创建 cancelCtx 过程，源码分析</strong></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line"><span class="comment">// use ctx do something</span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可以看到，如果 parent 传递为 nil 时，直接panic</span></span><br><span class="line"><span class="comment">// 所以在不知道传什么的时候，也不要传 nil，传 TODO 即可</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCancel</span><span class="params">(parent Context)</span> <span class="params">(ctx Context, cancel CancelFunc)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> parent == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;cannot create context from nil parent&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    c := newCancelCtx(parent)</span><br><span class="line">    <span class="comment">// 传播这个 ctx，意思为将这个新的 ctx 挂到父节点的下边</span></span><br><span class="line">    propagateCancel(parent, &amp;c)</span><br><span class="line">    <span class="keyword">return</span> &amp;c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">true</span>, Canceled) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// propagateCancel arranges for child to be canceled when parent is.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">propagateCancel</span><span class="params">(parent Context, child canceler)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 父节点的 Done 放在子节点进行初始化操作</span></span><br><span class="line">    done := parent.Done()</span><br><span class="line">    <span class="comment">// 这里就能看到，如果是 emptyCtx， done 直接返回了 nil</span></span><br><span class="line">    <span class="keyword">if</span> done == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="comment">// parent is never canceled</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="comment">// 避免 parent 被取消，额外做一次检查</span></span><br><span class="line">        <span class="keyword">case</span> &lt;-done:</span><br><span class="line">        <span class="comment">// parent is already canceled</span></span><br><span class="line">        child.cancel(<span class="literal">false</span>, parent.Err())</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断parent的类型，如果是 cancelCtx，走下面这个分支</span></span><br><span class="line">    <span class="comment">// 否则单起一个 goroutine 进行监听</span></span><br><span class="line">    <span class="keyword">if</span> p, ok := parentCancelCtx(parent); ok &#123;</span><br><span class="line">        <span class="comment">// 拿到父节点的 cancelCtx 后</span></span><br><span class="line">        <span class="comment">// 将子节点给加入进去就行了。</span></span><br><span class="line">        p.mu.Lock()</span><br><span class="line">        <span class="keyword">if</span> p.err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// parent has already been canceled</span></span><br><span class="line">            child.cancel(<span class="literal">false</span>, p.err)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> p.children == <span class="literal">nil</span> &#123;</span><br><span class="line">                p.children = <span class="built_in">make</span>(<span class="keyword">map</span>[canceler]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">            &#125;</span><br><span class="line">            p.children[child] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        p.mu.Unlock()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 一开始真的想不到什么情况下会走到这个分支</span></span><br><span class="line">        <span class="comment">// 后来想通了，自定义实现的 ctx 就可以走到这里</span></span><br><span class="line">        <span class="comment">// 并且必须实现 Done 方法</span></span><br><span class="line">        atomic.AddInt32(&amp;goroutines, +<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="comment">// select 会直接阻塞住，除非下边两个里边的一个“通了”</span></span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">                <span class="comment">// 如果parent被取消了，取消其子节点</span></span><br><span class="line">                <span class="keyword">case</span> &lt;-parent.Done():</span><br><span class="line">                    child.cancel(<span class="literal">false</span>, parent.Err())</span><br><span class="line">                <span class="comment">// 如果子节点被取消了，不用做额外处理</span></span><br><span class="line">                <span class="keyword">case</span> &lt;-child.Done():</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// parentCancelCtx 将父节点中的 cancelCtx 提取出啦</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parentCancelCtx</span><span class="params">(parent Context)</span> <span class="params">(*cancelCtx, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    done := parent.Done()</span><br><span class="line">    <span class="comment">// 验证 parent 是否已经关闭了</span></span><br><span class="line">    <span class="keyword">if</span> done == closedchan || done == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这个 key 就是专门用来判断是否为 cancelCtx 的</span></span><br><span class="line">    <span class="comment">// 一开始还很好奇是在哪里进行存储的这个 key value 的</span></span><br><span class="line">    <span class="comment">// 其实人家根本没存，就是用两个特定的 key 进行比对的</span></span><br><span class="line">    p, ok := parent.Value(&amp;cancelCtxKey).(*cancelCtx)</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    p.mu.Lock()</span><br><span class="line">    ok = p.done == done</span><br><span class="line">    p.mu.Unlock()</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p, <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后另外 <code>timerCtx</code> 的实现其实大差不差，增加了时间限制而已。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>使用 Context 需要注意什么呢？</p><ul><li>不要自己内嵌 <code>Context</code>; 取而代之的是显示传递 <code>Context</code> 给需要的函数。</li><li>Context 应该作为函数的第一个参数。</li><li>不要给函数传递 nil 的 <code>Context</code>，尽管函数没加限制，使用 <code>context.TODO</code> 代替。</li><li>使用 context Value 附加参数时，只对那些请求范围内的参数使用。</li></ul><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><p>参考链接: <a href="https://www.sobyte.net/post/2022-03/go-ctx-best-practice/">Go Context Best Practices</a> [1]</p><p><strong>使用 context 防止 Goroutine 泄露</strong>，来源于 [<a href="https://pkg.go.dev/context#example-WithCancel">这里</a>]</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;context&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// gen generates integers in a separate goroutine and</span></span><br><span class="line">    <span class="comment">// sends them to the returned channel.</span></span><br><span class="line">    <span class="comment">// The callers of gen need to cancel the context once</span></span><br><span class="line">    <span class="comment">// they are done consuming generated integers not to leak</span></span><br><span class="line">    <span class="comment">// the internal goroutine started by gen.</span></span><br><span class="line">    gen := <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context)</span> &lt;-<span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        dst := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">        n := <span class="number">1</span></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">for</span> &#123;</span><br><span class="line">                <span class="keyword">select</span> &#123;</span><br><span class="line">                <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">                    <span class="keyword">return</span> <span class="comment">// returning not to leak the goroutine</span></span><br><span class="line">                <span class="keyword">case</span> dst &lt;- n:</span><br><span class="line">                    n++</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line">        <span class="keyword">return</span> dst</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line">    <span class="keyword">defer</span> cancel() <span class="comment">// cancel when we are finished consuming integers</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> n := <span class="keyword">range</span> gen(ctx) &#123;</span><br><span class="line">        fmt.Println(n)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">5</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2022/06/15/4SjfIcJUAtRrigO.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;这两天在看 Context 的最佳实践，在项目中有用到这个东西，但是又没有实际起作用，只是单纯的作为一个参数传来传去。这篇文章的目的就是学会使用 Context 以及阅读 Context 部分源码实现，还有在使用时需要注意的事项。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>初识 go ast</title>
    <link href="https://bqyang.top/2022/language/golang/go-ast/"/>
    <id>https://bqyang.top/2022/language/golang/go-ast/</id>
    <published>2022-06-23T10:30:51.692Z</published>
    <updated>2022-06-24T12:47:08.642Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2022/06/09/xjzPQnLJZUb7BIw.png"></p><p>从介绍 AST 到动手实践解析一个文件，再到查看开源代码的使用场景，一步步了解 AST。</p><p>前一阵子学到了一个 linter（检查err是否被 wrap），实现的方式用的就是 AST ，正好借这个机会了解一下。</p><span id="more"></span><p>AST (Abstact Syntax Tree) 抽象语法树，第一次听到这个应该还是在读大学时候，没想到终究还是要填坑。</p><blockquote><p>AST 是源代码的一种抽象表示。</p></blockquote><p><img src="https://s2.loli.net/2022/06/09/1SkCYVgRaWsZDwd.jpg" alt="go-ast-types"></p><p>这张大图把 AST 中的对象进行了归类，包含了语句（If, For, Range）、表达式、声明、注释。</p><p>然后我们看一个官方关于 Inspect 的例子：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;go/ast&quot;</span></span><br><span class="line">    <span class="string">&quot;go/parser&quot;</span></span><br><span class="line">    <span class="string">&quot;go/token&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fset := token.NewFileSet()</span><br><span class="line">    src := <span class="string">`</span></span><br><span class="line"><span class="string">package p</span></span><br><span class="line"><span class="string">const c = 1.0</span></span><br><span class="line"><span class="string">var X = f(3.14)*2 + c</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line">    astFile, err := parser.ParseFile(fset, <span class="string">&quot;src.go&quot;</span>, src, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalln(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ast.Inspect(astFile, <span class="function"><span class="keyword">func</span><span class="params">(n ast.Node)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> s <span class="keyword">string</span></span><br><span class="line">        <span class="keyword">switch</span> x := n.(<span class="keyword">type</span>) &#123;</span><br><span class="line">        <span class="comment">//case *ast.BasicLit:</span></span><br><span class="line">        <span class="comment">//s = x.Value</span></span><br><span class="line">        <span class="keyword">case</span> *ast.Ident:</span><br><span class="line">            s = x.Name</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> s != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;%s:\t%s\n&quot;</span>, fset.Position(n.Pos()), s)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Output:</span></span><br><span class="line"><span class="comment">        src.go:2:9:p</span></span><br><span class="line"><span class="comment">        src.go:3:7:c</span></span><br><span class="line"><span class="comment">        src.go:4:5:X</span></span><br><span class="line"><span class="comment">        src.go:4:9:f</span></span><br><span class="line"><span class="comment">        src.go:4:21:c</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>把 <code>BasicLit</code> 注释掉了，方便一步步观察输出内容，通过输出内容可以得出，<code>ast.Ident</code> 的含义就是标识符。</p><p>然后像是这种的 <code>xxxLit</code>  都是字面量的声明方式如：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// BasicLit</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">&quot;string&quot;</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&quot;bqyang&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// FuncLit</span></span><br><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>BasicLit</code> 中包含：token.INT, token.FLOAT, token.IMAG, token.CHAR, or token.STRING 内容。</p><p>这么看不太直观，可以使用 <a href="https://yuroyoro.github.io/goast-viewer/index.html">GoAst Viewer</a> 输出一颗完整的语法树，还是使用上述内容：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  0  *ast.File &#123;</span><br><span class="line">  1  .  Doc: nil</span><br><span class="line">  2  .  Package: foo:1:1</span><br><span class="line">  3  .  Name: *ast.Ident &#123;</span><br><span class="line">  4  .  .  NamePos: foo:1:9</span><br><span class="line">  5  .  .  Name: &quot;p&quot;</span><br><span class="line">  6  .  .  Obj: nil</span><br><span class="line">  7  .  &#125;</span><br><span class="line">  8  .  Decls: []ast.Decl (len = 2) &#123;</span><br><span class="line">  9  .  .  0: *ast.GenDecl &#123;</span><br><span class="line"> 10  .  .  .  Doc: nil</span><br><span class="line"> 11  .  .  .  TokPos: foo:2:1</span><br><span class="line"> 12  .  .  .  Tok: const</span><br><span class="line"> 13  .  .  .  Lparen: -</span><br><span class="line"> 14  .  .  .  Specs: []ast.Spec (len = 1) &#123;</span><br><span class="line"> 15  .  .  .  .  0: *ast.ValueSpec &#123;</span><br><span class="line"> 16  .  .  .  .  .  Doc: nil</span><br><span class="line"> 17  .  .  .  .  .  Names: []*ast.Ident (len = 1) &#123;</span><br><span class="line"> 18  .  .  .  .  .  .  0: *ast.Ident &#123;</span><br><span class="line"> 19  .  .  .  .  .  .  .  NamePos: foo:2:7</span><br><span class="line"> 20  .  .  .  .  .  .  .  Name: &quot;c&quot;</span><br><span class="line"> 21  .  .  .  .  .  .  .  Obj: *ast.Object &#123;</span><br><span class="line"> 22  .  .  .  .  .  .  .  .  Kind: const</span><br><span class="line"> 23  .  .  .  .  .  .  .  .  Name: &quot;c&quot;</span><br><span class="line"> 24  .  .  .  .  .  .  .  .  Decl: *(obj @ 15)</span><br><span class="line"> 25  .  .  .  .  .  .  .  .  Data: 0</span><br><span class="line"> 26  .  .  .  .  .  .  .  .  Type: nil</span><br><span class="line"> 27  .  .  .  .  .  .  .  &#125;</span><br><span class="line"> 28  .  .  .  .  .  .  &#125;</span><br><span class="line"> 29  .  .  .  .  .  &#125;</span><br><span class="line"> 30  .  .  .  .  .  Type: nil</span><br><span class="line"> 31  .  .  .  .  .  Values: []ast.Expr (len = 1) &#123;</span><br><span class="line"> 32  .  .  .  .  .  .  0: *ast.BasicLit &#123;</span><br><span class="line"> 33  .  .  .  .  .  .  .  ValuePos: foo:2:11</span><br><span class="line"> 34  .  .  .  .  .  .  .  Kind: FLOAT</span><br><span class="line"> 35  .  .  .  .  .  .  .  Value: &quot;1.0&quot;</span><br><span class="line"> 36  .  .  .  .  .  .  &#125;</span><br><span class="line"> 37  .  .  .  .  .  &#125;</span><br><span class="line"> 38  .  .  .  .  .  Comment: nil</span><br><span class="line"> 39  .  .  .  .  &#125;</span><br><span class="line"> 40  .  .  .  &#125;</span><br><span class="line"> 41  .  .  .  Rparen: -</span><br><span class="line"> 42  .  .  &#125;</span><br><span class="line"> 43  .  .  1: *ast.GenDecl &#123;</span><br><span class="line"> 44  .  .  .  Doc: nil</span><br><span class="line"> 45  .  .  .  TokPos: foo:3:1</span><br><span class="line"> 46  .  .  .  Tok: var</span><br><span class="line"> 47  .  .  .  Lparen: -</span><br><span class="line"> 48  .  .  .  Specs: []ast.Spec (len = 1) &#123;</span><br><span class="line"> 49  .  .  .  .  0: *ast.ValueSpec &#123;</span><br><span class="line"> 50  .  .  .  .  .  Doc: nil</span><br><span class="line"> 51  .  .  .  .  .  Names: []*ast.Ident (len = 1) &#123;</span><br><span class="line"> 52  .  .  .  .  .  .  0: *ast.Ident &#123;</span><br><span class="line"> 53  .  .  .  .  .  .  .  NamePos: foo:3:5</span><br><span class="line"> 54  .  .  .  .  .  .  .  Name: &quot;X&quot;</span><br><span class="line"> 55  .  .  .  .  .  .  .  Obj: *ast.Object &#123;</span><br><span class="line"> 56  .  .  .  .  .  .  .  .  Kind: var</span><br><span class="line"> 57  .  .  .  .  .  .  .  .  Name: &quot;X&quot;</span><br><span class="line"> 58  .  .  .  .  .  .  .  .  Decl: *(obj @ 49)</span><br><span class="line"> 59  .  .  .  .  .  .  .  .  Data: 0</span><br><span class="line"> 60  .  .  .  .  .  .  .  .  Type: nil</span><br><span class="line"> 61  .  .  .  .  .  .  .  &#125;</span><br><span class="line"> 62  .  .  .  .  .  .  &#125;</span><br><span class="line"> 63  .  .  .  .  .  &#125;</span><br><span class="line"> 64  .  .  .  .  .  Type: nil</span><br><span class="line"> 65  .  .  .  .  .  Values: []ast.Expr (len = 1) &#123;</span><br><span class="line"> 66  .  .  .  .  .  .  0: *ast.BinaryExpr &#123;</span><br><span class="line"> 67  .  .  .  .  .  .  .  X: *ast.BinaryExpr &#123;</span><br><span class="line"> 68  .  .  .  .  .  .  .  .  X: *ast.CallExpr &#123;</span><br><span class="line"> 69  .  .  .  .  .  .  .  .  .  Fun: *ast.Ident &#123;</span><br><span class="line"> 70  .  .  .  .  .  .  .  .  .  .  NamePos: foo:3:9</span><br><span class="line"> 71  .  .  .  .  .  .  .  .  .  .  Name: &quot;f&quot;</span><br><span class="line"> 72  .  .  .  .  .  .  .  .  .  .  Obj: nil</span><br><span class="line"> 73  .  .  .  .  .  .  .  .  .  &#125;</span><br><span class="line"> 74  .  .  .  .  .  .  .  .  .  Lparen: foo:3:10</span><br><span class="line"> 75  .  .  .  .  .  .  .  .  .  Args: []ast.Expr (len = 1) &#123;</span><br><span class="line"> 76  .  .  .  .  .  .  .  .  .  .  0: *ast.BasicLit &#123;</span><br><span class="line"> 77  .  .  .  .  .  .  .  .  .  .  .  ValuePos: foo:3:11</span><br><span class="line"> 78  .  .  .  .  .  .  .  .  .  .  .  Kind: FLOAT</span><br><span class="line"> 79  .  .  .  .  .  .  .  .  .  .  .  Value: &quot;3.14&quot;</span><br><span class="line"> 80  .  .  .  .  .  .  .  .  .  .  &#125;</span><br><span class="line"> 81  .  .  .  .  .  .  .  .  .  &#125;</span><br><span class="line"> 82  .  .  .  .  .  .  .  .  .  Ellipsis: -</span><br><span class="line"> 83  .  .  .  .  .  .  .  .  .  Rparen: foo:3:15</span><br><span class="line"> 84  .  .  .  .  .  .  .  .  &#125;</span><br><span class="line"> 85  .  .  .  .  .  .  .  .  OpPos: foo:3:16</span><br><span class="line"> 86  .  .  .  .  .  .  .  .  Op: *</span><br><span class="line"> 87  .  .  .  .  .  .  .  .  Y: *ast.BasicLit &#123;</span><br><span class="line"> 88  .  .  .  .  .  .  .  .  .  ValuePos: foo:3:17</span><br><span class="line"> 89  .  .  .  .  .  .  .  .  .  Kind: INT</span><br><span class="line"> 90  .  .  .  .  .  .  .  .  .  Value: &quot;2&quot;</span><br><span class="line"> 91  .  .  .  .  .  .  .  .  &#125;</span><br><span class="line"> 92  .  .  .  .  .  .  .  &#125;</span><br><span class="line"> 93  .  .  .  .  .  .  .  OpPos: foo:3:19</span><br><span class="line"> 94  .  .  .  .  .  .  .  Op: +</span><br><span class="line"> 95  .  .  .  .  .  .  .  Y: *ast.Ident &#123;</span><br><span class="line"> 96  .  .  .  .  .  .  .  .  NamePos: foo:3:21</span><br><span class="line"> 97  .  .  .  .  .  .  .  .  Name: &quot;c&quot;</span><br><span class="line"> 98  .  .  .  .  .  .  .  .  Obj: *(obj @ 21)</span><br><span class="line"> 99  .  .  .  .  .  .  .  &#125;</span><br><span class="line">100  .  .  .  .  .  .  &#125;</span><br><span class="line">101  .  .  .  .  .  &#125;</span><br><span class="line">102  .  .  .  .  .  Comment: nil</span><br><span class="line">103  .  .  .  .  &#125;</span><br><span class="line">104  .  .  .  &#125;</span><br><span class="line">105  .  .  .  Rparen: -</span><br><span class="line">106  .  .  &#125;</span><br><span class="line">107  .  &#125;</span><br><span class="line">108  .  Scope: *ast.Scope &#123;</span><br><span class="line">109  .  .  Outer: nil</span><br><span class="line">110  .  .  Objects: map[string]*ast.Object (len = 2) &#123;</span><br><span class="line">111  .  .  .  &quot;c&quot;: *(obj @ 21)</span><br><span class="line">112  .  .  .  &quot;X&quot;: *(obj @ 55)</span><br><span class="line">113  .  .  &#125;</span><br><span class="line">114  .  &#125;</span><br><span class="line">115  .  Imports: nil</span><br><span class="line">116  .  Unresolved: []*ast.Ident (len = 1) &#123;</span><br><span class="line">117  .  .  0: *(obj @ 69)</span><br><span class="line">118  .  &#125;</span><br><span class="line">119  .  Comments: nil</span><br><span class="line">120  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Inspect traverses an AST in depth-first order: It starts by calling</span></span><br><span class="line"><span class="comment">// f(node); node must not be nil. If f returns true, Inspect invokes f</span></span><br><span class="line"><span class="comment">// recursively for each of the non-nil children of node, followed by a</span></span><br><span class="line"><span class="comment">// call of f(nil).</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2022/06/09/xjzPQnLJZUb7BIw.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;从介绍 AST 到动手实践解析一个文件，再到查看开源代码的使用场景，一步步了解 AST。&lt;/p&gt;
&lt;p&gt;前一阵子学到了一个 linter（检查err是否被 wrap），实现的方式用的就是 AST ，正好借这个机会了解一下。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>GC from go comments</title>
    <link href="https://bqyang.top/2022/language/golang/GCComments/"/>
    <id>https://bqyang.top/2022/language/golang/GCComments/</id>
    <published>2022-06-23T10:30:51.690Z</published>
    <updated>2022-06-23T14:46:33.135Z</updated>
    
    <content type="html"><![CDATA[<p>来自 Go 官方对 GC 的解释。</p><span id="more"></span><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Garbage collector (GC).</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The GC runs concurrently with mutator threads, is type accurate (aka precise), allows multiple</span></span><br><span class="line"><span class="comment">// GC thread to run in parallel. It is a concurrent mark and sweep that uses a write barrier. It is</span></span><br><span class="line"><span class="comment">// non-generational and non-compacting. Allocation is done using size segregated per P allocation</span></span><br><span class="line"><span class="comment">// areas to minimize fragmentation while eliminating locks in the common case.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The algorithm decomposes into several steps.</span></span><br><span class="line"><span class="comment">// This is a high level description of the algorithm being used. For an overview of GC a good</span></span><br><span class="line"><span class="comment">// place to start is Richard Jones&#x27; gchandbook.org.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The algorithm&#x27;s intellectual heritage includes Dijkstra&#x27;s on-the-fly algorithm, see</span></span><br><span class="line"><span class="comment">// Edsger W. Dijkstra, Leslie Lamport, A. J. Martin, C. S. Scholten, and E. F. M. Steffens. 1978.</span></span><br><span class="line"><span class="comment">// On-the-fly garbage collection: an exercise in cooperation. Commun. ACM 21, 11 (November 1978),</span></span><br><span class="line"><span class="comment">// 966-975.</span></span><br><span class="line"><span class="comment">// For journal quality proofs that these steps are complete, correct, and terminate see</span></span><br><span class="line"><span class="comment">// Hudson, R., and Moss, J.E.B. Copying Garbage Collection without stopping the world.</span></span><br><span class="line"><span class="comment">// Concurrency and Computation: Practice and Experience 15(3-5), 2003.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 1. GC performs sweep termination.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    a. Stop the world. This causes all Ps to reach a GC safe-point.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    b. Sweep any unswept spans. There will only be unswept spans if</span></span><br><span class="line"><span class="comment">//    this GC cycle was forced before the expected time.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 2. GC performs the mark phase.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    a. Prepare for the mark phase by setting gcphase to _GCmark</span></span><br><span class="line"><span class="comment">//    (from _GCoff), enabling the write barrier, enabling mutator</span></span><br><span class="line"><span class="comment">//    assists, and enqueueing root mark jobs. No objects may be</span></span><br><span class="line"><span class="comment">//    scanned until all Ps have enabled the write barrier, which is</span></span><br><span class="line"><span class="comment">//    accomplished using STW.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    b. Start the world. From this point, GC work is done by mark</span></span><br><span class="line"><span class="comment">//    workers started by the scheduler and by assists performed as</span></span><br><span class="line"><span class="comment">//    part of allocation. The write barrier shades both the</span></span><br><span class="line"><span class="comment">//    overwritten pointer and the new pointer value for any pointer</span></span><br><span class="line"><span class="comment">//    writes (see mbarrier.go for details). Newly allocated objects</span></span><br><span class="line"><span class="comment">//    are immediately marked black.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    c. GC performs root marking jobs. This includes scanning all</span></span><br><span class="line"><span class="comment">//    stacks, shading all globals, and shading any heap pointers in</span></span><br><span class="line"><span class="comment">//    off-heap runtime data structures. Scanning a stack stops a</span></span><br><span class="line"><span class="comment">//    goroutine, shades any pointers found on its stack, and then</span></span><br><span class="line"><span class="comment">//    resumes the goroutine.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    d. GC drains the work queue of grey objects, scanning each grey</span></span><br><span class="line"><span class="comment">//    object to black and shading all pointers found in the object</span></span><br><span class="line"><span class="comment">//    (which in turn may add those pointers to the work queue).</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    e. Because GC work is spread across local caches, GC uses a</span></span><br><span class="line"><span class="comment">//    distributed termination algorithm to detect when there are no</span></span><br><span class="line"><span class="comment">//    more root marking jobs or grey objects (see gcMarkDone). At this</span></span><br><span class="line"><span class="comment">//    point, GC transitions to mark termination.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 3. GC performs mark termination.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    a. Stop the world.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    b. Set gcphase to _GCmarktermination, and disable workers and</span></span><br><span class="line"><span class="comment">//    assists.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    c. Perform housekeeping like flushing mcaches.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 4. GC performs the sweep phase.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    a. Prepare for the sweep phase by setting gcphase to _GCoff,</span></span><br><span class="line"><span class="comment">//    setting up sweep state and disabling the write barrier.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    b. Start the world. From this point on, newly allocated objects</span></span><br><span class="line"><span class="comment">//    are white, and allocating sweeps spans before use if necessary.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    c. GC does concurrent sweeping in the background and in response</span></span><br><span class="line"><span class="comment">//    to allocation. See description below.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 5. When sufficient allocation has taken place, replay the sequence</span></span><br><span class="line"><span class="comment">// starting with 1 above. See discussion of GC rate below.</span></span><br><span class="line"><span class="comment">// Concurrent sweep.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The sweep phase proceeds concurrently with normal program execution.</span></span><br><span class="line"><span class="comment">// The heap is swept span-by-span both lazily (when a goroutine needs another span)</span></span><br><span class="line"><span class="comment">// and concurrently in a background goroutine (this helps programs that are not CPU bound).</span></span><br><span class="line"><span class="comment">// At the end of STW mark termination all spans are marked as &quot;needs sweeping&quot;.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The background sweeper goroutine simply sweeps spans one-by-one.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// To avoid requesting more OS memory while there are unswept spans, when a</span></span><br><span class="line"><span class="comment">// goroutine needs another span, it first attempts to reclaim that much memory</span></span><br><span class="line"><span class="comment">// by sweeping. When a goroutine needs to allocate a new small-object span, it</span></span><br><span class="line"><span class="comment">// sweeps small-object spans for the same object size until it frees at least</span></span><br><span class="line"><span class="comment">// one object. When a goroutine needs to allocate large-object span from heap,</span></span><br><span class="line"><span class="comment">// it sweeps spans until it frees at least that many pages into heap. There is</span></span><br><span class="line"><span class="comment">// one case where this may not suffice: if a goroutine sweeps and frees two</span></span><br><span class="line"><span class="comment">// nonadjacent one-page spans to the heap, it will allocate a new two-page</span></span><br><span class="line"><span class="comment">// span, but there can still be other one-page unswept spans which could be</span></span><br><span class="line"><span class="comment">// combined into a two-page span.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// It&#x27;s critical to ensure that no operations proceed on unswept spans (that would corrupt</span></span><br><span class="line"><span class="comment">// mark bits in GC bitmap). During GC all mcaches are flushed into the central cache,</span></span><br><span class="line"><span class="comment">// so they are empty. When a goroutine grabs a new span into mcache, it sweeps it.</span></span><br><span class="line"><span class="comment">// When a goroutine explicitly frees an object or sets a finalizer, it ensures that</span></span><br><span class="line"><span class="comment">// the span is swept (either by sweeping it, or by waiting for the concurrent sweep to finish).</span></span><br><span class="line"><span class="comment">// The finalizer goroutine is kicked off only when all spans are swept.</span></span><br><span class="line"><span class="comment">// When the next GC starts, it sweeps all not-yet-swept spans (if any).</span></span><br><span class="line"><span class="comment">// GC rate.</span></span><br><span class="line"><span class="comment">// Next GC is after we&#x27;ve allocated an extra amount of memory proportional to</span></span><br><span class="line"><span class="comment">// the amount already in use. The proportion is controlled by GOGC environment variable</span></span><br><span class="line"><span class="comment">// (100 by default). If GOGC=100 and we&#x27;re using 4M, we&#x27;ll GC again when we get to 8M</span></span><br><span class="line"><span class="comment">// (this mark is tracked in next_gc variable). This keeps the GC cost in linear</span></span><br><span class="line"><span class="comment">// proportion to the allocation cost. Adjusting GOGC just changes the linear constant</span></span><br><span class="line"><span class="comment">// (and also the amount of extra memory used).</span></span><br><span class="line"><span class="comment">// Oblets</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// In order to prevent long pauses while scanning large objects and to</span></span><br><span class="line"><span class="comment">// improve parallelism, the garbage collector breaks up scan jobs for</span></span><br><span class="line"><span class="comment">// objects larger than maxObletBytes into &quot;oblets&quot; of at most</span></span><br><span class="line"><span class="comment">// maxObletBytes. When scanning encounters the beginning of a large</span></span><br><span class="line"><span class="comment">// object, it scans only the first oblet and enqueues the remaining</span></span><br><span class="line"><span class="comment">// oblets as new scan jobs.</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;来自 Go 官方对 GC 的解释。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
</feed>
