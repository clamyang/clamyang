<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>杨宝强的技术笔记</title>
  
  <subtitle>欢迎~</subtitle>
  <link href="http://bqyang.top/atom.xml" rel="self"/>
  
  <link href="http://bqyang.top/"/>
  <updated>2021-11-17T01:35:34.263Z</updated>
  <id>http://bqyang.top/</id>
  
  <author>
    <name>杨宝强</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>工作现状</title>
    <link href="http://bqyang.top/2021/11/17/%E8%81%8A%E8%81%8A%E5%B7%A5%E4%BD%9C%E4%B8%8A%E7%9A%84%E5%B0%8F%E4%BA%8B/"/>
    <id>http://bqyang.top/2021/11/17/%E8%81%8A%E8%81%8A%E5%B7%A5%E4%BD%9C%E4%B8%8A%E7%9A%84%E5%B0%8F%E4%BA%8B/</id>
    <published>2021-11-17T01:34:27.819Z</published>
    <updated>2021-11-17T01:35:34.263Z</updated>
    
    <content type="html"><![CDATA[<p>今天要聊的与技术无关，简单聊聊最近。<br>闲聊工作，最近有点迷，每天也不知道在忙啥，除了改bug还是改bug，还不是我写的bug，给上一任擦屁股，感觉永远都擦不干净。（说起来挺恶心，事实就是很恶心）</p><span id="more"></span><p>我没什么职业规划，不知道该干啥，学习也不是因为感兴趣，只是单单觉得作为一个程序员，要有基本的职业素养。就像一名司机，虽然你日常开自动挡，但是学驾照依然考的手动挡。不为别的，多一手准备。</p><p>关于职业规划，我的想法是，刚毕业基础一定要打牢，还有我觉得职业规划更重要的是机遇，某个时间点你接触到了某个领域遇到了对的人，没有必要花费过多的时间在这上，有些事情就是船到桥头自然直，把握好当下。</p><p>从毕业到工作，有很多事情是现在的我不能理解的。或许这是不成熟的表现，也有些人将之称为特立独行。</p><p>上学时被老师管教，回家后被家长管教，走到哪里都有条条框框约束着。俗话有国有国法，家有家规，没有规矩不成方圆。但是你有没有想过，什么东西可以穿透这些条条框框的限制？</p><p>我认为是人情与压力。不喜欢谈人情，所以简单聊聊压力给我们带来的影响。</p><p>有时候你按照约定，符合规矩，可是还会遭受到心灵上的拷问。举个例子，你身边三个人，每个人有八个苹果，工作内容把八个苹果削皮，期限是从早上到晚上八小时，中午休息一小时。ABC都是一小时削一个，但是区别就是AB利用中午休息时间削了一个。C 老老实实按规矩办事，上午四个，下午四个。<br>那么问题就来了，C 有打破边框吗？C 应该被谴责吗？此时此刻，所有的压力都在 C 身上。但是 C 真的什么都没做啊，只是个老老实实的打工人。</p><p>C 如果也开始利用休息时间去工作，这就叫内卷了。C 如果还是按规矩办事，C 这就叫特立独行了。C 处在这种尴尬的环境中，自然要突破。不能适应，只好被淘汰。</p><p>咱知识浅薄，扯不出什么高大上的东西，希望其所表达的意思是清晰的。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天要聊的与技术无关，简单聊聊最近。&lt;br&gt;闲聊工作，最近有点迷，每天也不知道在忙啥，除了改bug还是改bug，还不是我写的bug，给上一任擦屁股，感觉永远都擦不干净。（说起来挺恶心，事实就是很恶心）&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>timer 优化</title>
    <link href="http://bqyang.top/2021/11/14/timer%20%E4%BC%98%E5%8C%96/"/>
    <id>http://bqyang.top/2021/11/14/timer%20%E4%BC%98%E5%8C%96/</id>
    <published>2021-11-14T14:47:26.661Z</published>
    <updated>2021-11-15T03:17:36.429Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们已经知道了，老版本 timer 的性能瓶颈主要是在那把全局锁以及频繁的上下文切换上，今天我们看看 go 大佬们通过哪种方式进行优化的。<br>​</p><p>在这里解释一下为什么选择这几个版本，据我所知啊，从 1.10 版本以前都是像上一篇文中所描述的那样，在 1.10 版本开始就做了这个优化，但从 1.14 开始又对 timer 进行了优化，所以我选择了 1.8， 1.13， 1.14 这几个邻近的作为参考。</p><span id="more"></span><h2 id="1-13-中的优化"><a href="#1-13-中的优化" class="headerlink" title="1.13 中的优化"></a>1.13 中的优化</h2><h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3><ul><li>go version: go1.13</li><li>compute: linux, centos7</li></ul><h3 id="timer-结构的变化"><a href="#timer-结构的变化" class="headerlink" title="timer 结构的变化"></a>timer 结构的变化</h3><h5 id="go1-8"><a href="#go1-8" class="headerlink" title="go1.8"></a>go1.8</h5><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> timer <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>i <span class="token builtin">int</span> <span class="token comment">// heap index</span>when   <span class="token builtin">int64</span>period <span class="token builtin">int64</span>f      <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token builtin">uintptr</span><span class="token punctuation">)</span>arg    <span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>seq    <span class="token builtin">uintptr</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="go1-13"><a href="#go1-13" class="headerlink" title="go1.13"></a>go1.13</h5><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> timer <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>tb <span class="token operator">*</span>timersBucket <span class="token comment">// the bucket the timer lives in</span>i  <span class="token builtin">int</span>           <span class="token comment">// heap index</span>when   <span class="token builtin">int64</span>period <span class="token builtin">int64</span>f      <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token builtin">uintptr</span><span class="token punctuation">)</span>arg    <span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>seq    <span class="token builtin">uintptr</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在go1.13版本中添加了一个 tb 字段，表示当前这个 timer 是在哪个 bucket 中的，其余字段含义还是和老版本中的一致。<br>​</p><p>还记得老版本把新建的 <code>timer</code> 对象都放在哪里了吗？<code>一个全局的 timers 中</code> go1.13版本中将的 timers 拆分成了 64 个大小的 timers 数组，每一个里边包含了一个 bucket ，bucket 中再存放 timer 对象，至于为什么是 64 官方的解释如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// timersLen is the length of timers array.</span><span class="token comment">//</span><span class="token comment">// Ideally, this would be set to GOMAXPROCS, but that would require</span><span class="token comment">// dynamic reallocation</span><span class="token comment">//</span><span class="token comment">// The current value is a compromise between memory usage and performance</span><span class="token comment">// that should cover the majority of GOMAXPROCS values used in the wild.</span><span class="token keyword">const</span> timersLen <span class="token operator">=</span> <span class="token number">64</span><span class="token comment">// timersLen is the length of timers array.</span><span class="token comment">//</span><span class="token comment">// Ideally, this would be set to GOMAXPROCS, but that would require</span><span class="token comment">// dynamic reallocation</span><span class="token comment">//</span><span class="token comment">// The current value is a compromise between memory usage and performance</span><span class="token comment">// that should cover the majority of GOMAXPROCS values used in the wild.</span><span class="token keyword">var</span> timers <span class="token punctuation">[</span>timersLen<span class="token punctuation">]</span><span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>timersBucket<span class="token comment">// The padding should eliminate false sharing</span><span class="token comment">// between timersBucket values.</span>pad <span class="token punctuation">[</span>cpu<span class="token punctuation">.</span>CacheLinePadSize <span class="token operator">-</span> unsafe<span class="token punctuation">.</span><span class="token function">Sizeof</span><span class="token punctuation">(</span>timersBucket<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token operator">%</span>cpu<span class="token punctuation">.</span>CacheLinePadSize<span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">&#125;</span><span class="token comment">//go:notinheap</span><span class="token keyword">type</span> timersBucket <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>lock         mutexgp           <span class="token operator">*</span>gcreated      <span class="token builtin">bool</span>sleeping     <span class="token builtin">bool</span>rescheduling <span class="token builtin">bool</span>sleepUntil   <span class="token builtin">int64</span>waitnote     notet            <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>timer<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在添加 timer 对象时逻辑变成了，根据当前 p 的 id 对 timersLen 取模，得到了 p 对应的 timersBucket <code>id := uint8(getg().m.p.ptr().id) % _timersLen_</code><br>从这个优化的方法来看，以前是每个p去抢同一把锁，现在变成，每个p只会操作对应的 timersBucket（大多数情况下）。</p><ul><li><input disabled="" type="checkbox"> <strong>在超过 64 个 p 的时候，就会出现取模到同一个 bucket 中，这种情况在多核cpu(&gt;64)上是没办法避免的</strong></li><li><input disabled="" type="checkbox"> <strong>可能还有p从别的p上偷timer的情况，但是目前我还没有在代码中找到相应的地方(1.14版本中)</strong></li></ul><p>接下里我们看下执行 timer 的 <code>timerproc</code><br>1.8 版本中，全局只有一个执行 timer 的 timerproc，可以理解为只有一个消费者。1.13 中修改为每个不同的 bucket 都会有一个对应的 bucket。举个例子，比如我们有 4 个 P，就说明我们会有 4 个 bucket 和 4 个 timerproc，每当通过 addtimer 添加时，都会往 p 对应的 bucket 中添加任务，timerproc 作为消费者从中找可执行的timer，如下图：<br><img src="https://gitee.com/yangbaoqiang/images/raw/master/blogpics/1636033788855-ece14ebf-e72d-4851-9a75-de7cd60d59ba.png" alt="image.png"><br>（该图只是描述一个简单的模型，实际的生产者可能不止addtimer)</p><h3 id="timer-的“生产者”"><a href="#timer-的“生产者”" class="headerlink" title="timer 的“生产者”"></a>timer 的“生产者”</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// 如前所述，每个p对应不同的 timersBucket，那么在创建之前我们是不是应该先找到在哪个 p 上执行</span><span class="token keyword">func</span> <span class="token punctuation">(</span>t <span class="token operator">*</span>timer<span class="token punctuation">)</span> <span class="token function">assignBucket</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span>timersBucket <span class="token punctuation">&#123;</span>id <span class="token operator">:=</span> <span class="token function">uint8</span><span class="token punctuation">(</span><span class="token function">getg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>m<span class="token punctuation">.</span>p<span class="token punctuation">.</span><span class="token function">ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>id<span class="token punctuation">)</span> <span class="token operator">%</span> timersLent<span class="token punctuation">.</span>tb <span class="token operator">=</span> <span class="token operator">&amp;</span>timers<span class="token punctuation">[</span>id<span class="token punctuation">]</span><span class="token punctuation">.</span>timersBucket<span class="token keyword">return</span> t<span class="token punctuation">.</span>tb<span class="token punctuation">&#125;</span><span class="token comment">// 将 timer 添加到对应的 timersBucket 中</span><span class="token keyword">func</span> <span class="token function">addtimer</span><span class="token punctuation">(</span>t <span class="token operator">*</span>timer<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>tb <span class="token operator">:=</span> t<span class="token punctuation">.</span><span class="token function">assignBucket</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tb<span class="token punctuation">.</span>lock<span class="token punctuation">)</span>ok <span class="token operator">:=</span> tb<span class="token punctuation">.</span><span class="token function">addtimerLocked</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tb<span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token keyword">if</span> <span class="token operator">!</span>ok <span class="token punctuation">&#123;</span><span class="token function">badTimer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 咱们只把重点放在与以前不同的地方上</span><span class="token keyword">func</span> <span class="token punctuation">(</span>tb <span class="token operator">*</span>timersBucket<span class="token punctuation">)</span> <span class="token function">addtimerLocked</span><span class="token punctuation">(</span>t <span class="token operator">*</span>timer<span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> t<span class="token punctuation">.</span>when <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>t<span class="token punctuation">.</span>when <span class="token operator">=</span> <span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">63</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">&#125;</span>t<span class="token punctuation">.</span>i <span class="token operator">=</span> <span class="token function">len</span><span class="token punctuation">(</span>tb<span class="token punctuation">.</span>t<span class="token punctuation">)</span>tb<span class="token punctuation">.</span>t <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>tb<span class="token punctuation">.</span>t<span class="token punctuation">,</span> t<span class="token punctuation">)</span> <span class="token comment">// 添加到p对应的timersBucket中，而不是全局的 timers 中了</span><span class="token keyword">if</span> <span class="token operator">!</span><span class="token function">siftupTimer</span><span class="token punctuation">(</span>tb<span class="token punctuation">.</span>t<span class="token punctuation">,</span> t<span class="token punctuation">.</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> t<span class="token punctuation">.</span>i <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span><span class="token comment">// siftup moved to top: new earliest deadline.</span><span class="token keyword">if</span> tb<span class="token punctuation">.</span>sleeping <span class="token operator">&amp;&amp;</span> tb<span class="token punctuation">.</span>sleepUntil <span class="token operator">></span> t<span class="token punctuation">.</span>when <span class="token punctuation">&#123;</span>tb<span class="token punctuation">.</span>sleeping <span class="token operator">=</span> <span class="token boolean">false</span><span class="token function">notewakeup</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tb<span class="token punctuation">.</span>waitnote<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> tb<span class="token punctuation">.</span>rescheduling <span class="token punctuation">&#123;</span>tb<span class="token punctuation">.</span>rescheduling <span class="token operator">=</span> <span class="token boolean">false</span><span class="token function">goready</span><span class="token punctuation">(</span>tb<span class="token punctuation">.</span>gp<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token operator">!</span>tb<span class="token punctuation">.</span>created <span class="token punctuation">&#123;</span><span class="token comment">// 判断属于这个 tb 的 timerproc 是否启动了，区别于1.8版本是一个全局变量控制的，只有一个消费者，这里是每一个 tb 都有一个消费者</span>tb<span class="token punctuation">.</span>created <span class="token operator">=</span> <span class="token boolean">true</span><span class="token keyword">go</span> <span class="token function">timerproc</span><span class="token punctuation">(</span>tb<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="timer-的“消费者”"><a href="#timer-的“消费者”" class="headerlink" title="timer 的“消费者”"></a>timer 的“消费者”</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// 主要的逻辑还是同 1.8 版本中一致的，不同的地方就是针对每个tb进行的操作，不是全局的 timers</span><span class="token keyword">func</span> <span class="token function">timerproc</span><span class="token punctuation">(</span>tb <span class="token operator">*</span>timersBucket<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>tb<span class="token punctuation">.</span>gp <span class="token operator">=</span> <span class="token function">getg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">for</span> <span class="token punctuation">&#123;</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tb<span class="token punctuation">.</span>lock<span class="token punctuation">)</span>tb<span class="token punctuation">.</span>sleeping <span class="token operator">=</span> <span class="token boolean">false</span>now <span class="token operator">:=</span> <span class="token function">nanotime</span><span class="token punctuation">(</span><span class="token punctuation">)</span>delta <span class="token operator">:=</span> <span class="token function">int64</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">for</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>tb<span class="token punctuation">.</span>t<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>delta <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token keyword">break</span><span class="token punctuation">&#125;</span>t <span class="token operator">:=</span> tb<span class="token punctuation">.</span>t<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>delta <span class="token operator">=</span> t<span class="token punctuation">.</span>when <span class="token operator">-</span> now<span class="token keyword">if</span> delta <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">&#123;</span><span class="token keyword">break</span><span class="token punctuation">&#125;</span>ok <span class="token operator">:=</span> <span class="token boolean">true</span><span class="token keyword">if</span> t<span class="token punctuation">.</span>period <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">&#123;</span><span class="token comment">// leave in heap but adjust next time to fire</span>t<span class="token punctuation">.</span>when <span class="token operator">+=</span> t<span class="token punctuation">.</span>period <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">+</span> <span class="token operator">-</span>delta<span class="token operator">/</span>t<span class="token punctuation">.</span>period<span class="token punctuation">)</span><span class="token keyword">if</span> <span class="token operator">!</span><span class="token function">siftdownTimer</span><span class="token punctuation">(</span>tb<span class="token punctuation">.</span>t<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>ok <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span><span class="token comment">// remove from heap</span>last <span class="token operator">:=</span> <span class="token function">len</span><span class="token punctuation">(</span>tb<span class="token punctuation">.</span>t<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token keyword">if</span> last <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>tb<span class="token punctuation">.</span>t<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> tb<span class="token punctuation">.</span>t<span class="token punctuation">[</span>last<span class="token punctuation">]</span>tb<span class="token punctuation">.</span>t<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">&#125;</span>tb<span class="token punctuation">.</span>t<span class="token punctuation">[</span>last<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">nil</span>tb<span class="token punctuation">.</span>t <span class="token operator">=</span> tb<span class="token punctuation">.</span>t<span class="token punctuation">[</span><span class="token punctuation">:</span>last<span class="token punctuation">]</span><span class="token keyword">if</span> last <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token operator">!</span><span class="token function">siftdownTimer</span><span class="token punctuation">(</span>tb<span class="token punctuation">.</span>t<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>ok <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>t<span class="token punctuation">.</span>i <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token comment">// mark as removed</span><span class="token punctuation">&#125;</span>f <span class="token operator">:=</span> t<span class="token punctuation">.</span>farg <span class="token operator">:=</span> t<span class="token punctuation">.</span>argseq <span class="token operator">:=</span> t<span class="token punctuation">.</span>seq<span class="token function">unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tb<span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token keyword">if</span> <span class="token operator">!</span>ok <span class="token punctuation">&#123;</span><span class="token function">badTimer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> raceenabled <span class="token punctuation">&#123;</span><span class="token function">raceacquire</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token function">f</span><span class="token punctuation">(</span>arg<span class="token punctuation">,</span> seq<span class="token punctuation">)</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tb<span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> delta <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> faketime <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">&#123;</span><span class="token comment">// No timers left - put goroutine to sleep.</span>tb<span class="token punctuation">.</span>rescheduling <span class="token operator">=</span> <span class="token boolean">true</span><span class="token function">goparkunlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tb<span class="token punctuation">.</span>lock<span class="token punctuation">,</span> waitReasonTimerGoroutineIdle<span class="token punctuation">,</span> traceEvGoBlock<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">continue</span><span class="token punctuation">&#125;</span><span class="token comment">// At least one timer pending. Sleep until then.</span>tb<span class="token punctuation">.</span>sleeping <span class="token operator">=</span> <span class="token boolean">true</span>tb<span class="token punctuation">.</span>sleepUntil <span class="token operator">=</span> now <span class="token operator">+</span> delta<span class="token function">noteclear</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tb<span class="token punctuation">.</span>waitnote<span class="token punctuation">)</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tb<span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token function">notetsleepg</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tb<span class="token punctuation">.</span>waitnote<span class="token punctuation">,</span> delta<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>相比于 1.8，1.13版本中还添加了一个 <code>modtimer(t *timer, when, period int64, f func(interface&#123;&#125;, uintptr), arg interface&#123;&#125;, seq uintptr)</code><br>modtimer 函数主要做了，将 t 从 tb 中删除，然后有 重新给它 加入进去</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">modtimer</span><span class="token punctuation">(</span>t <span class="token operator">*</span>timer<span class="token punctuation">,</span> when<span class="token punctuation">,</span> period <span class="token builtin">int64</span><span class="token punctuation">,</span> f <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token builtin">uintptr</span><span class="token punctuation">)</span><span class="token punctuation">,</span> arg <span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> seq <span class="token builtin">uintptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>tb <span class="token operator">:=</span> t<span class="token punctuation">.</span>tb<span class="token function">lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tb<span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token boolean">_</span><span class="token punctuation">,</span> ok <span class="token operator">:=</span> tb<span class="token punctuation">.</span><span class="token function">deltimerLocked</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token keyword">if</span> ok <span class="token punctuation">&#123;</span>t<span class="token punctuation">.</span>when <span class="token operator">=</span> whent<span class="token punctuation">.</span>period <span class="token operator">=</span> periodt<span class="token punctuation">.</span>f <span class="token operator">=</span> ft<span class="token punctuation">.</span>arg <span class="token operator">=</span> argt<span class="token punctuation">.</span>seq <span class="token operator">=</span> seqok <span class="token operator">=</span> tb<span class="token punctuation">.</span><span class="token function">addtimerLocked</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tb<span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token keyword">if</span> <span class="token operator">!</span>ok <span class="token punctuation">&#123;</span><span class="token function">badTimer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 netpoll 中，有两处地方调用了这个函数，主要就是给 fd 调整超时处理使用的。<br>​</p><p>总的来说这个版本中的优化只是做了全局锁粒度的拆分，上下文切换带来额外的性能开销仍然没有得到优化，不过不要着急，1.14 版本中针对这个问题已经做了妥善的处理，我们马上就来看一下。<br>​</p><h2 id="1-14-中的优化"><a href="#1-14-中的优化" class="headerlink" title="1.14 中的优化"></a>1.14 中的优化</h2><h3 id="环境信息-1"><a href="#环境信息-1" class="headerlink" title="环境信息"></a>环境信息</h3><p>go version: go1.14.1<br>compute: linux, centos7<br>​</p><h3 id="timer-结构的变化-1"><a href="#timer-结构的变化-1" class="headerlink" title="timer 结构的变化"></a>timer 结构的变化</h3><p>以前的结构体都是全局变量，在 1.14 版本开始，timer 结构体就内嵌到了 P 中。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// Package time knows the layout of this structure.</span><span class="token comment">// If this struct changes, adjust ../time/sleep.go:/runtimeTimer.</span><span class="token keyword">type</span> timer <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span><span class="token comment">// If this timer is on a heap, which P's heap it is on.</span><span class="token comment">// puintptr rather than *p to match uintptr in the versions</span><span class="token comment">// of this struct defined in other packages.</span>pp puintptr<span class="token comment">// Timer wakes up at when, and then at when+period, ... (period > 0 only)</span><span class="token comment">// each time calling f(arg, now) in the timer goroutine, so f must be</span><span class="token comment">// a well-behaved function and not block.</span>when   <span class="token builtin">int64</span>period <span class="token builtin">int64</span>f      <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token builtin">uintptr</span><span class="token punctuation">)</span>arg    <span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>seq    <span class="token builtin">uintptr</span><span class="token comment">// What to set the when field to in timerModifiedXX status.</span>nextwhen <span class="token builtin">int64</span><span class="token comment">// The status field holds one of the values below.</span>status <span class="token builtin">uint32</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> p <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>id          <span class="token builtin">int32</span>        <span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">)</span>    <span class="token comment">// Lock for timers. We normally access the timers while running</span><span class="token comment">// on this P, but the scheduler can also do it from a different P.</span>    <span class="token comment">// 讲道理，你p处理本地的 timer 用锁干什么？</span>    <span class="token comment">// 1.14 是可以偷 timer 的，这时候就变成了共享资源，访问的时候是一定要加锁的。</span>    <span class="token comment">// 上边注释（英文）说的也很清楚，这个是官方的解释</span>timersLock mutex<span class="token comment">// Actions to take at some time. This is used to implement the</span><span class="token comment">// standard library's time package.</span><span class="token comment">// Must hold timersLock to access.</span>timers <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>timer<span class="token comment">// Number of timers in P's heap.</span><span class="token comment">// Modified using atomic instructions.</span>    <span class="token comment">// 记录当前 p 中 timer的总数量</span>numTimers <span class="token builtin">uint32</span><span class="token comment">// Number of timerModifiedEarlier timers on P's heap.</span><span class="token comment">// This should only be modified while holding timersLock,</span><span class="token comment">// or while the timer status is in a transient state</span><span class="token comment">// such as timerModifying.</span>    <span class="token comment">// P 中 调整 when 的时间提前了的 timer 数量</span>adjustTimers <span class="token builtin">uint32</span><span class="token comment">// Number of timerDeleted timers in P's heap.</span><span class="token comment">// Modified using atomic instructions.</span>    <span class="token comment">// 记录 p 中被删除的 timer 数量</span>deletedTimers <span class="token builtin">uint32</span><span class="token comment">// Race context used while executing timer functions.</span>timerRaceCtx <span class="token builtin">uintptr</span>        <span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="timer-的“生产者”-1"><a href="#timer-的“生产者”-1" class="headerlink" title="timer 的“生产者”"></a>timer 的“生产者”</h3><p><code>TODO ... 基本上大同小异，只不过是加了一些状态</code><br>不过需要注意的一点是，1.14 中有了 timer 和 netpoll 的结合。我的理解是：<br>findrunnable 最后没有找到可执行的 g 的时候会再检查 netpoll。这个调用过程是阻塞的，阻塞 delta 这段时间，然后这时候比如说我通过 addtimer 加入新timer，就是假设哈，1s 后要执行，然后你那个阻塞过程要阻塞 3s，但这是在阻塞没有办法执行我们的 timer，然后这时候 addtimer 中的 wakenetpoller 就派上用场，通过 <code>netpollbreak</code> 中断那个阻塞调用，然后就回到 <code>findrunnable</code> 继续执行，及时响应那个近期的 timer 对象。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// addtimer:</span><span class="token comment">//   timerNoStatus   -> timerWaiting</span><span class="token comment">//   anything else   -> panic: invalid value</span><span class="token comment">// deltimer:</span><span class="token comment">//   timerWaiting         -> timerModifying -> timerDeleted</span><span class="token comment">//   timerModifiedEarlier -> timerModifying -> timerDeleted</span><span class="token comment">//   timerModifiedLater   -> timerModifying -> timerDeleted</span><span class="token comment">//   timerNoStatus        -> do nothing</span><span class="token comment">//   timerDeleted         -> do nothing</span><span class="token comment">//   timerRemoving        -> do nothing</span><span class="token comment">//   timerRemoved         -> do nothing</span><span class="token comment">//   timerRunning         -> wait until status changes</span><span class="token comment">//   timerMoving          -> wait until status changes</span><span class="token comment">//   timerModifying       -> wait until status changes</span><span class="token comment">// modtimer:</span><span class="token comment">//   timerWaiting    -> timerModifying -> timerModifiedXX</span><span class="token comment">//   timerModifiedXX -> timerModifying -> timerModifiedYY</span><span class="token comment">//   timerNoStatus   -> timerModifying -> timerWaiting</span><span class="token comment">//   timerRemoved    -> timerModifying -> timerWaiting</span><span class="token comment">//   timerDeleted    -> timerModifying -> timerModifiedXX</span><span class="token comment">//   timerRunning    -> wait until status changes</span><span class="token comment">//   timerMoving     -> wait until status changes</span><span class="token comment">//   timerRemoving   -> wait until status changes</span><span class="token comment">//   timerModifying  -> wait until status changes</span><span class="token comment">// cleantimers (looks in P's timer heap):</span><span class="token comment">//   timerDeleted    -> timerRemoving -> timerRemoved</span><span class="token comment">//   timerModifiedXX -> timerMoving -> timerWaiting</span><span class="token comment">// adjusttimers (looks in P's timer heap):</span><span class="token comment">//   timerDeleted    -> timerRemoving -> timerRemoved</span><span class="token comment">//   timerModifiedXX -> timerMoving -> timerWaiting</span><span class="token comment">// runtimer (looks in P's timer heap):</span><span class="token comment">//   timerNoStatus   -> panic: uninitialized timer</span><span class="token comment">//   timerWaiting    -> timerWaiting or</span><span class="token comment">//   timerWaiting    -> timerRunning -> timerNoStatus or</span><span class="token comment">//   timerWaiting    -> timerRunning -> timerWaiting</span><span class="token comment">//   timerModifying  -> wait until status changes</span><span class="token comment">//   timerModifiedXX -> timerMoving -> timerWaiting</span><span class="token comment">//   timerDeleted    -> timerRemoving -> timerRemoved</span><span class="token comment">//   timerRunning    -> panic: concurrent runtimer calls</span><span class="token comment">//   timerRemoved    -> panic: inconsistent timer heap</span><span class="token comment">//   timerRemoving   -> panic: inconsistent timer heap</span><span class="token comment">//   timerMoving     -> panic: inconsistent timer heap</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="timer-的“消费者”-1"><a href="#timer-的“消费者”-1" class="headerlink" title="timer 的“消费者”"></a>timer 的“消费者”</h3><p>新版本中的“消费者”有着非常重要的改变，<code>timerproc</code> 没了，首先我们要明确：<br>timerproc 不仅仅是一个函数，它是 runtime 创建的一个 goroutine，因此可知，以前的“消费者”就是一个 goroutine， 它并没有什么不同，同样被 <code>scheduler</code>调度。</p><p>1.14 中，直接给“消费者”升到“头等舱”，看你小子干活勤勤恳恳，scheduler说，你来我这上班吧，结果人家就去了。<br>​</p><p>1.14 中，timer 的消费者就是在调度循环的 <code>schedule</code> 中，其次就是 <code>sysmon</code> （sysmon作为兜底），我们看下源码，看看新版本的消费者是怎么“晋升”的。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">schedule</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">)</span> <span class="token comment">// 省略安全检查</span>        <span class="token comment">// 看看人家 timer 直接被安排到顶级位置</span>    <span class="token comment">// 调度循环上来就是先检查 timer</span><span class="token function">checkTimers</span><span class="token punctuation">(</span>pp<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> gp <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>gp<span class="token punctuation">,</span> inheritTime <span class="token operator">=</span> <span class="token function">findrunnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// blocks until work is available</span><span class="token punctuation">&#125;</span>    <span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">)</span>    <span class="token function">execute</span><span class="token punctuation">(</span>gp<span class="token punctuation">,</span> inheritTime<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以得出结论，新版本的“消费者” 从 goroutine 级别 转变到 函数级别。（我自己总结的，可能措辞用的不好，希望我表达的意思你们能明白。。）<br>这样做的好处：不需要被 <code>scheduler</code> 调度，减少了上下文的切换。<br>​</p><h4 id="checkTimers"><a href="#checkTimers" class="headerlink" title="checkTimers()"></a>checkTimers()</h4><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// checkTimers runs any timers for the P that are ready.</span><span class="token comment">// If now is not 0 it is the current time.</span><span class="token comment">// It returns the current time or 0 if it is not known,</span><span class="token comment">// and the time when the next timer should run or 0 if there is no next timer,</span><span class="token comment">// and reports whether it ran any timers.</span><span class="token comment">// If the time when the next timer should run is not 0,</span><span class="token comment">// it is always larger than the returned time.</span><span class="token comment">// We pass now in and out to avoid extra calls of nanotime.</span><span class="token comment">//go:yeswritebarrierrec</span><span class="token comment">// rnow</span><span class="token comment">// pollUntil 0 表示没有下一个 timer，非 0 表示下一个timer的等待时间</span><span class="token comment">// ran  表示是否执行了 timer</span><span class="token keyword">func</span> <span class="token function">checkTimers</span><span class="token punctuation">(</span>pp <span class="token operator">*</span>p<span class="token punctuation">,</span> now <span class="token builtin">int64</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>rnow<span class="token punctuation">,</span> pollUntil <span class="token builtin">int64</span><span class="token punctuation">,</span> ran <span class="token builtin">bool</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// If there are no timers to adjust, and the first timer on</span><span class="token comment">// the heap is not yet ready to run, then there is nothing to do.</span><span class="token keyword">if</span> atomic<span class="token punctuation">.</span><span class="token function">Load</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pp<span class="token punctuation">.</span>adjustTimers<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>next <span class="token operator">:=</span> <span class="token function">int64</span><span class="token punctuation">(</span>atomic<span class="token punctuation">.</span><span class="token function">Load64</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pp<span class="token punctuation">.</span>timer0When<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">if</span> next <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> now<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> now <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>now <span class="token operator">=</span> <span class="token function">nanotime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> now <span class="token operator">&lt;</span> next <span class="token punctuation">&#123;</span><span class="token comment">// Next timer is not ready to run.</span><span class="token comment">// But keep going if we would clear deleted timers.</span><span class="token comment">// This corresponds to the condition below where</span><span class="token comment">// we decide whether to call clearDeletedTimers.</span>            <span class="token comment">// 尽可能找机会清理 timer</span><span class="token keyword">if</span> pp <span class="token operator">!=</span> <span class="token function">getg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>m<span class="token punctuation">.</span>p<span class="token punctuation">.</span><span class="token function">ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">int</span><span class="token punctuation">(</span>atomic<span class="token punctuation">.</span><span class="token function">Load</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pp<span class="token punctuation">.</span>deletedTimers<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token function">int</span><span class="token punctuation">(</span>atomic<span class="token punctuation">.</span><span class="token function">Load</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pp<span class="token punctuation">.</span>numTimers<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> now<span class="token punctuation">,</span> next<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pp<span class="token punctuation">.</span>timersLock<span class="token punctuation">)</span><span class="token function">adjusttimers</span><span class="token punctuation">(</span>pp<span class="token punctuation">)</span>rnow <span class="token operator">=</span> now<span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>pp<span class="token punctuation">.</span>timers<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> rnow <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>rnow <span class="token operator">=</span> <span class="token function">nanotime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span> <span class="token function">len</span><span class="token punctuation">(</span>pp<span class="token punctuation">.</span>timers<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">&#123;</span><span class="token comment">// Note that runtimer may temporarily unlock</span><span class="token comment">// pp.timersLock.</span><span class="token keyword">if</span> tw <span class="token operator">:=</span> <span class="token function">runtimer</span><span class="token punctuation">(</span>pp<span class="token punctuation">,</span> rnow<span class="token punctuation">)</span><span class="token punctuation">;</span> tw <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> tw <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>pollUntil <span class="token operator">=</span> tw<span class="token punctuation">&#125;</span><span class="token keyword">break</span><span class="token punctuation">&#125;</span>ran <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// If this is the local P, and there are a lot of deleted timers,</span><span class="token comment">// clear them out. We only do this for the local P to reduce</span><span class="token comment">// lock contention on timersLock.</span><span class="token keyword">if</span> pp <span class="token operator">==</span> <span class="token function">getg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>m<span class="token punctuation">.</span>p<span class="token punctuation">.</span><span class="token function">ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">int</span><span class="token punctuation">(</span>atomic<span class="token punctuation">.</span><span class="token function">Load</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pp<span class="token punctuation">.</span>deletedTimers<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token function">len</span><span class="token punctuation">(</span>pp<span class="token punctuation">.</span>timers<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">4</span> <span class="token punctuation">&#123;</span><span class="token function">clearDeletedTimers</span><span class="token punctuation">(</span>pp<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pp<span class="token punctuation">.</span>timersLock<span class="token punctuation">)</span><span class="token keyword">return</span> rnow<span class="token punctuation">,</span> pollUntil<span class="token punctuation">,</span> ran<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上述 <code>checkTimers</code> 中，通过 <code>adjusttimers</code> 调整当前 p 的 timers 数组，我们看一下它的实现</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// adjusttimers looks through the timers in the current P's heap for</span><span class="token comment">// any timers that have been modified to run earlier, and puts them in</span><span class="token comment">// the correct place in the heap. While looking for those timers,</span><span class="token comment">// it also moves timers that have been modified to run later,</span><span class="token comment">// and removes deleted timers. The caller must have locked the timers for pp.</span><span class="token keyword">func</span> <span class="token function">adjusttimers</span><span class="token punctuation">(</span>pp <span class="token operator">*</span>p<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 判断当前 p 是否有 timer</span><span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>pp<span class="token punctuation">.</span>timers<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> atomic<span class="token punctuation">.</span><span class="token function">Load</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pp<span class="token punctuation">.</span>adjustTimers<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> verifyTimers <span class="token punctuation">&#123;</span><span class="token function">verifyTimerHeap</span><span class="token punctuation">(</span>pp<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span><span class="token punctuation">&#125;</span>    <span class="token comment">// 存放需要移动的 timer</span><span class="token keyword">var</span> moved <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>timerloop<span class="token punctuation">:</span>    <span class="token comment">// 遍历当前 p 的 timers</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token function">len</span><span class="token punctuation">(</span>pp<span class="token punctuation">.</span>timers<span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>t <span class="token operator">:=</span> pp<span class="token punctuation">.</span>timers<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token keyword">if</span> t<span class="token punctuation">.</span>pp<span class="token punctuation">.</span><span class="token function">ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> pp <span class="token punctuation">&#123;</span><span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">"adjusttimers: bad p"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span>        <span class="token comment">// 判断当前 timer 的状态</span><span class="token keyword">switch</span> s <span class="token operator">:=</span> atomic<span class="token punctuation">.</span><span class="token function">Load</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t<span class="token punctuation">.</span>status<span class="token punctuation">)</span><span class="token punctuation">;</span> s <span class="token punctuation">&#123;</span>        <span class="token comment">// 表示 timer 需要删除，但是还没有删除呢</span><span class="token keyword">case</span> timerDeleted<span class="token punctuation">:</span>            <span class="token comment">// 修改 timer 的状态为，正在删除中 timerRemoving</span><span class="token keyword">if</span> atomic<span class="token punctuation">.</span><span class="token function">Cas</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t<span class="token punctuation">.</span>status<span class="token punctuation">,</span> s<span class="token punctuation">,</span> timerRemoving<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 执行删除操作</span><span class="token function">dodeltimer</span><span class="token punctuation">(</span>pp<span class="token punctuation">,</span> i<span class="token punctuation">)</span>                <span class="token comment">// 修改 timer 的状态为，已删除 timerRemoved</span><span class="token keyword">if</span> <span class="token operator">!</span>atomic<span class="token punctuation">.</span><span class="token function">Cas</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t<span class="token punctuation">.</span>status<span class="token punctuation">,</span> timerRemoving<span class="token punctuation">,</span> timerRemoved<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">badTimer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span>                <span class="token comment">// 修改待删除 timer 的数量 pp.deletedTimers - 1</span>atomic<span class="token punctuation">.</span><span class="token function">Xadd</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pp<span class="token punctuation">.</span>deletedTimers<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">// Look at this heap position again.</span>                <span class="token comment">// 思考一下就可以知道，为什么需要再次检查当前这个位置的 timer</span>                <span class="token comment">// 通过 dodeltimer 将索引为 i 的 timer 删除后，我们知道的是</span>                <span class="token comment">// 假设总数量为 n, [0, i) 之前的元素不需要改变，删掉第 I 个后</span>                <span class="token comment">// 需要在 [i,n-1) 里边中选一个填补 i 的位置，所以需要重新检查一次</span>i<span class="token operator">--</span><span class="token punctuation">&#125;</span>        <span class="token comment">// 表示 timer 的等待时间被调整了</span>        <span class="token comment">// timerModifiedEarlier 向前调整</span>        <span class="token comment">// timerModifiedLater 向后调整</span><span class="token keyword">case</span> timerModifiedEarlier<span class="token punctuation">,</span> timerModifiedLater<span class="token punctuation">:</span>            <span class="token comment">// 因为调整了 timer 的时间点，所以需要重新调整该 timer 在堆中的位置</span>            <span class="token comment">// 修改 timer 状态为，移动中 timerMoving</span><span class="token keyword">if</span> atomic<span class="token punctuation">.</span><span class="token function">Cas</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t<span class="token punctuation">.</span>status<span class="token punctuation">,</span> s<span class="token punctuation">,</span> timerMoving<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// Now we can change the when field.</span>t<span class="token punctuation">.</span>when <span class="token operator">=</span> t<span class="token punctuation">.</span>nextwhen<span class="token comment">// Take t off the heap, and hold onto it.</span><span class="token comment">// We don't add it back yet because the</span><span class="token comment">// heap manipulation could cause our</span><span class="token comment">// loop to skip some other timer.</span><span class="token function">dodeltimer</span><span class="token punctuation">(</span>pp<span class="token punctuation">,</span> i<span class="token punctuation">)</span>                <span class="token comment">// 将这个 timer 加入到需要移动的 timer 当中</span>moved <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>moved<span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token keyword">if</span> s <span class="token operator">==</span> timerModifiedEarlier <span class="token punctuation">&#123;</span><span class="token keyword">if</span> n <span class="token operator">:=</span> atomic<span class="token punctuation">.</span><span class="token function">Xadd</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pp<span class="token punctuation">.</span>adjustTimers<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">int32</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span><span class="token keyword">break</span> loop<span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// Look at this heap position again.</span>i<span class="token operator">--</span><span class="token punctuation">&#125;</span><span class="token keyword">case</span> timerNoStatus<span class="token punctuation">,</span> timerRunning<span class="token punctuation">,</span> timerRemoving<span class="token punctuation">,</span> timerRemoved<span class="token punctuation">,</span> timerMoving<span class="token punctuation">:</span><span class="token function">badTimer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">case</span> timerWaiting<span class="token punctuation">:</span><span class="token comment">// OK, nothing to do.</span><span class="token keyword">case</span> timerModifying<span class="token punctuation">:</span><span class="token comment">// Check again after modification is complete.</span><span class="token function">osyield</span><span class="token punctuation">(</span><span class="token punctuation">)</span>i<span class="token operator">--</span><span class="token keyword">default</span><span class="token punctuation">:</span><span class="token function">badTimer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>moved<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 将 timer 重新加入到当前 p 的 timers 中</span>        <span class="token comment">// 并且按照小顶堆进行排序</span><span class="token function">addAdjustedTimers</span><span class="token punctuation">(</span>pp<span class="token punctuation">,</span> moved<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> verifyTimers <span class="token punctuation">&#123;</span><span class="token function">verifyTimerHeap</span><span class="token punctuation">(</span>pp<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后我们再看一下 <code>checkTimers</code> 函数末尾的位置，就是要真正执行 timer 的时候了，通过 <code>runtimer</code> 来执行 p 中的 timer</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// runtimer examines the first timer in timers. If it is ready based on now,</span><span class="token comment">// it runs the timer and removes or updates it.</span><span class="token comment">// Returns 0 if it ran a timer, -1 if there are no more timers, or the time</span><span class="token comment">// when the first timer should run.</span><span class="token comment">// The caller must have locked the timers for pp.</span><span class="token comment">// If a timer is run, this will temporarily unlock the timers.</span><span class="token comment">/*根据上述注释可以了解到:    返回值 = 0;  表示执行了一个 timer    返回值 = -1; 表示 p 中没有 timer 了    返回值 > 0;  表示第一个 timer 要执行的时间点    （这里的源码就不做过多分析了，没有什么可说的，基本上都覆盖到了）*/</span><span class="token comment">//go:systemstack</span><span class="token keyword">func</span> <span class="token function">runtimer</span><span class="token punctuation">(</span>pp <span class="token operator">*</span>p<span class="token punctuation">,</span> now <span class="token builtin">int64</span><span class="token punctuation">)</span> <span class="token builtin">int64</span> <span class="token punctuation">&#123;</span><span class="token keyword">for</span> <span class="token punctuation">&#123;</span>t <span class="token operator">:=</span> pp<span class="token punctuation">.</span>timers<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token keyword">if</span> t<span class="token punctuation">.</span>pp<span class="token punctuation">.</span><span class="token function">ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> pp <span class="token punctuation">&#123;</span><span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">"runtimer: bad p"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">switch</span> s <span class="token operator">:=</span> atomic<span class="token punctuation">.</span><span class="token function">Load</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t<span class="token punctuation">.</span>status<span class="token punctuation">)</span><span class="token punctuation">;</span> s <span class="token punctuation">&#123;</span><span class="token keyword">case</span> timerWaiting<span class="token punctuation">:</span><span class="token keyword">if</span> t<span class="token punctuation">.</span>when <span class="token operator">></span> now <span class="token punctuation">&#123;</span><span class="token comment">// Not ready to run.</span><span class="token keyword">return</span> t<span class="token punctuation">.</span>when<span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token operator">!</span>atomic<span class="token punctuation">.</span><span class="token function">Cas</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t<span class="token punctuation">.</span>status<span class="token punctuation">,</span> s<span class="token punctuation">,</span> timerRunning<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">continue</span><span class="token punctuation">&#125;</span><span class="token comment">// Note that runOneTimer may temporarily unlock</span><span class="token comment">// pp.timersLock.</span><span class="token function">runOneTimer</span><span class="token punctuation">(</span>pp<span class="token punctuation">,</span> t<span class="token punctuation">,</span> now<span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token keyword">case</span> timerDeleted<span class="token punctuation">:</span><span class="token keyword">if</span> <span class="token operator">!</span>atomic<span class="token punctuation">.</span><span class="token function">Cas</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t<span class="token punctuation">.</span>status<span class="token punctuation">,</span> s<span class="token punctuation">,</span> timerRemoving<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">continue</span><span class="token punctuation">&#125;</span><span class="token function">dodeltimer0</span><span class="token punctuation">(</span>pp<span class="token punctuation">)</span><span class="token keyword">if</span> <span class="token operator">!</span>atomic<span class="token punctuation">.</span><span class="token function">Cas</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t<span class="token punctuation">.</span>status<span class="token punctuation">,</span> timerRemoving<span class="token punctuation">,</span> timerRemoved<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">badTimer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span>atomic<span class="token punctuation">.</span><span class="token function">Xadd</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pp<span class="token punctuation">.</span>deletedTimers<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>pp<span class="token punctuation">.</span>timers<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token keyword">case</span> timerModifiedEarlier<span class="token punctuation">,</span> timerModifiedLater<span class="token punctuation">:</span><span class="token keyword">if</span> <span class="token operator">!</span>atomic<span class="token punctuation">.</span><span class="token function">Cas</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t<span class="token punctuation">.</span>status<span class="token punctuation">,</span> s<span class="token punctuation">,</span> timerMoving<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">continue</span><span class="token punctuation">&#125;</span>t<span class="token punctuation">.</span>when <span class="token operator">=</span> t<span class="token punctuation">.</span>nextwhen<span class="token function">dodeltimer0</span><span class="token punctuation">(</span>pp<span class="token punctuation">)</span><span class="token function">doaddtimer</span><span class="token punctuation">(</span>pp<span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token keyword">if</span> s <span class="token operator">==</span> timerModifiedEarlier <span class="token punctuation">&#123;</span>atomic<span class="token punctuation">.</span><span class="token function">Xadd</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pp<span class="token punctuation">.</span>adjustTimers<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token operator">!</span>atomic<span class="token punctuation">.</span><span class="token function">Cas</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t<span class="token punctuation">.</span>status<span class="token punctuation">,</span> timerMoving<span class="token punctuation">,</span> timerWaiting<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">badTimer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">case</span> timerModifying<span class="token punctuation">:</span><span class="token comment">// Wait for modification to complete.</span><span class="token function">osyield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">case</span> timerNoStatus<span class="token punctuation">,</span> timerRemoved<span class="token punctuation">:</span><span class="token comment">// Should not see a new or inactive timer on the heap.</span><span class="token function">badTimer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">case</span> timerRunning<span class="token punctuation">,</span> timerRemoving<span class="token punctuation">,</span> timerMoving<span class="token punctuation">:</span><span class="token comment">// These should only be set when timers are locked,</span><span class="token comment">// and we didn't do it.</span><span class="token function">badTimer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">default</span><span class="token punctuation">:</span><span class="token function">badTimer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>截止到目前为止，我们已经把 <code>checkTimers</code> 给分析完了。</p><h3 id="偷-timer"><a href="#偷-timer" class="headerlink" title="偷 timer"></a>偷 timer</h3><p>这里的偷 timer 不是说把 另一个 p 的 timer 偷到我本地后再执行，而是在当前这个 p ，执行其他 p timer。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// 截取部分 findrunnable 代码</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span><span class="token keyword">for</span> enum <span class="token operator">:=</span> stealOrder<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token function">fastrand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">!</span>enum<span class="token punctuation">.</span><span class="token function">done</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> enum<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">)</span>                        <span class="token keyword">if</span> i <span class="token operator">></span> <span class="token number">2</span> <span class="token operator">&amp;&amp;</span> <span class="token function">shouldStealTimers</span><span class="token punctuation">(</span>p2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>tnow<span class="token punctuation">,</span> w<span class="token punctuation">,</span> ran <span class="token operator">:=</span> <span class="token function">checkTimers</span><span class="token punctuation">(</span>p2<span class="token punctuation">,</span> now<span class="token punctuation">)</span>                <span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">)</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="后语"><a href="#后语" class="headerlink" title="后语"></a>后语</h2><p>给大家分享一下我在整理过程中的参考资料吧：<br><em>1.luozhiyun Go中定时器实现原理及源码解析</em><br>   <a href="https://www.cnblogs.com/luozhiyun/p/14494540.html"><em>https://www.cnblogs.com/luozhiyun/p/14494540.html</em></a><br><em>2.猪吃鱼 Netpoll 解析</em><br>   <a href="https://www.pefish.club/2020/05/04/Golang/1011Netpoll%E8%A7%A3%E6%9E%90/"><em>https://www.pefish.club/2020/05/04/Golang/1011Netpoll%E8%A7%A3%E6%9E%90/</em></a><br>_3.issues _<br>   <a href="https://github.com/golang/go/issues/6239"><em>https://github.com/golang/go/issues/6239</em></a><br><em>4.峰云就她了  go1.14基于netpoll定时器实现原理</em><br>   <a href="http://xiaorui.cc/archives/6483"><em>http://xiaorui.cc/archives/6483</em></a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;我们已经知道了，老版本 timer 的性能瓶颈主要是在那把全局锁以及频繁的上下文切换上，今天我们看看 go 大佬们通过哪种方式进行优化的。&lt;br&gt;​&lt;/p&gt;
&lt;p&gt;在这里解释一下为什么选择这几个版本，据我所知啊，从 1.10 版本以前都是像上一篇文中所描述的那样，在 1.10 版本开始就做了这个优化，但从 1.14 开始又对 timer 进行了优化，所以我选择了 1.8， 1.13， 1.14 这几个邻近的作为参考。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>timer 源码分析</title>
    <link href="http://bqyang.top/2021/11/14/timer%20%E6%B5%85%E6%9E%90/"/>
    <id>http://bqyang.top/2021/11/14/timer%20%E6%B5%85%E6%9E%90/</id>
    <published>2021-11-14T14:46:05.911Z</published>
    <updated>2021-11-15T03:17:27.708Z</updated>
    
    <content type="html"><![CDATA[<p>golang timer 的优化过程以及底层实现。</p><span id="more"></span><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>buzhidaoxieshenme</p><h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3><ul><li>go version：go1.8</li><li>compute: linux, centos7</li></ul><h3 id="带着问题出发"><a href="#带着问题出发" class="headerlink" title="带着问题出发"></a>带着问题出发</h3><p>1.数据结构-堆，有什么特征？<br>2.timer 在执行用户函数的时候是否新建了 goroutine？<br>3.当 timer 需要阻塞时，g 被谁接管了？<br>4.timer 中有两种不同的挂起方式分别是？</p><h3 id="timer-中的“增删改查”"><a href="#timer-中的“增删改查”" class="headerlink" title="timer 中的“增删改查”"></a>timer 中的“增删改查”</h3><h4 id="timer-的创建"><a href="#timer-的创建" class="headerlink" title="timer 的创建"></a>timer 的创建</h4><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// 可以理解为 timer 的入口</span><span class="token keyword">func</span> <span class="token function">startTimer</span><span class="token punctuation">(</span>t <span class="token operator">*</span>timer<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> raceenabled <span class="token punctuation">&#123;</span><span class="token function">racerelease</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">// 将新的 timer 加入到全局的 timers 中</span>    <span class="token function">addtimer</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id=""><a href="#" class="headerlink" title=""></a></h4><h4 id="addtimer"><a href="#addtimer" class="headerlink" title="addtimer"></a>addtimer</h4><p>了解添加 timer 的过程：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">/*再次说明版本!! go1.8 !!*/</span><span class="token comment">// 向全局 timers 中添加 timer</span><span class="token keyword">func</span> <span class="token function">addtimer</span><span class="token punctuation">(</span>t <span class="token operator">*</span>timer<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// 要访问全局的 timers 加锁</span>    <span class="token function">lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>timers<span class="token punctuation">.</span>lock<span class="token punctuation">)</span>    <span class="token comment">// 将 t 加入到 timers 中</span><span class="token function">addtimerLocked</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span>     <span class="token comment">// 添加完成，释放锁</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>timers<span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">addtimerLocked</span><span class="token punctuation">(</span>t <span class="token operator">*</span>timer<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// when must never be negative; otherwise timerproc will overflow</span><span class="token comment">// during its delta calculation and never expire other runtime timers.</span><span class="token keyword">if</span> t<span class="token punctuation">.</span>when <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>t<span class="token punctuation">.</span>when <span class="token operator">=</span> <span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">63</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">&#125;</span>    <span class="token comment">// 计算 t 在 timers 中的索引</span>t<span class="token punctuation">.</span>i <span class="token operator">=</span> <span class="token function">len</span><span class="token punctuation">(</span>timers<span class="token punctuation">.</span>t<span class="token punctuation">)</span>timers<span class="token punctuation">.</span>t <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>timers<span class="token punctuation">.</span>t<span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token comment">// 对小顶堆重新排列</span>    <span class="token function">siftupTimer</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>i<span class="token punctuation">)</span>     <span class="token comment">// 如果说 t.i == 0，意味着在所有等待执行的 timer 中，这个 timer 的值最小，排在了堆顶</span><span class="token keyword">if</span> t<span class="token punctuation">.</span>i <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span><span class="token comment">// siftup moved to top: new earliest deadline.</span>        <span class="token comment">// 如果 timers 处于 sleeping 状态，则通过 notewakeup 进行唤醒</span><span class="token keyword">if</span> timers<span class="token punctuation">.</span>sleeping <span class="token punctuation">&#123;</span>timers<span class="token punctuation">.</span>sleeping <span class="token operator">=</span> <span class="token boolean">false</span><span class="token function">notewakeup</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>timers<span class="token punctuation">.</span>waitnote<span class="token punctuation">)</span><span class="token punctuation">&#125;</span>        <span class="token comment">// 如果 timers 处于 rescheduling 状态，则通过 goready 进行唤醒</span><span class="token keyword">if</span> timers<span class="token punctuation">.</span>rescheduling <span class="token punctuation">&#123;</span>timers<span class="token punctuation">.</span>rescheduling <span class="token operator">=</span> <span class="token boolean">false</span><span class="token function">goready</span><span class="token punctuation">(</span>timers<span class="token punctuation">.</span>gp<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>    <span class="token comment">// 检查全局唯一的 timerproc 是否已经创建，没有则启动</span><span class="token keyword">if</span> <span class="token operator">!</span>timers<span class="token punctuation">.</span>created <span class="token punctuation">&#123;</span>timers<span class="token punctuation">.</span>created <span class="token operator">=</span> <span class="token boolean">true</span><span class="token keyword">go</span> <span class="token function">timerproc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们暂时可以不用理解为什么有 sleeping, rescheduling 两种状态，先掌握整体的执行过程，再深入的去看细节。<br>​</p><h4 id="timer-的删除"><a href="#timer-的删除" class="headerlink" title="timer 的删除"></a>timer 的删除</h4><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// Delete timer t from the heap.</span><span class="token comment">// Do not need to update the timerproc: if it wakes up early, no big deal.</span><span class="token keyword">func</span> <span class="token function">deltimer</span><span class="token punctuation">(</span>t <span class="token operator">*</span>timer<span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">&#123;</span><span class="token comment">// Dereference t so that any panic happens before the lock is held.</span><span class="token comment">// Discard result, because t might be moving in the heap.</span><span class="token boolean">_</span> <span class="token operator">=</span> t<span class="token punctuation">.</span>i<span class="token function">lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>timers<span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token comment">// t may not be registered anymore and may have</span><span class="token comment">// a bogus i (typically 0, if generated by Go).</span><span class="token comment">// Verify it before proceeding.</span>i <span class="token operator">:=</span> t<span class="token punctuation">.</span>ilast <span class="token operator">:=</span> <span class="token function">len</span><span class="token punctuation">(</span>timers<span class="token punctuation">.</span>t<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token keyword">if</span> i <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> i <span class="token operator">></span> last <span class="token operator">||</span> timers<span class="token punctuation">.</span>t<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> t <span class="token punctuation">&#123;</span> <span class="token comment">// 边界检查，校验 timer 是否有效</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>timers<span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> i <span class="token operator">!=</span> last <span class="token punctuation">&#123;</span><span class="token comment">// 如果要删除的 timer 不是堆中的 最后一个 timer</span>timers<span class="token punctuation">.</span>t<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> timers<span class="token punctuation">.</span>t<span class="token punctuation">[</span>last<span class="token punctuation">]</span><span class="token comment">// 堆顶元素与堆尾元素进行互换</span>timers<span class="token punctuation">.</span>t<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>i <span class="token operator">=</span> i<span class="token punctuation">&#125;</span>timers<span class="token punctuation">.</span>t<span class="token punctuation">[</span>last<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">nil</span><span class="token comment">// 上述操作已经将要删除的元素放到堆的末尾，直接通过置为 nil 的方式进行删除</span>timers<span class="token punctuation">.</span>t <span class="token operator">=</span> timers<span class="token punctuation">.</span>t<span class="token punctuation">[</span><span class="token punctuation">:</span>last<span class="token punctuation">]</span><span class="token keyword">if</span> i <span class="token operator">!=</span> last <span class="token punctuation">&#123;</span><span class="token comment">// 重新对堆进行排列</span><span class="token function">siftupTimer</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token function">siftdownTimer</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>timers<span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token comment">// 删除并重排序完成，释放掉timer的全局锁</span><span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="timerproc"><a href="#timerproc" class="headerlink" title="timerproc"></a>timerproc</h4><p>addtimer 是生产者的话，我们可以把 timerproc 理解为消费者。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">timerproc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 注意这里！将执行timerproc的 goroutine 赋值给了 timers 中的 gp 字段。</span>timers<span class="token punctuation">.</span>gp <span class="token operator">=</span> <span class="token function">getg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">for</span> <span class="token punctuation">&#123;</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>timers<span class="token punctuation">.</span>lock<span class="token punctuation">)</span>         <span class="token comment">// 当前执行 timerproc 所以不再是 sleeping 状态，置为 false</span>timers<span class="token punctuation">.</span>sleeping <span class="token operator">=</span> <span class="token boolean">false</span>now <span class="token operator">:=</span> <span class="token function">nanotime</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment">// delta 表示 timer 要执行的时间与当前时间的差值，</span>        <span class="token comment">// 如果 delta > 0 说明还没有到 timer 的执行时间</span>delta <span class="token operator">:=</span> <span class="token function">int64</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">for</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 判断 timers 中是否有要执行的 timer</span><span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>timers<span class="token punctuation">.</span>t<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>delta <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token keyword">break</span><span class="token punctuation">&#125;</span>            <span class="token comment">// 有要执行的，直接获取堆顶元素，小顶堆嘛，堆顶的肯定是最小的</span>            t <span class="token operator">:=</span> timers<span class="token punctuation">.</span>t<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>            <span class="token comment">// 计算 delta 差值</span>delta <span class="token operator">=</span> t<span class="token punctuation">.</span>when <span class="token operator">-</span> now<span class="token keyword">if</span> delta <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">&#123;</span><span class="token keyword">break</span><span class="token punctuation">&#125;</span>            <span class="token comment">// 如果是一个要周期执行的 timer，计算下次执行时间，并重新排列堆</span><span class="token keyword">if</span> t<span class="token punctuation">.</span>period <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">&#123;</span><span class="token comment">// leave in heap but adjust next time to fire</span>t<span class="token punctuation">.</span>when <span class="token operator">+=</span> t<span class="token punctuation">.</span>period <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">+</span> <span class="token operator">-</span>delta<span class="token operator">/</span>t<span class="token punctuation">.</span>period<span class="token punctuation">)</span><span class="token function">siftdownTimer</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span><span class="token comment">// remove from heap</span>last <span class="token operator">:=</span> <span class="token function">len</span><span class="token punctuation">(</span>timers<span class="token punctuation">.</span>t<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token keyword">if</span> last <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>timers<span class="token punctuation">.</span>t<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> timers<span class="token punctuation">.</span>t<span class="token punctuation">[</span>last<span class="token punctuation">]</span>timers<span class="token punctuation">.</span>t<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">&#125;</span>timers<span class="token punctuation">.</span>t<span class="token punctuation">[</span>last<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">nil</span>timers<span class="token punctuation">.</span>t <span class="token operator">=</span> timers<span class="token punctuation">.</span>t<span class="token punctuation">[</span><span class="token punctuation">:</span>last<span class="token punctuation">]</span><span class="token keyword">if</span> last <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">&#123;</span><span class="token function">siftdownTimer</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span>t<span class="token punctuation">.</span>i <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token comment">// mark as removed</span><span class="token punctuation">&#125;</span>            <span class="token comment">// 获取该 timer 中的函数</span>f <span class="token operator">:=</span> t<span class="token punctuation">.</span>farg <span class="token operator">:=</span> t<span class="token punctuation">.</span>argseq <span class="token operator">:=</span> t<span class="token punctuation">.</span>seq            <span class="token comment">// 因为执行用户的代码并不需要加锁，所以在此处对锁进行释放，防止其他获取锁的g阻塞太久时间</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>timers<span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token keyword">if</span> raceenabled <span class="token punctuation">&#123;</span><span class="token function">raceacquire</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span>            <span class="token comment">// 执行用户函数</span><span class="token function">f</span><span class="token punctuation">(</span>arg<span class="token punctuation">,</span> seq<span class="token punctuation">)</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>timers<span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> delta <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> faketime <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">&#123;</span><span class="token comment">// No timers left - put goroutine to sleep.</span><span class="token comment">// 这种情况意味着 timers 中没有任何可以执行的 timer，gopark挂起，后面goready唤醒</span>            timers<span class="token punctuation">.</span>rescheduling <span class="token operator">=</span> <span class="token boolean">true</span><span class="token function">goparkunlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>timers<span class="token punctuation">.</span>lock<span class="token punctuation">,</span> <span class="token string">"timer goroutine (idle)"</span><span class="token punctuation">,</span> traceEvGoBlock<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">// 恢复回来回到头部执行</span>            <span class="token keyword">continue</span><span class="token punctuation">&#125;</span><span class="token comment">// At least one timer pending. Sleep until then. timers 中至少有一个可以执行的 timer</span><span class="token comment">// 设置为 sleeping 我们不使用 gopark 挂起是因为，可能某个timer要执行了，但是你 goready 后重新调度后，会导致这个timer超时</span>        timers<span class="token punctuation">.</span>sleeping <span class="token operator">=</span> <span class="token boolean">true</span><span class="token function">noteclear</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>timers<span class="token punctuation">.</span>waitnote<span class="token punctuation">)</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>timers<span class="token punctuation">.</span>lock<span class="token punctuation">)</span>        <span class="token comment">// 通过 futex 系统调用，让这个 timerproc 睡一会，醒来之后继续干活</span>        <span class="token comment">// 该过程涉及到 handoffp，文章末尾做了简要总结</span><span class="token function">notetsleepg</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>timers<span class="token punctuation">.</span>waitnote<span class="token punctuation">,</span> delta<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>至此我们已经解答了文章开头的一部分问题。<br>​</p><ul><li>1.在堆的小节去了解</li><li>2.创建 timer 的时<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> runtimeTimer <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>i      <span class="token builtin">int</span><span class="token comment">// 在堆中的位置</span>when   <span class="token builtin">int64</span><span class="token comment">// 某个时间点</span>period <span class="token builtin">int64</span><span class="token comment">// 周期</span>f      <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token builtin">uintptr</span><span class="token punctuation">)</span> <span class="token comment">// NOTE: must not be closure go的封装的一些函数</span>arg    <span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token comment">// 这个才是我们自己的函数</span>seq    <span class="token builtin">uintptr</span><span class="token comment">// 这个好像是没用到</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">goFunc</span><span class="token punctuation">(</span>arg <span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> seq <span class="token builtin">uintptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">go</span> arg<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>我们如果写了一个死循环并不会影响timerproc的执行，底层为我们新建了一个 goroutine 去执行。<br>​</li></ul><ul><li>3.g 被谁接管了？我在一开始看的时候也有点迷惑，要是能被接管肯定是放在某个地方了，看的时候就是没找到，后来再梳理的时候发现，在 timerproc 函数开始的第一行代码就是 把 g 放入了 timer.gp 字段。</li><li>4.timer中的两种挂起方式，这个在代码中注释的已经很详细了</li></ul><p>1&gt; futex syscall<br>2&gt; gopark</p><p>我们已经看完了整个 创建 timer 的过程，并且知道了 timerproc 就是用来真正执行 timer 的函数。总结一下现在的 timer 有什么问题：<br>​</p><p><strong>全局只有一把锁，只要对四叉堆修改，必须要加锁，所以怎么做优化才能降低锁的竞争，与此同时，一个非常隐蔽的，也是至关重要的问题正在发生。当我们 timers 中有待执行的对象时，在 timerproc 中通过 syscall 使当前 M 进入阻塞，调度模型中的 handoffp 会将 M 从当前 P 上剥离，然后找一个空闲的 M 或 新建一个 M 执行本地队列中的 g。当进入阻塞的 syscall 调用完成了的时候，需要把 timerproc 重新放回队列进行调度。这种频繁的上下文切换白白浪费了资源。</strong>（在 1.14 版本中去掉了 timerproc 把执行 timer 的逻辑嵌入到调度循环，sysmon等函数中）</p><h3 id="实际开发中的-timer"><a href="#实际开发中的-timer" class="headerlink" title="实际开发中的 timer"></a>实际开发中的 timer</h3><h4 id="time-Sleep-后发生了什么？"><a href="#time-Sleep-后发生了什么？" class="headerlink" title="time.Sleep() 后发生了什么？"></a>time.Sleep() 后发生了什么？</h4><p>日常的开发工作中，或者是写 demo 的时候，经常会用到 time.Sleep()，会让当前的 goroutine 睡一会，等到满足某个 condition 的时候再醒来继续工作。<br>废话不多说，直接上源码。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// timeSleep puts the current goroutine to sleep for at least ns nanoseconds.</span><span class="token comment">//go:linkname timeSleep time.Sleep 可以看到当我们使用 time.Sleep 的时候实际上底层调用的是 timeSleep() 这个函数</span><span class="token keyword">func</span> <span class="token function">timeSleep</span><span class="token punctuation">(</span>ns <span class="token builtin">int64</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> ns <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span><span class="token punctuation">&#125;</span>    <span class="token comment">// 新建一个 timer 对象</span>t <span class="token operator">:=</span> <span class="token function">new</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span>    <span class="token comment">// 计算要让这个 goroutine 休眠的时间</span>t<span class="token punctuation">.</span>when <span class="token operator">=</span> <span class="token function">nanotime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> ns    <span class="token comment">// t.f 前文中有提到过，是到时后要执行的那个 function</span>t<span class="token punctuation">.</span>f <span class="token operator">=</span> goroutineReady<span class="token comment">// 上述 function 的 arg，把执行 timeSleep 的 goroutine 存储到 t.arg 中</span>    t<span class="token punctuation">.</span>arg <span class="token operator">=</span> <span class="token function">getg</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment">// 新的 timer 封装好了，要把新 timer 加入到 堆中，保证并发安全，上锁！</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>timers<span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token function">addtimerLocked</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span>    <span class="token comment">// 挂起当前的 goroutine</span><span class="token function">goparkunlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>timers<span class="token punctuation">.</span>lock<span class="token punctuation">,</span> <span class="token string">"sleep"</span><span class="token punctuation">,</span> traceEvGoSleep<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="time-AfterFunc-后发生了什么？"><a href="#time-AfterFunc-后发生了什么？" class="headerlink" title="time.AfterFunc() 后发生了什么？"></a>time.AfterFunc() 后发生了什么？</h4><p>经过上述的分析是不是已经很简单了，不过我们还是来看一下源码。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// AfterFunc waits for the duration to elapse and then calls f</span><span class="token comment">// in its own goroutine. It returns a Timer that can</span><span class="token comment">// be used to cancel the call using its Stop method.</span><span class="token keyword">func</span> <span class="token function">AfterFunc</span><span class="token punctuation">(</span>d Duration<span class="token punctuation">,</span> f <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">*</span>Timer <span class="token punctuation">&#123;</span>t <span class="token operator">:=</span> <span class="token operator">&amp;</span>Timer<span class="token punctuation">&#123;</span><span class="token comment">// 封装 timer</span>r<span class="token punctuation">:</span> runtimeTimer<span class="token punctuation">&#123;</span>when<span class="token punctuation">:</span> <span class="token function">when</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">,</span>f<span class="token punctuation">:</span>    goFunc<span class="token punctuation">,</span>arg<span class="token punctuation">:</span>  f<span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span>    <span class="token comment">// startTimer 前文中提到过，内部就是将新的timer加入到堆中，其中逻辑前文都覆盖到了</span><span class="token function">startTimer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t<span class="token punctuation">.</span>r<span class="token punctuation">)</span><span class="token keyword">return</span> t<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="堆的简单了解"><a href="#堆的简单了解" class="headerlink" title="堆的简单了解"></a>堆的简单了解</h3><p>go1.8 版本的 timers 结构如下图所示，全局共享一个四叉堆，那么当访问这个数据结构的时候，为了保证并发的安全性，一定是要获取到锁的。<br>也正是因此锁成了 go1.8 中 timer 主要的性能瓶颈。<br><img src="https://gitee.com/yangbaoqiang/images/raw/f4fa80bedef662b0abaf2a695cefcc0658c83439/blogpics/1635754910137-44029b08-6db8-4417-a709-0ff8b7b38a24.png" alt="image.png"></p><p>我们简单说一下堆这个数据结构，二叉树大家都很了解，那怎么把一颗二叉树转换成一个二叉堆呢？go 中存储 timer 的数据结构就是一个切片，那什么样的树结构能够使用数组进行存储呢？<br>​</p><p>这里先给出结论：<br>1.完全二叉树可以使用数组来存储。<br>2.当一颗二叉树满足完全二叉树的性质，并且满足每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆，大顶堆概念相反。</p><p>如上图所示，四叉堆，各个元素存储在数组中，如果想得到子节点的父节点，设子节点索引为 i，那么父节点 p = (i - 1) / 4 (图上的n画错了应该是 i，懒得改了）。<br>​</p><h4 id="timer-四叉堆排序算法"><a href="#timer-四叉堆排序算法" class="headerlink" title="timer 四叉堆排序算法"></a>timer 四叉堆排序算法</h4><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// Heap maintenance algorithms.</span><span class="token comment">// 由下向上</span><span class="token comment">// 主要的算法思想是：用索引为 i 的timer，不断地找到该 timer 的 parent，并比较两者的 when 进行交换</span><span class="token keyword">func</span> <span class="token function">siftupTimer</span><span class="token punctuation">(</span>i <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>t <span class="token operator">:=</span> timers<span class="token punctuation">.</span>twhen <span class="token operator">:=</span> t<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>whentmp <span class="token operator">:=</span> t<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token keyword">for</span> i <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>p <span class="token operator">:=</span> <span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">4</span> <span class="token comment">// parent</span><span class="token keyword">if</span> when <span class="token operator">>=</span> t<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">.</span>when <span class="token punctuation">&#123;</span><span class="token keyword">break</span><span class="token punctuation">&#125;</span>t<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token punctuation">[</span>p<span class="token punctuation">]</span>t<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>i <span class="token operator">=</span> it<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">=</span> tmpt<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">.</span>i <span class="token operator">=</span> pi <span class="token operator">=</span> p<span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 由上向下</span><span class="token keyword">func</span> <span class="token function">siftdownTimer</span><span class="token punctuation">(</span>i <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>t <span class="token operator">:=</span> timers<span class="token punctuation">.</span>tn <span class="token operator">:=</span> <span class="token function">len</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token comment">// 堆中总的元素数量</span>when <span class="token operator">:=</span> t<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>whentmp <span class="token operator">:=</span> t<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token keyword">for</span> <span class="token punctuation">&#123;</span>c <span class="token operator">:=</span> i<span class="token operator">*</span><span class="token number">4</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token comment">// left child</span>c3 <span class="token operator">:=</span> c <span class="token operator">+</span> <span class="token number">2</span>  <span class="token comment">// mid child</span><span class="token keyword">if</span> c <span class="token operator">>=</span> n <span class="token punctuation">&#123;</span><span class="token comment">// 判断 i 的四个子节点中的第一个是否超过了总节点个数</span><span class="token keyword">break</span><span class="token punctuation">&#125;</span>w <span class="token operator">:=</span> t<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">.</span>when <span class="token keyword">if</span> c<span class="token operator">+</span><span class="token number">1</span> <span class="token operator">&lt;</span> n <span class="token operator">&amp;&amp;</span> t<span class="token punctuation">[</span>c<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>when <span class="token operator">&lt;</span> w <span class="token punctuation">&#123;</span> <span class="token comment">// 找到前两个子节点中最小的</span>w <span class="token operator">=</span> t<span class="token punctuation">[</span>c<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>whenc<span class="token operator">++</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> c3 <span class="token operator">&lt;</span> n <span class="token punctuation">&#123;</span>w3 <span class="token operator">:=</span> t<span class="token punctuation">[</span>c3<span class="token punctuation">]</span><span class="token punctuation">.</span>when<span class="token keyword">if</span> c3<span class="token operator">+</span><span class="token number">1</span> <span class="token operator">&lt;</span> n <span class="token operator">&amp;&amp;</span> t<span class="token punctuation">[</span>c3<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>when <span class="token operator">&lt;</span> w3 <span class="token punctuation">&#123;</span><span class="token comment">// 找到后两个子节点中最小的</span>w3 <span class="token operator">=</span> t<span class="token punctuation">[</span>c3<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>whenc3<span class="token operator">++</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> w3 <span class="token operator">&lt;</span> w <span class="token punctuation">&#123;</span> <span class="token comment">// 找到这两组子结点中最小的</span>w <span class="token operator">=</span> w3c <span class="token operator">=</span> c3<span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> w <span class="token operator">>=</span> when <span class="token punctuation">&#123;</span><span class="token comment">// 判断子节点中的值是否大于父节点，是就不需要交换</span><span class="token keyword">break</span><span class="token punctuation">&#125;</span>        <span class="token comment">// 由此开始，是把子节点与父节点进行互换</span>t<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token punctuation">[</span>c<span class="token punctuation">]</span>t<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>i <span class="token operator">=</span> it<span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">=</span> tmpt<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">.</span>i <span class="token operator">=</span> ci <span class="token operator">=</span> c<span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><p>如果完全二叉树，采用数组进行存储，索引从 0 开始存储和索引从 1 开始存储有什么区别？可以动手画一下。</p><h3 id="timer-中的上下文切换"><a href="#timer-中的上下文切换" class="headerlink" title="timer 中的上下文切换"></a>timer 中的上下文切换</h3><h4 id="notesleepg"><a href="#notesleepg" class="headerlink" title="notesleepg"></a>notesleepg</h4><p>在 timers 中没有任何将要执行的 timer 时，会通过 futex 这个系统调用将当前这个 M 挂起，看看代码中是怎么做的。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">notetsleepg</span><span class="token punctuation">(</span>n <span class="token operator">*</span>note<span class="token punctuation">,</span> ns <span class="token builtin">int64</span><span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">&#123;</span>gp <span class="token operator">:=</span> <span class="token function">getg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">if</span> gp <span class="token operator">==</span> gp<span class="token punctuation">.</span>m<span class="token punctuation">.</span>g0 <span class="token punctuation">&#123;</span><span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">"notetsleepg on g0"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">// 进入系统调用</span><span class="token function">entersyscallblock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment">// 阻塞当前线程</span>ok <span class="token operator">:=</span> <span class="token function">notetsleep_internal</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> ns<span class="token punctuation">)</span><span class="token comment">// 退出系统调用</span>    <span class="token function">exitsyscall</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">return</span> ok<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">entersyscallblock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">)</span> <span class="token comment">// 省略了一些处理 g 状态的代码</span>    <span class="token comment">// 切换到 g0 栈，执行 handoff 操作</span><span class="token function">systemstack</span><span class="token punctuation">(</span>entersyscallblock_handoff<span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">entersyscallblock_handoff</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">)</span> <span class="token comment">// 省略 trace</span>    <span class="token comment">// releasep 中解绑了 M 与 P 的关系</span>    <span class="token comment">// handoffp 中会获取线程</span>    <span class="token function">handoffp</span><span class="token punctuation">(</span><span class="token function">releasep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// 上述函数将 M 与 P 解绑之后，M 通过 futex 系统调用休眠 ns </span><span class="token keyword">func</span> <span class="token function">notetsleep_internal</span><span class="token punctuation">(</span>n <span class="token operator">*</span>note<span class="token punctuation">,</span> ns <span class="token builtin">int64</span><span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">&#123;</span>gp <span class="token operator">:=</span> <span class="token function">getg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">if</span> ns <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token operator">*</span>cgo_yield <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span><span class="token comment">// Sleep for an arbitrary-but-moderate interval to poll libc interceptors.</span>ns <span class="token operator">=</span> <span class="token number">10e6</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span> atomic<span class="token punctuation">.</span><span class="token function">Load</span><span class="token punctuation">(</span><span class="token function">key32</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>n<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>gp<span class="token punctuation">.</span>m<span class="token punctuation">.</span>blocked <span class="token operator">=</span> <span class="token boolean">true</span><span class="token function">futexsleep</span><span class="token punctuation">(</span><span class="token function">key32</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>n<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> ns<span class="token punctuation">)</span><span class="token keyword">if</span> <span class="token operator">*</span>cgo_yield <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span><span class="token function">asmcgocall</span><span class="token punctuation">(</span><span class="token operator">*</span>cgo_yield<span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span>gp<span class="token punctuation">.</span>m<span class="token punctuation">.</span>blocked <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> atomic<span class="token punctuation">.</span><span class="token function">Load</span><span class="token punctuation">(</span><span class="token function">key32</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>n<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">&#125;</span>deadline <span class="token operator">:=</span> <span class="token function">nanotime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> ns<span class="token keyword">for</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token operator">*</span>cgo_yield <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token operator">&amp;&amp;</span> ns <span class="token operator">></span> <span class="token number">10e6</span> <span class="token punctuation">&#123;</span>ns <span class="token operator">=</span> <span class="token number">10e6</span><span class="token punctuation">&#125;</span>gp<span class="token punctuation">.</span>m<span class="token punctuation">.</span>blocked <span class="token operator">=</span> <span class="token boolean">true</span><span class="token comment">// 表示当前 M 正在阻塞</span><span class="token function">futexsleep</span><span class="token punctuation">(</span><span class="token function">key32</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>n<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> ns<span class="token punctuation">)</span><span class="token comment">// 让 M 睡一会</span><span class="token keyword">if</span> <span class="token operator">*</span>cgo_yield <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span><span class="token function">asmcgocall</span><span class="token punctuation">(</span><span class="token operator">*</span>cgo_yield<span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span>gp<span class="token punctuation">.</span>m<span class="token punctuation">.</span>blocked <span class="token operator">=</span> <span class="token boolean">false</span><span class="token comment">// 休眠完成，修改回 M 的阻塞状态</span><span class="token keyword">if</span> atomic<span class="token punctuation">.</span><span class="token function">Load</span><span class="token punctuation">(</span><span class="token function">key32</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>n<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span><span class="token keyword">break</span><span class="token punctuation">&#125;</span>now <span class="token operator">:=</span> <span class="token function">nanotime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">if</span> now <span class="token operator">>=</span> deadline <span class="token punctuation">&#123;</span><span class="token keyword">break</span><span class="token punctuation">&#125;</span>ns <span class="token operator">=</span> deadline <span class="token operator">-</span> now<span class="token punctuation">&#125;</span><span class="token keyword">return</span> atomic<span class="token punctuation">.</span><span class="token function">Load</span><span class="token punctuation">(</span><span class="token function">key32</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>n<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>M 从系统调用中恢复过来，在缺少 P 的情况下是怎么个执行过程</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">exitsyscall</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">)</span>        oldp <span class="token operator">:=</span> _g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>oldp<span class="token punctuation">.</span><span class="token function">ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">// 获取之前执行这个 M 的 P</span>_g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>oldp <span class="token operator">=</span> <span class="token number">0</span>    <span class="token comment">// fast path，如果能获取到之前的 P 还是放在原来的 P 上进行调度，否则看看有没有空闲的 P</span><span class="token keyword">if</span> <span class="token function">exitsyscallfast</span><span class="token punctuation">(</span>oldp<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> _g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>mcache <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span><span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">"lost mcache"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> trace<span class="token punctuation">.</span>enabled <span class="token punctuation">&#123;</span><span class="token keyword">if</span> oldp <span class="token operator">!=</span> _g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>p<span class="token punctuation">.</span><span class="token function">ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> _g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>syscalltick <span class="token operator">!=</span> _g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>p<span class="token punctuation">.</span><span class="token function">ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>syscalltick <span class="token punctuation">&#123;</span><span class="token function">systemstack</span><span class="token punctuation">(</span>traceGoStart<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// There's a cpu for us, so we can run.</span>_g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>p<span class="token punctuation">.</span><span class="token function">ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>syscalltick<span class="token operator">++</span><span class="token comment">// We need to cas the status and scan before resuming...</span><span class="token function">casgstatus</span><span class="token punctuation">(</span>_g_<span class="token punctuation">,</span> _Gsyscall<span class="token punctuation">,</span> _Grunning<span class="token punctuation">)</span><span class="token comment">// Garbage collector isn't running (since we are),</span><span class="token comment">// so okay to clear syscallsp.</span>_g_<span class="token punctuation">.</span>syscallsp <span class="token operator">=</span> <span class="token number">0</span>_g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>locks<span class="token operator">--</span><span class="token keyword">if</span> _g_<span class="token punctuation">.</span>preempt <span class="token punctuation">&#123;</span><span class="token comment">// restore the preemption request in case we've cleared it in newstack</span>_g_<span class="token punctuation">.</span>stackguard0 <span class="token operator">=</span> stackPreempt<span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span><span class="token comment">// otherwise restore the real _StackGuard, we've spoiled it in entersyscall/entersyscallblock</span>_g_<span class="token punctuation">.</span>stackguard0 <span class="token operator">=</span> _g_<span class="token punctuation">.</span>stack<span class="token punctuation">.</span>lo <span class="token operator">+</span> _StackGuard<span class="token punctuation">&#125;</span>_g_<span class="token punctuation">.</span>throwsplit <span class="token operator">=</span> <span class="token boolean">false</span><span class="token keyword">if</span> sched<span class="token punctuation">.</span>disable<span class="token punctuation">.</span>user <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">schedEnabled</span><span class="token punctuation">(</span>_g_<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// Scheduling of this goroutine is disabled.</span><span class="token function">Gosched</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span><span class="token punctuation">&#125;</span>    <span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">)</span>    <span class="token comment">// Call the scheduler.</span><span class="token function">mcall</span><span class="token punctuation">(</span>exitsyscall0<span class="token punctuation">)</span><span class="token comment">// slow path put g to globalrunq</span>    <span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>感谢你能够看完，笔者能力有限，有问题的地方欢迎大家指出，共同探讨，一起学习、进步！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;golang timer 的优化过程以及底层实现。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://bqyang.top/2021/11/14/hello-world/"/>
    <id>http://bqyang.top/2021/11/14/hello-world/</id>
    <published>2021-11-14T14:46:05.909Z</published>
    <updated>2021-11-15T02:10:38.495Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
