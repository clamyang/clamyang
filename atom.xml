<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>杨宝强的技术笔记</title>
  
  <subtitle>宝强的技术成长</subtitle>
  <link href="https://bqyang.top/atom.xml" rel="self"/>
  
  <link href="https://bqyang.top/"/>
  <updated>2022-05-30T14:38:45.169Z</updated>
  <id>https://bqyang.top/</id>
  
  <author>
    <name>杨宝强</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数组-简单题</title>
    <link href="https://bqyang.top/2022/leetcode/array/easy/"/>
    <id>https://bqyang.top/2022/leetcode/array/easy/</id>
    <published>2022-05-30T13:49:02.926Z</published>
    <updated>2022-05-30T14:38:45.169Z</updated>
    
    <content type="html"><![CDATA[<p>没想到竟然能做出来..虽然有些不是最优解，大体上还是挺让我惊讶的，竟然做出来了..</p><span id="more"></span><table><thead><tr><th align="left">最近提交时间</th><th align="left">题目</th><th align="left">题目难度</th><th align="left">提交次数</th></tr></thead><tbody><tr><td align="left">2022-5-30</td><td align="left"><a href="https://leetcode.cn/problems/plus-one/">#66 加一</a></td><td align="left">简单</td><td align="left">4 次</td></tr><tr><td align="left">2022-5-30</td><td align="left"><a href="https://leetcode.cn/problems/search-insert-position/">#35 搜索插入位置</a></td><td align="left">简单</td><td align="left">7 次</td></tr><tr><td align="left">2022-5-30</td><td align="left"><a href="https://leetcode.cn/problems/remove-element/">#27 移除元素</a></td><td align="left">简单</td><td align="left">5 次</td></tr><tr><td align="left">2022-5-30</td><td align="left"><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/">#26 删除有序数组中的重复项</a></td><td align="left">简单</td><td align="left">1 次</td></tr></tbody></table><p>今天搞了四道关于数组的简单题，过程上都是大差不差，很难一次性把答案写的完美，都需要调整一下亦或是语法写错了…</p><p>印象比较深刻的是 27 和 66 花的时间稍微久一些，很多情况第一时间没有考虑到导致提交次数比较多。还有一个使用了 二分算法的，在判断取 start 还是 end 的时候比较纠结，但是后来还是巧妙地化解了。</p><p><a href="https://leetcode.cn/problems/plus-one/">#66 加一</a></p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">plusOne</span><span class="token punctuation">(</span>digits <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 直接对最后一位进行加一操作</span>    digits<span class="token punctuation">[</span><span class="token function">len</span><span class="token punctuation">(</span>digits<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token comment">// 处理进位的情况</span>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token function">len</span><span class="token punctuation">(</span>digits<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 因为 0 对 任何数取余都是 0 所以要排除 0 的情况</span>        <span class="token comment">// 这也导致我多提交一次..尬</span>        <span class="token keyword">if</span> digits<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token number">0</span> <span class="token operator">&amp;&amp;</span> digits<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">%</span><span class="token number">10</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>            digits<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>            <span class="token keyword">if</span> i <span class="token operator">>=</span> <span class="token number">1</span> <span class="token punctuation">&#123;</span>                digits<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">++</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                res <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">&#125;</span>                <span class="token keyword">for</span> j <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token function">len</span><span class="token punctuation">(</span>digits<span class="token punctuation">)</span><span class="token punctuation">;</span> j<span class="token operator">++</span> <span class="token punctuation">&#123;</span>                    res <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>                <span class="token punctuation">&#125;</span>                <span class="token keyword">return</span> res            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> digits<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://leetcode.cn/problems/search-insert-position/">#35 搜索插入位置</a></p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">searchInsert</span><span class="token punctuation">(</span>nums <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> target <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span>    start <span class="token operator">:=</span> <span class="token number">0</span>    end <span class="token operator">:=</span> <span class="token function">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>    <span class="token comment">// 直接用两个 if 处理越界的情况</span>    <span class="token keyword">if</span> nums<span class="token punctuation">[</span>end<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token function">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> nums<span class="token punctuation">[</span>start<span class="token punctuation">]</span> <span class="token operator">>=</span> target <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">&#125;</span>    <span class="token keyword">var</span> midIndex <span class="token builtin">int</span>  <span class="token comment">// 二分的方式进行处理</span>    <span class="token keyword">for</span> <span class="token punctuation">&#123;</span>        midIndex <span class="token operator">=</span> <span class="token punctuation">(</span>start <span class="token operator">+</span> end<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span>        <span class="token keyword">if</span> nums<span class="token punctuation">[</span>midIndex<span class="token punctuation">]</span> <span class="token operator">>=</span> target <span class="token punctuation">&#123;</span>            end <span class="token operator">=</span> midIndex        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            start <span class="token operator">=</span> midIndex        <span class="token punctuation">&#125;</span><span class="token keyword">if</span> start <span class="token operator">==</span> end<span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>start<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> target <span class="token punctuation">&#123;</span>                <span class="token keyword">return</span> end            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">return</span> start            <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://leetcode.cn/problems/remove-element/">#27 移除元素</a></p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// 我写的 n^2 的时间复杂度</span><span class="token keyword">func</span> <span class="token function">removeElement</span><span class="token punctuation">(</span>nums <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> val <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">for</span> index <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> index <span class="token operator">&lt;</span> <span class="token function">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span> index<span class="token operator">++</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> nums<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">==</span> val <span class="token punctuation">&#123;</span>            <span class="token keyword">for</span> i <span class="token operator">:=</span> index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token function">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">&#123;</span>                nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>            <span class="token punctuation">&#125;</span>            index<span class="token operator">--</span>            nums <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token function">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token function">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">// 人家这个 O(N) 的时间复杂度</span><span class="token keyword">func</span> <span class="token function">removeElement</span><span class="token punctuation">(</span>nums <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> val <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span>    left <span class="token operator">:=</span> <span class="token number">0</span>    <span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> v <span class="token operator">:=</span> <span class="token keyword">range</span> nums <span class="token punctuation">&#123;</span> <span class="token comment">// v 即 nums[right]</span>        <span class="token keyword">if</span> v <span class="token operator">!=</span> val <span class="token punctuation">&#123;</span>            nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">=</span> v            left<span class="token operator">++</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> left<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/">#26 删除有序数组中的重复项</a></p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">removeDuplicates</span><span class="token punctuation">(</span>nums <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">for</span> index<span class="token punctuation">,</span> num <span class="token operator">:=</span> <span class="token keyword">range</span> nums <span class="token punctuation">&#123;</span>        <span class="token comment">// 找出最后一个重复数字的索引，然后保留一个， 其余的切掉</span>        last <span class="token operator">:=</span> <span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token operator">:=</span> index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token function">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> num <span class="token operator">==</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>            last <span class="token operator">=</span> i        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> last <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>            nums <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span><span class="token punctuation">:</span>index<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>last<span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token operator">...</span><span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token function">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>暴力解法没什么不好的，先写出来，再考虑优化的事情，一个好的算法必须要经历千百次的调试。（我总结的hh）</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;没想到竟然能做出来..虽然有些不是最优解，大体上还是挺让我惊讶的，竟然做出来了..&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>再学递归（几个有意思的递归练习）</title>
    <link href="https://bqyang.top/2022/language/c/recur/"/>
    <id>https://bqyang.top/2022/language/c/recur/</id>
    <published>2022-05-24T14:08:21.157Z</published>
    <updated>2022-05-24T14:50:10.734Z</updated>
    
    <content type="html"><![CDATA[<p>逃不过的汉诺塔…</p><span id="more"></span><p>由间到难：</p><ul><li>给定一个整数，如 1234，使用递归的方式打印出，4321。</li><li>给定一个整数，如 9，使用递归的方式打印出该数的二进制形式，输入 9，输出 1001。</li></ul><p>这两个数以同一种类型，做出来一个另一个也迎刃而解，如果没什么思路的话，也不建议直接去查答案，肯定可以，我这么笨的都能琢磨出来，多花点时间。</p><p>（提示请见评论）</p><ul><li><p>给定一个整数，求这个数的阶乘。</p></li><li><p>汉诺塔..只要是认认真真学过一门语言肯定会接触到这个例子，具体描述请见百科。</p></li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">void</span> <span class="token function">hanoi</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">hanoi</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">'x'</span><span class="token punctuation">,</span> <span class="token string">'y'</span><span class="token punctuation">,</span> <span class="token string">'z'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">hanoi</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">char</span> from<span class="token punctuation">,</span> <span class="token keyword">char</span> mid<span class="token punctuation">,</span> <span class="token keyword">char</span> to<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// from x to z through y</span>        <span class="token function">hanoi</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> from<span class="token punctuation">,</span> to<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"take %d from %c to %c\n"</span><span class="token punctuation">,</span> n<span class="token punctuation">,</span> from<span class="token punctuation">,</span> to<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// from z to x through y</span>        <span class="token function">hanoi</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> mid<span class="token punctuation">,</span> from<span class="token punctuation">,</span> to<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;逃不过的汉诺塔…&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>打印字符</title>
    <link href="https://bqyang.top/2022/language/c/print/"/>
    <id>https://bqyang.top/2022/language/c/print/</id>
    <published>2022-05-17T06:31:17.737Z</published>
    <updated>2022-05-17T09:58:57.886Z</updated>
    
    <content type="html"><![CDATA[<p>for循环打印字符</p><span id="more"></span><p>还是有点意思的，使用嵌套for循环输出如下格式：</p><pre class="line-numbers language-none"><code class="language-none">ABCDEFGHIJK...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>另一个输出这样：</p><pre class="line-numbers language-none"><code class="language-none">  A   ABA ABCBA<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>华</p><hr><p>​                    丽</p><hr><p>​                                    的</p><hr><p>​                                                    分</p><hr><p>​                                                                    割</p><hr><p>​                                                                                    线</p><hr><p>答案如下：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;int main(void) &#123;    for (int i &#x3D; 0, s &#x3D; &#39;A&#39;; i &lt; 6; i++, s+&#x3D;i) &#123;          for(int j &#x3D; s, k &#x3D; 0; k &lt;&#x3D; i; k++, j++ ) &#123;            printf(&quot;%c&quot;, j);        &#125;        printf(&quot;\n&quot;);    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;int main(void) &#123;    printf(&quot;Please input start letter for print\n&quot;);       char alpha;    scanf(&quot;%c&quot;, &amp;alpha);    char A &#x3D; 65;    for (char t &#x3D; A; t &lt;&#x3D; alpha; t++) &#123;           for (char j &#x3D; alpha; j &gt; t; j--) &#123;            printf(&quot; &quot;);        &#125;                for(char i &#x3D; A; i &lt; t; i++) &#123;                 printf(&quot;%c&quot;, i);        &#125;        for (char k &#x3D; t; k &gt;&#x3D; A; k--) &#123;               printf(&quot;%c&quot;, k);        &#125;                printf(&quot;\n&quot;);    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;for循环打印字符&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>C-String</title>
    <link href="https://bqyang.top/2022/language/c/string/"/>
    <id>https://bqyang.top/2022/language/c/string/</id>
    <published>2022-05-11T10:47:31.133Z</published>
    <updated>2022-05-11T11:17:50.298Z</updated>
    
    <content type="html"><![CDATA[<p>复习 C 语言字符串</p><span id="more"></span><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p><strong>字符串 （character string）</strong> 是一个或多个字符的序列。</p><p>实际上，字符串就是一个字符数组，**但是在字符末尾插入了 \0 **用来表示字符串的结束。</p><p>所以，数组的容量一定是要比待存储的字符串字节数多 1，用来存储 \0，举个例子，我们想存储名字 <code>abc </code> 就必须使用 <code>char name[4]</code> 来存储。</p><blockquote><p>末尾的 \0 计算机会自动帮我们加上</p></blockquote><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>接收控制台输入，parisel.c</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">PRAISE</span> <span class="token string">"good jobbbb"</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">char</span> name<span class="token punctuation">[</span><span class="token number">40</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Input you name "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s, %s\n"</span><span class="token punctuation">,</span> name<span class="token punctuation">,</span> PRAISE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>问题：</p><ul><li>为什么 scanf 接收参数的时候不需要传递指针？</li></ul><h1 id="字符串和字符"><a href="#字符串和字符" class="headerlink" title="字符串和字符"></a>字符串和字符</h1><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 字符串 "x"</span><span class="token comment">// 字符   'x'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这两个虽然看起来相似，但是底层的存储结构是不一样的，字符使用 char 类型来存储，字符串使用的是数组，而且还需要一个 <code>\0</code>，由两个字符组成。</p><h1 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h1><p>为什么使用符号常量更好？</p><ul><li><em>常量名称可以表达更多的意思</em></li><li><em>方便后续修改</em></li></ul><h2 id="定义常量"><a href="#定义常量" class="headerlink" title="定义常量"></a>定义常量</h2><p><code>#define PI 3.14</code> 更通用的表示为 <code>#define NAME value</code>, C 中一般采用大写名称来表示常量。</p><p>代码中使用这样的常量，会在编译时替换掉（预处理阶段替换），即<em>编译时替换</em>（compile-time substitution）。</p><h2 id="const-限定符号"><a href="#const-限定符号" class="headerlink" title="const 限定符号"></a>const 限定符号</h2><p>Go 中使用的方式 <code>const name = &quot;xx&quot;</code></p><p>C 中要这样用 <code>const int Months = 12;</code></p><blockquote><p>C 中 const 声明的是变量，不是常量。</p></blockquote><h2 id="看几个标准库中的常量"><a href="#看几个标准库中的常量" class="headerlink" title="看几个标准库中的常量"></a>看几个标准库中的常量</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;复习 C 语言字符串&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Rust-Enums</title>
    <link href="https://bqyang.top/2022/language/rust/enum/"/>
    <id>https://bqyang.top/2022/language/rust/enum/</id>
    <published>2022-05-10T07:53:07.016Z</published>
    <updated>2022-05-11T06:29:35.881Z</updated>
    
    <content type="html"><![CDATA[<p>Rust 枚举</p><span id="more"></span><p><strong>定义、声明</strong></p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">enmu <span class="token class-name">IpAddrKind</span> <span class="token punctuation">&#123;</span>    <span class="token constant">V4</span><span class="token punctuation">,</span>    <span class="token constant">V6</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>定义了一个枚举数据类型，IpAddrKind，枚举中有两个变量，V4，V6。但是这样存在一个问题，实际的 IP 地址应该存储在哪里，这只是定义了两种 Ip 类型。</p><p>如何使用 enum 存储值？</p><p>方法一，使用 struct：</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">struct</span> <span class="token type-definition class-name">IpAddr</span> <span class="token punctuation">&#123;</span>    kind<span class="token punctuation">:</span> <span class="token class-name">IpAddrKind</span><span class="token punctuation">,</span>    address<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token keyword">let</span> home <span class="token operator">=</span> <span class="token class-name">IpAddr</span> <span class="token punctuation">&#123;</span>    kind<span class="token punctuation">:</span> <span class="token class-name">IpAddrKind</span><span class="token punctuation">::</span><span class="token constant">V4</span><span class="token punctuation">,</span>    address<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">let</span> loopback <span class="token operator">=</span> <span class="token class-name">IpAddr</span> <span class="token punctuation">&#123;</span>    kind<span class="token punctuation">:</span> <span class="token class-name">IpAddrKind</span><span class="token punctuation">::</span><span class="token constant">V6</span><span class="token punctuation">,</span>    address<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"::1"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>方法二，使用 enum 存储：</p><p>直接使用 enum 存储值，这个有点意思..</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">enum</span> <span class="token type-definition class-name">IpAddr</span> <span class="token punctuation">&#123;</span>    <span class="token constant">V4</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token constant">V6</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token keyword">let</span> home <span class="token operator">=</span> <span class="token class-name">IpAddr</span><span class="token punctuation">::</span><span class="token constant">V4</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> loopback <span class="token operator">=</span> <span class="token class-name">IpAddr</span><span class="token punctuation">::</span><span class="token constant">V6</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"::1"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>标准库中如何定义 IpAddr 的：</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">struct</span> <span class="token type-definition class-name">Ipv4Addr</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// --snip--</span><span class="token punctuation">&#125;</span><span class="token keyword">struct</span> <span class="token type-definition class-name">Ipv6Addr</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// --snip--</span><span class="token punctuation">&#125;</span><span class="token keyword">enum</span> <span class="token type-definition class-name">IpAddr</span> <span class="token punctuation">&#123;</span>    <span class="token constant">V4</span><span class="token punctuation">(</span><span class="token class-name">Ipv4Addr</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token constant">V6</span><span class="token punctuation">(</span><span class="token class-name">Ipv6Addr</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>**可以给 enum 添加 method..**这里其实 Go 也可以实现：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// 类似这样的代码</span><span class="token keyword">type</span> Strings <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token keyword">func</span> <span class="token punctuation">(</span>s Strings<span class="token punctuation">)</span> <span class="token function">Less</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>The <code>Option</code> Enum</strong></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Rust 枚举&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Rust-Structs</title>
    <link href="https://bqyang.top/2022/language/rust/structs/"/>
    <id>https://bqyang.top/2022/language/rust/structs/</id>
    <published>2022-05-10T07:26:34.826Z</published>
    <updated>2022-05-11T02:54:20.456Z</updated>
    
    <content type="html"><![CDATA[<p>rust 中的结构体和方法（method）。</p><span id="more"></span><h1 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h1><p>其实各种语言对 Struct 的实例化都差不多，主要就是关注下 Rust 里关于 struct 的语法。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// struct from C</span><span class="token keyword">struct</span> <span class="token class-name">foo</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> age<span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token comment">// struct from Rust</span><span class="token keyword">struct</span> <span class="token type-definition class-name">bar</span> <span class="token punctuation">&#123;</span>    active<span class="token punctuation">:</span> <span class="token keyword">bool</span><span class="token punctuation">,</span>    username<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">,</span>    email<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">,</span>    sign_in_count<span class="token punctuation">:</span> <span class="token keyword">u64</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// struct from Go</span><span class="token keyword">type</span> foobar <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>    name <span class="token builtin">string</span>    age <span class="token builtin">int</span>    email <span class="token builtin">string</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>都差不多..</p><h2 id="打印结构体"><a href="#打印结构体" class="headerlink" title="打印结构体"></a>打印结构体</h2><p>没想到 rust 里边打印一个结构体这么麻烦，如果说打印某个字段直接用 <code>println!(&quot;&#123;&#125;&quot;, xx.xx);</code> 就行，但是要是打印整个结构体中的内容，还得给结构体定义前加上 <code>#[derive(Debug)] </code>..这样才能打印出调试信息。</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token attribute attr-name">#[derive(Debug)]</span><span class="token keyword">struct</span> <span class="token type-definition class-name">User</span> <span class="token punctuation">&#123;</span>    name<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">,</span>    age<span class="token punctuation">:</span> <span class="token keyword">u32</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>输出完整结构体算是调试功能，但是我们需要手动添加相关内容让某个结构体使用这个功能。</p></blockquote><p>添加完以后才能输出完整的结构体：</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token comment">// pretty print</span><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"&#123;:#?&#125;"</span><span class="token punctuation">,</span> xx<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="dbg"><a href="#dbg" class="headerlink" title="dbg!"></a>dbg!</h2><p>可以用来输出调试信息，<code>dbg!(xx);</code></p><h1 id="method"><a href="#method" class="headerlink" title="method"></a>method</h1><p>method 的第一个参数永远是 self。    </p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">struct</span> <span class="token type-definition class-name">User</span> <span class="token punctuation">&#123;</span>    name<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">,</span>    age<span class="token punctuation">:</span> <span class="token keyword">u32</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token keyword">impl</span> <span class="token class-name">User</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">fn</span> <span class="token function-definition function">print_name</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token operator">&amp;</span><span class="token class-name">String</span> <span class="token punctuation">&#123;</span>        <span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">.</span>name    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;rust 中的结构体和方法（method）。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Rust-Ownership</title>
    <link href="https://bqyang.top/2022/language/rust/ownership/"/>
    <id>https://bqyang.top/2022/language/rust/ownership/</id>
    <published>2022-05-09T11:47:42.459Z</published>
    <updated>2022-05-10T07:21:55.003Z</updated>
    
    <content type="html"><![CDATA[<p>Rust 核心概念了解 —— Ownership</p><span id="more"></span><p>Ownership 就是定义了一些规则，比如在函数中传递参数的时候是怎么处理参数的，官网的解释为<strong>Rust程序如何管理内存的一系列规则</strong>。</p><p><strong>内存管理的三种方式</strong></p><ul><li>Go 语言这类，自动垃圾回收机制</li><li>C 语言，手动垃圾回收，显示分配、释放</li><li>Rust 独一档，结合<strong>编译器、ownership 定义的规则</strong>，如果说没有按照 Rust Ownership 定义的规则，那么编译就不会通过。</li></ul><p>第一次知道，还能有这样的内存管理方式..</p><h1 id="ownership-by-example"><a href="#ownership-by-example" class="headerlink" title="ownership by example"></a>ownership by example</h1><p>（通过例子学习 ownership）</p><blockquote><p>The Stack and the Heap</p></blockquote><p><code>All data stored on the stack must have a known, fixed size. Data with an unknown size at compile time or a size that might change must be stored on the heap instead.</code></p><p><code>Accessing data in the heap is slower than accessing data on the stack because you have to follow a pointer to get there. </code></p><h2 id="ownership-Rules"><a href="#ownership-Rules" class="headerlink" title="ownership Rules"></a>ownership Rules</h2><ul><li>Rust 中每一个值都有一个被叫做 <code>owner</code> 的变量，比如 a = 1, 1 的 owner 就是 a。</li><li>同一时刻有且仅有一个 owner。</li><li>当 owner 超出范围时（超出作用域），value 会被丢弃。</li></ul><h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h2><p>作用域大家了解的已经很多了，要是直接看 C 代码其实还是有点懵逼的。。不信你试试。。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>很显然，答案不是 2 ，2； 正确答案为：2， 1；</p></blockquote><p>Rust 中其实也类似，如下：</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span><span class="token comment">// 这时候变量开始有效</span>    <span class="token punctuation">&#125;</span>     <span class="token comment">// 从这时起，就无效</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>两个重要的点：</p><ul><li>变量 s 在作用域内，有效</li><li>变量 s 超出作用域，无效</li></ul><h2 id="内存和分配"><a href="#内存和分配" class="headerlink" title="内存和分配"></a>内存和分配</h2><p>Rust 中内存释放的方式，<strong>超出了作用域自动释放</strong>。Rust 也算是帮我们做了内存管理，虽然没有 GC，但是也不用我们手动进行 free，避免出现 double free 问题，如上述分配的 s 变量，超出了作用域就被释放掉。</p><h2 id="ownership-Move"><a href="#ownership-Move" class="headerlink" title="ownership Move"></a>ownership Move</h2><p>Stack </p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> y <span class="token operator">=</span> x<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>Heap</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> s1 <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> s2 <span class="token operator">=</span> s1<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>两段代码表达的意思相近，但是，在不同的内存空间上有着很大的差别。</p><ul><li><p>stack 不赘述</p></li><li><p>heap</p><p><img src="https://doc.rust-lang.org/book/img/trpl04-02.svg" alt="s1 and s2 pointing to the same value"></p></li></ul><p>执行完赋值操作后，有两个指向同一块内存的指针，但是这也会存在一种情况，当 s1 和 s2 都用不到时候，会进行 free，就会出现 double free 的情况。</p><p>所以，为了保证内存安全，在 <code>let s2 = s1;</code> 执行完成后，Rust <strong>认为 s1 不再有效</strong>。即，将 s1 ownership move to s2.</p><h2 id="ownership-Clone"><a href="#ownership-Clone" class="headerlink" title="ownership Clone"></a>ownership Clone</h2><p>(deeply copy)</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> s1 <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> s2 <span class="token operator">=</span> s1<span class="token punctuation">.</span><span class="token class-name">Copy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"s1 is &#123;&#125;, s2 is &#123;&#125;"</span><span class="token punctuation">,</span> s1<span class="token punctuation">,</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://doc.rust-lang.org/book/img/trpl04-03.svg" alt="s1 and s2 to two places"></p><h2 id="Stack-Only-Data-Copy"><a href="#Stack-Only-Data-Copy" class="headerlink" title="Stack-Only Data: Copy"></a>Stack-Only Data: Copy</h2><p><code>The reason is that types such as integers that have a known size at compile time are stored entirely on the stack, so copies of the actual values are quick to make. That means there’s no reason we would want to prevent </code>x<code>from being valid after we create the variable</code>y<code>. </code></p><p>总而言之，栈上的数据会进行 Copy，堆上的数据会进行 move。</p><h2 id="函数之间-ownership-的改变"><a href="#函数之间-ownership-的改变" class="headerlink" title="函数之间 ownership 的改变"></a>函数之间 ownership 的改变</h2><p>将变量传递给函数的时候也可能会发生 move 或 copy，和分配差不多。</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// s comes into scope</span>    <span class="token function">takes_ownership</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment">// s's value moves into the function...</span>    <span class="token comment">// ... and so is no longer valid here</span>    <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>                      <span class="token comment">// x comes into scope</span>    <span class="token function">makes_copy</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token comment">// x would move into the function,</span>    <span class="token comment">// but i32 is Copy, so it's okay to still</span>    <span class="token comment">// use x afterward</span><span class="token punctuation">&#125;</span> <span class="token comment">// Here, x goes out of scope, then s. But because s's value was moved, nothing</span><span class="token comment">// special happens.</span><span class="token keyword">fn</span> <span class="token function-definition function">takes_ownership</span><span class="token punctuation">(</span>some_string<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// some_string comes into scope</span>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"&#123;&#125;"</span><span class="token punctuation">,</span> some_string<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token comment">// Here, some_string goes out of scope and `drop` is called. The backing</span><span class="token comment">// memory is freed.</span><span class="token keyword">fn</span> <span class="token function-definition function">makes_copy</span><span class="token punctuation">(</span>some_integer<span class="token punctuation">:</span> <span class="token keyword">i32</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// some_integer comes into scope</span>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"&#123;&#125;"</span><span class="token punctuation">,</span> some_integer<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token comment">// Here, some_integer goes out of scope. Nothing special happens.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="函数返回时与-ownership"><a href="#函数返回时与-ownership" class="headerlink" title="函数返回时与 ownership"></a>函数返回时与 ownership</h2><p>返回值也会转移 ownership。</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> s1 <span class="token operator">=</span> <span class="token function">gives_ownership</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// gives_ownership moves its return</span>    <span class="token comment">// value into s1</span>    <span class="token keyword">let</span> s2 <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// s2 comes into scope</span>    <span class="token keyword">let</span> s3 <span class="token operator">=</span> <span class="token function">takes_and_gives_back</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// s2 is moved into</span>    <span class="token comment">// takes_and_gives_back, which also</span>    <span class="token comment">// moves its return value into s3</span><span class="token punctuation">&#125;</span> <span class="token comment">// Here, s3 goes out of scope and is dropped. s2 was moved, so nothing</span><span class="token comment">// happens. s1 goes out of scope and is dropped.</span><span class="token keyword">fn</span> <span class="token function-definition function">gives_ownership</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token class-name">String</span> <span class="token punctuation">&#123;</span>             <span class="token comment">// gives_ownership will move its</span>    <span class="token comment">// return value into the function</span>    <span class="token comment">// that calls it</span>    <span class="token keyword">let</span> some_string <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"yours"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// some_string comes into scope</span>    some_string                              <span class="token comment">// some_string is returned and</span>    <span class="token comment">// moves out to the calling</span>    <span class="token comment">// function</span><span class="token punctuation">&#125;</span><span class="token comment">// This function takes a String and returns one</span><span class="token keyword">fn</span> <span class="token function-definition function">takes_and_gives_back</span><span class="token punctuation">(</span>a_string<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token class-name">String</span> <span class="token punctuation">&#123;</span> <span class="token comment">// a_string comes into</span>    <span class="token comment">// scope</span>    a_string  <span class="token comment">// a_string is returned and moves out to the calling function</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>综上所述，每次进行函数传参的时候都会发生 ownership 的转移，如果说我们给 funcA 传一个 A 参数后，仍然要使用 A 参数，应该怎么办呢？</p><ul><li> 可以把这个参数从 funcA 中返回</li></ul><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> s1 <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> <span class="token punctuation">(</span>s2<span class="token punctuation">,</span> len<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">calculate_length</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"The length of string &#123;&#125; is &#123;&#125;"</span><span class="token punctuation">,</span> s2<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">fn</span> <span class="token function-definition function">calculate_length</span><span class="token punctuation">(</span>s<span class="token punctuation">:</span> string<span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token keyword">usize</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> length <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">(</span>s<span class="token punctuation">,</span> length<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>牛x的 Rust 当然还提供了另一种方式，<strong>reference</strong>。</li></ul><h2 id="Reference-and-Borrowing"><a href="#Reference-and-Borrowing" class="headerlink" title="Reference and Borrowing"></a>Reference and Borrowing</h2><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>本以为这个 reference 和 pointer 是一个东西，但是 rust 中貌似并不是这么定义的，且看且分析。</p><p><code> A reference is like a pointer in that it’s an address we can follow to access data stored at that address that is owned by some other variable.</code></p><p>reference 和 pointer 相同的点，存储的都是地址，可以通过这个地址访问存储在这个地址上的数据，这个数据可能是属于别的变量的。 <strong>不同的点</strong>，reference 指向的永远是<strong>有效</strong>的地址。</p><p><img src="https://doc.rust-lang.org/book/img/trpl04-05.svg" alt="&amp;String s pointing at String s1"></p><p>因此，上述代码就可以就改为，</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> s1 <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> len <span class="token operator">=</span> <span class="token function">calculate_length</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"The length of '&#123;&#125;' is &#123;&#125;."</span><span class="token punctuation">,</span> s1<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">fn</span> <span class="token function-definition function">calculate_length</span><span class="token punctuation">(</span>s<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token keyword">usize</span> <span class="token punctuation">&#123;</span> <span class="token comment">// s is a reference to a String</span>    s<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面这段引用，再一次解释了，传递引用给函数时发生了什么，不再赘述。</p><blockquote><p><code>When functions have references as parameters instead of the actual values, we won’t need to return the values in order to give back ownership, because we never had ownership.</code></p></blockquote><h3 id="Borrowing"><a href="#Borrowing" class="headerlink" title="Borrowing"></a>Borrowing</h3><p>（把创建 reference 的行为定义成 borrowing）。在实际生活中，就跟借东西是一个意思，假设一个人拥有一辆保时捷，你借过来开两天，然后还回去，我们从未拥有过保时捷。</p><p>然后问题就来了，比如我们接过来保时捷开两天，发现他的颜色看着不顺眼，你想给他改装，这时候怎么办？如下。</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> s1 <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">change</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">fn</span> <span class="token function-definition function">change</span><span class="token punctuation">(</span>some_str<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>         some_str<span class="token punctuation">.</span><span class="token function">push_str</span><span class="token punctuation">(</span><span class="token string">"RTFM"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">error[E0596]: cannot borrow &#96;*some_str&#96; as mutable, as it is behind a &#96;&amp;&#96; reference --&gt; src&#x2F;main.rs:8:5  |7 | fn change(some_str: &amp;String) &#123;  |                     ------- help: consider changing this to be a mutable reference: &#96;&amp;mut String&#96;8 |     some_str.push_str(&quot;RTFM&quot;);  |     ^^^^^^^^^^^^^^^^^^^^^^^^^ &#96;some_str&#96; is a &#96;&amp;&#96; reference, so the data it refers to cannot be borrowed as mutableFor more information about this error, try &#96;rustc --explain E0596&#96;.error: could not compile &#96;borrowing&#96; due to previous error<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>验证了一个结论，默认情况加，<strong>borrow</strong>过来的东西是不可修改的，除非加上<strong>mut</strong>(mutable)，如下：</p><pre class="line-numbers language-none"><code class="language-none">fn main() &#123;    let mut s1 &#x3D; String::from(&quot;hello&quot;);    change(&amp;mut s1);&#125;fn change(some_str: &amp;mut String) &#123;         some_str.push_str(&quot;RTFM&quot;);     &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样就可肆无忌惮的修改 reference 指向的内容了，形如这样的被称为 <code>mutable reference</code>。</p><p>Mutable referenct 一个最大限制：<strong>在同一时刻只能拥有某个变量的一个 mut reference</strong>。可以试试下面这段代码：</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> <span class="token keyword">mut</span> s1 <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"RTFM"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> r1 <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> s1<span class="token punctuation">;</span>    <span class="token keyword">let</span> r2 <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> s2<span class="token punctuation">;</span>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"&#123;&#125; &#123;&#125;"</span><span class="token punctuation">,</span> r1<span class="token punctuation">,</span> r2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">error[E0499]: cannot borrow &#96;s1&#96; as mutable more than once at a time --&gt; src&#x2F;main.rs:5:14  |4 |     let s2 &#x3D; &amp;mut s1;  |              ------- first mutable borrow occurs here5 |     let s3 &#x3D; &amp;mut s1;  |              ^^^^^^^ second mutable borrow occurs here6 | 7 |     println!(&quot;&#123;&#125; &#123;&#125;&quot;, s2, s3);  |                       -- first borrow later used hereFor more information about this error, try &#96;rustc --explain E0499&#96;.error: could not compile &#96;borrowing&#96; due to previous error<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>mutable reference and immutable reference</strong></p><p><strong>不能同时拥有可变的和不可变的 reference</strong>，意味着，要么只有一个 mutable，要么有多个 immutable，不能有一个 mutable 和多个 immutable 的情况。</p><h2 id="Reference-scope"><a href="#Reference-scope" class="headerlink" title="Reference scope"></a>Reference scope</h2><p>reference 的生效范围，**Note that a reference’s scope starts from where it is introduced and continues through the last time that reference is used. **</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> <span class="token keyword">mut</span> s <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> r1 <span class="token operator">=</span> <span class="token operator">&amp;</span>s<span class="token punctuation">;</span> <span class="token comment">// no problem</span>    <span class="token keyword">let</span> r2 <span class="token operator">=</span> <span class="token operator">&amp;</span>s<span class="token punctuation">;</span> <span class="token comment">// no problem</span>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"&#123;&#125; and &#123;&#125;"</span><span class="token punctuation">,</span> r1<span class="token punctuation">,</span> r2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// variables r1 and r2 will not be used after this point</span>    <span class="token keyword">let</span> r3 <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> s<span class="token punctuation">;</span> <span class="token comment">// no problem</span>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"&#123;&#125;"</span><span class="token punctuation">,</span> r3<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Dangling-References"><a href="#Dangling-References" class="headerlink" title="Dangling References"></a>Dangling References</h2><p>悬垂引用，有点类似 dangling pointer， rust 中，编译器会检查 reference 指向的内容是否有效，不会发生这种情况。。</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> reference_to_nothing <span class="token operator">=</span> <span class="token function">dangle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">fn</span> <span class="token function-definition function">dangle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token operator">&amp;</span><span class="token class-name">String</span> <span class="token punctuation">&#123;</span> <span class="token comment">// dangle returns a reference to a String</span>    <span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// s is a new String</span>    <span class="token operator">&amp;</span>s <span class="token comment">// we return a reference to the String, s</span><span class="token punctuation">&#125;</span> <span class="token comment">// Here, s goes out of scope, and is dropped. Its memory goes away.</span><span class="token comment">// Danger!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">$ cargo run   Compiling ownership v0.1.0 (file:&#x2F;&#x2F;&#x2F;projects&#x2F;ownership)error[E0106]: missing lifetime specifier --&gt; src&#x2F;main.rs:5:16  |5 | fn dangle() -&gt; &amp;String &#123;  |                ^ expected named lifetime parameter  |  &#x3D; help: this function&#39;s return type contains a borrowed value, but there is no value for it to be borrowed fromhelp: consider using the &#96;&#39;static&#96; lifetime  |5 | fn dangle() -&gt; &amp;&#39;static String &#123;  |                ~~~~~~~~For more information about this error, try &#96;rustc --explain E0106&#96;.error: could not compile &#96;ownership&#96; due to previous error<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Rules-of-Reference"><a href="#Rules-of-Reference" class="headerlink" title="Rules of Reference"></a>Rules of Reference</h2><ul><li>任何时刻，要么只能有一个 mutable reference，要么有多个 immutable reference。</li><li>Reference 指向的内容一定是有效的。</li></ul><h2 id="Slices"><a href="#Slices" class="headerlink" title="Slices"></a>Slices</h2><p>这个跟 Go 的切片引用类似..，直接贴张图，不再赘述。</p><p><img src="https://doc.rust-lang.org/book/img/trpl04-06.svg" alt="world containing a pointer to the byte at index 6 of String s and a length 5"></p><h2 id="完结撒花"><a href="#完结撒花" class="headerlink" title="完结撒花"></a>完结撒花</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;Rust 核心概念了解 —— Ownership&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Deployment 更新策略</title>
    <link href="https://bqyang.top/2022/k8s/deployment/"/>
    <id>https://bqyang.top/2022/k8s/deployment/</id>
    <published>2022-05-09T07:28:40.904Z</published>
    <updated>2022-05-09T11:36:05.417Z</updated>
    
    <content type="html"><![CDATA[<p>将笔记进行拆分，都写在一个里边很拥挤，不方便翻阅查看。</p><span id="more"></span><h1 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h1><h2 id="更新策略"><a href="#更新策略" class="headerlink" title="更新策略"></a>更新策略</h2><table><thead><tr><th>更新策略</th><th>描述</th></tr></thead><tbody><tr><td>Recreate</td><td>见名知意，更新的时候就是把已存在的 Pod 删除，创建一个新的</td></tr><tr><td>RollingUpdate</td><td>滚动更新，先准备新的 Pod，就绪后再删除老的 Pod，在更新期间也可以正常提供服务。<strong>默认配置</strong>。</td></tr></tbody></table><p><img src="https://s2.loli.net/2022/05/09/uwBeEpl6Gq41WkC.png" alt="img"></p><h2 id="Recreate-如何影响应用"><a href="#Recreate-如何影响应用" class="headerlink" title="Recreate 如何影响应用"></a>Recreate 如何影响应用</h2><p>在重启期间，无法正常访问服务，正如上图中会有一段空档期。</p><h2 id="Deployment-和-Replicas-的关系"><a href="#Deployment-和-Replicas-的关系" class="headerlink" title="Deployment 和 Replicas 的关系"></a>Deployment 和 Replicas 的关系</h2><p><img src="https://s2.loli.net/2022/05/09/cmYjDQrSAguyaN3.png" alt="img"></p><p>正如我们看到的，<code>Deployment</code> 和 <code>Replica</code> 并不是总是一对一的关系，在更新操作执行后，会出现上图中的情况。</p><h2 id="RollingUpdate"><a href="#RollingUpdate" class="headerlink" title="RollingUpdate"></a>RollingUpdate</h2><p><img src="https://s2.loli.net/2022/05/09/GzleTsRbmFaNLwI.png" alt="img"></p><h3 id="Deployment-配置"><a href="#Deployment-配置" class="headerlink" title="Deployment 配置"></a>Deployment 配置</h3><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">kind</span><span class="token punctuation">:</span> Deployment<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> kiada<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">strategy</span><span class="token punctuation">:</span>    <span class="token key atrule">type</span><span class="token punctuation">:</span> RollingUpdate    <span class="token key atrule">rollingUpdate</span><span class="token punctuation">:</span>      <span class="token key atrule">maxSurge</span><span class="token punctuation">:</span> <span class="token number">0</span>      <span class="token key atrule">maxUnavailable</span><span class="token punctuation">:</span> <span class="token number">1</span>  <span class="token key atrule">minReadySeconds</span><span class="token punctuation">:</span> <span class="token number">10</span>  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">3</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token punctuation">...</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="配置一次替换多少个-Pod"><a href="#配置一次替换多少个-Pod" class="headerlink" title="配置一次替换多少个 Pod"></a>配置一次替换多少个 Pod</h3><p>通过 <code>maxSurge</code> 和 <code>maxUnavailable</code> 配置</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>maxSurge</td><td>The maximum number of Pods above the desired number of replicas that the Deployment can have during the rolling update. The value can be an absolute number or a percentage of the desired number of replicas.<br /><br />在滚动更新期间 Deployment 可以超过 replica 中最大的 Pod 数量。</td></tr><tr><td>maxUnavaliable</td><td>The maximum number of Pods relative to the desired replica count that can be unavailable during the rolling update. The value can be an absolute number or a percentage of the desired number of replicas.<br /><br />最少可用的 Pod 数量为 total - maxUnavailable，最多不可用的 Pod 数量为 maxUnavailable</td></tr></tbody></table><p> <code>maxSurge</code> 和 <code>maxUnavailable</code> 会影响 Replica 中期望的 Pod 数量。</p><p><strong>maxSurge = 0, maxUnavailable = 1</strong></p><p><img src="https://s2.loli.net/2022/05/09/toFLwvXl5HuqObE.png" alt="img"></p><p><strong>maxSurge = 1, maxUnavailable = 0</strong></p><p><img src="https://s2.loli.net/2022/05/09/cE5UJVdDAa8mkrg.png" alt="img"></p><p><strong>maxSurge = 1, maxUnavailable = 1</strong></p><p><img src="https://s2.loli.net/2022/05/09/mnLPUaQyldEHxj3.png" alt="img"></p><h3 id="暂停、恢复-RollingUpdate"><a href="#暂停、恢复-RollingUpdate" class="headerlink" title="暂停、恢复 RollingUpdate"></a>暂停、恢复 RollingUpdate</h3><p><code>kubectl rollout pause deployment kiada</code> 和 <code>kubectl rollout resume deployment kiada</code></p><p>这个骚操作还是第一次听说..</p><h3 id="minReadySeconds"><a href="#minReadySeconds" class="headerlink" title="minReadySeconds"></a>minReadySeconds</h3><p>在 RollingUpdate 过程中，新创建的 Pod Ready 后，<strong>还不算结束</strong>，要等待 <code>minReadySeconds</code> 这么久后， Pod 才会变为 available 状态。</p><p>默认情况下是 0，Pod Ready 了就算 available.</p><h3 id="检查-rollout-是否在执行"><a href="#检查-rollout-是否在执行" class="headerlink" title="检查 rollout 是否在执行"></a>检查 rollout 是否在执行</h3><p><code>kubectl describe deployment xxx</code></p><h3 id="回滚-Rolling-Back"><a href="#回滚-Rolling-Back" class="headerlink" title="回滚 Rolling Back"></a>回滚 Rolling Back</h3><ul><li><p>回滚到上一版本</p><p><code>kubectl rollout undo deployment kiada</code></p></li></ul><blockquote><p>undo 命令也可以在 RollingUpdate 过程中使用，用来取消这个升级</p></blockquote><ul><li><p>回滚到指定版本</p><p><code>kubectl rollout undo deployment kiada --to-revision=1</code></p></li></ul><h3 id="回滚和使用-yaml-文件恢复的区别"><a href="#回滚和使用-yaml-文件恢复的区别" class="headerlink" title="回滚和使用 yaml 文件恢复的区别"></a>回滚和使用 yaml 文件恢复的区别</h3><ul><li>回滚使用 <code>kubectl rollout undo</code> 命令，只是恢复 pod-templete 内容</li><li>使用 apply -f 的方式会将所有的内容进行恢复</li></ul><p>比如我们在 1.2 版本中修改了升级方式为 RollingUpdate，1.1 仍然为 Recreate，这时候如果我们通过，apply 的方式，会将我们改的内容进行覆盖。</p><p>一般情况下，都是用 <code>kubectl rollout undo</code> 命令，之前没学到这个命令，在操作更新版本的时候，都是 edit deployment 然后修改一下 镜像的版本，出了问题也是简单粗暴的处理，直接将版本恢复回去。</p><p>下次上线升级的时候，可以考虑使用这种方式，两个字，优雅。</p><h3 id="显示-rollout-历史"><a href="#显示-rollout-历史" class="headerlink" title="显示 rollout 历史"></a>显示 rollout 历史</h3><p><code>kubectl rollout history deploy kiada</code></p><ul><li><p>查看某次升级的具体信息</p><p><code>kubectl rollout history deployment kiada --revision 2</code></p><p>查看 kiada 这个 Deployment 在 revision 为 2 的版本做了哪些调整。</p></li></ul><p><img src="https://s2.loli.net/2022/05/09/XWgT2rFj7blSqU9.png" alt="img"></p><ul><li><code>revisionHistoryLimit</code> 用来配置保存多少个历史记录，默认是 10。</li></ul><h2 id="Traffic-shadowing"><a href="#Traffic-shadowing" class="headerlink" title="Traffic shadowing"></a>Traffic shadowing</h2><p>（这个应该翻译成啥呢？）</p><p><img src="https://s2.loli.net/2022/05/09/Pu9zvCGAU4e1dZy.png" alt="img"></p><p>利用 Ingress 进行流量复制，将请求转发一份到新的版本中，然后忽略掉响应。</p><h2 id="完"><a href="#完" class="headerlink" title="完"></a>完</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;将笔记进行拆分，都写在一个里边很拥挤，不方便翻阅查看。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>操作系统启动</title>
    <link href="https://bqyang.top/2022/os/os-start/"/>
    <id>https://bqyang.top/2022/os/os-start/</id>
    <published>2022-05-05T11:02:26.938Z</published>
    <updated>2022-05-13T03:22:13.982Z</updated>
    
    <content type="html"><![CDATA[<hr><p>尝试揭开操作系统的神秘面纱。</p><span id="more"></span><h1 id="QEMU"><a href="#QEMU" class="headerlink" title="QEMU"></a>QEMU</h1><h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><pre class="line-numbers language-none"><code class="language-none">wget https:&#x2F;&#x2F;download.qemu.org&#x2F;qemu-7.0.0.tar.xztar xvJf qemu-7.0.0.tar.xzcd qemu-7.0.0.&#x2F;configuremake&#x2F;&#x2F; make 后记得 make install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>安装个 QEMU 真的是费死劲了，能遇到的问题基本上都遇到了，而且<strong>这个容器我挂了windows</strong>的一个目录（为了保存下来），make 花了<strong>3</strong>小时。</p></blockquote><p>遇到的具体问题如下：</p><ul><li>缺少依赖，pixman-1, gthread, glib, 我是基于 alpine 镜像构建的，很多依赖找起来很费事，不过要熟练使用 search 命令。</li></ul><p>具体解决方案省略，作为一个合格的工程师，肯定会找到办法的。</p><h1 id="CPU-Reset"><a href="#CPU-Reset" class="headerlink" title="CPU Reset"></a>CPU Reset</h1><p>程序就是状态机，操作系统也是一个 C 程序。那么问题就来了，电脑在 CPU Reset 之后（获得了一个初始状态）发生了什么？</p><blockquote><p>初始状态指的是：各种寄存器的初始值是什么。</p></blockquote><p><strong>计算机中没有任何神秘的东西</strong></p><p><img src="https://s2.loli.net/2022/05/06/e6anlsRhC2BULVu.png" alt="intel-cpu-reset"></p><p>可以看到，表 9-1 列出了在通电、重置、初始化后各种寄存器的值。这些都是<strong>约定</strong>，即硬件和软件约定好，每次加电后，CPU 状态设置为这些值，CPU 就是不断地执行指令，然后一步一步的加载出操作系统代码。</p><p><img src="https://s2.loli.net/2022/05/06/9SzlH2nRchoykQL.png" alt="image-20220506202315147"></p><h1 id="Legacy-BIOS-约定"><a href="#Legacy-BIOS-约定" class="headerlink" title="Legacy BIOS 约定"></a>Legacy BIOS 约定</h1><p>（操作系统与BIOS之间的约定，BIOS 上哪加载操作系统代码）</p><p>BIOS （Basic I/O System），BIOS 就是我们 CPU Reset 后 PC 指向的位置，也就意味着加电后执行的第一个程序是 BIOS 代码。然后 BIOS  代码都做了什么呢？他要做的事情都是约定好的。</p><p>MBR（Master Boot Record）主引导扇区，BIOS 要做的事情就是加载磁盘的前<strong>512字节</strong>（主引导扇区）到 <strong>0x7c00</strong>，<strong>检查这块磁盘是否可以作为启动盘</strong>。如果是，可以从磁盘中加载更多的内容到内存中，否则检查下一块磁盘的前512字节。</p><p>检查磁盘作为启动盘的标志是什么？<strong>55aa</strong></p><blockquote><p>怎么查看呢？有没有什么命令能查？</p><p>还真就是只有想不到的，没有做不到的。</p></blockquote><p>**hexdump ** 可以 <code>hexdump --help</code> 看一下具体细节，这里就是 <code>hexdump -n 512 /dev/sda    </code></p><p>补上一张 MBR 的图片</p><p><img src="https://s2.loli.net/2022/05/13/K9cL6sJ2etyP4QR.png" alt="o_mbr_anatomy"></p><p>是哪条指令将 MBR 中的内容加载到内存中的？</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly"># 就是下面这条指令0xfa759:     rep insl (%dx),%es:(%di)# ...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>如何查看上述的指令？x/i ($cs * 16 + $rip)</p></blockquote><p>cs （code segment register） 代码段寄存器</p><p>ds （data segment register） 数据段寄存器</p><p>为什么要按照这个算式进行查询呢？<code>($cs * 16 + $rip)</code> 早期的 IBM PC 机器，总线是 20 位，但是寄存器中都是 16 位的数据，所以怎么凑够这个 20 位的总线，代码段地址左移 4 位，然后加上偏移量，就是我们要执行的下一条指令地址。</p><h1 id="为什么叫做-x86-架构"><a href="#为什么叫做-x86-架构" class="headerlink" title="为什么叫做 x86 架构"></a>为什么叫做 x86 架构</h1><p>一般这种都是历史原因… 早期的 IBM PC 机器使用 Intel 8086 处理器，后来就把这个 8086 CPU 的架构叫做 x86。更详细的内容可以 Google 上看下，其实就连这个 <code>0x7c00  </code>都有一部分历史原因。</p>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;p&gt;尝试揭开操作系统的神秘面纱。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>同步原语-semaphore</title>
    <link href="https://bqyang.top/2022/os/concurrency-sema/"/>
    <id>https://bqyang.top/2022/os/concurrency-sema/</id>
    <published>2022-04-25T02:48:51.361Z</published>
    <updated>2022-04-27T06:46:19.575Z</updated>
    
    <content type="html"><![CDATA[<p>同步原语–信号量学习</p><span id="more"></span><h2 id="信号量定义"><a href="#信号量定义" class="headerlink" title="信号量定义"></a>信号量定义</h2><p>信号量就是一个拥有整数值的对象，可以用多个例程操控它。</p><blockquote><p>信号量的初始值决定了它的行为，在与它交互之前需要进行初始化，如下：</p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;semaphore.h></span></span><span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">int</span> <span class="token expression"><span class="token function">sem_init</span><span class="token punctuation">(</span></span></span><span class="token class-name">sem_t</span> <span class="token operator">*</span>sem<span class="token punctuation">,</span><span class="token keyword">int</span> pshared<span class="token punctuation">,</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">sem</span> <span class="token expression">信号</span></span><span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">value</span> <span class="token expression">指定了信号量的初始值</span></span><span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">pshared</span> <span class="token expression">表示在线程间共享，还是进程间</span></span><span class="token function">sema_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="使用-sema-实现-lock"><a href="#使用-sema-实现-lock" class="headerlink" title="使用 sema 实现 lock"></a>使用 sema 实现 lock</h2><p>这时应将 sema 的 value 设置为几？</p><p>可以想象，锁的状态其实只有<strong>上锁，未上锁</strong>两种状态，所以我们只需要使信号量满足这两种状态即可，即 value = 1，这种情况下，0，1就可以表示锁的这两种状态。</p><p>想进入临界区（以下用 CS 代替），就需要获取锁，检查信号量是否被占用：</p><ul><li>未上锁，信号量的值减一，进入临界区</li><li>上锁，信号量值减一，睡眠等待</li></ul><p>退出 CS，调用 <code>sema_post</code> 释放信号：</p><ul><li>有等待线程：信号量值加一，退出临界区，唤醒一个等待中的线程</li><li>没有等待线程：信号量值加一，退出临界区，无需唤醒</li></ul><blockquote><p>当信号量为负数时，比如说 -3，代表着有三个线程在等待这个信号被释放</p></blockquote><p>不难看出，当我们使用信号量来实现锁的时候，只有这两种状态（上锁，未上锁），所以这种信号通常也被称为<strong>binary semaphore</strong></p><h2 id="sema-实现-CVs"><a href="#sema-实现-CVs" class="headerlink" title="sema 实现 CVs"></a>sema 实现 CVs</h2><p><code>sema_init(sema, 0, 0)</code></p><p>想要父进程等待子进程执行结束的话，为什么 value 的值要设置为 0 ？</p><h2 id="sema-实现-producer-consumer-模型"><a href="#sema-实现-producer-consumer-模型" class="headerlink" title="sema 实现 producer/consumer 模型"></a>sema 实现 producer/consumer 模型</h2><p>如同当初使用 CVs 实现生产者消费者模型时一样，这里也是需要两个信号量来表示何时生产者可发送，接收者可接收。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// ...</span>    <span class="token function">sem_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>empty<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> MAX<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// MAX are empty</span>    <span class="token function">sem_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>full<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 0 are full</span>    <span class="token comment">// ...</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当 MAX &gt; 1 时，会出现什么问题？（仔细观察，的确不难看出，data-race）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> buffer<span class="token punctuation">[</span>MAX<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> fill <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">int</span> use <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    buffer<span class="token punctuation">[</span>fill<span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">;</span> <span class="token comment">// Line F1</span>    fill <span class="token operator">=</span> <span class="token punctuation">(</span>fill <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> MAX<span class="token punctuation">;</span> <span class="token comment">// Line F2</span><span class="token punctuation">&#125;</span> <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> tmp <span class="token operator">=</span> buffer<span class="token punctuation">[</span>use<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// Line G1</span>    use <span class="token operator">=</span> <span class="token punctuation">(</span>use <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> MAX<span class="token punctuation">;</span> <span class="token comment">// Line G2</span>    <span class="token keyword">return</span> tmp<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token class-name">sem_t</span> empty<span class="token punctuation">;</span><span class="token class-name">sem_t</span> full<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">producer</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> loops<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">sem_wait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>empty<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Line P1</span>        <span class="token function">put</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Line P2</span>        <span class="token function">sem_post</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>full<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Line P3</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">consumer</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> tmp <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>tmp <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">sem_wait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>full<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Line C1</span>        tmp <span class="token operator">=</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Line C2</span>        <span class="token function">sem_post</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>empty<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Line C3</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="哲学家吃饭"><a href="#哲学家吃饭" class="headerlink" title="哲学家吃饭.."></a>哲学家吃饭..</h2><p><img src="https://s2.loli.net/2022/04/27/wYIi1fhCQog2XVP.png" alt="image-20220427140847674"></p><ul><li><p><strong>如何解决相互依赖的问题</strong></p></li><li><p><strong>什么情况下会出现死锁</strong></p></li></ul><h2 id="Thread-Throttling"><a href="#Thread-Throttling" class="headerlink" title="Thread Throttling"></a>Thread Throttling</h2><p>线程节流，控制线程数量。</p><p>通过信号量控制进入临界区的线程数量</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;同步原语–信号量学习&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>并发控制-Condition-variables</title>
    <link href="https://bqyang.top/2022/os/concurrency-cv/"/>
    <id>https://bqyang.top/2022/os/concurrency-cv/</id>
    <published>2022-04-24T08:51:57.520Z</published>
    <updated>2022-04-24T09:36:40.764Z</updated>
    
    <content type="html"><![CDATA[<p>检查某些<strong>特定条件</strong>是否满足，然后决定线程是否继续执行。</p><span id="more"></span><p>使用<strong>变量</strong>控制具体该哪个线程执行。</p><p>使用 CVs 实现 生产者/消费者 模型，最终实现：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> buffer<span class="token punctuation">[</span>MAX<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> fill_ptr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">int</span> use_ptr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    buffer<span class="token punctuation">[</span>fill_ptr<span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">;</span>    fill_ptr <span class="token operator">=</span> <span class="token punctuation">(</span>fill_ptr <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> MAX<span class="token punctuation">;</span>    count<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> tmp <span class="token operator">=</span> buffer<span class="token punctuation">[</span>use_ptr<span class="token punctuation">]</span><span class="token punctuation">;</span>    use_ptr <span class="token operator">=</span> <span class="token punctuation">(</span>use_ptr <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> MAX<span class="token punctuation">;</span>    count<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> tmp<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token class-name">cond_t</span> empty<span class="token punctuation">,</span> fill<span class="token punctuation">;</span><span class="token class-name">mutex_t</span> mutex<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">producer</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> loops<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">Pthread_mutex_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// p1</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> MAX<span class="token punctuation">)</span> <span class="token comment">// p2</span>            <span class="token function">Pthread_cond_wait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>empty<span class="token punctuation">,</span> <span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// p3</span>        <span class="token function">put</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// p4</span>        <span class="token function">Pthread_cond_signal</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>fill<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// p5</span>        <span class="token function">Pthread_mutex_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// p6</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">consumer</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> loops<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">Pthread_mutex_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// c1</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// c2</span>            <span class="token function">Pthread_cond_wait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>fill<span class="token punctuation">,</span> <span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// c3</span>        <span class="token keyword">int</span> tmp <span class="token operator">=</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// c4</span>        <span class="token function">Pthread_cond_signal</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>empty<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// c5</span>        <span class="token function">Pthread_mutex_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// c6</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为什么判断 <code>count == MAX OR count == 0</code> 的时候使用 <code>while</code> 而不是 <code>if</code>？？</p><blockquote><p>结论不重要，重要的是分析的过程</p></blockquote><p>// TODO 需要画状态机执行流程分析</p><blockquote><p><code>Pthread_cond_wait</code> 主要职责：将当前线程休眠<strong>并释放锁</strong>，当被唤醒的时候会尝试<strong>重新获取锁</strong>。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;检查某些&lt;strong&gt;特定条件&lt;/strong&gt;是否满足，然后决定线程是否继续执行。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>跟兄弟们聊聊</title>
    <link href="https://bqyang.top/2022/summary/about-0423/"/>
    <id>https://bqyang.top/2022/summary/about-0423/</id>
    <published>2022-04-23T05:24:37.969Z</published>
    <updated>2022-04-23T06:59:12.009Z</updated>
    
    <content type="html"><![CDATA[<p>今天上来就是为了跟兄弟们聊聊，在工作中怎么“优雅”的向别人提问，还有关于工作态度的一点理解。</p><span id="more"></span><p>这不也是闲的没事情嘛，明天还得补一天班，东拼西凑弄个五天假期，估计不少程序员同事还得加个两天。前两天女朋友刚好有一个面试，整个对话过程里外里透露着要剥削你。</p><p>她上来就给你承诺，法定节假日都是遵循国家规定的，后边说到加班的时候，冷不丁来一句，法定节假日加班是没有三倍工资的，我俩直接四目相对人都傻了。</p><p>后边当然就是果断拒绝，毕竟也是刚开始面试，还有很多机会。</p><p>好！接下来就聊聊，我最近工作上遇到的一件事情，或者说一类事情。（跟我没关系，是一种现象）开始之前先跟兄弟们说一下我平常的状态，每天基本上都是独来独往，因为住的也比较近嘛，中午也不在公司都是买完回家吃，所以跟同事平时的交流只有工作上的事情。对于公司里、同事间的八卦，我当然也感兴趣，但是奈何交流的不多，自然知道的也就比较少。</p><p>我想的就是，每天按时上下班，工作期间把活做完，合理安排时间。现在这家公司已经很人性化了，不用 KPI 逼着你出活，不用每天加班，给我们开发的时间也都绰绰有余。当给你一个完全没有涉猎过的领域时，你是有足够的时间从零开始的。</p><p>委婉的说，自己可支配时间很多，说白了，很多时间都是闲着没事干。</p><p>也就是这样，各种千奇百怪的人都冒出来了，先说说我，我就在座位上不忙的时候每天都有机会看会技术文章，忙的时候也不会抱怨，毕竟赚的就是这份钱。再说我见到的，大家都很默契的找到了同伴，两个人一组，基本上每天也都是固定的时间，到点就下楼。说实话，很羡慕但是自己还不敢出去转悠。我们这边工位一天有 1/4 的时间都是空着。</p><p>这都是我看到的，也没有刻意的去盯着谁谁，大家每天都是这个套路。</p><p>反正就我目前的想法来讲，有这个时间，不如多搞点技术。咱也别把话说的太死，万一以后咱也一样呢。</p><p>另一个就是怎么向别人提问，想跟兄弟们聊的并不是提问的方式，而是向别人提问的时候应该抱着怎样的态度，这是我的观点。</p><p>我们组前几个月新来了一个小子，五年工作经验，最开始没接触不知道他底，后边聊了几次，问了几次问题。话语之间就感觉到这tm五年，这五年怎么过来的。一些我这种初级问的问题，从他口中不知道问出来多少次，而且他问的还是我，一个初级。</p><p>就是觉得挺诧异，你不应该自己详细了解之后，然后针对没搞明白的地方进行提问吗，难道说要从到到尾给你讲一遍？这怎么体现你的学习能力，适应能力。所以所别很随便的就去提问，或者说我们要提就要提一些有意义的问题。</p><p>人不可能把你当小白对待，更没有时间给你做针对性的培训。不要把希望寄托在别人身上，既然一切的答案都在代码中，有时间浏览工作无关的网页，为什么不能花些时间去研究一下代码呢？</p><p>每个人的心里都有一杆秤，你张口，就可能会掉秤。咬咬牙，啃下来，那你就有机会涨。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天上来就是为了跟兄弟们聊聊，在工作中怎么“优雅”的向别人提问，还有关于工作态度的一点理解。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>并发控制-互斥（自旋锁、互斥锁）</title>
    <link href="https://bqyang.top/2022/os/concurrency-lock/"/>
    <id>https://bqyang.top/2022/os/concurrency-lock/</id>
    <published>2022-04-20T14:10:43.287Z</published>
    <updated>2022-04-24T08:52:37.868Z</updated>
    
    <content type="html"><![CDATA[<p>锁.</p><span id="more"></span><p>如何定义一把锁？</p><ul><li>basic - 能否达到互斥</li><li>fairness - 能否保证公平，极端情况下，是否会出现 thread 获取不到锁的情况</li><li>performance - 性能，使用锁带来的负载。<ul><li>没有竞争时</li><li>单核多线程竞争</li><li>多核多线程竞争</li></ul></li></ul><h2 id="原子指令-Bus-Lock"><a href="#原子指令-Bus-Lock" class="headerlink" title="原子指令 Bus Lock"></a>原子指令 Bus Lock</h2><p>正如我们最熟悉的<strong>累加</strong>运算，很多像我一样的初级程序员都会在编写并发程序的时候注意不到这个问题，运算过程中涉及到 load/store 指令，但是并不是原子操作。</p><p>所以在没有并发控制的情况下，很容易就会导致 data-race 的问题。我们可以通过算法，比如之前文章提到的 <code>Peterson</code> 来实现并发控制，但是我们可以图省事，把这项工作交给硬件工程师去做呀？</p><p>我们向硬件工程师提需求，让底层提供一条可以在多线程场景下使用的指令而且还得是并发安全的</p><p>有了硬件提供给我们一条原子的 读+写 （load+store） 指令，那我们就放心的去并发访问了，这里就是 exchange （x86 叫这个，别的又叫 Test_And_Set） 指令。</p><blockquote><p>请注意！不要误以为是 CAS</p></blockquote><p>只要执行 exchange 每次都会进行<strong>值的交换</strong>，就看交换得到的值是什么！</p><p>如何使用 exchange 实现互斥？</p><p><code>lock xchg</code> 这个 lock 就会将 bus 锁住（或许这就是为啥它叫 Bus Lock），所以这时候就不是共享的内存了，是<strong>持有这个 bus lock</strong> 线程专有的内存。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// global param</span><span class="token keyword">int</span> table <span class="token operator">=</span> YES<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>retry<span class="token operator">:</span>  <span class="token comment">// use NOPE exchange table(YES)</span>  <span class="token keyword">int</span> got <span class="token operator">=</span> <span class="token function">xchg</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>table<span class="token punctuation">,</span> NOPE<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// if got == NOPE mean other thread have exchanged; so should wait</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>got <span class="token operator">==</span> NOPE<span class="token punctuation">)</span>    <span class="token keyword">goto</span> retry<span class="token punctuation">;</span>  <span class="token function">assert</span><span class="token punctuation">(</span>got <span class="token operator">==</span> YES<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// unlock: use YES exchange NOPE</span><span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token function">xchg</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>table<span class="token punctuation">,</span> YES<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实现互斥的协议（即上述代码的描述）：</p><ul><li>想上厕所的同学 (一条 xchg 指令)<ul><li>天黑请闭眼（锁总线）</li><li>看一眼桌子上有什么 (🔑 或 🔞)</li><li>把 🔞 放到桌上 (覆盖之前有的任何东西)</li><li>天亮请睁眼；看到 🔑 才可以进厕所哦</li></ul></li><li>出厕所的同学<ul><li>把 🔑 放到桌上</li></ul></li></ul><blockquote><p>原子指令的模型</p><ul><li>保证之前的 store 都写入内存（在执行原子指令时，保证所有的 store 都执行完毕）</li><li>保证 load/store 不与原子指令乱序</li></ul></blockquote><p><strong>这里真的是解答了一个困惑我很长时间而且没有得到解决的疑问！</strong></p><p>原子操作并不是无锁的！</p><h3 id="TODO-Lock-指令的现代实现"><a href="#TODO-Lock-指令的现代实现" class="headerlink" title="// TODO Lock 指令的现代实现"></a>// TODO Lock 指令的现代实现</h3><h2 id="RISC-V-中原子操作的实现"><a href="#RISC-V-中原子操作的实现" class="headerlink" title="RISC-V 中原子操作的实现"></a>RISC-V 中原子操作的实现</h2><h2 id="自旋锁-spin-lock"><a href="#自旋锁-spin-lock" class="headerlink" title="自旋锁 (spin lock)"></a>自旋锁 (spin lock)</h2><p><a href="https://en.wikipedia.org/wiki/Spinlock#:~:text=In%20software%20engineering%2C%20a%20spinlock,a%20kind%20of%20busy%20waiting.">wiki</a> 定义：a <strong>spinlock</strong> is a <a href="https://en.wikipedia.org/wiki/Lock_(computer_science)">lock</a> that causes a <a href="https://en.wikipedia.org/wiki/Thread_(computer_science)">thread</a> trying to acquire it to simply wait in a loop (“spin”) while repeatedly checking whether the lock is available. </p><blockquote><p>spin 自旋，在这里就是循环等待锁被释放；GMP 模型中有一个 spining m 用来寻找可执行的 g 同样也是自旋。</p></blockquote><p>从上述的代码也不难看出，就是通过不断的循环，load 锁的状态，直到锁被上一个持有者释放。</p><p>自旋锁存在的问题：</p><ul><li>空转</li><li>获得自旋锁的线程可能被切换</li></ul><p>自旋锁使用场景：</p><p>操作系统内核的并发数据结构</p><ul><li>临界区几乎不拥堵，很快就能执行完</li><li>持有自旋锁时禁止执行流切换</li></ul><h2 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;锁.&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>图片仓库被屏蔽</title>
    <link href="https://bqyang.top/2022/warning/"/>
    <id>https://bqyang.top/2022/warning/</id>
    <published>2022-04-19T10:03:54.932Z</published>
    <updated>2022-04-19T12:18:32.924Z</updated>
    
    <content type="html"><![CDATA[<p>使用 gitee 做的图床被封了，导致很多图片都失效了，正在申请恢复，然后将图片一点点迁移到 SM.MS …</p><p>SM.MS 又有加载延迟的问题.. 但是也比看不了强..</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;使用 gitee 做的图床被封了，导致很多图片都失效了，正在申请恢复，然后将图片一点点迁移到 SM.MS …&lt;/p&gt;
&lt;p&gt;SM.MS 又有加载延迟的问题.. 但是也比看不了强..&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>perterson 算法学习</title>
    <link href="https://bqyang.top/2022/peterson/"/>
    <id>https://bqyang.top/2022/peterson/</id>
    <published>2022-04-18T06:31:47.361Z</published>
    <updated>2022-04-19T12:17:15.034Z</updated>
    
    <content type="html"><![CDATA[<p>并发控制算法之-Peterson</p><span id="more"></span><h3 id="Peterson-算法解决了什么问题"><a href="#Peterson-算法解决了什么问题" class="headerlink" title="Peterson 算法解决了什么问题"></a>Peterson 算法解决了什么问题</h3><ul><li>peterson 算法解决的是双线程访问共享变量导致的 data-race 问题。</li></ul><blockquote><p>这里确实是双线程，但是该算法在多线程场景下也适用。</p></blockquote><h3 id="Peterson-算法描述"><a href="#Peterson-算法描述" class="headerlink" title="Peterson 算法描述"></a>Peterson 算法描述</h3><p>抽象的代码描述，内容来自 <a href="https://en.wikipedia.org/wiki/Peterson%27s_algorithm">wiki</a>：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">bool flag<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>false<span class="token punctuation">,</span> false<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> turn<span class="token punctuation">;</span><span class="token comment">/*pc 1*/</span>P0<span class="token operator">:</span>      flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> true<span class="token punctuation">;</span><span class="token comment">/*pc 2*/</span>P0_gate<span class="token operator">:</span> turn <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">/*pc 3*/</span>         <span class="token keyword">while</span> <span class="token punctuation">(</span>flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> true <span class="token operator">&amp;&amp;</span> turn <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>                 <span class="token punctuation">&#123;</span>                     <span class="token comment">// busy wait</span>                 <span class="token punctuation">&#125;</span>                 <span class="token comment">// critical section</span>                 <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                 <span class="token comment">// end of critical section</span><span class="token comment">/*pc 4*/</span>         flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> false<span class="token punctuation">;</span><span class="token comment">/* pc 1*/</span>P1<span class="token operator">:</span>      flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> true<span class="token punctuation">;</span><span class="token comment">/* pc 2*/</span>P1_gate<span class="token operator">:</span> turn <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">/* pc 3*/</span>         <span class="token keyword">while</span> <span class="token punctuation">(</span>flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> true <span class="token operator">&amp;&amp;</span> turn <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>                 <span class="token punctuation">&#123;</span>                     <span class="token comment">// busy wait</span>                 <span class="token punctuation">&#125;</span>                 <span class="token comment">// critical section</span>                 <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                 <span class="token comment">// end of critical section</span><span class="token comment">/* pc 4*/</span>        flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> false<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码解释：</p><ul><li>flag 用于标识哪个线程想要进入临界区</li><li>turn 用于辅助flag表示，也是用来判断是否可以进入临界区</li></ul><p>规定如下：</p><blockquote><p>如果对方的 flag 为真且 turn 不是自己的名字，需要等待，否则（上述两条件任意一个为假）进入临界区。</p></blockquote><p>这时候我们启动 P1,P2 两个线程，模拟两个线程交替执行，然后将涉及到的状态变化画出来，正如图中所表示的一样。</p><p><img src="https://s2.loli.net/2022/04/19/l4dy1wmXIgMuUCx.png" alt="peterson"></p><p>综上所述，Peterson 算法，巧妙地运用了 flag, turn 标识达到了互斥访问的目的。</p><h3 id="表面上的谦让"><a href="#表面上的谦让" class="headerlink" title="表面上的谦让"></a>表面上的谦让</h3><p>这里我们可以看到，如果说 P1 先将 P2 的名字放到了 turn 上，假惺惺的说，你先进吧。但是 P2 执行的时候会覆盖掉 turn，让 P1 进，所以就出现了先修改 turn 变量的线程先进入，后修改的等待。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;并发控制算法之-Peterson&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>宽松内存模型</title>
    <link href="https://bqyang.top/2022/RMO/"/>
    <id>https://bqyang.top/2022/RMO/</id>
    <published>2022-04-16T15:52:21.800Z</published>
    <updated>2022-04-19T06:02:45.861Z</updated>
    
    <content type="html"><![CDATA[<hr><p>最近学习到一个关于内存模型的知识点，一开始对内存模型的认识还是以为是描述数据结构实在内存中怎样进行存储的。</p><span id="more"></span><p>后来发现我这种理解完全被这个名字所误导了，宽松内存模型指的是，在多核处理器的情况下，对访问共享内存行为的描述。</p><p>解释下面这个 C 代码：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"thread.h"</span></span><span class="token comment">// 全局变量 x, y</span><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>atomic_int flag<span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">FLAG</span> <span class="token expression"><span class="token function">atomic_load</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>flag<span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">FLAG_XOR</span><span class="token expression"><span class="token punctuation">(</span>val<span class="token punctuation">)</span> <span class="token function">atomic_fetch_xor</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>flag<span class="token punctuation">,</span> val<span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">WAIT_FOR</span><span class="token expression"><span class="token punctuation">(</span>cond<span class="token punctuation">)</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>cond<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">;</span></span></span><span class="token comment">// 指定编译的时候不要进行内联优化</span> <span class="token keyword">__attribute__</span><span class="token punctuation">(</span><span class="token punctuation">(</span>noinline<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">void</span> <span class="token function">write_x_read_y</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> y_val<span class="token punctuation">;</span>  <span class="token comment">// 汇编实现变量 +1 的操作</span>  <span class="token keyword">asm</span> <span class="token keyword">volatile</span><span class="token punctuation">(</span>    <span class="token string">"movl $1, %0;"</span> <span class="token comment">// x = 1</span>    <span class="token string">"movl %2, %1;"</span> <span class="token comment">// y_val = y</span>    <span class="token operator">:</span> <span class="token string">"=m"</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"=r"</span><span class="token punctuation">(</span>y_val<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token string">"m"</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span>  <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> y_val<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 代码含义如上</span> <span class="token keyword">__attribute__</span><span class="token punctuation">(</span><span class="token punctuation">(</span>noinline<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">void</span> <span class="token function">write_y_read_x</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> x_val<span class="token punctuation">;</span>  <span class="token keyword">asm</span> <span class="token keyword">volatile</span><span class="token punctuation">(</span>    <span class="token string">"movl $1, %0;"</span> <span class="token comment">// y = 1</span>    <span class="token string">"movl %2, %1;"</span> <span class="token comment">// x_val = x</span>    <span class="token operator">:</span> <span class="token string">"=m"</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"=r"</span><span class="token punctuation">(</span>x_val<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token string">"m"</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>  <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> x_val<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">T1</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">WAIT_FOR</span><span class="token punctuation">(</span><span class="token punctuation">(</span>FLAG <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">write_x_read_y</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">FLAG_XOR</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">T2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">WAIT_FOR</span><span class="token punctuation">(</span><span class="token punctuation">(</span>FLAG <span class="token operator">&amp;</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">write_y_read_x</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">FLAG_XOR</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// thread sync func</span><span class="token keyword">void</span> <span class="token function">Tsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    x <span class="token operator">=</span> y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">/*      No memory operand will be moved across the operation,      either forward or backward. Further,       instructions will be issued as necessary to prevent       the processor from speculating loads across       the operation and from queuing stores after the operation.      简言之就是会保证 x=y=0 这条赋值操作执行完成      或许你会问，我把这个赋值语句写在前边    */</span>    <span class="token function">__sync_synchronize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// full barrier</span>    <span class="token function">assert</span><span class="token punctuation">(</span>FLAG <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">FLAG_XOR</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 这里没搞懂，为什么执行 XOR 会使 cache miss</span>    <span class="token comment">// T1 and T2 clear 0/1-bit, respectively      </span>    <span class="token function">WAIT_FOR</span><span class="token punctuation">(</span>FLAG <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">fflush</span><span class="token punctuation">(</span><span class="token constant">stdout</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 创建线程，线程的起点为 T1</span>  <span class="token function">create</span><span class="token punctuation">(</span>T1<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">create</span><span class="token punctuation">(</span>T2<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">create</span><span class="token punctuation">(</span>Tsync<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码执行流程分析：</p><ul><li>T1,T2 函数开始执行就会被卡住，因为 FLAG 变量初始值为 0</li><li>Tsync 函数，初始化全局变量 x,y 然后执行了一个 <code>__sync_synchronize();</code> 函数，详情见注释。</li></ul><p>然后 <code>FLAG_XOR</code> 命令，让 T1, T2 两个在等待中的开始执行。</p><p>write_y_read_x 和 write_x_read_y 两个函数，也比较简单，就是将 x y 分别进行赋值的操作，然后读取另一个变量。写 y 读 x，写 x 读 y。我们看下具体的汇编代码：</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">00000000004008f1 &lt;write_x_read_y&gt;:  ... # 省略无关代码  # 将 1 赋值 x  4008f9:       c7 05 89 17 20 00 01    movl   $0x1,0x201789(%rip)        # 60208c &lt;x&gt;  # 读取 y 变量  400903:       8b 05 87 17 20 00       mov    0x201787(%rip),%eax        # 602090 &lt;y&gt;  ...  400921:       c3                      retq<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 从程序就是状态机的视角去分析的话，如下：</p><p>在开始时，我们有 x,y两个全局变量，T1,T2 两个线程，然后 T1，T2 开始交替执行。</p><p><img src="https://s2.loli.net/2022/04/19/x6KeQ2mMXN9qOJ3.jpg" alt="28d0652f7b48792aeea6c52883045fe.jpg"></p><p>从上图我们不难得出，所有的输出结果无外乎是</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 0 1</span><span class="token comment">// 1 0</span><span class="token comment">// 1 1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>我们看一下执行 1000 次的输出结果是什么样</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//   756 0 0 </span><span class="token comment">//   242 0 1</span><span class="token comment">//     2 1 0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>很奇怪，根本不存在序列为 <code>1 1</code> 的组合，而且输出占最多次数的是  <code>0 0</code> ，从我们刚才列出的输出结果中，并没有这个序列。</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><p>实际上，我们的代码经过编译器优化后生成汇编指令，汇编指令被放到处理器上进行执行。在多核的情况下，为了榨取 CPU 的最高性能，<code>处理器会对待执行的汇编代码进行优化</code> 也就是将汇编代码再执行一次编译优化的过程，即处理器也是编译器。</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">movl   $0x1,0x201789(%rip)mov    0x201787(%rip),%eax<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>从我们人类的视角出发，我们更偏向于顺序化执行，但如果从处理器的视角出发，会对这两条指令进行优化。</p><p>他做的优化是：将写操作放入到待执行队列中，如果说队列塞满了，批量进行写操作。所以，第一条 mov 指令会被放入到队列中，然后先进行读操作。</p><p><img src="https://s2.loli.net/2022/04/19/X5LUKbMhiE9JpCt.png" alt="mem-tso.png"></p><p>所以这就是为什么我们没有看到 1 1 的原因。</p><h3 id="如何进行修复"><a href="#如何进行修复" class="headerlink" title="如何进行修复"></a>如何进行修复</h3><p>既然找到了问题的源头，那么就“有从下手了”，我们不让他放入到队列中，直接执行即可。</p><h3 id="Go-中的内存模型是怎样的？"><a href="#Go-中的内存模型是怎样的？" class="headerlink" title="Go 中的内存模型是怎样的？"></a>Go 中的内存模型是怎样的？</h3><p>// TODO</p>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;p&gt;最近学习到一个关于内存模型的知识点，一开始对内存模型的认识还是以为是描述数据结构实在内存中怎样进行存储的。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>一点总结</title>
    <link href="https://bqyang.top/2022/tips0309/"/>
    <id>https://bqyang.top/2022/tips0309/</id>
    <published>2022-03-09T11:52:02.048Z</published>
    <updated>2022-04-10T07:32:32.396Z</updated>
    
    <content type="html"><![CDATA[<p>这是一篇记录关于生活的记录。</p><span id="more"></span><p>时不时的想感慨一下，但是都是在脑海中一闪而过，现在努力回忆也记不清了，那就和大家聊聊近况吧！</p><p>过完年回来其实并不忙，每天都有时间去学习，要知道，传统的互联网公司，都是赶着进度走的。就好像老师昨天布置了三天的作业量，截止日期还没到的时候，又布置好三天后的作业了。在这种情况下，想参加什么课外活动是根本不可能的，所以你想做一些工作之外的事情也是抽不出来时间的，这也是我比较喜欢现在这家公司的一点。</p><p>我其实并不是喜欢，”前辈们“经常提到的一句话，在压力的驱动下做某些事情可能会更加高效。我觉得这更像是他们把一些繁琐复杂的，他们不想做的工作，强加到你身上的一个借口。所以说，当发生了别人强加于我某些事情时，我所关注的点就变了，我不会把解决问题放在第一位，相反，我在想，本来是你的事情，为什么现在变成了我的事情？</p><blockquote><p>在这里郑重声明，只是描述现象，不具有任何指向性。</p></blockquote><p>上边描述的内容，扯的有点远了，陷入了负面、消极的情绪之中，确实亲身经历过，每每说到这种话题的时候，就开始抑制不住自己。</p><p>也不吐槽啥了..跟大家汇报下最近的收获吧！</p><h3 id="收获-1-生活上"><a href="#收获-1-生活上" class="headerlink" title="收获 1 生活上"></a>收获 1 生活上</h3><p>我办了人生中的第一张信用卡，就算家里人知道我不会乱花钱，那也不敢让家里人知道，他们可能从某些地方听谁家的孩子欠了多少钱，就是这个信用卡什么乱七八糟的.. 我妈嘱咐我很多次不能碰这个东西哈哈。</p><p>但是我说办信用卡是为了买书是不是太装杯了哈哈，作为一名程序员，常需要汲取新鲜的技术和知识，以应对不断变化的大环境，随时做好换工作的准备。国外有一个专门做技术书籍的网站，manning.com 不知道大家有没有听说过，这里边采用了一种模式，<strong>连载</strong>，常看小说的人可能了解的比较多，就是作者还没有更新完全部章节呢，但是呢，他更一点你就可以看一点。</p><p>对！国内的资料在某些方面已经很多了，但是针对某些新鲜的技术，新鲜的领域，都是一些纯英文的资料。国内的技术人经过二次加工然后才呈现给大家。那干嘛不自己主动的去查阅最新的、一手的资料呢？</p><p>个人觉得没啥缺点，唯一的缺点就是我的缺点，我太穷了买不起哈哈，正常国内一本技术书，再贵也就 80 90块钱，这国外买本书打 5 折，还得 24 美元，算下来也得 150 块钱。</p><p>随后不久，就拥有了人生中第二张信用卡，但第二张并不是自己想办的，组长让我们帮她在某银行上班的媳妇一个忙，让我们组的人帮忙注册信用卡，大家没有拒绝的，那我这也不好意思拒绝了，不当那个出头的。</p><p>不过也还好，之前那个只有在境外消费的时候才用到，第二张就当作自己的“花呗”，每个月都会提前还款，对个人征信也是有好处的，反正也没啥毛病。。</p><blockquote><p>如果你克制不住自己消费的欲望，经常把钱花到透支.. 那可能你不适合信用卡..</p></blockquote><h3 id="收获-2-工作上"><a href="#收获-2-工作上" class="headerlink" title="收获 2 工作上"></a>收获 2 工作上</h3><p>作为一名新兵蛋子，能经历一个从零到一的项目，对自己来说可以算是莫大的帮助。从 21 年 8 月入职以来，就一直沉浸在各种的 bug 之中，每天都是解决不完的 bug。</p><p>今年过完年回来，才开始真正的做需求，从最初的年度规划到需求设计-需求评审-技术方案-代码开发（进行中）。可以在其中的每一步学习到很多东西，也包括人与人之间的交流，针对某些问题展开辩论，最终定下来某个方案。</p><p>讨论并不可怕，怕的就是某些时候这个“讨论”是根本没有意义的，最终确定不下来方案，没有可执行的计划。就好像，寝室六个人坐在一起，在讨论今天晚上吃什么，讨论了一晚上，也不知道吃什么，是不是挺形象的。</p><p>在做这个需求的时候，发现需要考虑的东西真的是挺多的，我最开始没有想的那么细致，先是把整体框架搭建出来，写上几个 TODO，直接给大家上个图，献丑了。</p><p><img src="https://gitee.com/yangbaoqiang/images/raw/master/blogpics/image-20220310211719535.png" alt="image-20220310211719535"></p><p>比如说上图，就是将一个点，分成几个阶段，然后记录下每个阶段该做什么事情，后续可能根据集体情况再进行调整。</p><p>以前实习的时候，公司前辈提到，某个业务逻辑先想清楚，想好了再写，写的又快又有质量。现在想想，其实和写作文一个意思，当然我作文写的并不好哈哈，语文经常不及格。所以这招对我来说好像并没有那么适用。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这是一篇记录关于生活的记录。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>k8s 2nd</title>
    <link href="https://bqyang.top/2022/k8s2nd/"/>
    <id>https://bqyang.top/2022/k8s2nd/</id>
    <published>2022-03-02T08:20:23.003Z</published>
    <updated>2022-04-29T07:30:51.493Z</updated>
    
    <content type="html"><![CDATA[<p>各个部分及其字段的含义。</p><span id="more"></span><p><img src="https://gitee.com/yangbaoqiang/images/raw/master/blogpics/image-20220302162130087.png" alt="image-20220302162130087"></p><p><img src="https://gitee.com/yangbaoqiang/images/raw/master/blogpics/image-20220302162138717.png" alt="image-20220302162138717"></p><p>更通俗的方式：</p><p><code>kubectl explain nodes</code></p><p>可以查看 node 的相关信息。</p><p>一个 pod 不应该运行多个容器：</p><ul><li>比如多个进程都会输出日志到控制台，会出现日志混乱。</li><li>container runtime 指挥在 root 进程崩溃的时候进行重启，并不关心子进程。</li><li>如果在一个 pod 中运行多个 container ，水平扩展的时候，会根据 pod 进行扩展，而不是根据 pod 中的 container 进行扩展。</li></ul><p>什么时候需要一个 pod 运行多个容器？</p><p><img src="https://gitee.com/yangbaoqiang/images/raw/master/blogpics/image-20220303135731675.png" alt="image-20220303135731675"></p><p>怎么确定是需要 sidecar 还是要 separate 模式？</p><p>• Do these containers have to run on the same host? </p><p>• Do I want to manage them as a single unit? </p><p>• Do they form a unified whole instead of being independent components? </p><p>• Do they have to be scaled together? </p><p>• Can a single node meet their combined resource needs? </p><p>只输出 yaml 文件 <code>kubectl run kubia --image=luksa/kubia:1.0 --dry-run=client -o yaml &gt; mypod.yaml</code></p><p>–dry-run=client 只输出定义不执行创建。</p><p>使用 port-forward 的执行过程。</p><p><img src="https://gitee.com/yangbaoqiang/images/raw/master/blogpics/image-20220303152703523.png" alt="image-20220303152703523"></p><p>pod 日志的相关操作：</p><ul><li>查看日志 <code>kubectl logs kubia</code></li><li>实时查看 <code>kubectl logs --follow kubia</code> 简版 <code>kubectl logs -f kubia</code></li><li>查看最近两分钟的日志 <code>kubectl logs kubia --since=2m</code></li><li>查看从某个时间点开始的日志 <code>kubectl logs kubia --since-time=xxxxxx</code></li><li>查看倒数10行的日志 <code>kubectl logs kubia --tail=10</code></li></ul><p>日志文件存储在哪里了？</p><p>pod 中的container日志，通常会存储在 node 的 <code>/var/log/containers</code> 中，每一个容器对应上一个独立的文件。<strong>如果 container 重启了，它的日志会写入到新的文件中</strong>，想要查看以前的日志文件，使用 <code>--previous(-p)</code> 命令。</p><p><img src="https://gitee.com/yangbaoqiang/images/raw/master/blogpics/image-20220303155702882.png" alt="image-20220303155702882"></p><p>对应的日志文件是长这个样子的.. 里边存储的日志也是 json 格式的。</p><hr><p>作者提到一个pod运行多个容器，现在要往一个运行容器的pod中再添加一个容器？</p><p>要怎么才能做到呢？</p><p>擦，感觉被骗了，人家后边是新创建一个 pod，新 pod  中包含两个 container。</p><p>分别查看pod中多个容器的日志</p><ul><li><code>kubectl logs kubia-ssl -c kubia</code> <strong>指定容器的名称</strong></li><li><code>kubectl logs kubia-ssl --all-containers</code> 查看所有容器的日志</li></ul><h3 id="Pod-的生命周期"><a href="#Pod-的生命周期" class="headerlink" title="Pod 的生命周期"></a>Pod 的生命周期</h3><p>状态变化过程：</p><p><img src="https://gitee.com/yangbaoqiang/images/raw/master/blogpics/image-20220304100100883.png" alt="image-20220304100100883"></p><p>Pod condition 变化过程：</p><p><img src="https://gitee.com/yangbaoqiang/images/raw/master/blogpics/image-20220304102134299.png" alt="image-20220304102134299"></p><p>Pod 重启策略</p><p><img src="https://gitee.com/yangbaoqiang/images/raw/master/blogpics/image-20220304134321707.png" alt="image-20220304134321707"></p><p>Pod 重启中的指数回退算法：</p><p>防止 pod 频繁重启，所以增加了每次 pod 的重启间隔。</p><p><img src="https://gitee.com/yangbaoqiang/images/raw/master/blogpics/image-20220304140257223.png" alt="image-20220304140257223"></p><p>当容器正常运行 10 分钟之后，这个重置时间会被清零。</p><p>探活过程，及参数解释：</p><p><img src="https://gitee.com/yangbaoqiang/images/raw/master/blogpics/image-20220304145015728.png" alt="image-20220304145015728"></p><ul><li><p>initialDelaySeconds：延迟探测时间</p></li><li><p>periodSeconds ：探测时间间隔</p></li><li><p>timeoutSeconds ：响应超时时间</p></li><li><p>failureThreshold ：失败次数</p></li></ul><p>Pod 探活指针，如果说要通过 httpGet 进行实现，那么在 handler 中<strong>不要做额外的重试工作</strong>，这种就像 k8s 通过 failureThreshold  参数给你搞了一个 for 循环，for 一次执行一次你的 handler，然后你在 handler 中又添加了 for 循环，其实这样是没有必要的。</p><p>比起这样直接添加 failureThreshold  的值即可。</p><p>在 Pod <strong>开始后，结束前</strong>执行某些特定操作。</p><p><img src="https://gitee.com/yangbaoqiang/images/raw/master/blogpics/image-20220308181524107.png" alt="image-20220308181524107"></p><p>post-start AND pre-stop</p><blockquote><p>post-start  并不是开始后执行，而是容器创建了就开始执行。</p></blockquote><p>pre-stop</p><p>当容器在初始化时候被终止，所有类型的探针都不会被执行。</p><p><strong>Pod 的声明周期</strong></p><p><img src="https://gitee.com/yangbaoqiang/images/raw/master/blogpics/image-20220322180937014.png" alt="image-20220322180937014"></p><p>imagePullPolicy：（init 阶段执行）</p><ul><li>Not specified 未指定的话，默认就是 always</li><li>Always 每一次启动或重启容器，都拉取镜像。<strong>如果有本地缓存，就不会重新拉取了</strong></li><li>Never</li><li>IfNotPresent </li></ul><p><img src="https://gitee.com/yangbaoqiang/images/raw/master/blogpics/image-20220322181518924.png" alt="image-20220322181518924"></p><p>拉一个 initContainer 镜像，执行一个初始化，然后再拉下一个 init 镜像，直到所有的 initContainer 执行完毕。</p><p><img src="https://gitee.com/yangbaoqiang/images/raw/master/blogpics/image-20220322181920040.png" alt="image-20220322181920040"></p><p><strong>Pod 的完整声明周期</strong></p><p><img src="https://gitee.com/yangbaoqiang/images/raw/master/blogpics/image-20220322215904044.png" alt="image-20220322215904044"></p><p><img src="https://gitee.com/yangbaoqiang/images/raw/master/blogpics/image-20220322215918443.png" alt="image-20220322215918443"></p><p><strong>为什么要给 Pod 挂卷</strong></p><p>为的就是重启的时候持久化数据。</p><blockquote><p>卷的生命周期和pod的生命周期是保持一致的，卷的生命周期独立于容器（即容器重启了，并不影响卷。如果pod被删除了，卷也会被删除）。</p></blockquote><p>卷的生命周期独立于 Pod 的情况，也就是挂载的卷不在 pod 内。</p><p><img src="https://gitee.com/yangbaoqiang/images/raw/master/blogpics/image-20220324100102363.png" alt="image-20220324100102363"></p><p><strong>emptyDir 卷类型</strong></p><p>从下图中可以看出，该类型的卷还是存储在了 Pod 所在的 Node 上</p><p><img src="https://gitee.com/yangbaoqiang/images/raw/master/blogpics/image-20220324143444116.png" alt="image-20220324143444116"></p><p><code>/var/lib/kubelet/pods/&lt;pod_UID&gt;/volumes/kubernetes.io~empty-dir/&lt;volume_name&gt;</code></p><p>hostPath 的用途？</p><p>通常来讲，Pod 被调度到哪个 Node 上是未知的，所以 hostPath 适用场景比较少。</p><p>当采用外部存储的时候，如果直接指定了存储卷的IP地址，那么在将 Pod 移动到另一个集群上时，比如从google移动到 Amazon，在 Google 的存储卷，在 Amazon 上不支持。</p><p>由此，k8s 引用了 PV(persistent volume)，抽象出来一个持久卷，从 yaml 直接指定存储卷，到间接引用 pv 对象，进行了引用间的解耦。</p><blockquote><p>Pod 并不会直接引用 PV，而是通过 PVC 。</p></blockquote><p>PV 的三种访问模式</p><table><thead><tr><th>访问模式</th><th>缩写</th><th>描述</th></tr></thead><tbody><tr><td>ReadWriteOnce</td><td>RWO</td><td>卷可以被一个 Worker Node 以读、写模式绑定。当他绑定到某个 node 时，不能被其他node 绑定。</td></tr><tr><td>ReadOnlyMany</td><td>ROX</td><td>卷可以被多个 node 以 读 的方式进行绑定。</td></tr><tr><td>ReadWriteMany</td><td>RWX</td><td>卷可以被多个 node 以 读/写的方式进行绑定。</td></tr></tbody></table><p>Pod 挂载到了 PVC，在删除的时候需要注意：</p><ul><li>删除了 pod pvc 显示的仍然是已绑定状态。</li><li>删除 pvc 后，绑定的 pv 是 released 状态，claim 列仍然显示已经被删除的 pvc。</li></ul><p>这是因为，pv 中可能保存了一些 application 存储在其中的数据，如果想要重复使用，需要将其中的数据清空。</p><p>想要 pv 可以重复使用，只有删除掉，然后重新创建。</p><blockquote><p>这个不会影响 volume 中存储的数据</p></blockquote><p>另一种方式是 edit pv 中的 claimRef，把这个 ref 删除掉， pv 的状态也会恢复为 available。</p><p>pv 的回收策略:</p><ul><li>retain</li><li>delete</li><li>recycle</li></ul><p>使用 configMap 的三种方式</p><p>单条 key - value 的方式进行注入</p><p>将整个 configMap 进行注入</p><p>将 configMap 以 volume 的方式进行注入</p><ul><li>通过 volume 的方式也可以指定特定的 key value，不需要卷下的所有内容。</li></ul><p>secret</p><p>worker node 上，secret 中的内容是存储在内存中的，并不会存储在磁盘上，进一步增加安全性。</p><p>downwardAPI</p><p>主要是用来暴露 pod 的一些信息给 pod 中的 application</p><p>还提供了一种聚合了 configMap、secret、downwardAPI 的 volume 类型，projected</p><h3 id="service"><a href="#service" class="headerlink" title="service"></a>service</h3><p>如果两个 pod 需要进行通信，想要知道另一个 pod 的 ip 地址是很困难的，原因如下：</p><ul><li>pod 只有在调度到指定 node 上才会有 IP 地址</li><li>pod 可能随时被替换，或者调度到其他的 node 上</li><li>水平扩展时，会出现很多相同服务的 pod</li></ul><p> 更新 service selector</p><p><code>kubectl set selector service service_name label_key=label_value</code></p><p>external service LB</p><p>配置分发模式，externalTrafficPolicy:</p><ul><li><p>Local 只转发给 service 选择的 node，不会通过这个node传递给另一个node</p></li><li><p>Cluster 如果说 service 选择的 node 没有我们想要的 pod 服务，那么会转发给下一个 node，需要额外的开销，下一跳，source ip 也会改成 转发 packet 的 node ip。</p></li></ul><h3 id="Ingress"><a href="#Ingress" class="headerlink" title="Ingress"></a>Ingress</h3><p><img src="https://s2.loli.net/2022/04/27/wJybIj2eWUGXvx3.png" alt="12image002"></p><p><img src="https://s2.loli.net/2022/04/27/UOyvTbXYrnofKu8.png" alt="12image003"></p><p>有了 service 还要 ingress 干啥？</p><p>如果说通过 service 对外提供服务，数量少还好，如果服务数量多，会需要占用很多外部IP，导致没必要的资源浪费。</p><p>可以通过 ingress 对 service 进行一层封装，这就好像我们不是直接访问 pod 一样，而是通过 service 访问一样。统一通过 ingress 访问我们集群体提供的服务，而且 ingress 是 7 层的，可以提供更多功能，比如 cookie TLS 等，相比之下 service 是 4 层的负载均衡。</p><p>所谓的 7，4 层负载均衡，都是在请求到达真正服务器之前做的一些处理，差别简单的说就是，在做负载均衡的时候，使用的信息不一样，在 7 层可以用 http 相关的东西，4 层可以用 TCP/UDP 相关的东西。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;各个部分及其字段的含义。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>chi 框架路由分析</title>
    <link href="https://bqyang.top/2022/chi/"/>
    <id>https://bqyang.top/2022/chi/</id>
    <published>2022-02-22T09:21:53.087Z</published>
    <updated>2022-02-24T02:26:34.506Z</updated>
    
    <content type="html"><![CDATA[<p>（暂时还没写完，不过为了方便阅读，我也发表了出来。这样回家就不用带电脑了。。）</p><p>chi 框架相对容易一些，跟上一篇文章中的 appsrv 框架进行一个简单地对比，看一下实现的差异在哪里。</p><span id="more"></span><p>废话不多说，直接上源码</p><hr><blockquote><p>下面这段话是我看过后才写的，这个框架中涉及到的了节点的拆分替换。这样做的好处就是可以节省更多的空间，如果彼此之间没有公共部分的话。</p></blockquote><p>我用这三个路由进行的测试：</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 1 &quot;&#x2F;&quot;&#x2F;&#x2F; 2 &quot;&#x2F;hello&#x2F;world&quot;&#x2F;&#x2F; 3 &quot;&#x2F;hello&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果是按照上述方式进行插入，执行的 2 的时候，node 的存储方式就是一个 <code>hello/world</code> ，但是当 3 执行的时候，匹配到了相同的前缀 <code>hello</code> 此时会将 <code>hello/world</code> 拆分成两个 node，而 3 中的 hello 这个node的实现，就是 2中的 hello。不知道这样表述是否清晰。。</p><hr><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// 路由的插入</span><span class="token keyword">func</span> <span class="token punctuation">(</span>n <span class="token operator">*</span>node<span class="token punctuation">)</span> <span class="token function">InsertRoute</span><span class="token punctuation">(</span>method methodTyp<span class="token punctuation">,</span> pattern <span class="token builtin">string</span><span class="token punctuation">,</span> handler http<span class="token punctuation">.</span>Handler<span class="token punctuation">)</span> <span class="token operator">*</span>node <span class="token punctuation">&#123;</span>    <span class="token keyword">var</span> parent <span class="token operator">*</span>node    <span class="token comment">// 获取访问路径，形如 /hello/world</span>    search <span class="token operator">:=</span> pattern    <span class="token keyword">for</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// Handle key exhaustion</span>        <span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>search<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// Insert or update the node's leaf handler</span>            n<span class="token punctuation">.</span><span class="token function">setEndpoint</span><span class="token punctuation">(</span>method<span class="token punctuation">,</span> handler<span class="token punctuation">,</span> pattern<span class="token punctuation">)</span>            <span class="token keyword">return</span> n        <span class="token punctuation">&#125;</span>        <span class="token comment">// We're going to be searching for a wild node next,</span>        <span class="token comment">// in this case, we need to get the tail</span>        <span class="token keyword">var</span> label <span class="token operator">=</span> search<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        <span class="token keyword">var</span> segTail <span class="token builtin">byte</span>        <span class="token keyword">var</span> segEndIdx <span class="token builtin">int</span>        <span class="token keyword">var</span> segTyp nodeTyp        <span class="token keyword">var</span> segRexpat <span class="token builtin">string</span>        <span class="token keyword">if</span> label <span class="token operator">==</span> <span class="token string">'&#123;'</span> <span class="token operator">||</span> label <span class="token operator">==</span> <span class="token string">'*'</span> <span class="token punctuation">&#123;</span>            segTyp<span class="token punctuation">,</span> <span class="token boolean">_</span><span class="token punctuation">,</span> segRexpat<span class="token punctuation">,</span> segTail<span class="token punctuation">,</span> <span class="token boolean">_</span><span class="token punctuation">,</span> segEndIdx <span class="token operator">=</span> <span class="token function">patNextSegment</span><span class="token punctuation">(</span>search<span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">var</span> prefix <span class="token builtin">string</span>        <span class="token keyword">if</span> segTyp <span class="token operator">==</span> ntRegexp <span class="token punctuation">&#123;</span>            prefix <span class="token operator">=</span> segRexpat        <span class="token punctuation">&#125;</span>        <span class="token comment">// Look for the edge to attach to</span>        parent <span class="token operator">=</span> n        n <span class="token operator">=</span> n<span class="token punctuation">.</span><span class="token function">getEdge</span><span class="token punctuation">(</span>segTyp<span class="token punctuation">,</span> label<span class="token punctuation">,</span> segTail<span class="token punctuation">,</span> prefix<span class="token punctuation">)</span>        <span class="token comment">// No edge, create one</span>        <span class="token keyword">if</span> n <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>            child <span class="token operator">:=</span> <span class="token operator">&amp;</span>node<span class="token punctuation">&#123;</span>label<span class="token punctuation">:</span> label<span class="token punctuation">,</span> tail<span class="token punctuation">:</span> segTail<span class="token punctuation">,</span> prefix<span class="token punctuation">:</span> search<span class="token punctuation">&#125;</span>            hn <span class="token operator">:=</span> parent<span class="token punctuation">.</span><span class="token function">addChild</span><span class="token punctuation">(</span>child<span class="token punctuation">,</span> search<span class="token punctuation">)</span>            hn<span class="token punctuation">.</span><span class="token function">setEndpoint</span><span class="token punctuation">(</span>method<span class="token punctuation">,</span> handler<span class="token punctuation">,</span> pattern<span class="token punctuation">)</span>            <span class="token keyword">return</span> hn        <span class="token punctuation">&#125;</span>        <span class="token comment">// Found an edge to match the pattern</span>        <span class="token keyword">if</span> n<span class="token punctuation">.</span>typ <span class="token operator">></span> ntStatic <span class="token punctuation">&#123;</span>            <span class="token comment">// We found a param node, trim the param from the search path and continue.</span>            <span class="token comment">// This param/wild pattern segment would already be on the tree from a previous</span>            <span class="token comment">// call to addChild when creating a new node.</span>            search <span class="token operator">=</span> search<span class="token punctuation">[</span>segEndIdx<span class="token punctuation">:</span><span class="token punctuation">]</span>            <span class="token keyword">continue</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// Static nodes fall below here.</span>        <span class="token comment">// Determine longest prefix of the search key on match.</span>        <span class="token comment">// 匹配最长前缀，一个时间复杂度为 O(n) 的算法，遇到不同的直接 break</span>        commonPrefix <span class="token operator">:=</span> <span class="token function">longestPrefix</span><span class="token punctuation">(</span>search<span class="token punctuation">,</span> n<span class="token punctuation">.</span>prefix<span class="token punctuation">)</span>        <span class="token keyword">if</span> commonPrefix <span class="token operator">==</span> <span class="token function">len</span><span class="token punctuation">(</span>n<span class="token punctuation">.</span>prefix<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 走到这个 if 里边，说明当前 parent 的前缀，被完全包含在了 child 中</span>            <span class="token comment">// the common prefix is as long as the current node's prefix we're attempting to insert.</span>            <span class="token comment">// keep the search going.</span>            search <span class="token operator">=</span> search<span class="token punctuation">[</span>commonPrefix<span class="token punctuation">:</span><span class="token punctuation">]</span>            <span class="token keyword">continue</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// Split the node</span>        child <span class="token operator">:=</span> <span class="token operator">&amp;</span>node<span class="token punctuation">&#123;</span>            typ<span class="token punctuation">:</span>    ntStatic<span class="token punctuation">,</span>            prefix<span class="token punctuation">:</span> search<span class="token punctuation">[</span><span class="token punctuation">:</span>commonPrefix<span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// replace 的过程就是将，旧 node 替换成最大相同前缀的样子</span>        parent<span class="token punctuation">.</span><span class="token function">replaceChild</span><span class="token punctuation">(</span>search<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> segTail<span class="token punctuation">,</span> child<span class="token punctuation">)</span>        <span class="token comment">// Restore the existing node</span>        <span class="token comment">// 上述已经替换了，但是还剩下 旧 node 除了最大相同前缀余下的部分，</span>        <span class="token comment">// 这里的操作就是将这个 node 的后半部分重新插入</span>        n<span class="token punctuation">.</span>label <span class="token operator">=</span> n<span class="token punctuation">.</span>prefix<span class="token punctuation">[</span>commonPrefix<span class="token punctuation">]</span>        n<span class="token punctuation">.</span>prefix <span class="token operator">=</span> n<span class="token punctuation">.</span>prefix<span class="token punctuation">[</span>commonPrefix<span class="token punctuation">:</span><span class="token punctuation">]</span>        child<span class="token punctuation">.</span><span class="token function">addChild</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> n<span class="token punctuation">.</span>prefix<span class="token punctuation">)</span>        <span class="token comment">// If the new key is a subset, set the method/handler on this node and finish.</span>        <span class="token comment">// 拆分后，如果search就没了，说明 search 是 parent node 的 prefix 的子集</span>        <span class="token comment">// 直接更新当前 node 的 handler 即可</span>        search <span class="token operator">=</span> search<span class="token punctuation">[</span>commonPrefix<span class="token punctuation">:</span><span class="token punctuation">]</span>        <span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>search<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>            child<span class="token punctuation">.</span><span class="token function">setEndpoint</span><span class="token punctuation">(</span>method<span class="token punctuation">,</span> handler<span class="token punctuation">,</span> pattern<span class="token punctuation">)</span>            <span class="token keyword">return</span> child        <span class="token punctuation">&#125;</span>        <span class="token comment">// Create a new edge for the node</span>        <span class="token comment">// 这里其实也好理解了，如果说拆分后，search 中还有内容，</span>        <span class="token comment">// 也不用管了，直接扔到下一个child中，之后再添加的时候，</span>        <span class="token comment">// 通过匹配最大相同前缀的方式，继续拆。。</span>        subchild <span class="token operator">:=</span> <span class="token operator">&amp;</span>node<span class="token punctuation">&#123;</span>            typ<span class="token punctuation">:</span>    ntStatic<span class="token punctuation">,</span>            label<span class="token punctuation">:</span>  search<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>            prefix<span class="token punctuation">:</span> search<span class="token punctuation">,</span>        <span class="token punctuation">&#125;</span>        hn <span class="token operator">:=</span> child<span class="token punctuation">.</span><span class="token function">addChild</span><span class="token punctuation">(</span>subchild<span class="token punctuation">,</span> search<span class="token punctuation">)</span>        hn<span class="token punctuation">.</span><span class="token function">setEndpoint</span><span class="token punctuation">(</span>method<span class="token punctuation">,</span> handler<span class="token punctuation">,</span> pattern<span class="token punctuation">)</span>        <span class="token keyword">return</span> hn    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>个人感觉这个插入的过程还是挺绕的。。需要结合例子动手看一下，光在脑子里想，抱歉！我智商不够..</p><p>chi 框架中，将 node 分成了几个类型，如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> nodeTyp <span class="token builtin">uint8</span><span class="token keyword">const</span> <span class="token punctuation">(</span>ntStatic   nodeTyp <span class="token operator">=</span> <span class="token boolean">iota</span> <span class="token comment">// /home</span>ntRegexp                  <span class="token comment">// /&#123;id:[0-9]+&#125;</span>ntParam                   <span class="token comment">// /&#123;user&#125;</span>ntCatchAll                <span class="token comment">// /api/v1/*</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>看看插入过程涉及到的一些杂七杂八的函数：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// patNextSegment returns the next segment details from a pattern:</span><span class="token comment">// node type, param key, regexp string, param tail byte, param starting index, param ending index</span><span class="token keyword">func</span> <span class="token function">patNextSegment</span><span class="token punctuation">(</span>pattern <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>nodeTyp<span class="token punctuation">,</span> <span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">byte</span><span class="token punctuation">,</span> <span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    ps <span class="token operator">:=</span> strings<span class="token punctuation">.</span><span class="token function">Index</span><span class="token punctuation">(</span>pattern<span class="token punctuation">,</span> <span class="token string">"&#123;"</span><span class="token punctuation">)</span>    ws <span class="token operator">:=</span> strings<span class="token punctuation">.</span><span class="token function">Index</span><span class="token punctuation">(</span>pattern<span class="token punctuation">,</span> <span class="token string">"*"</span><span class="token punctuation">)</span>    <span class="token comment">// 静态node，既不是参数，也不是正则表达式</span>    <span class="token keyword">if</span> ps <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> ws <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> ntStatic<span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>pattern<span class="token punctuation">)</span> <span class="token comment">// we return the entire thing</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// Sanity check 完整性检查，也体现了路由的规则，通配符只能出现在 &#123;&#125; 之后</span>    <span class="token keyword">if</span> ps <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> ws <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> ws <span class="token operator">&lt;</span> ps <span class="token punctuation">&#123;</span>        <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"chi: wildcard '*' must be the last pattern in a route, otherwise use a '&#123;param&#125;'"</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">var</span> tail <span class="token builtin">byte</span> <span class="token operator">=</span> <span class="token string">'/'</span> <span class="token comment">// Default endpoint tail to / byte</span>    <span class="token keyword">if</span> ps <span class="token operator">>=</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// Param/Regexp pattern is next</span>        nt <span class="token operator">:=</span> ntParam        <span class="token comment">// Read to closing &#125; taking into account opens and closes in curl count (cc)</span>        <span class="token comment">// 这里就是找成对的 &#123;&#125; ，虽然没在 leetcode 上做这个题，但是也听过。。</span>        <span class="token comment">// 如果 cc > 0，说明花括号多了</span>        <span class="token comment">// 如果 cc &lt; 0，说明花括号少了</span>        <span class="token comment">// 如果 cc == 0，说明正好匹配上</span>        cc <span class="token operator">:=</span> <span class="token number">0</span>        pe <span class="token operator">:=</span> ps        <span class="token keyword">for</span> i<span class="token punctuation">,</span> c <span class="token operator">:=</span> <span class="token keyword">range</span> pattern<span class="token punctuation">[</span>ps<span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> c <span class="token operator">==</span> <span class="token string">'&#123;'</span> <span class="token punctuation">&#123;</span>                cc<span class="token operator">++</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> c <span class="token operator">==</span> <span class="token string">'&#125;'</span> <span class="token punctuation">&#123;</span>                cc<span class="token operator">--</span>                <span class="token keyword">if</span> cc <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>                    pe <span class="token operator">=</span> ps <span class="token operator">+</span> i                    <span class="token keyword">break</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> pe <span class="token operator">==</span> ps <span class="token punctuation">&#123;</span>            <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"chi: route param closing delimiter '&#125;' is missing"</span><span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 拿到了括号中的参数名称</span>        key <span class="token operator">:=</span> pattern<span class="token punctuation">[</span>ps<span class="token operator">+</span><span class="token number">1</span> <span class="token punctuation">:</span> pe<span class="token punctuation">]</span>        pe<span class="token operator">++</span> <span class="token comment">// set end to next position，花括号后边的那个值</span>        <span class="token comment">// tail 指向的就是花括号后边的第一个字节，比如 /&#123;name&#125;/world</span>        <span class="token keyword">if</span> pe <span class="token operator">&lt;</span> <span class="token function">len</span><span class="token punctuation">(</span>pattern<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            tail <span class="token operator">=</span> pattern<span class="token punctuation">[</span>pe<span class="token punctuation">]</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">/*        从这里往下开始就是有关正则的内容        */</span>        <span class="token keyword">var</span> rexpat <span class="token builtin">string</span>        <span class="token keyword">if</span> idx <span class="token operator">:=</span> strings<span class="token punctuation">.</span><span class="token function">Index</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token string">":"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> idx <span class="token operator">>=</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>            nt <span class="token operator">=</span> ntRegexp            rexpat <span class="token operator">=</span> key<span class="token punctuation">[</span>idx<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span>            key <span class="token operator">=</span> key<span class="token punctuation">[</span><span class="token punctuation">:</span>idx<span class="token punctuation">]</span>        <span class="token punctuation">&#125;</span><span class="token comment">// 如果是正则匹配，人家还给校验了开始和结束。。</span>        <span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>rexpat<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> rexpat<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'^'</span> <span class="token punctuation">&#123;</span>                rexpat <span class="token operator">=</span> <span class="token string">"^"</span> <span class="token operator">+</span> rexpat            <span class="token punctuation">&#125;</span>            <span class="token keyword">if</span> rexpat<span class="token punctuation">[</span><span class="token function">len</span><span class="token punctuation">(</span>rexpat<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'$'</span> <span class="token punctuation">&#123;</span>                rexpat <span class="token operator">+=</span> <span class="token string">"$"</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>                <span class="token comment">/*        注释里边提到了这几个参数是啥意思，不过还是看一眼        nt节点类型        key参数名称        rexpat 正则表达式字符串        tailkey 参数后边的一个字节        ps参数开始的索引位置        pe参数结束的索引位置        */</span>        <span class="token keyword">return</span> nt<span class="token punctuation">,</span> key<span class="token punctuation">,</span> rexpat<span class="token punctuation">,</span> tail<span class="token punctuation">,</span> ps<span class="token punctuation">,</span> pe    <span class="token punctuation">&#125;</span>    <span class="token comment">// Wildcard pattern as finale</span>    <span class="token keyword">if</span> ws <span class="token operator">&lt;</span> <span class="token function">len</span><span class="token punctuation">(</span>pattern<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">&#123;</span>        <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"chi: wildcard '*' must be the last value in a route. trim trailing text or use a '&#123;param&#125;' instead"</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> ntCatchAll<span class="token punctuation">,</span> <span class="token string">"*"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> ws<span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>pattern<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// ntyp节点类型</span><span class="token comment">// labellabel 表示的就是 path 路径上的第一个字节</span><span class="token comment">// tail表示与 label 相反，表示最后一个字节</span><span class="token comment">// prefix当前 node 中存储的 path</span><span class="token keyword">func</span> <span class="token punctuation">(</span>n <span class="token operator">*</span>node<span class="token punctuation">)</span> <span class="token function">getEdge</span><span class="token punctuation">(</span>ntyp nodeTyp<span class="token punctuation">,</span> label<span class="token punctuation">,</span> tail <span class="token builtin">byte</span><span class="token punctuation">,</span> prefix <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token operator">*</span>node <span class="token punctuation">&#123;</span> <span class="token comment">// 首先是通过 节点类型找到对应的 节点集合，剩下的就比较简单了..</span>    nds <span class="token operator">:=</span> n<span class="token punctuation">.</span>children<span class="token punctuation">[</span>ntyp<span class="token punctuation">]</span>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token function">len</span><span class="token punctuation">(</span>nds<span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> nds<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>label <span class="token operator">==</span> label <span class="token operator">&amp;&amp;</span> nds<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>tail <span class="token operator">==</span> tail <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> ntyp <span class="token operator">==</span> ntRegexp <span class="token operator">&amp;&amp;</span> nds<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>prefix <span class="token operator">!=</span> prefix <span class="token punctuation">&#123;</span>                <span class="token keyword">continue</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">return</span> nds<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// 写的 endpoint，其实就是给 node 设置上 handler，正如人家在下面注释所描述的</span><span class="token keyword">func</span> <span class="token punctuation">(</span>n <span class="token operator">*</span>node<span class="token punctuation">)</span> <span class="token function">setEndpoint</span><span class="token punctuation">(</span>method methodTyp<span class="token punctuation">,</span> handler http<span class="token punctuation">.</span>Handler<span class="token punctuation">,</span> pattern <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// Set the handler for the method type on the node</span>    <span class="token keyword">if</span> n<span class="token punctuation">.</span>endpoints <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>        n<span class="token punctuation">.</span>endpoints <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span>endpoints<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// &#123;name&#125; &#123;job&#125; paramKeys 中存储的就是这些名字</span>    paramKeys <span class="token operator">:=</span> <span class="token function">patParamKeys</span><span class="token punctuation">(</span>pattern<span class="token punctuation">)</span>    <span class="token comment">// 往下就没啥好说了，通过位运算找到对应的分支，然后直接赋值就行了。。</span>    <span class="token keyword">if</span> method<span class="token operator">&amp;</span>mSTUB <span class="token operator">==</span> mSTUB <span class="token punctuation">&#123;</span>        n<span class="token punctuation">.</span>endpoints<span class="token punctuation">.</span><span class="token function">Value</span><span class="token punctuation">(</span>mSTUB<span class="token punctuation">)</span><span class="token punctuation">.</span>handler <span class="token operator">=</span> handler    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> method<span class="token operator">&amp;</span>mALL <span class="token operator">==</span> mALL <span class="token punctuation">&#123;</span>        h <span class="token operator">:=</span> n<span class="token punctuation">.</span>endpoints<span class="token punctuation">.</span><span class="token function">Value</span><span class="token punctuation">(</span>mALL<span class="token punctuation">)</span>        h<span class="token punctuation">.</span>handler <span class="token operator">=</span> handler        h<span class="token punctuation">.</span>pattern <span class="token operator">=</span> pattern        h<span class="token punctuation">.</span>paramKeys <span class="token operator">=</span> paramKeys        <span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> m <span class="token operator">:=</span> <span class="token keyword">range</span> methodMap <span class="token punctuation">&#123;</span>            h <span class="token operator">:=</span> n<span class="token punctuation">.</span>endpoints<span class="token punctuation">.</span><span class="token function">Value</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span>            h<span class="token punctuation">.</span>handler <span class="token operator">=</span> handler            h<span class="token punctuation">.</span>pattern <span class="token operator">=</span> pattern            h<span class="token punctuation">.</span>paramKeys <span class="token operator">=</span> paramKeys        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        h <span class="token operator">:=</span> n<span class="token punctuation">.</span>endpoints<span class="token punctuation">.</span><span class="token function">Value</span><span class="token punctuation">(</span>method<span class="token punctuation">)</span>        h<span class="token punctuation">.</span>handler <span class="token operator">=</span> handler        h<span class="token punctuation">.</span>pattern <span class="token operator">=</span> pattern        h<span class="token punctuation">.</span>paramKeys <span class="token operator">=</span> paramKeys    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后这个就是最核心最复杂的了吧…，不过我们为了方便理解，可以暂时先忽略掉<strong>正则匹配</strong>，<strong>带参数</strong>的部分代码。。只关注 nodetyp 是 static 的即可。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// addChild appends the new `child` node to the tree using the `pattern` as the trie key.</span><span class="token comment">// For a URL router like chi's, we split the static, param, regexp and wildcard segments</span><span class="token comment">// into different nodes. In addition, addChild will recursively call itself until every</span><span class="token comment">// pattern segment is added to the url pattern tree as individual nodes, depending on type.</span><span class="token comment">// 人家上边注释说的非常清晰了..</span><span class="token keyword">func</span> <span class="token punctuation">(</span>n <span class="token operator">*</span>node<span class="token punctuation">)</span> <span class="token function">addChild</span><span class="token punctuation">(</span>child <span class="token operator">*</span>node<span class="token punctuation">,</span> prefix <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token operator">*</span>node <span class="token punctuation">&#123;</span>    search <span class="token operator">:=</span> prefix    <span class="token comment">// handler leaf node added to the tree is the child.</span>    <span class="token comment">// this may be overridden later down the flow</span>    hn <span class="token operator">:=</span> child    <span class="token comment">// Parse next segment</span>    segTyp<span class="token punctuation">,</span> <span class="token boolean">_</span><span class="token punctuation">,</span> segRexpat<span class="token punctuation">,</span> segTail<span class="token punctuation">,</span> segStartIdx<span class="token punctuation">,</span> segEndIdx <span class="token operator">:=</span> <span class="token function">patNextSegment</span><span class="token punctuation">(</span>search<span class="token punctuation">)</span>    <span class="token comment">// Add child depending on next up segment</span>    <span class="token keyword">switch</span> segTyp <span class="token punctuation">&#123;</span>        <span class="token comment">// 这里直接判断类型呗，如果是static就直接加入到parent的children节点中</span>        <span class="token keyword">case</span> ntStatic<span class="token punctuation">:</span>        <span class="token comment">// Search prefix is all static (that is, has no params in path)</span>        <span class="token comment">// noop</span>        <span class="token keyword">default</span><span class="token punctuation">:</span>        <span class="token comment">// Search prefix contains a param, regexp or wildcard</span>        <span class="token keyword">if</span> segTyp <span class="token operator">==</span> ntRegexp <span class="token punctuation">&#123;</span>            rex<span class="token punctuation">,</span> err <span class="token operator">:=</span> regexp<span class="token punctuation">.</span><span class="token function">Compile</span><span class="token punctuation">(</span>segRexpat<span class="token punctuation">)</span>            <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>                <span class="token function">panic</span><span class="token punctuation">(</span>fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">"chi: invalid regexp pattern '%s' in route param"</span><span class="token punctuation">,</span> segRexpat<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">&#125;</span>            child<span class="token punctuation">.</span>prefix <span class="token operator">=</span> segRexpat            child<span class="token punctuation">.</span>rex <span class="token operator">=</span> rex        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> segStartIdx <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// Route starts with a param</span>            child<span class="token punctuation">.</span>typ <span class="token operator">=</span> segTyp            <span class="token keyword">if</span> segTyp <span class="token operator">==</span> ntCatchAll <span class="token punctuation">&#123;</span>                segStartIdx <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                segStartIdx <span class="token operator">=</span> segEndIdx            <span class="token punctuation">&#125;</span>            <span class="token keyword">if</span> segStartIdx <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>                segStartIdx <span class="token operator">=</span> <span class="token function">len</span><span class="token punctuation">(</span>search<span class="token punctuation">)</span>            <span class="token punctuation">&#125;</span>            child<span class="token punctuation">.</span>tail <span class="token operator">=</span> segTail <span class="token comment">// for params, we set the tail</span>            <span class="token keyword">if</span> segStartIdx <span class="token operator">!=</span> <span class="token function">len</span><span class="token punctuation">(</span>search<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// add static edge for the remaining part, split the end.</span>                <span class="token comment">// its not possible to have adjacent param nodes, so its certainly</span>                <span class="token comment">// going to be a static node next.</span>                search <span class="token operator">=</span> search<span class="token punctuation">[</span>segStartIdx<span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token comment">// advance search position</span>                nn <span class="token operator">:=</span> <span class="token operator">&amp;</span>node<span class="token punctuation">&#123;</span>                    typ<span class="token punctuation">:</span>    ntStatic<span class="token punctuation">,</span>                    label<span class="token punctuation">:</span>  search<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                    prefix<span class="token punctuation">:</span> search<span class="token punctuation">,</span>                <span class="token punctuation">&#125;</span>                hn <span class="token operator">=</span> child<span class="token punctuation">.</span><span class="token function">addChild</span><span class="token punctuation">(</span>nn<span class="token punctuation">,</span> search<span class="token punctuation">)</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> segStartIdx <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// Route has some param</span>            <span class="token comment">// starts with a static segment</span>            child<span class="token punctuation">.</span>typ <span class="token operator">=</span> ntStatic            child<span class="token punctuation">.</span>prefix <span class="token operator">=</span> search<span class="token punctuation">[</span><span class="token punctuation">:</span>segStartIdx<span class="token punctuation">]</span>            child<span class="token punctuation">.</span>rex <span class="token operator">=</span> <span class="token boolean">nil</span>            <span class="token comment">// add the param edge node</span>            search <span class="token operator">=</span> search<span class="token punctuation">[</span>segStartIdx<span class="token punctuation">:</span><span class="token punctuation">]</span>            nn <span class="token operator">:=</span> <span class="token operator">&amp;</span>node<span class="token punctuation">&#123;</span>                typ<span class="token punctuation">:</span>   segTyp<span class="token punctuation">,</span>                label<span class="token punctuation">:</span> search<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                tail<span class="token punctuation">:</span>  segTail<span class="token punctuation">,</span>            <span class="token punctuation">&#125;</span>            hn <span class="token operator">=</span> child<span class="token punctuation">.</span><span class="token function">addChild</span><span class="token punctuation">(</span>nn<span class="token punctuation">,</span> search<span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    n<span class="token punctuation">.</span>children<span class="token punctuation">[</span>child<span class="token punctuation">.</span>typ<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>n<span class="token punctuation">.</span>children<span class="token punctuation">[</span>child<span class="token punctuation">.</span>typ<span class="token punctuation">]</span><span class="token punctuation">,</span> child<span class="token punctuation">)</span>    <span class="token comment">// 排序操作，暂时不知道人家这个用途。。</span>    n<span class="token punctuation">.</span>children<span class="token punctuation">[</span>child<span class="token punctuation">.</span>typ<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">Sort</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> hn<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;（暂时还没写完，不过为了方便阅读，我也发表了出来。这样回家就不用带电脑了。。）&lt;/p&gt;
&lt;p&gt;chi 框架相对容易一些，跟上一篇文章中的 appsrv 框架进行一个简单地对比，看一下实现的差异在哪里。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>一个 web 框架的那些事</title>
    <link href="https://bqyang.top/2022/webFrame/"/>
    <id>https://bqyang.top/2022/webFrame/</id>
    <published>2022-02-18T08:29:25.030Z</published>
    <updated>2022-02-20T14:23:30.250Z</updated>
    
    <content type="html"><![CDATA[<p>项目上用了一套开源的云管理代码，他们框架中的路由的相关功能都是自研的，学习学习人家是怎么实现的。</p><span id="more"></span><p>大致分成以下几个部分：</p><ul><li>使用什么数据结构存储</li><li>路由的查找过程</li><li>关于正则的路由是怎么实现的</li></ul><p><strong>实现路由的数据结构</strong></p><p>这里巧妙的运用了 Go 原生 map 的特性，结合 map 高效的查询，构建了一颗<strong>基数树</strong>。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> RadixNode <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>data        <span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>stringNodes <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token operator">*</span>RadixNoderegexpNodes <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>RegexpNodesegNames    <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">&#125;</span><span class="token keyword">type</span> RegexpNode <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>node   <span class="token operator">*</span>RadixNoderegStr <span class="token builtin">string</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>光看声明方式或许有些抽象，把图画出来就好多了。（回头补上）</p><p><strong>路由注册过程</strong></p><p>核心的代码就这么多，对于我这种菜鸟来说，阅读起来还行，不是那么费劲，但是要想写出来这种代码，得有几年功底哈哈。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// segments 就是将 path 通过 "/" 进行分割，得到的结果</span><span class="token keyword">func</span> <span class="token punctuation">(</span>r <span class="token operator">*</span>RadixNode<span class="token punctuation">)</span> <span class="token function">add</span><span class="token punctuation">(</span>segments <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">,</span> data <span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> depth <span class="token builtin">int</span><span class="token punctuation">,</span> segNames <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 递归的终止条件</span>    <span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>segments<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 这里的 data 就是 handler 的信息，最后要通过 path 最终找到handler</span>        <span class="token keyword">if</span> r<span class="token punctuation">.</span>data <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 添加了重复路由，会报这个错误</span>            <span class="token keyword">return</span> fmt<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"Duplicate data for node"</span><span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            r<span class="token punctuation">.</span>data <span class="token operator">=</span> data            r<span class="token punctuation">.</span>segNames <span class="token operator">=</span> segNames            <span class="token keyword">return</span> <span class="token boolean">nil</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">var</span> nextNode <span class="token operator">*</span>RadixNode        <span class="token comment">// 判断是否为正则匹配的 path （为了方便理解可以先看下边 else 的部分）</span>        <span class="token keyword">if</span> <span class="token function">isRegexSegment</span><span class="token punctuation">(</span>segments<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">var</span> <span class="token punctuation">(</span>                <span class="token comment">// 正则字符串</span>                regStr     <span class="token builtin">string</span>                segName    <span class="token builtin">string</span>                <span class="token comment">// 把 "&lt; >" 去掉</span>                segStr     <span class="token operator">=</span> segments<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span> <span class="token punctuation">:</span> <span class="token function">len</span><span class="token punctuation">(</span>segments<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>                <span class="token comment">// 后续判断是否为 paramName:reg 的这种形式</span>                splitIndex <span class="token operator">=</span> strings<span class="token punctuation">.</span><span class="token function">IndexByte</span><span class="token punctuation">(</span>segStr<span class="token punctuation">,</span> <span class="token string">':'</span><span class="token punctuation">)</span>            <span class="token punctuation">)</span>            <span class="token keyword">if</span> splitIndex <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>                regStr <span class="token operator">=</span> <span class="token string">".*"</span> <span class="token comment">// match anything</span>                segName <span class="token operator">=</span> <span class="token string">"&lt;"</span> <span class="token operator">+</span> segStr <span class="token operator">+</span> <span class="token string">">"</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// &lt;phone_number:^1[0-9-]&#123;10&#125;$></span>                <span class="token comment">// 结合上边这个表达式，一下就清晰明了了</span>                regStr <span class="token operator">=</span> segStr<span class="token punctuation">[</span>splitIndex<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span>                segName <span class="token operator">=</span> <span class="token string">"&lt;"</span> <span class="token operator">+</span> segStr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span>splitIndex<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">">"</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">// TODO 暂时没看出来这个 segNames 和 depth 的关系</span>            <span class="token keyword">if</span> segNames <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>                segNames <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token punctuation">&#125;</span>            segNames<span class="token punctuation">[</span>depth<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> segName<span class="token comment">// 这里的逻辑就和下边的一样了，不再赘述</span>            <span class="token keyword">if</span> node<span class="token punctuation">,</span> ok <span class="token operator">:=</span> <span class="token function">isRegstrInRegexpNodes</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span>regexpNodes<span class="token punctuation">,</span> regStr<span class="token punctuation">)</span><span class="token punctuation">;</span> ok <span class="token punctuation">&#123;</span>                nextNode <span class="token operator">=</span> node            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                nextNode <span class="token operator">=</span> <span class="token function">NewRadix</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                regNode <span class="token operator">:=</span> <span class="token function">NewRegexpNode</span><span class="token punctuation">(</span>nextNode<span class="token punctuation">,</span> regStr<span class="token punctuation">)</span>                <span class="token comment">// 这里采用的是 array 存储，所以在查找的时候有一种可能</span>                <span class="token comment">// 就是一个node下挂着多个正则匹配，并且秉着先进来的优先级高的方式</span>                r<span class="token punctuation">.</span>regexpNodes <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span>regexpNodes<span class="token punctuation">,</span> regNode<span class="token punctuation">)</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 这里的 stringNodes 存储结构见下图，其实很简单，一个 node 代表的就是path中的一部分</span>            <span class="token comment">// 如果说两个 path 有重合的部分，那么他们之间就可以共用这些 node，这也是基数树的一个特征</span>            <span class="token comment">// ** 正如这里的判断，其实就是验证是否可以有公共的部分 **</span>            <span class="token keyword">if</span> node<span class="token punctuation">,</span> ok <span class="token operator">:=</span> r<span class="token punctuation">.</span>stringNodes<span class="token punctuation">[</span>segments<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span> ok <span class="token punctuation">&#123;</span>                nextNode <span class="token operator">=</span> node            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 走到这里说明，这个 seg 不存在，也就是没有公共部分，需要新建</span>                nextNode <span class="token operator">=</span> <span class="token function">NewRadix</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                r<span class="token punctuation">.</span>stringNodes<span class="token punctuation">[</span>segments<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> nextNode            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 递归调用</span>        <span class="token keyword">return</span> nextNode<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>segments<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">,</span> data<span class="token punctuation">,</span> depth<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> segNames<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/yangbaoqiang/images/raw/master/blogpics/image-20220218174102417.png" alt="image-20220218174102417"></p><p>这里我想了下，不用递归行不行，答案肯定是可以的，所有的递归都是可以通过 for 循环来完成的。但是细想了下，毕竟只有在项目启动中执行一次，也没必要，这样看起来更清晰，代码更简洁。</p><p><strong>路由查找过程</strong></p><p>先简单看看正则匹配的过程。比如我们定义了一个路由 <code>/user/&lt;^1[0-9-]&#123;10&#125;$&gt;</code> (按照人家框架的约束条件声明)</p><p>那么只要是匹配到该规则的路径，都是相同的 handler 进行处理。</p><p>如果上述路由注册的过程看明白了的话，我想你心里已经可以构建出一颗基数树，没有也没关系，我给你画出来，请见下图。</p><p><img src="https://gitee.com/yangbaoqiang/images/raw/master/blogpics/image-20220220154418325.png" alt="image-20220220154418325"></p><p>画的比较简陋，不过大概意思就是这样。</p><p><strong>代码实现</strong></p><p>我们可以尝试使用下面的函数，加上上面的图作为辅助，查找一下 <code>/student/Peter</code></p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// 可以先看下返回结果</span><span class="token comment">// bool 表示是否找到</span><span class="token comment">// RadixNode 则表示具体的 node，也可以理解为最终的 handler</span><span class="token keyword">func</span> <span class="token punctuation">(</span>r <span class="token operator">*</span>RadixNode<span class="token punctuation">)</span> <span class="token function">match</span><span class="token punctuation">(</span>segments <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">*</span>RadixNode<span class="token punctuation">,</span> <span class="token builtin">bool</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>segments<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> r<span class="token punctuation">,</span> <span class="token boolean">true</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span>stringNodes<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token function">len</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span>regexpNodes<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> r<span class="token punctuation">,</span> <span class="token boolean">false</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 不难看出，这里仍然采用的是递归调用的方式</span>    <span class="token keyword">if</span> node<span class="token punctuation">,</span> ok <span class="token operator">:=</span> r<span class="token punctuation">.</span>stringNodes<span class="token punctuation">[</span>segments<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span> ok <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> rnode<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> node<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>segments<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> rnode <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token operator">&amp;&amp;</span> rnode<span class="token punctuation">.</span>data <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> rnode<span class="token punctuation">,</span> <span class="token boolean">true</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">var</span> nodeTmp <span class="token operator">*</span>RadixNode    <span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> regNode <span class="token operator">:=</span> <span class="token keyword">range</span> r<span class="token punctuation">.</span>regexpNodes <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> regexp<span class="token punctuation">.</span><span class="token function">MustCompile</span><span class="token punctuation">(</span>regNode<span class="token punctuation">.</span>regStr<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">MatchString</span><span class="token punctuation">(</span>segments<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> rnode<span class="token punctuation">,</span> fullMatch <span class="token operator">:=</span> regNode<span class="token punctuation">.</span>node<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>segments<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> rnode <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token operator">&amp;&amp;</span> rnode<span class="token punctuation">.</span>data <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> fullMatch <span class="token punctuation">&#123;</span>                    <span class="token keyword">return</span> rnode<span class="token punctuation">,</span> fullMatch                <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">if</span> nodeTmp <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>                        log<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"segments %v match mutil node"</span><span class="token punctuation">,</span> segments<span class="token punctuation">)</span>                        <span class="token keyword">continue</span>                    <span class="token punctuation">&#125;</span>                    nodeTmp <span class="token operator">=</span> rnode                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> nodeTmp <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> nodeTmp<span class="token punctuation">,</span> <span class="token boolean">false</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> r<span class="token punctuation">,</span> <span class="token boolean">false</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>从上述代码可以看出，路由匹配过程中，优先级最高的是名称相同，其次才是正则匹配。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;项目上用了一套开源的云管理代码，他们框架中的路由的相关功能都是自研的，学习学习人家是怎么实现的。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
</feed>
