---
title: golang 中的抢占
comment: false
---

关于 go 1.13 协作式抢占的一点理解

<!--more-->

基于协作式的抢占，要 goroutine 进行配合，在 G 执行的函数中添加栈的边界检查。

我一开始有一点没想明白，假设有个 G 正在 P 上执行，但是呢，抢占条件的检测是 false 不需要抢占，执行几行代码后，我又想抢占了。这时候怎么办？

需要知道的是，协作式一定需要 goroutine 进行配合，配合的意思就是：一定是栈边界检查为true。执行完第一个条件检查不要紧，你会发现只要是函数调用的地方（你的代码，println 也会检查）基本上都加入了栈边界检查。尽最大努力进行抢占。

如果说整个函数就一个简单的运算，没有别的任何函数调用，如果第一次边界检查为 false，后续想抢占应该也是不行的，只能等当前的 G 主动退出。

最近时间都花在 GC 上了，GC 和抢占的内容紧密关联。因为 STW 的时候就需要进行抢占，把 P 上执行的 G 都给挂起。



// TODO 立个 flag 一定把协作式抢占与基于信号的抢占整理出来。