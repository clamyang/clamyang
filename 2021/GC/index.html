<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.png" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"bqyang.top","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"hide","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":{"gitalk":{"order":-2}},"activeClass":"gitalk"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Golang GC 垃圾回收知识点总结，有些内容还没有完成，只是抛出了问题..">
<meta property="og:type" content="article">
<meta property="og:title" content="GC 源码梳理">
<meta property="og:url" content="https://bqyang.top/2021/GC/index.html">
<meta property="og:site_name" content="杨宝强的技术笔记">
<meta property="og:description" content="Golang GC 垃圾回收知识点总结，有些内容还没有完成，只是抛出了问题..">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blogstatic.haohtml.com/uploads/2021/04/d2b5ca33bd970f64a6301fa75ae2eb22-6.png?x-oss-process=image/format,webp">
<meta property="article:published_time" content="2021-12-02T08:11:37.293Z">
<meta property="article:modified_time" content="2021-12-14T11:03:59.300Z">
<meta property="article:author" content="杨宝强">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blogstatic.haohtml.com/uploads/2021/04/d2b5ca33bd970f64a6301fa75ae2eb22-6.png?x-oss-process=image/format,webp">

<link rel="canonical" href="https://bqyang.top/2021/GC/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>GC 源码梳理 | 杨宝强的技术笔记</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="杨宝强的技术笔记" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <h1 class="site-title" style="font-size:27px">杨宝强的技术笔记</h1>
      <span class="logo-line-before"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">欢迎~</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://bqyang.top/2021/GC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="杨宝强">
      <meta itemprop="description" content="记录技术精进之路，记录生活的打情骂俏">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="杨宝强的技术笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          GC 源码梳理
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-02 16:11:37" itemprop="dateCreated datePublished" datetime="2021-12-02T16:11:37+08:00">2021-12-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-14 19:03:59" itemprop="dateModified" datetime="2021-12-14T19:03:59+08:00">2021-12-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>Golang GC 垃圾回收知识点总结，有些内容还没有完成，只是抛出了问题.. </p>
<span id="more"></span>

<h2 id="GC-连连问"><a href="#GC-连连问" class="headerlink" title="GC 连连问"></a>GC 连连问</h2><h3 id="GC-的流程阶段"><a href="#GC-的流程阶段" class="headerlink" title="GC 的流程阶段"></a>GC 的流程阶段</h3><ul>
<li><p>sweep termination</p>
</li>
<li><p>mark</p>
</li>
<li><p>mark termination</p>
</li>
<li><p>sweep</p>
</li>
</ul>
<h3 id="GC-的触发时机"><a href="#GC-的触发时机" class="headerlink" title="GC 的触发时机"></a>GC 的触发时机</h3><p>1.runtime.GC 手动触发</p>
<p>2.mallocgc 根据内存分配大小，比如当前使用 4M，当内存分配到达 8M 时，会触发 GC，这个百分比是可以调整的，通过 设置 triggerRatio 指定触发 GC 的阈值 go1.16.5 中，是 7/8.0 = 87.5% </p>
<p>3.forcegchelper 定时触发 GC</p>
<p>mallocgc 是主要的触发函数。</p>
<h3 id="GC-的起点"><a href="#GC-的起点" class="headerlink" title="GC 的起点"></a>GC 的起点</h3><p>gcStart，控制 worker 的数量，大约占 CPU 的 1/4。</p>
<h3 id="为什么老版本需要重新扫描栈？"><a href="#为什么老版本需要重新扫描栈？" class="headerlink" title="为什么老版本需要重新扫描栈？"></a>为什么老版本需要重新扫描栈？</h3><h3 id="GC-标记的根都有什么？"><a href="#GC-标记的根都有什么？" class="headerlink" title="GC 标记的根都有什么？"></a>GC 标记的根都有什么？</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// gcMarkRootPrepare queues root scanning jobs (stacks, globals, and</span>
<span class="token comment">// some miscellany) and initializes scanning-related state.</span>
<span class="token comment">//</span>
<span class="token comment">// The world must be stopped.</span>
<span class="token comment">/*
	写在最前边，我们关注的重点只是 GC，
	不要过多的被其他知识点所蒙蔽，
	比如这里，我们只需要知道，根从哪里来，根都包含什么
	其它的都可以忽略．．
*/</span>
<span class="token keyword">func</span> <span class="token function">gcMarkRootPrepare</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token function">assertWorldStopped</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token comment">// Compute how many data and BSS root blocks there are.</span>
    nBlocks <span class="token operator">:=</span> <span class="token keyword">func</span><span class="token punctuation">(</span>bytes <span class="token builtin">uintptr</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> <span class="token function">int</span><span class="token punctuation">(</span><span class="token function">divRoundUp</span><span class="token punctuation">(</span>bytes<span class="token punctuation">,</span> rootBlockBytes<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">// 初始化需要被扫描的 data、bss 段个数</span>
    work<span class="token punctuation">.</span>nDataRoots <span class="token operator">=</span> <span class="token number">0</span>
    work<span class="token punctuation">.</span>nBSSRoots <span class="token operator">=</span> <span class="token number">0</span>
    
    <span class="token comment">/*
    	暂时记录下目前的理解：
    	这里的 bss data 段，有可能会变得，比如说进行动态链接的时候，
    	就会把那个被链接的文件加入到 activeModules 中，所以都是通过
    	函数调用的方式来获取对应的数据
    	注：他这个对总数的赋值操作有点迷惑，不知道为啥要这样写..
    */</span>

    <span class="token comment">// Scan globals.</span>
    <span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> datap <span class="token operator">:=</span> <span class="token keyword">range</span> <span class="token function">activeModules</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        nDataRoots <span class="token operator">:=</span> <span class="token function">nBlocks</span><span class="token punctuation">(</span>datap<span class="token punctuation">.</span>edata <span class="token operator">-</span> datap<span class="token punctuation">.</span>data<span class="token punctuation">)</span>
        <span class="token keyword">if</span> nDataRoots <span class="token operator">></span> work<span class="token punctuation">.</span>nDataRoots <span class="token punctuation">&#123;</span>
            work<span class="token punctuation">.</span>nDataRoots <span class="token operator">=</span> nDataRoots
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> datap <span class="token operator">:=</span> <span class="token keyword">range</span> <span class="token function">activeModules</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        nBSSRoots <span class="token operator">:=</span> <span class="token function">nBlocks</span><span class="token punctuation">(</span>datap<span class="token punctuation">.</span>ebss <span class="token operator">-</span> datap<span class="token punctuation">.</span>bss<span class="token punctuation">)</span>
        <span class="token keyword">if</span> nBSSRoots <span class="token operator">></span> work<span class="token punctuation">.</span>nBSSRoots <span class="token punctuation">&#123;</span>
            work<span class="token punctuation">.</span>nBSSRoots <span class="token operator">=</span> nBSSRoots
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">// Scan span roots for finalizer specials.</span>
    <span class="token comment">//</span>
    <span class="token comment">// We depend on addfinalizer to mark objects that get</span>
    <span class="token comment">// finalizers after root marking.</span>
    <span class="token comment">//</span>
    <span class="token comment">// We're going to scan the whole heap (that was available at the time the</span>
    <span class="token comment">// mark phase started, i.e. markArenas) for in-use spans which have specials.</span>
    <span class="token comment">//</span>
    <span class="token comment">// Break up the work into arenas, and further into chunks.</span>
    <span class="token comment">//</span>
    <span class="token comment">// Snapshot allArenas as markArenas. This snapshot is safe because allArenas</span>
    <span class="token comment">// is append-only.</span>
    <span class="token comment">// 扫描整个 heap，对 allArenas 做快照</span>
    mheap_<span class="token punctuation">.</span>markArenas <span class="token operator">=</span> mheap_<span class="token punctuation">.</span>allArenas<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token function">len</span><span class="token punctuation">(</span>mheap_<span class="token punctuation">.</span>allArenas<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token function">len</span><span class="token punctuation">(</span>mheap_<span class="token punctuation">.</span>allArenas<span class="token punctuation">)</span><span class="token punctuation">]</span>
    <span class="token comment">// 计算需要扫描的 span 数量，arena * （单个 arena 中 span 的数量）</span>
    work<span class="token punctuation">.</span>nSpanRoots <span class="token operator">=</span> <span class="token function">len</span><span class="token punctuation">(</span>mheap_<span class="token punctuation">.</span>markArenas<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>pagesPerArena <span class="token operator">/</span> pagesPerSpanRoot<span class="token punctuation">)</span>

    <span class="token comment">// Scan stacks.</span>
    <span class="token comment">//</span>
    <span class="token comment">// Gs may be created after this point, but it's okay that we</span>
    <span class="token comment">// ignore them because they begin life without any roots, so</span>
    <span class="token comment">// there's nothing to scan, and any roots they create during</span>
    <span class="token comment">// the concurrent phase will be caught by the write barrier.</span>
    <span class="token comment">// 如注释所说，尽管这时候有 goroutine 被创建，也不需要担心</span>
    <span class="token comment">// 因为他们没有 root，即不需要扫描。如果在并发阶段创建出来的 goroutine，</span>
    <span class="token comment">// 这个 G 使用的 root 会被 write barrier 捕获到。</span>
    work<span class="token punctuation">.</span>nStackRoots <span class="token operator">=</span> <span class="token function">int</span><span class="token punctuation">(</span>atomic<span class="token punctuation">.</span><span class="token function">Loaduintptr</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>allglen<span class="token punctuation">)</span><span class="token punctuation">)</span>

    <span class="token comment">// 初始化标记的开始位置</span>
    work<span class="token punctuation">.</span>markrootNext <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token comment">//　计算所有根的数量</span>
    <span class="token comment">//　包括了：Data　段，BSS　段,span,以及 goroutine 栈</span>
    work<span class="token punctuation">.</span>markrootJobs <span class="token operator">=</span> <span class="token function">uint32</span><span class="token punctuation">(</span>fixedRootCount <span class="token operator">+</span> work<span class="token punctuation">.</span>nDataRoots <span class="token operator">+</span> work<span class="token punctuation">.</span>nBSSRoots <span class="token operator">+</span> work<span class="token punctuation">.</span>nSpanRoots <span class="token operator">+</span> work<span class="token punctuation">.</span>nStackRoots<span class="token punctuation">)</span>

    <span class="token comment">// Calculate base indexes of each root type</span>
    <span class="token comment">// markroot 标记的时候会根据不同的 i 找到不同的根</span>
    work<span class="token punctuation">.</span>baseData <span class="token operator">=</span> <span class="token function">uint32</span><span class="token punctuation">(</span>fixedRootCount<span class="token punctuation">)</span>
    work<span class="token punctuation">.</span>baseBSS <span class="token operator">=</span> work<span class="token punctuation">.</span>baseData <span class="token operator">+</span> <span class="token function">uint32</span><span class="token punctuation">(</span>work<span class="token punctuation">.</span>nDataRoots<span class="token punctuation">)</span>
    work<span class="token punctuation">.</span>baseSpans <span class="token operator">=</span> work<span class="token punctuation">.</span>baseBSS <span class="token operator">+</span> <span class="token function">uint32</span><span class="token punctuation">(</span>work<span class="token punctuation">.</span>nBSSRoots<span class="token punctuation">)</span>
    work<span class="token punctuation">.</span>baseStacks <span class="token operator">=</span> work<span class="token punctuation">.</span>baseSpans <span class="token operator">+</span> <span class="token function">uint32</span><span class="token punctuation">(</span>work<span class="token punctuation">.</span>nSpanRoots<span class="token punctuation">)</span>
    work<span class="token punctuation">.</span>baseEnd <span class="token operator">=</span> work<span class="token punctuation">.</span>baseStacks <span class="token operator">+</span> <span class="token function">uint32</span><span class="token punctuation">(</span>work<span class="token punctuation">.</span>nStackRoots<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>结合上边代码来看，GC 标记过程中涉及到的根有：全局变量，stack，heap（span）</li>
</ul>
<h3 id="单独使用-D-屏障有何问题？"><a href="#单独使用-D-屏障有何问题？" class="headerlink" title="单独使用 D 屏障有何问题？"></a>单独使用 D 屏障有何问题？</h3><h3 id="单独使用-Y-屏障有何问题？"><a href="#单独使用-Y-屏障有何问题？" class="headerlink" title="单独使用 Y 屏障有何问题？"></a>单独使用 Y 屏障有何问题？</h3><h3 id="混合写屏障是怎么一回事？"><a href="#混合写屏障是怎么一回事？" class="headerlink" title="混合写屏障是怎么一回事？"></a>混合写屏障是怎么一回事？</h3><h3 id="协助标记流程"><a href="#协助标记流程" class="headerlink" title="协助标记流程"></a>协助标记流程</h3><h3 id="对象的交叉引用是如何剪枝的？"><a href="#对象的交叉引用是如何剪枝的？" class="headerlink" title="对象的交叉引用是如何剪枝的？"></a>对象的交叉引用是如何剪枝的？</h3><h4 id="与运算"><a href="#与运算" class="headerlink" title="与运算"></a>与运算</h4><p>两个都是一才是一</p>
<h4 id="或运算"><a href="#或运算" class="headerlink" title="或运算"></a>或运算</h4><p>有一个是一就是一</p>
<h4 id="异或运算"><a href="#异或运算" class="headerlink" title="异或运算"></a>异或运算</h4><p>同零异一</p>
<h3 id="GC-的-CPU-使用率"><a href="#GC-的-CPU-使用率" class="headerlink" title="GC 的 CPU 使用率"></a>GC 的 CPU 使用率</h3><ul>
<li>GC cpu 使用率主要用来控制，启动 mark worker 的数量</li>
</ul>
<p>mark worker count = gomaxprocs * 25%</p>
<p>如果 gomaxprocs = 4，那么只需要启动一个 markworker</p>
<p>对于计算结果不为整数的情况，比如 gomaxprocs = 6，那么 work count  = 1.5，会对结果 + 0.5 进行 rounding， 然后通过计算误差是否 &gt; 0.3 判断开几个全职 worker</p>
<p>2/1.5 -1 = 1/3 &gt; 0.3</p>
<h3 id="gcTriggerKind"><a href="#gcTriggerKind" class="headerlink" title="gcTriggerKind"></a>gcTriggerKind</h3><p>gc 触发类型：</p>
<ul>
<li>gcTriggerHeap 内存到达阈值</li>
<li>gcTriggerTime 到达触发时间</li>
<li>gcTriggerCycle 可以理解为用户手动触发类型</li>
</ul>
<h3 id="STW-时间怎么算出来的？"><a href="#STW-时间怎么算出来的？" class="headerlink" title="STW 时间怎么算出来的？"></a>STW 时间怎么算出来的？</h3><h3 id="GC-过程中是什么时候将对象标记为黑色的"><a href="#GC-过程中是什么时候将对象标记为黑色的" class="headerlink" title="GC 过程中是什么时候将对象标记为黑色的"></a>GC 过程中是什么时候将对象标记为黑色的</h3><p>换句话说，是通过修改了什么变量，就代表这个指针被标记为黑色。</p>
<p>解释如下：</p>
<p>​    通过源码分析，我们可以知道，从白色对象到灰色对象是通过 greyobject 来实现的，同事也能够知道在 gcw 队列中的对象都是灰色的。</p>
<p>​    标记为黑色的过程是从 gcw 队列中取出灰色对象，再遍历其子对象并将其标灰，也即是说当灰色对象出队的时候就自动变成黑色了，就完成了将一个灰色对象标记位黑色的过程，在 Go 的源码中，其实并不存在的某个方法或者某个标志位，来表示一个对象是黑色的。</p>
<h2 id="gcStart-源码剖析"><a href="#gcStart-源码剖析" class="headerlink" title="gcStart 源码剖析"></a>gcStart 源码剖析</h2><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// gcStart starts the GC. It transitions from _GCoff to _GCmark (if</span>
<span class="token comment">// debug.gcstoptheworld == 0) or performs all of GC (if</span>
<span class="token comment">// debug.gcstoptheworld != 0).</span>
<span class="token comment">//</span>
<span class="token comment">// This may return without performing this transition in some cases,</span>
<span class="token comment">// such as when called on a system stack or with locks held.</span>

<span class="token comment">// gcStart 是 GC 的起点，并将 GC 的状态由 _GCoff 切换到 _GCmark，</span>
<span class="token comment">// 如果 gcStart 在系统栈上被调用或者持有锁的时候，就不会执行状态的改变直接返回了。</span>
<span class="token keyword">func</span> <span class="token function">gcStart</span><span class="token punctuation">(</span>trigger gcTrigger<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// Since this is called from malloc and malloc is called in</span>
    <span class="token comment">// the guts of a number of libraries that might be holding</span>
    <span class="token comment">// locks, don't attempt to start GC in non-preemptible or</span>
    <span class="token comment">// potentially unstable situations.</span>

    <span class="token comment">// 如果 gcStart 是从 malloc 调用的，并且 malloc 又是被其他的库调用的，</span>
    <span class="token comment">// 这种情况下可能会持有锁（mp.locks > 1）</span>
    <span class="token comment">// 不要再非抢占或者不稳定的情况下调用 gcStart</span>
    <span class="token comment">/*
       我的理解：如果不是非抢占模式，可能会导致后面 stw 时，一些 g 没有办法停止
       会影响 GC 的结果。
    */</span>
    mp <span class="token operator">:=</span> <span class="token function">acquirem</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">// mp.locks > 1 说明在 gcStart 之前就持有锁</span>
    <span class="token comment">// mp.preemptoff != "" 说明在 non-preempt 模式下</span>
    <span class="token keyword">if</span> gp <span class="token operator">:=</span> <span class="token function">getg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> gp <span class="token operator">==</span> mp<span class="token punctuation">.</span>g0 <span class="token operator">||</span> mp<span class="token punctuation">.</span>locks <span class="token operator">></span> <span class="token number">1</span> <span class="token operator">||</span> mp<span class="token punctuation">.</span>preemptoff <span class="token operator">!=</span> <span class="token string">""</span> <span class="token punctuation">&#123;</span>
        <span class="token function">releasem</span><span class="token punctuation">(</span>mp<span class="token punctuation">)</span>
        <span class="token keyword">return</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">releasem</span><span class="token punctuation">(</span>mp<span class="token punctuation">)</span>
    mp <span class="token operator">=</span> <span class="token boolean">nil</span>	

    <span class="token comment">// Pick up the remaining unswept/not being swept spans concurrently</span>
    <span class="token comment">//</span>
    <span class="token comment">// This shouldn't happen if we're being invoked in background</span>
    <span class="token comment">// mode since proportional sweep should have just finished</span>
    <span class="token comment">// sweeping everything, but rounding errors, etc, may leave a</span>
    <span class="token comment">// few spans unswept. In forced mode, this is necessary since</span>
    <span class="token comment">// GC can be forced at any point in the sweeping cycle.</span>
    <span class="token comment">//</span>
    <span class="token comment">// We check the transition condition continuously here in case</span>
    <span class="token comment">// this G gets delayed in to the next GC cycle.</span>
    <span class="token comment">/*
        trigger.test() 检测是否满足 GC 的触发条件
        sweepone() 我的理解是：清扫上次 GC 遗留下来的 unswept 的 span
        ？？ 是否可以理解成 sweep termination 的阶段 
    */</span>
    <span class="token keyword">for</span> trigger<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">sweepone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">^</span><span class="token function">uintptr</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        sweep<span class="token punctuation">.</span>nbgsweep<span class="token operator">++</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">// Perform GC initialization and the sweep termination</span>
    <span class="token comment">// transition.</span>
    <span class="token comment">/*
    	semaacquire 的操作，是否可以理解为，通过 atomic 去掉了锁。
		换句话说，只有获取了某个 sema，才能对 gc 状态进行修改。
    */</span>
    <span class="token function">semacquire</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>work<span class="token punctuation">.</span>startSema<span class="token punctuation">)</span>
    <span class="token comment">// Re-check transition condition under transition lock.</span>
    <span class="token keyword">if</span> <span class="token operator">!</span>trigger<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">semrelease</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>work<span class="token punctuation">.</span>startSema<span class="token punctuation">)</span>
        <span class="token keyword">return</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">// For stats, check if this GC was forced by the user.</span>
    work<span class="token punctuation">.</span>userForced <span class="token operator">=</span> trigger<span class="token punctuation">.</span>kind <span class="token operator">==</span> gcTriggerCycle

    <span class="token comment">// In gcstoptheworld debug mode, upgrade the mode accordingly.</span>
    <span class="token comment">// We do this after re-checking the transition condition so</span>
    <span class="token comment">// that multiple goroutines that detect the heap trigger don't</span>
    <span class="token comment">// start multiple STW GCs.</span>
    <span class="token comment">// 如果没开启 GODEBUG 都是 gcBackgroundMode 模式</span>
    mode <span class="token operator">:=</span> gcBackgroundMode
    <span class="token keyword">if</span> debug<span class="token punctuation">.</span>gcstoptheworld <span class="token operator">==</span> <span class="token number">1</span> <span class="token punctuation">&#123;</span>
        mode <span class="token operator">=</span> gcForceMode
    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> debug<span class="token punctuation">.</span>gcstoptheworld <span class="token operator">==</span> <span class="token number">2</span> <span class="token punctuation">&#123;</span>
        mode <span class="token operator">=</span> gcForceBlockMode
    <span class="token punctuation">&#125;</span>

    <span class="token comment">// Ok, we're doing it! Stop everybody else</span>
    <span class="token comment">// 获取 STW 需要的 semaphore</span>
    <span class="token function">semacquire</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>gcsema<span class="token punctuation">)</span>
    <span class="token function">semacquire</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>worldsema<span class="token punctuation">)</span>

    <span class="token keyword">if</span> trace<span class="token punctuation">.</span>enabled <span class="token punctuation">&#123;</span>
        <span class="token function">traceGCStart</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">// Check that all Ps have finished deferred mcache flushes.</span>
    <span class="token comment">// TODO 检查 P 的 mcache</span>
    <span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> p <span class="token operator">:=</span> <span class="token keyword">range</span> allp <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> fg <span class="token operator">:=</span> atomic<span class="token punctuation">.</span><span class="token function">Load</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p<span class="token punctuation">.</span>mcache<span class="token punctuation">.</span>flushGen<span class="token punctuation">)</span><span class="token punctuation">;</span> fg <span class="token operator">!=</span> mheap_<span class="token punctuation">.</span>sweepgen <span class="token punctuation">&#123;</span>
            <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"runtime: p"</span><span class="token punctuation">,</span> p<span class="token punctuation">.</span>id<span class="token punctuation">,</span> <span class="token string">"flushGen"</span><span class="token punctuation">,</span> fg<span class="token punctuation">,</span> <span class="token string">"!= sweepgen"</span><span class="token punctuation">,</span> mheap_<span class="token punctuation">.</span>sweepgen<span class="token punctuation">)</span>
            <span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">"p mcache not flushed"</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">// 开启 nproc 个 gcMarkWorker，加入到 workerPool 中</span>
    <span class="token comment">// 创建完一个 worker，休眠一个 worker</span>
    <span class="token comment">// 由 schedule.findRunnableGCWorker 唤醒</span>
    <span class="token function">gcBgMarkStartWorkers</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token comment">// 重置标志位，allg 的标志位，heapArena 的标志位</span>
    <span class="token comment">// 清空了每一个 g 的 AssistBytes</span>
    <span class="token function">systemstack</span><span class="token punctuation">(</span>gcResetMarkState<span class="token punctuation">)</span>

    work<span class="token punctuation">.</span>stwprocs<span class="token punctuation">,</span> work<span class="token punctuation">.</span>maxprocs <span class="token operator">=</span> gomaxprocs<span class="token punctuation">,</span> gomaxprocs
    <span class="token keyword">if</span> work<span class="token punctuation">.</span>stwprocs <span class="token operator">></span> ncpu <span class="token punctuation">&#123;</span>
        <span class="token comment">// This is used to compute CPU time of the STW phases,</span>
        <span class="token comment">// so it can't be more than ncpu, even if GOMAXPROCS is.</span>
        work<span class="token punctuation">.</span>stwprocs <span class="token operator">=</span> ncpu
    <span class="token punctuation">&#125;</span>
    work<span class="token punctuation">.</span>heap0 <span class="token operator">=</span> atomic<span class="token punctuation">.</span><span class="token function">Load64</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>memstats<span class="token punctuation">.</span>heap_live<span class="token punctuation">)</span>
    work<span class="token punctuation">.</span>pauseNS <span class="token operator">=</span> <span class="token number">0</span>
    work<span class="token punctuation">.</span>mode <span class="token operator">=</span> mode

    now <span class="token operator">:=</span> <span class="token function">nanotime</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    work<span class="token punctuation">.</span>tSweepTerm <span class="token operator">=</span> now
    work<span class="token punctuation">.</span>pauseStart <span class="token operator">=</span> now
    <span class="token keyword">if</span> trace<span class="token punctuation">.</span>enabled <span class="token punctuation">&#123;</span>
        <span class="token function">traceGCSTWStart</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">// STW 调用者必须为 stopTheWorldWithSema 获取 worldsema 并且 关闭抢占</span>
    <span class="token function">systemstack</span><span class="token punctuation">(</span>stopTheWorldWithSema<span class="token punctuation">)</span>

    <span class="token comment">// Finish sweep before we start concurrent scan.</span>
    <span class="token comment">// 确保本次 GC 开始时，已完成上一次 GC 的 sweep 工作</span>
    <span class="token function">systemstack</span><span class="token punctuation">(</span><span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">finishsweep_m</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>

    <span class="token comment">// clearpools before we start the GC. If we wait they memory will not be</span>
    <span class="token comment">// reclaimed until the next GC cycle.</span>
    <span class="token comment">// 1.处理 sync.Pool</span>
    <span class="token comment">// 2.清空 sudog cache</span>
    <span class="token comment">// 3.清空 defer pools</span>
    <span class="token function">clearpools</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token comment">// 增加 gc 周期数</span>
    work<span class="token punctuation">.</span>cycles<span class="token operator">++</span>

    <span class="token comment">// 开始本次 gc 周期</span>
    gcController<span class="token punctuation">.</span><span class="token function">startCycle</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    work<span class="token punctuation">.</span>heapGoal <span class="token operator">=</span> memstats<span class="token punctuation">.</span>next_gc

    <span class="token comment">// In STW mode, disable scheduling of user Gs. This may also</span>
    <span class="token comment">// disable scheduling of this goroutine, so it may block as</span>
    <span class="token comment">// soon as we start the world again.</span>
    <span class="token keyword">if</span> mode <span class="token operator">!=</span> gcBackgroundMode <span class="token punctuation">&#123;</span>
        <span class="token function">schedEnableUser</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">// Enter concurrent mark phase and enable</span>
    <span class="token comment">// write barriers.</span>
    <span class="token comment">//</span>
    <span class="token comment">// Because the world is stopped, all Ps will</span>
    <span class="token comment">// observe that write barriers are enabled by</span>
    <span class="token comment">// the time we start the world and begin</span>
    <span class="token comment">// scanning.</span>
    <span class="token comment">//</span>
    <span class="token comment">// Write barriers must be enabled before assists are</span>
    <span class="token comment">// enabled because they must be enabled before</span>
    <span class="token comment">// any non-leaf heap objects are marked. Since</span>
    <span class="token comment">// allocations are blocked until assists can</span>
    <span class="token comment">// happen, we want enable assists as early as</span>
    <span class="token comment">// possible.</span>
    <span class="token function">setGCPhase</span><span class="token punctuation">(</span>_GCmark<span class="token punctuation">)</span>

    <span class="token function">gcBgMarkPrepare</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// Must happen before assist enable.</span>
    <span class="token function">gcMarkRootPrepare</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token comment">// Mark all active tinyalloc blocks. Since we're</span>
    <span class="token comment">// allocating from these, they need to be black like</span>
    <span class="token comment">// other allocations. The alternative is to blacken</span>
    <span class="token comment">// the tiny block on every allocation from it, which</span>
    <span class="token comment">// would slow down the tiny allocator.</span>
    <span class="token function">gcMarkTinyAllocs</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token comment">// At this point all Ps have enabled the write</span>
    <span class="token comment">// barrier, thus maintaining the no white to</span>
    <span class="token comment">// black invariant. Enable mutator assists to</span>
    <span class="token comment">// put back-pressure on fast allocating</span>
    <span class="token comment">// mutators.</span>
    atomic<span class="token punctuation">.</span><span class="token function">Store</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>gcBlackenEnabled<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>

    <span class="token comment">// Assists and workers can start the moment we start</span>
    <span class="token comment">// the world.</span>
    gcController<span class="token punctuation">.</span>markStartTime <span class="token operator">=</span> now

    <span class="token comment">// In STW mode, we could block the instant systemstack</span>
    <span class="token comment">// returns, so make sure we're not preemptible.</span>
    mp <span class="token operator">=</span> <span class="token function">acquirem</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token comment">// Concurrent mark.</span>
    <span class="token function">systemstack</span><span class="token punctuation">(</span><span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        now <span class="token operator">=</span> <span class="token function">startTheWorldWithSema</span><span class="token punctuation">(</span>trace<span class="token punctuation">.</span>enabled<span class="token punctuation">)</span>
        work<span class="token punctuation">.</span>pauseNS <span class="token operator">+=</span> now <span class="token operator">-</span> work<span class="token punctuation">.</span>pauseStart
        work<span class="token punctuation">.</span>tMark <span class="token operator">=</span> now
        memstats<span class="token punctuation">.</span>gcPauseDist<span class="token punctuation">.</span><span class="token function">record</span><span class="token punctuation">(</span>now <span class="token operator">-</span> work<span class="token punctuation">.</span>pauseStart<span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>

    <span class="token comment">// Release the world sema before Gosched() in STW mode</span>
    <span class="token comment">// because we will need to reacquire it later but before</span>
    <span class="token comment">// this goroutine becomes runnable again, and we could</span>
    <span class="token comment">// self-deadlock otherwise.</span>
    <span class="token function">semrelease</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>worldsema<span class="token punctuation">)</span>
    <span class="token function">releasem</span><span class="token punctuation">(</span>mp<span class="token punctuation">)</span>

    <span class="token comment">// Make sure we block instead of returning to user code</span>
    <span class="token comment">// in STW mode.</span>
    <span class="token keyword">if</span> mode <span class="token operator">!=</span> gcBackgroundMode <span class="token punctuation">&#123;</span>
        <span class="token function">Gosched</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>

    <span class="token function">semrelease</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>work<span class="token punctuation">.</span>startSema<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="findRunnableGCWorker-源码剖析"><a href="#findRunnableGCWorker-源码剖析" class="headerlink" title="findRunnableGCWorker 源码剖析"></a>findRunnableGCWorker 源码剖析</h2><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// findRunnableGCWorker returns a background mark worker for _p_ if it</span>
<span class="token comment">// should be run. This must only be called when gcBlackenEnabled != 0.</span>
<span class="token comment">// 只有在 gc 开启的时候才会执行，gcStart 中设置为 1</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>c <span class="token operator">*</span>gcControllerState<span class="token punctuation">)</span> <span class="token function">findRunnableGCWorker</span><span class="token punctuation">(</span>_p_ <span class="token operator">*</span>p<span class="token punctuation">)</span> <span class="token operator">*</span>g <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> gcBlackenEnabled <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>
        <span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">"gcControllerState.findRunnable: blackening not enabled"</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">if</span> <span class="token operator">!</span><span class="token function">gcMarkWorkAvailable</span><span class="token punctuation">(</span>_p_<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// No work to be done right now. This can happen at</span>
        <span class="token comment">// the end of the mark phase when there are still</span>
        <span class="token comment">// assists tapering off. Don't bother running a worker</span>
        <span class="token comment">// now because it'll just return immediately.</span>
        <span class="token keyword">return</span> <span class="token boolean">nil</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">// Grab a worker before we commit to running below.</span>
    <span class="token comment">// 从 workpool 中弹出一个 gcMarkWorker</span>
    node <span class="token operator">:=</span> <span class="token punctuation">(</span><span class="token operator">*</span>gcBgMarkWorkerNode<span class="token punctuation">)</span><span class="token punctuation">(</span>gcBgMarkWorkerPool<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> node <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// There is at least one worker per P, so normally there are</span>
        <span class="token comment">// enough workers to run on all Ps, if necessary. However, once</span>
        <span class="token comment">// a worker enters gcMarkDone it may park without rejoining the</span>
        <span class="token comment">// pool, thus freeing a P with no corresponding worker.</span>
        <span class="token comment">// gcMarkDone never depends on another worker doing work, so it</span>
        <span class="token comment">// is safe to simply do nothing here.</span>
        <span class="token comment">//</span>
        <span class="token comment">// If gcMarkDone bails out without completing the mark phase,</span>
        <span class="token comment">// it will always do so with queued global work. Thus, that P</span>
        <span class="token comment">// will be immediately eligible to re-run the worker G it was</span>
        <span class="token comment">// just using, ensuring work can complete.</span>
        <span class="token keyword">return</span> <span class="token boolean">nil</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">// 用于计算该 markNode 的工作模式</span>
    <span class="token comment">// >  0 dedicatedMode</span>
    <span class="token comment">// &lt;= 0 fractionalMode</span>
    decIfPositive <span class="token operator">:=</span> <span class="token keyword">func</span><span class="token punctuation">(</span>ptr <span class="token operator">*</span><span class="token builtin">int64</span><span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">for</span> <span class="token punctuation">&#123;</span>
            v <span class="token operator">:=</span> atomic<span class="token punctuation">.</span><span class="token function">Loadint64</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span>
            <span class="token keyword">if</span> v <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>
                <span class="token keyword">return</span> <span class="token boolean">false</span>
            <span class="token punctuation">&#125;</span>

            <span class="token keyword">if</span> atomic<span class="token punctuation">.</span><span class="token function">Casint64</span><span class="token punctuation">(</span>ptr<span class="token punctuation">,</span> v<span class="token punctuation">,</span> v<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token keyword">return</span> <span class="token boolean">true</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">if</span> <span class="token function">decIfPositive</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>c<span class="token punctuation">.</span>dedicatedMarkWorkersNeeded<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// This P is now dedicated to marking until the end of</span>
        <span class="token comment">// the concurrent mark phase.</span>
        _p_<span class="token punctuation">.</span>gcMarkWorkerMode <span class="token operator">=</span> gcMarkWorkerDedicatedMode
    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> c<span class="token punctuation">.</span>fractionalUtilizationGoal <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// No need for fractional workers.</span>
        gcBgMarkWorkerPool<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>node<span class="token punctuation">.</span>node<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token boolean">nil</span>
    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// Is this P behind on the fractional utilization</span>
        <span class="token comment">// goal?</span>
        <span class="token comment">//</span>
        <span class="token comment">// This should be kept in sync with pollFractionalWorkerExit.</span>
        delta <span class="token operator">:=</span> <span class="token function">nanotime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> c<span class="token punctuation">.</span>markStartTime
        <span class="token keyword">if</span> delta <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token function">float64</span><span class="token punctuation">(</span>_p_<span class="token punctuation">.</span>gcFractionalMarkTime<span class="token punctuation">)</span><span class="token operator">/</span><span class="token function">float64</span><span class="token punctuation">(</span>delta<span class="token punctuation">)</span> <span class="token operator">></span> c<span class="token punctuation">.</span>fractionalUtilizationGoal <span class="token punctuation">&#123;</span>
            <span class="token comment">// Nope. No need to run a fractional worker.</span>
            gcBgMarkWorkerPool<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>node<span class="token punctuation">.</span>node<span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token boolean">nil</span>
        <span class="token punctuation">&#125;</span>
        <span class="token comment">// Run a fractional worker.</span>
        _p_<span class="token punctuation">.</span>gcMarkWorkerMode <span class="token operator">=</span> gcMarkWorkerFractionalMode
    <span class="token punctuation">&#125;</span>

    <span class="token comment">// Run the background mark worker.</span>
    <span class="token comment">// 修改 workerg 的状态并返回</span>
    gp <span class="token operator">:=</span> node<span class="token punctuation">.</span>gp<span class="token punctuation">.</span><span class="token function">ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token function">casgstatus</span><span class="token punctuation">(</span>gp<span class="token punctuation">,</span> _Gwaiting<span class="token punctuation">,</span> _Grunnable<span class="token punctuation">)</span>
    <span class="token keyword">if</span> trace<span class="token punctuation">.</span>enabled <span class="token punctuation">&#123;</span>
        <span class="token function">traceGoUnpark</span><span class="token punctuation">(</span>gp<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> gp
<span class="token punctuation">&#125;</span>


<span class="token comment">// gcMarkWorkAvailable reports whether executing a mark worker</span>
<span class="token comment">// on p is potentially useful. p may be nil, in which case it only</span>
<span class="token comment">// checks the global sources of work.</span>
<span class="token comment">/*
	该函数主要作用：返回是否有标记工作可以干
	gcw p的队列
	work 全局队列
*/</span>
<span class="token keyword">func</span> <span class="token function">gcMarkWorkAvailable</span><span class="token punctuation">(</span>p <span class="token operator">*</span>p<span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> p <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>p<span class="token punctuation">.</span>gcw<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">if</span> <span class="token operator">!</span>work<span class="token punctuation">.</span>full<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span> <span class="token comment">// global work available</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">if</span> work<span class="token punctuation">.</span>markrootNext <span class="token operator">&lt;</span> work<span class="token punctuation">.</span>markrootJobs <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span> <span class="token comment">// root scan work available</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="剖析-gcBgMarkWorker-创建过程"><a href="#剖析-gcBgMarkWorker-创建过程" class="headerlink" title="剖析 gcBgMarkWorker 创建过程"></a>剖析 gcBgMarkWorker 创建过程</h2><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// gcBgMarkStartWorkers prepares background mark worker goroutines. These</span>
<span class="token comment">// goroutines will not run until the mark phase, but they must be started while</span>
<span class="token comment">// the work is not stopped and from a regular G stack. The caller must hold</span>
<span class="token comment">// worldsema.</span>
<span class="token keyword">func</span> <span class="token function">gcBgMarkStartWorkers</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// Background marking is performed by per-P G's. Ensure that each P has</span>
    <span class="token comment">// a background GC G.</span>
    <span class="token comment">//</span>
    <span class="token comment">// Worker Gs don't exit if gomaxprocs is reduced. If it is raised</span>
    <span class="token comment">// again, we can reuse the old workers; no need to create new workers.</span>
    <span class="token keyword">for</span> gcBgMarkWorkerCount <span class="token operator">&lt;</span> gomaxprocs <span class="token punctuation">&#123;</span>
        <span class="token keyword">go</span> <span class="token function">gcBgMarkWorker</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

        <span class="token function">notetsleepg</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>work<span class="token punctuation">.</span>bgMarkReady<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token function">noteclear</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>work<span class="token punctuation">.</span>bgMarkReady<span class="token punctuation">)</span>
        <span class="token comment">// The worker is now guaranteed to be added to the pool before</span>
        <span class="token comment">// its P's next findRunnableGCWorker.</span>

        gcBgMarkWorkerCount<span class="token operator">++</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>由上可知，所有 gcMarkWorker 都是通过该函数创建的，我们需要关注的是 <code>notesleepg()</code> 和 <code>go gcBgMarkWorker</code> 这两行代码</li>
</ul>
<h3 id="notesleepg"><a href="#notesleepg" class="headerlink" title="notesleepg"></a><code>notesleepg</code></h3><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// same as runtime·notetsleep, but called on user g (not g0)</span>
<span class="token comment">// calls only nosplit functions between entersyscallblock/exitsyscall</span>
<span class="token keyword">func</span> <span class="token function">notetsleepg</span><span class="token punctuation">(</span>n <span class="token operator">*</span>note<span class="token punctuation">,</span> ns <span class="token builtin">int64</span><span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">&#123;</span>
    gp <span class="token operator">:=</span> <span class="token function">getg</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> gp <span class="token operator">==</span> gp<span class="token punctuation">.</span>m<span class="token punctuation">.</span>g0 <span class="token punctuation">&#123;</span>
        <span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">"notetsleepg on g0"</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>
    <span class="token comment">// 这个我们在学习 timer 的时候已经看过了</span>
    <span class="token comment">// 主要就是执行 handoff</span>
    <span class="token function">entersyscallblock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">// 这里才是真正进行系统调用的地方，ns = -1，会无休止的休眠</span>
    <span class="token comment">// 直到通过 wakeup 唤醒</span>
    ok <span class="token operator">:=</span> <span class="token function">notetsleep_internal</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> ns<span class="token punctuation">)</span>
    <span class="token comment">// 上述，通过 wakeup 唤醒后会继续执行这块代码</span>
    <span class="token comment">// 该函数主要是给刚刚剥离的 GM 找一个 P</span>
    <span class="token comment">// 找到了，执行</span>
    <span class="token comment">// 没找到，把 g 放到全局队列</span>
    <span class="token function">exitsyscall</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> ok
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="go-gcBgMarkWorker"><a href="#go-gcBgMarkWorker" class="headerlink" title="go gcBgMarkWorker"></a><code>go gcBgMarkWorker</code></h3><ul>
<li>这里应用到 MPG 调度的知识点，我们通过 go 关键字新建一个 goroutine，放入 runnext 等待被调度。</li>
</ul>
<h3 id="结合着看"><a href="#结合着看" class="headerlink" title="结合着看"></a>结合着看</h3><p>我们假设现在只有一个 P，即 <code>runtime.GOMAXPROCS(1)</code> 。这时我们来看上述代码，其执行过程为：</p>
<ul>
<li>1.通过 <code>gcBgMarkStartWorkers</code> 创建 worker</li>
<li>2.worker 被放入 runnext 等待被调度</li>
<li>3.执行 <code>notesleepg</code><ul>
<li>handoffp</li>
<li>futex &amp;&amp; timeout = -1</li>
<li>第 3 步执行完成后，GM 已经从 P 上剥离</li>
</ul>
</li>
<li>4.handoffp 中会启动一个 M 继续执行调度循环</li>
<li>5.newM 从 P 上找 G 执行</li>
<li>6.拿到我们刚刚创建的 newg</li>
<li>7.进入到 <code>gcBgMarkWorker()</code> 中执行<ul>
<li>新建 node &amp;&amp; <strong>wakeup</strong> 休眠的 GM</li>
<li>然后 <code>gopark</code> 挂起 worker 等待唤醒</li>
</ul>
</li>
<li>8.休眠的 GM 醒来后<ul>
<li>尝试获取 oldp</li>
<li>如果获取不到则，尝试获取 idlep</li>
<li>如果获取不到则，将 g 放入全局队列</li>
</ul>
</li>
<li>9.第 8 步中的 g 被调度后，会继续执行 create worker 的工作，回到第 1 步 继续执行</li>
</ul>
<h2 id="gcMarkWorker-执行过程"><a href="#gcMarkWorker-执行过程" class="headerlink" title="gcMarkWorker 执行过程"></a>gcMarkWorker 执行过程</h2><h3 id="gcBgMarkWorker-源码剖析"><a href="#gcBgMarkWorker-源码剖析" class="headerlink" title="gcBgMarkWorker 源码剖析"></a>gcBgMarkWorker 源码剖析</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">gcBgMarkWorker</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    gp <span class="token operator">:=</span> <span class="token function">getg</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token comment">// We pass node to a gopark unlock function, so it can't be on</span>
    <span class="token comment">// the stack (see gopark). Prevent deadlock from recursively</span>
    <span class="token comment">// starting GC by disabling preemption.</span>
    gp<span class="token punctuation">.</span>m<span class="token punctuation">.</span>preemptoff <span class="token operator">=</span> <span class="token string">"GC worker init"</span>
    node <span class="token operator">:=</span> <span class="token function">new</span><span class="token punctuation">(</span>gcBgMarkWorkerNode<span class="token punctuation">)</span>
    gp<span class="token punctuation">.</span>m<span class="token punctuation">.</span>preemptoff <span class="token operator">=</span> <span class="token string">""</span>

    node<span class="token punctuation">.</span>gp<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>gp<span class="token punctuation">)</span>

    node<span class="token punctuation">.</span>m<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token function">acquirem</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token function">notewakeup</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>work<span class="token punctuation">.</span>bgMarkReady<span class="token punctuation">)</span>
    <span class="token comment">// After this point, the background mark worker is generally scheduled</span>
    <span class="token comment">// cooperatively by gcController.findRunnableGCWorker. While performing</span>
    <span class="token comment">// work on the P, preemption is disabled because we are working on</span>
    <span class="token comment">// P-local work buffers. When the preempt flag is set, this puts itself</span>
    <span class="token comment">// into _Gwaiting to be woken up by gcController.findRunnableGCWorker</span>
    <span class="token comment">// at the appropriate time.</span>
    <span class="token comment">//</span>
    <span class="token comment">// When preemption is enabled (e.g., while in gcMarkDone), this worker</span>
    <span class="token comment">// may be preempted and schedule as a _Grunnable G from a runq. That is</span>
    <span class="token comment">// fine; it will eventually gopark again for further scheduling via</span>
    <span class="token comment">// findRunnableGCWorker.</span>
    <span class="token comment">//</span>
    <span class="token comment">// Since we disable preemption before notifying bgMarkReady, we</span>
    <span class="token comment">// guarantee that this G will be in the worker pool for the next</span>
    <span class="token comment">// findRunnableGCWorker. This isn't strictly necessary, but it reduces</span>
    <span class="token comment">// latency between _GCmark starting and the workers starting.</span>

    <span class="token keyword">for</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// Go to sleep until woken by</span>
        <span class="token comment">// gcController.findRunnableGCWorker.</span>
        <span class="token function">gopark</span><span class="token punctuation">(</span><span class="token keyword">func</span><span class="token punctuation">(</span>g <span class="token operator">*</span>g<span class="token punctuation">,</span> nodep unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">&#123;</span>
            node <span class="token operator">:=</span> <span class="token punctuation">(</span><span class="token operator">*</span>gcBgMarkWorkerNode<span class="token punctuation">)</span><span class="token punctuation">(</span>nodep<span class="token punctuation">)</span>

            <span class="token keyword">if</span> mp <span class="token operator">:=</span> node<span class="token punctuation">.</span>m<span class="token punctuation">.</span><span class="token function">ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> mp <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
                <span class="token comment">// The worker G is no longer running; release</span>
                <span class="token comment">// the M.</span>
                <span class="token comment">//</span>
                <span class="token comment">// N.B. it is _safe_ to release the M as soon</span>
                <span class="token comment">// as we are no longer performing P-local mark</span>
                <span class="token comment">// work.</span>
                <span class="token comment">//</span>
                <span class="token comment">// However, since we cooperatively stop work</span>
                <span class="token comment">// when gp.preempt is set, if we releasem in</span>
                <span class="token comment">// the loop then the following call to gopark</span>
                <span class="token comment">// would immediately preempt the G. This is</span>
                <span class="token comment">// also safe, but inefficient: the G must</span>
                <span class="token comment">// schedule again only to enter gopark and park</span>
                <span class="token comment">// again. Thus, we defer the release until</span>
                <span class="token comment">// after parking the G.</span>
                <span class="token function">releasem</span><span class="token punctuation">(</span>mp<span class="token punctuation">)</span>
            <span class="token punctuation">&#125;</span>

            <span class="token comment">// Release this G to the pool.</span>
            gcBgMarkWorkerPool<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>node<span class="token punctuation">.</span>node<span class="token punctuation">)</span>
            <span class="token comment">// Note that at this point, the G may immediately be</span>
            <span class="token comment">// rescheduled and may be running.</span>
            <span class="token keyword">return</span> <span class="token boolean">true</span>
        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">,</span> waitReasonGCWorkerIdle<span class="token punctuation">,</span> traceEvGoBlock<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>

        <span class="token comment">/*
        	以上代码都已经解释过了
        */</span>

        <span class="token comment">/*
        	TODO 关于在 GC 期间什么时候可以抢占，什么时候禁止抢占
        	还需要进一步研究，目前可以先把整个流程梳理下来
        */</span>

        <span class="token comment">// Preemption must not occur here, or another G might see</span>
        <span class="token comment">// p.gcMarkWorkerMode.</span>

        <span class="token comment">// Disable preemption so we can use the gcw. If the</span>
        <span class="token comment">// scheduler wants to preempt us, we'll stop draining,</span>
        <span class="token comment">// dispose the gcw, and then preempt.</span>
        node<span class="token punctuation">.</span>m<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token function">acquirem</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        pp <span class="token operator">:=</span> gp<span class="token punctuation">.</span>m<span class="token punctuation">.</span>p<span class="token punctuation">.</span><span class="token function">ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// P can't change with preemption disabled.</span>

        <span class="token comment">// 是否已开启标记</span>
        <span class="token keyword">if</span> gcBlackenEnabled <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>
            <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"worker mode"</span><span class="token punctuation">,</span> pp<span class="token punctuation">.</span>gcMarkWorkerMode<span class="token punctuation">)</span>
            <span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">"gcBgMarkWorker: blackening not enabled"</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#125;</span>

        <span class="token comment">// 检查 markworker 的 Mode</span>
        <span class="token keyword">if</span> pp<span class="token punctuation">.</span>gcMarkWorkerMode <span class="token operator">==</span> gcMarkWorkerNotWorker <span class="token punctuation">&#123;</span>
            <span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">"gcBgMarkWorker: mode not set"</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#125;</span>

        <span class="token comment">// 记录 worker 标记的开始时间</span>
        startTime <span class="token operator">:=</span> <span class="token function">nanotime</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        pp<span class="token punctuation">.</span>gcMarkWorkerStartTime <span class="token operator">=</span> startTime

        <span class="token comment">// 将等待执行的 worker 数量减一</span>
        decnwait <span class="token operator">:=</span> atomic<span class="token punctuation">.</span><span class="token function">Xadd</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>work<span class="token punctuation">.</span>nwait<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> decnwait <span class="token operator">==</span> work<span class="token punctuation">.</span>nproc <span class="token punctuation">&#123;</span>
            <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"runtime: work.nwait="</span><span class="token punctuation">,</span> decnwait<span class="token punctuation">,</span> <span class="token string">"work.nproc="</span><span class="token punctuation">,</span> work<span class="token punctuation">.</span>nproc<span class="token punctuation">)</span>
            <span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">"work.nwait was > work.nproc"</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#125;</span>

        <span class="token function">systemstack</span><span class="token punctuation">(</span><span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token comment">// Mark our goroutine preemptible so its stack</span>
            <span class="token comment">// can be scanned. This lets two mark workers</span>
            <span class="token comment">// scan each other (otherwise, they would</span>
            <span class="token comment">// deadlock). We must not modify anything on</span>
            <span class="token comment">// the G stack. However, stack shrinking is</span>
            <span class="token comment">// disabled for mark workers, so it is safe to</span>
            <span class="token comment">// read from the G stack.</span>
            <span class="token comment">// 关于这里为什么把 G 的 running 状态修改为 waiting 状态</span>
            <span class="token comment">// TODO 需要进一步的研究，曹大说要结合 suspendG 来看</span>
            <span class="token function">casgstatus</span><span class="token punctuation">(</span>gp<span class="token punctuation">,</span> _Grunning<span class="token punctuation">,</span> _Gwaiting<span class="token punctuation">)</span>
            <span class="token keyword">switch</span> pp<span class="token punctuation">.</span>gcMarkWorkerMode <span class="token punctuation">&#123;</span>
                <span class="token keyword">default</span><span class="token punctuation">:</span>
                	<span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">"gcBgMarkWorker: unexpected gcMarkWorkerMode"</span><span class="token punctuation">)</span>
                <span class="token keyword">case</span> gcMarkWorkerDedicatedMode<span class="token punctuation">:</span>
                	<span class="token function">gcDrain</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pp<span class="token punctuation">.</span>gcw<span class="token punctuation">,</span> gcDrainUntilPreempt<span class="token operator">|</span>gcDrainFlushBgCredit<span class="token punctuation">)</span>
                    <span class="token keyword">if</span> gp<span class="token punctuation">.</span>preempt <span class="token punctuation">&#123;</span>
                        <span class="token comment">// We were preempted. This is</span>
                        <span class="token comment">// a useful signal to kick</span>
                        <span class="token comment">// everything out of the run</span>
                        <span class="token comment">// queue so it can run</span>
                        <span class="token comment">// somewhere else.</span>
                        <span class="token keyword">if</span> drainQ<span class="token punctuation">,</span> n <span class="token operator">:=</span> <span class="token function">runqdrain</span><span class="token punctuation">(</span>pp<span class="token punctuation">)</span><span class="token punctuation">;</span> n <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>
                            <span class="token function">lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sched<span class="token punctuation">.</span>lock<span class="token punctuation">)</span>
                            <span class="token function">globrunqputbatch</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>drainQ<span class="token punctuation">,</span> <span class="token function">int32</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span>
                            <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sched<span class="token punctuation">.</span>lock<span class="token punctuation">)</span>
                        <span class="token punctuation">&#125;</span>
                    <span class="token punctuation">&#125;</span>
                    <span class="token comment">// Go back to draining, this time</span>
                    <span class="token comment">// without preemption.</span>
                    <span class="token function">gcDrain</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pp<span class="token punctuation">.</span>gcw<span class="token punctuation">,</span> gcDrainFlushBgCredit<span class="token punctuation">)</span>
                <span class="token keyword">case</span> gcMarkWorkerFractionalMode<span class="token punctuation">:</span>
                	<span class="token function">gcDrain</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pp<span class="token punctuation">.</span>gcw<span class="token punctuation">,</span> gcDrainFractional<span class="token operator">|</span>gcDrainUntilPreempt<span class="token operator">|</span>gcDrainFlushBgCredit<span class="token punctuation">)</span>
                <span class="token keyword">case</span> gcMarkWorkerIdleMode<span class="token punctuation">:</span>
                	<span class="token function">gcDrain</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pp<span class="token punctuation">.</span>gcw<span class="token punctuation">,</span> gcDrainIdle<span class="token operator">|</span>gcDrainUntilPreempt<span class="token operator">|</span>gcDrainFlushBgCredit<span class="token punctuation">)</span>
            <span class="token punctuation">&#125;</span>
            <span class="token function">casgstatus</span><span class="token punctuation">(</span>gp<span class="token punctuation">,</span> _Gwaiting<span class="token punctuation">,</span> _Grunning<span class="token punctuation">)</span>
        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>

        <span class="token comment">// Account for time.</span>
        duration <span class="token operator">:=</span> <span class="token function">nanotime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> startTime
        <span class="token keyword">switch</span> pp<span class="token punctuation">.</span>gcMarkWorkerMode <span class="token punctuation">&#123;</span>
            <span class="token keyword">case</span> gcMarkWorkerDedicatedMode<span class="token punctuation">:</span>
                atomic<span class="token punctuation">.</span><span class="token function">Xaddint64</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>gcController<span class="token punctuation">.</span>dedicatedMarkTime<span class="token punctuation">,</span> duration<span class="token punctuation">)</span>
                atomic<span class="token punctuation">.</span><span class="token function">Xaddint64</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>gcController<span class="token punctuation">.</span>dedicatedMarkWorkersNeeded<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
            <span class="token keyword">case</span> gcMarkWorkerFractionalMode<span class="token punctuation">:</span>
                atomic<span class="token punctuation">.</span><span class="token function">Xaddint64</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>gcController<span class="token punctuation">.</span>fractionalMarkTime<span class="token punctuation">,</span> duration<span class="token punctuation">)</span>
                atomic<span class="token punctuation">.</span><span class="token function">Xaddint64</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pp<span class="token punctuation">.</span>gcFractionalMarkTime<span class="token punctuation">,</span> duration<span class="token punctuation">)</span>
            <span class="token keyword">case</span> gcMarkWorkerIdleMode<span class="token punctuation">:</span>
                atomic<span class="token punctuation">.</span><span class="token function">Xaddint64</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>gcController<span class="token punctuation">.</span>idleMarkTime<span class="token punctuation">,</span> duration<span class="token punctuation">)</span>
        <span class="token punctuation">&#125;</span>

        <span class="token comment">// Was this the last worker and did we run out</span>
        <span class="token comment">// of work?</span>
        incnwait <span class="token operator">:=</span> atomic<span class="token punctuation">.</span><span class="token function">Xadd</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>work<span class="token punctuation">.</span>nwait<span class="token punctuation">,</span> <span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> incnwait <span class="token operator">></span> work<span class="token punctuation">.</span>nproc <span class="token punctuation">&#123;</span>
            <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"runtime: p.gcMarkWorkerMode="</span><span class="token punctuation">,</span> pp<span class="token punctuation">.</span>gcMarkWorkerMode<span class="token punctuation">,</span>
                    <span class="token string">"work.nwait="</span><span class="token punctuation">,</span> incnwait<span class="token punctuation">,</span> <span class="token string">"work.nproc="</span><span class="token punctuation">,</span> work<span class="token punctuation">.</span>nproc<span class="token punctuation">)</span>
            <span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">"work.nwait > work.nproc"</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#125;</span>

        <span class="token comment">// We'll releasem after this point and thus this P may run</span>
        <span class="token comment">// something else. We must clear the worker mode to avoid</span>
        <span class="token comment">// attributing the mode to a different (non-worker) G in</span>
        <span class="token comment">// traceGoStart.</span>
        pp<span class="token punctuation">.</span>gcMarkWorkerMode <span class="token operator">=</span> gcMarkWorkerNotWorker

        <span class="token comment">// If this worker reached a background mark completion</span>
        <span class="token comment">// point, signal the main GC goroutine.</span>
        <span class="token keyword">if</span> incnwait <span class="token operator">==</span> work<span class="token punctuation">.</span>nproc <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">gcMarkWorkAvailable</span><span class="token punctuation">(</span><span class="token boolean">nil</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token comment">// We don't need the P-local buffers here, allow</span>
            <span class="token comment">// preemption becuse we may schedule like a regular</span>
            <span class="token comment">// goroutine in gcMarkDone (block on locks, etc).</span>
            <span class="token function">releasem</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>m<span class="token punctuation">.</span><span class="token function">ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            node<span class="token punctuation">.</span>m<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token boolean">nil</span><span class="token punctuation">)</span>

            <span class="token function">gcMarkDone</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>gcMarkWorker 的状态（dedicated, fraction）这个状态是绑定在 P 上，并不是 G 的状态。</li>
</ul>
<h3 id="GC-标记的几个工作模式"><a href="#GC-标记的几个工作模式" class="headerlink" title="GC 标记的几个工作模式"></a>GC 标记的几个工作模式</h3><ol>
<li>gcDrainFlushBgCredit: 把 bgMarkWorker 积累的 credit 刷新到全局的 gcController 中。</li>
<li>gcDrainFractional: self-preempt 表示在达到 fractional 后自动退出。</li>
<li>gcDrainUntilPreempt: 一直执行，直到被抢占。</li>
<li>gcDrainIdle: 一直执行，直到其他任务要做。</li>
</ol>
<h3 id="bitmap-与-ha-的映射关系（标记过程用到的位图）"><a href="#bitmap-与-ha-的映射关系（标记过程用到的位图）" class="headerlink" title="bitmap 与 ha 的映射关系（标记过程用到的位图）"></a>bitmap 与 ha 的映射关系（标记过程用到的位图）</h3><h4 id="bitmap-的使用"><a href="#bitmap-的使用" class="headerlink" title="bitmap 的使用"></a>bitmap 的使用</h4><p>两个比特表示一个字</p>
<p>ha 64 M，bitmap 2 M，bitmap 中的一个字节可以表示ha连续4个指针的内存大小。</p>
<p>0-4，1-5， 2-6， 3-7 </p>
<p>低位 bit 用于表示是否为指针，0 为非指针，1 为指针。</p>
<p>高位 bit 用于表示是否要继续扫描该对象中后续的内容，0 为不需要，1 为需要。</p>
<p><img src="https://blogstatic.haohtml.com/uploads/2021/04/d2b5ca33bd970f64a6301fa75ae2eb22-6.png?x-oss-process=image/format,webp" alt="img"></p>
<h4 id="heapBitsForAddr"><a href="#heapBitsForAddr" class="headerlink" title="heapBitsForAddr"></a>heapBitsForAddr</h4><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// heapBitsForAddr returns the heapBits for the address addr.</span>
<span class="token comment">// The caller must ensure addr is in an allocated span.</span>
<span class="token comment">// In particular, be careful not to point past the end of an object.</span>
<span class="token comment">//</span>
<span class="token comment">// nosplit because it is used during write barriers and must not be preempted.</span>
<span class="token comment">//go:nosplit</span>
<span class="token keyword">func</span> <span class="token function">heapBitsForAddr</span><span class="token punctuation">(</span>addr <span class="token builtin">uintptr</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>h heapBits<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 2 bits per word, 4 pairs per byte, and a mask is hard coded.</span>
    <span class="token comment">// 如注释所说，两个比特可以用来表示一个字的大小</span>
    arena <span class="token operator">:=</span> <span class="token function">arenaIndex</span><span class="token punctuation">(</span>addr<span class="token punctuation">)</span>
    ha <span class="token operator">:=</span> mheap_<span class="token punctuation">.</span>arenas<span class="token punctuation">[</span>arena<span class="token punctuation">.</span><span class="token function">l1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">[</span>arena<span class="token punctuation">.</span><span class="token function">l2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
    <span class="token comment">// The compiler uses a load for nil checking ha, but in this</span>
    <span class="token comment">// case we'll almost never hit that cache line again, so it</span>
    <span class="token comment">// makes more sense to do a value check.</span>
    <span class="token keyword">if</span> ha <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// addr is not in the heap. Return nil heapBits, which</span>
        <span class="token comment">// we expect to crash in the caller.</span>
        <span class="token keyword">return</span>
    <span class="token punctuation">&#125;</span>
    <span class="token comment">// 笔者理解：之所以要 *4，就是因为 bitmap 与 ha 的映射关系</span>
    <span class="token comment">// 一字节可以表示堆上 4 个连续的指针内存</span>
    h<span class="token punctuation">.</span>bitp <span class="token operator">=</span> <span class="token operator">&amp;</span>ha<span class="token punctuation">.</span>bitmap<span class="token punctuation">[</span><span class="token punctuation">(</span>addr<span class="token operator">/</span><span class="token punctuation">(</span>sys<span class="token punctuation">.</span>PtrSize<span class="token operator">*</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">%</span>heapArenaBitmapBytes<span class="token punctuation">]</span>
    <span class="token comment">// 笔者理解：shift 就像掩码一样，用来计算低位与高位比特的位置</span>
    <span class="token comment">// &amp;3 的运算也能说明这一点，&amp;3 的结果只能是 0 1 2 3，</span>
    <span class="token comment">// 这里就对应上了 8 比特的低四位</span>
    h<span class="token punctuation">.</span>shift <span class="token operator">=</span> <span class="token function">uint32</span><span class="token punctuation">(</span><span class="token punctuation">(</span>addr <span class="token operator">/</span> sys<span class="token punctuation">.</span>PtrSize<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">3</span><span class="token punctuation">)</span>
    <span class="token comment">// 记录当前 arena 的位置</span>
    h<span class="token punctuation">.</span>arena <span class="token operator">=</span> <span class="token function">uint32</span><span class="token punctuation">(</span>arena<span class="token punctuation">)</span>
    <span class="token comment">// 记录当前 arena 对应的 bitmap 中的最后一字节</span>
    h<span class="token punctuation">.</span>last <span class="token operator">=</span> <span class="token operator">&amp;</span>ha<span class="token punctuation">.</span>bitmap<span class="token punctuation">[</span><span class="token function">len</span><span class="token punctuation">(</span>ha<span class="token punctuation">.</span>bitmap<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>
    <span class="token keyword">return</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// next returns the heapBits describing the next pointer-sized word in memory.</span>
<span class="token comment">// That is, if h describes address p, h.next() describes p+ptrSize.</span>
<span class="token comment">// Note that next does not modify h. The caller must record the result.</span>
<span class="token comment">//</span>
<span class="token comment">// 如注释所描述的，next 函数，返回描述了在内存中下一个指针类型的word的heapBits</span>
<span class="token comment">// 如果 h 表示的是指针 p 的地址，那么 h.next() 表示的就是 p+ptrSize 的heapBits</span>
<span class="token comment">// nosplit because it is used during write barriers and must not be preempted.</span>
<span class="token comment">//go:nosplit</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>h heapBits<span class="token punctuation">)</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> heapBits <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> h<span class="token punctuation">.</span>shift <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token operator">*</span>heapBitsShift <span class="token punctuation">&#123;</span> <span class="token comment">// 在同一字节上扫描，四个连续的ptr还没扫描完</span>
        h<span class="token punctuation">.</span>shift <span class="token operator">+=</span> heapBitsShift
    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> h<span class="token punctuation">.</span>bitp <span class="token operator">!=</span> h<span class="token punctuation">.</span>last <span class="token punctuation">&#123;</span>	<span class="token comment">// 如果没扫描到该 bitmap 的最后一字节，那么扫描下一个byte</span>
        h<span class="token punctuation">.</span>bitp<span class="token punctuation">,</span> h<span class="token punctuation">.</span>shift <span class="token operator">=</span> <span class="token function">add1</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>bitp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span>
    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>	<span class="token comment">// 此时，当前已经扫描完了当前 ha 的所有内容，移动到下一个 ha 进行扫描</span>
        <span class="token comment">// Move to the next arena.</span>
        <span class="token keyword">return</span> h<span class="token punctuation">.</span><span class="token function">nextArena</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> h
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="gcDrain-标记过程"><a href="#gcDrain-标记过程" class="headerlink" title="gcDrain 标记过程"></a>gcDrain 标记过程</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// gcDrain 扫描 work buffer 中的根节点和对象，</span>
<span class="token comment">// gcDrain 会将队列中所有的对象标记为灰色。</span>
<span class="token comment">// gcDrain 可能在 GC 结束前返回。</span>
<span class="token comment">// gcDrain 的调用者负责平衡当前 P 与 其他 P 的标记工作。</span>
<span class="token comment">//go:nowritebarrier</span>
<span class="token keyword">func</span> <span class="token function">gcDrain</span><span class="token punctuation">(</span>gcw <span class="token operator">*</span>gcWork<span class="token punctuation">,</span> flags gcDrainFlags<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token operator">!</span>writeBarrier<span class="token punctuation">.</span>needed <span class="token punctuation">&#123;</span>
        <span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">"gcDrain phase incorrect"</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>

    gp <span class="token operator">:=</span> <span class="token function">getg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>m<span class="token punctuation">.</span>curg
    preemptible <span class="token operator">:=</span> flags<span class="token operator">&amp;</span>gcDrainUntilPreempt <span class="token operator">!=</span> <span class="token number">0</span>
    flushBgCredit <span class="token operator">:=</span> flags<span class="token operator">&amp;</span>gcDrainFlushBgCredit <span class="token operator">!=</span> <span class="token number">0</span>
    idle <span class="token operator">:=</span> flags<span class="token operator">&amp;</span>gcDrainIdle <span class="token operator">!=</span> <span class="token number">0</span>

    initScanWork <span class="token operator">:=</span> gcw<span class="token punctuation">.</span>scanWork

    <span class="token comment">// checkWork is the scan work before performing the next</span>
    <span class="token comment">// self-preempt check.</span>
    checkWork <span class="token operator">:=</span> <span class="token function">int64</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">63</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token keyword">var</span> check <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">bool</span>
    <span class="token keyword">if</span> flags<span class="token operator">&amp;</span><span class="token punctuation">(</span>gcDrainIdle<span class="token operator">|</span>gcDrainFractional<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>
        checkWork <span class="token operator">=</span> initScanWork <span class="token operator">+</span> drainCheckThreshold
        <span class="token keyword">if</span> idle <span class="token punctuation">&#123;</span>
            check <span class="token operator">=</span> pollWork
        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> flags<span class="token operator">&amp;</span>gcDrainFractional <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>
            check <span class="token operator">=</span> pollFractionalWorkerExit
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">// Drain root marking jobs.</span>
    <span class="token comment">// 判断当前标记的位置是否超出了总的标记数量</span>
    <span class="token keyword">if</span> work<span class="token punctuation">.</span>markrootNext <span class="token operator">&lt;</span> work<span class="token punctuation">.</span>markrootJobs <span class="token punctuation">&#123;</span>
        <span class="token comment">// Stop if we're preemptible or if someone wants to STW.</span>
        <span class="token keyword">for</span> <span class="token operator">!</span><span class="token punctuation">(</span>gp<span class="token punctuation">.</span>preempt <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>preemptible <span class="token operator">||</span> atomic<span class="token punctuation">.</span><span class="token function">Load</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sched<span class="token punctuation">.</span>gcwaiting<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            job <span class="token operator">:=</span> atomic<span class="token punctuation">.</span><span class="token function">Xadd</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>work<span class="token punctuation">.</span>markrootNext<span class="token punctuation">,</span> <span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>
            <span class="token keyword">if</span> job <span class="token operator">>=</span> work<span class="token punctuation">.</span>markrootJobs <span class="token punctuation">&#123;</span>
                <span class="token keyword">break</span>
            <span class="token punctuation">&#125;</span>
            <span class="token comment">// 对 job 索引位置的 root 进行标记工作</span>
            <span class="token function">markroot</span><span class="token punctuation">(</span>gcw<span class="token punctuation">,</span> job<span class="token punctuation">)</span>
            <span class="token comment">// 完成一个根的标记工作，就去检查</span>
            <span class="token comment">// TODO 是否达到了 fractional 或者 其他</span>
            <span class="token keyword">if</span> check <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token operator">&amp;&amp;</span> <span class="token function">check</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token keyword">goto</span> done
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">// Drain heap marking jobs.</span>
    <span class="token comment">// Stop if we're preemptible or if someone wants to STW.</span>
    <span class="token keyword">for</span> <span class="token operator">!</span><span class="token punctuation">(</span>gp<span class="token punctuation">.</span>preempt <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>preemptible <span class="token operator">||</span> atomic<span class="token punctuation">.</span><span class="token function">Load</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sched<span class="token punctuation">.</span>gcwaiting<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// Try to keep work available on the global queue. We used to</span>
        <span class="token comment">// check if there were waiting workers, but it's better to</span>
        <span class="token comment">// just keep work available than to make workers wait. In the</span>
        <span class="token comment">// worst case, we'll do O(log(_WorkbufSize)) unnecessary</span>
        <span class="token comment">// balances.</span>
        <span class="token comment">// 平衡标记工作，让它有活可干比让它等着要好</span>
        <span class="token keyword">if</span> work<span class="token punctuation">.</span>full <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>
            gcw<span class="token punctuation">.</span><span class="token function">balance</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#125;</span>
		
        <span class="token comment">// 从 gcw 队列中取值</span>
        b <span class="token operator">:=</span> gcw<span class="token punctuation">.</span><span class="token function">tryGetFast</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> b <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>
            b <span class="token operator">=</span> gcw<span class="token punctuation">.</span><span class="token function">tryGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token keyword">if</span> b <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>
                <span class="token comment">// Flush the write barrier</span>
                <span class="token comment">// buffer; this may create</span>
                <span class="token comment">// more work.</span>
                如果说 wbuf 中都没有，将
                <span class="token function">wbBufFlush</span><span class="token punctuation">(</span><span class="token boolean">nil</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
                b <span class="token operator">=</span> gcw<span class="token punctuation">.</span><span class="token function">tryGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">if</span> b <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>
            <span class="token comment">// Unable to get work.</span>
            <span class="token keyword">break</span>
        <span class="token punctuation">&#125;</span>
        <span class="token function">scanobject</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> gcw<span class="token punctuation">)</span>

        <span class="token comment">// Flush background scan work credit to the global</span>
        <span class="token comment">// account if we've accumulated enough locally so</span>
        <span class="token comment">// mutator assists can draw on it.</span>
        <span class="token keyword">if</span> gcw<span class="token punctuation">.</span>scanWork <span class="token operator">>=</span> gcCreditSlack <span class="token punctuation">&#123;</span>
            atomic<span class="token punctuation">.</span><span class="token function">Xaddint64</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>gcController<span class="token punctuation">.</span>scanWork<span class="token punctuation">,</span> gcw<span class="token punctuation">.</span>scanWork<span class="token punctuation">)</span>
            <span class="token keyword">if</span> flushBgCredit <span class="token punctuation">&#123;</span>
                <span class="token function">gcFlushBgCredit</span><span class="token punctuation">(</span>gcw<span class="token punctuation">.</span>scanWork <span class="token operator">-</span> initScanWork<span class="token punctuation">)</span>
                initScanWork <span class="token operator">=</span> <span class="token number">0</span>
            <span class="token punctuation">&#125;</span>
            checkWork <span class="token operator">-=</span> gcw<span class="token punctuation">.</span>scanWork
            gcw<span class="token punctuation">.</span>scanWork <span class="token operator">=</span> <span class="token number">0</span>

            <span class="token keyword">if</span> checkWork <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>
                checkWork <span class="token operator">+=</span> drainCheckThreshold
                <span class="token keyword">if</span> check <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token operator">&amp;&amp;</span> <span class="token function">check</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                    <span class="token keyword">break</span>
                <span class="token punctuation">&#125;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>

    done<span class="token punctuation">:</span>
    <span class="token comment">// Flush remaining scan work credit.</span>
    <span class="token keyword">if</span> gcw<span class="token punctuation">.</span>scanWork <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>
        atomic<span class="token punctuation">.</span><span class="token function">Xaddint64</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>gcController<span class="token punctuation">.</span>scanWork<span class="token punctuation">,</span> gcw<span class="token punctuation">.</span>scanWork<span class="token punctuation">)</span>
        <span class="token keyword">if</span> flushBgCredit <span class="token punctuation">&#123;</span>
            <span class="token function">gcFlushBgCredit</span><span class="token punctuation">(</span>gcw<span class="token punctuation">.</span>scanWork <span class="token operator">-</span> initScanWork<span class="token punctuation">)</span>
        <span class="token punctuation">&#125;</span>
        gcw<span class="token punctuation">.</span>scanWork <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="标记工作的平衡"><a href="#标记工作的平衡" class="headerlink" title="标记工作的平衡"></a>标记工作的平衡</h4><h5 id="balance"><a href="#balance" class="headerlink" title="balance"></a>balance</h5><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// balance moves some work that's cached in this gcWork back on the</span>
<span class="token comment">// global queue.</span>
<span class="token comment">// 将缓存在 P gcw 上的标记任务，适当的移动到全局queue中</span>
<span class="token comment">//go:nowritebarrierrec</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>w <span class="token operator">*</span>gcWork<span class="token punctuation">)</span> <span class="token function">balance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 如果 P 的本地 wbf 没有标记任务，直接返回</span>
    <span class="token keyword">if</span> w<span class="token punctuation">.</span>wbuf1 <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span>
    <span class="token punctuation">&#125;</span>
    <span class="token comment">/*
   	1.先处理 wbuf2 中的数据，如果有，将数据放入到
   	全局 work full 队列中
   	2.查看 wbuf1 中对象数量，超过四个，执行 handoff
   */</span>
    <span class="token keyword">if</span> wbuf <span class="token operator">:=</span> w<span class="token punctuation">.</span>wbuf2<span class="token punctuation">;</span> wbuf<span class="token punctuation">.</span>nobj <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>
        <span class="token function">putfull</span><span class="token punctuation">(</span>wbuf<span class="token punctuation">)</span>
        w<span class="token punctuation">.</span>flushedWork <span class="token operator">=</span> <span class="token boolean">true</span>
        w<span class="token punctuation">.</span>wbuf2 <span class="token operator">=</span> <span class="token function">getempty</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> wbuf <span class="token operator">:=</span> w<span class="token punctuation">.</span>wbuf1<span class="token punctuation">;</span> wbuf<span class="token punctuation">.</span>nobj <span class="token operator">></span> <span class="token number">4</span> <span class="token punctuation">&#123;</span>
        w<span class="token punctuation">.</span>wbuf1 <span class="token operator">=</span> <span class="token function">handoff</span><span class="token punctuation">(</span>wbuf<span class="token punctuation">)</span>
        w<span class="token punctuation">.</span>flushedWork <span class="token operator">=</span> <span class="token boolean">true</span> <span class="token comment">// handoff did putfull</span>
    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span>
    <span class="token punctuation">&#125;</span>
    <span class="token comment">// We flushed a buffer to the full list, so wake a worker.</span>
    <span class="token keyword">if</span> gcphase <span class="token operator">==</span> _GCmark <span class="token punctuation">&#123;</span>
        gcController<span class="token punctuation">.</span><span class="token function">enlistWorker</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="enlistWorker"><a href="#enlistWorker" class="headerlink" title="enlistWorker"></a>enlistWorker</h5><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// enlistWorker encourages another dedicated mark worker to start on</span>
<span class="token comment">// another P if there are spare worker slots. It is used by putfull</span>
<span class="token comment">// when more work is made available.</span>
<span class="token comment">//</span>
<span class="token comment">//go:nowritebarrier</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>c <span class="token operator">*</span>gcControllerState<span class="token punctuation">)</span> <span class="token function">enlistWorker</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// If there are idle Ps, wake one so it will run an idle worker.</span>
    <span class="token comment">// NOTE: This is suspected of causing deadlocks. See golang.org/issue/19112.</span>
    <span class="token comment">//</span>
    <span class="token comment">// if atomic.Load(&amp;sched.npidle) != 0 &amp;&amp; atomic.Load(&amp;sched.nmspinning) == 0 &#123;</span>
    <span class="token comment">//    wakep()</span>
    <span class="token comment">//    return</span>
    <span class="token comment">// &#125;</span>

    <span class="token comment">// There are no idle Ps. If we need more dedicated workers,</span>
    <span class="token comment">// try to preempt a running P so it will switch to a worker.</span>
    <span class="token keyword">if</span> c<span class="token punctuation">.</span>dedicatedMarkWorkersNeeded <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span>
    <span class="token punctuation">&#125;</span>
    <span class="token comment">// Pick a random other P to preempt.</span>
    <span class="token keyword">if</span> gomaxprocs <span class="token operator">&lt;=</span> <span class="token number">1</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span>
    <span class="token punctuation">&#125;</span>
    gp <span class="token operator">:=</span> <span class="token function">getg</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> gp <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token operator">||</span> gp<span class="token punctuation">.</span>m <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token operator">||</span> gp<span class="token punctuation">.</span>m<span class="token punctuation">.</span>p <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span>
    <span class="token punctuation">&#125;</span>
    myID <span class="token operator">:=</span> gp<span class="token punctuation">.</span>m<span class="token punctuation">.</span>p<span class="token punctuation">.</span><span class="token function">ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>id
    <span class="token keyword">for</span> tries <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> tries <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> tries<span class="token operator">++</span> <span class="token punctuation">&#123;</span>
        id <span class="token operator">:=</span> <span class="token function">int32</span><span class="token punctuation">(</span><span class="token function">fastrandn</span><span class="token punctuation">(</span><span class="token function">uint32</span><span class="token punctuation">(</span>gomaxprocs <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> id <span class="token operator">>=</span> myID <span class="token punctuation">&#123;</span>
            id<span class="token operator">++</span>
        <span class="token punctuation">&#125;</span>
        p <span class="token operator">:=</span> allp<span class="token punctuation">[</span>id<span class="token punctuation">]</span>
        <span class="token keyword">if</span> p<span class="token punctuation">.</span>status <span class="token operator">!=</span> _Prunning <span class="token punctuation">&#123;</span>
            <span class="token keyword">continue</span>
        <span class="token punctuation">&#125;</span>
        <span class="token comment">// 执行抢占</span>
        <span class="token keyword">if</span> <span class="token function">preemptone</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">return</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>​    不知道你们想没想过这样一个问题，通过 preemptone 函数进行抢占，是怎么做到去启动一个 gcMarkWorker 的？</p>
<p>​    如果你没想到的话，给你一点提示，和调度循环相关。</p>
<h5 id="handoff"><a href="#handoff" class="headerlink" title="handoff"></a>handoff</h5><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// 在 wbuf 中对象数量大于 4 时，将前一半放入到全局 work full 队列中</span>
<span class="token comment">//go:nowritebarrier</span>
<span class="token keyword">func</span> <span class="token function">handoff</span><span class="token punctuation">(</span>b <span class="token operator">*</span>workbuf<span class="token punctuation">)</span> <span class="token operator">*</span>workbuf <span class="token punctuation">&#123;</span>
    <span class="token comment">// Make new buffer with half of b's pointers.</span>
    b1 <span class="token operator">:=</span> <span class="token function">getempty</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    n <span class="token operator">:=</span> b<span class="token punctuation">.</span>nobj <span class="token operator">/</span> <span class="token number">2</span>
    b<span class="token punctuation">.</span>nobj <span class="token operator">-=</span> n
    b1<span class="token punctuation">.</span>nobj <span class="token operator">=</span> n
    <span class="token comment">// 通过获取一个新的 empty workbuf</span>
    <span class="token comment">// 将前一半放进去</span>
    <span class="token function">memmove</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>b1<span class="token punctuation">.</span>obj<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>b<span class="token punctuation">.</span>obj<span class="token punctuation">[</span>b<span class="token punctuation">.</span>nobj<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token operator">*</span>unsafe<span class="token punctuation">.</span><span class="token function">Sizeof</span><span class="token punctuation">(</span>b1<span class="token punctuation">.</span>obj<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

    <span class="token comment">// Put b on full list - let first half of b get stolen.</span>
    <span class="token function">putfull</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>
    <span class="token keyword">return</span> b1
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="GC-过程中-P-的-gcw-队列"><a href="#GC-过程中-P-的-gcw-队列" class="headerlink" title="GC 过程中 P 的 gcw 队列"></a>GC 过程中 P 的 gcw 队列</h4><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> P <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
    <span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">)</span>
    <span class="token comment">// gcw is this P's GC work buffer cache. The work buffer is</span>
    <span class="token comment">// filled by write barriers, drained by mutator assists, and</span>
    <span class="token comment">// disposed on certain GC state transitions.</span>
    gcw gcWork
    <span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>以下是 Go 官方对 gcw 的描述：</p>
<p>为灰色指针对象实现了一个生产者/消费者模型。对象被标记为灰色后，放入到队列中。对象被标记为黑色后，会在队列中移除。</p>
<p>写屏障，根节点扫描，栈扫描和对象扫描过程会产生灰色对象。scanning 过程会消费灰色对象的指针并且有可能产生新的灰色对象指针。</p>
<p>gcWork 为垃圾回收器提供了一个生产和消费的接口。</p>
<p>可以在 stack 上这样使用 gcWork：</p>
<ul>
<li>调用 gcw.Put() 进行生产，调用 gcw.tryGet() 进行消费。</li>
</ul>
<p>重要的是，在 mark phase 使用 gcWork 可以阻止垃圾回收器从 transitioning 转变为 mark termination 因为 gcWork 可能在本地保存 GC work buffers。这可以通过禁用抢占来完成。</p>
<h5 id="wbuf1-和-wbuf2"><a href="#wbuf1-和-wbuf2" class="headerlink" title="wbuf1 和 wbuf2"></a>wbuf1 和 wbuf2</h5><p>可以将 wbuf1 和 wbuf2 想象成一块栈空间，然后这俩轮流使用。</p>
<p>当我们弹出队列中最后一个指针时，我们通过引入一个新的缓冲区并丢弃一个空缓冲区（交换这两个缓冲区），然后将 stack 向上移动一个新 buffer。 当我们将buffers都填满了，我们通过引入一个新的空缓冲区并丢弃那个满的缓冲区，然后将stack向下移动一个新 buffer。</p>
<p>这样我们就有了一个缓冲区的滞后值，它可以将获取或放置工作缓冲区的成本分摊到至少一个工作缓冲区上，并减少全局工作列表上的争用。</p>
<p>wbuf1 永远都是我们正在操作的那个 buffer，wbuf2 是接下来要丢弃的缓冲区。</p>
<p>总结：</p>
<p>wbuf1 和 wbuf2 都是用来存储灰色指针的，wbuf1 是我们真正操作的那个队列，入队出队操作的都是它，wbuf2 起到的是替换作用，当 wbuf1 空了，替换 wbuf2，当 wbuf1 满了，替换 wbuf2。</p>
<h5 id="work-full-和-work-empty"><a href="#work-full-和-work-empty" class="headerlink" title="work.full 和 work.empty"></a>work.full 和 work.empty</h5><p>全局 work 中有两个队列，full 和 empty，灰色对象入队过程：</p>
<p>fastPath: 检查 wbuf1 是否为空，是否满了，是就返回；都不是，将灰色对象入队。<br>slowPath：检查 wbuf1 是否为 nil，为 nil，执行初始化。否则，判断是否满了，满了，交换 wbuf1 和 wbuf2，再次判断 wbuf1 是否满了，满了加入到全局 full 队列中，然后从 empty 队列获取一个空的并赋值给 wbuf1，最后把这个灰色对象入队。</p>
<h4 id="GC-过程中负责标记的函数"><a href="#GC-过程中负责标记的函数" class="headerlink" title="GC 过程中负责标记的函数"></a>GC 过程中负责标记的函数</h4><h5 id="markroot"><a href="#markroot" class="headerlink" title="markroot"></a>markroot</h5><p>markroot 主要是根据不同的 i 来定位要扫描哪些区域，当 i == 0 ，i == 1 时，对应到以下两种情况，具体的含义暂时还不清晰。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// TODO 了解这两种分别是什么</span>
<span class="token keyword">case</span> i <span class="token operator">==</span> fixedRootFinalizers<span class="token punctuation">:</span>
   <span class="token keyword">for</span> fb <span class="token operator">:=</span> allfin<span class="token punctuation">;</span> fb <span class="token operator">!=</span> <span class="token boolean">nil</span><span class="token punctuation">;</span> fb <span class="token operator">=</span> fb<span class="token punctuation">.</span>alllink <span class="token punctuation">&#123;</span>
      cnt <span class="token operator">:=</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>atomic<span class="token punctuation">.</span><span class="token function">Load</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>fb<span class="token punctuation">.</span>cnt<span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token function">scanblock</span><span class="token punctuation">(</span><span class="token function">uintptr</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>fb<span class="token punctuation">.</span>fin<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> cnt<span class="token operator">*</span>unsafe<span class="token punctuation">.</span><span class="token function">Sizeof</span><span class="token punctuation">(</span>fb<span class="token punctuation">.</span>fin<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>finptrmask<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> gcw<span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">)</span>
   <span class="token punctuation">&#125;</span>

<span class="token keyword">case</span> i <span class="token operator">==</span> fixedRootFreeGStacks<span class="token punctuation">:</span>
   <span class="token comment">// Switch to the system stack so we can call</span>
   <span class="token comment">// stackfree.</span>
   <span class="token function">systemstack</span><span class="token punctuation">(</span>markrootFreeGStacks<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="scanobject"><a href="#scanobject" class="headerlink" title="scanobject"></a>scanobject</h5><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// scanobject scans the object starting at b, adding pointers to gcw.</span>
<span class="token comment">// b must point to the beginning of a heap object or an oblet.</span>
<span class="token comment">// scanobject consults the GC bitmap for the pointer mask and the</span>
<span class="token comment">// spans for the size of the object.</span>
<span class="token comment">//</span>
<span class="token comment">// 如注释所写，scanobject 扫描从 b 为起始地址的对象，并添加指针到 gcw 队列中。</span>
<span class="token comment">// b 必须指向堆对象的起始地址，或者一个 oblet。</span>
<span class="token comment">//go:nowritebarrier</span>
<span class="token keyword">func</span> <span class="token function">scanobject</span><span class="token punctuation">(</span>b <span class="token builtin">uintptr</span><span class="token punctuation">,</span> gcw <span class="token operator">*</span>gcWork<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// Find the bits for b and the size of the object at b.</span>
    <span class="token comment">//</span>
    <span class="token comment">// b is either the beginning of an object, in which case this</span>
    <span class="token comment">// is the size of the object to scan, or it points to an</span>
    <span class="token comment">// oblet, in which case we compute the size to scan below.</span>
    <span class="token comment">// 这个函数前边已经详细的分析过了，没啥好说的</span>
    hbits <span class="token operator">:=</span> <span class="token function">heapBitsForAddr</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>
    <span class="token comment">// 找到指针 b 对应的 mspan</span>
    s <span class="token operator">:=</span> <span class="token function">spanOfUnchecked</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>
    <span class="token comment">// s.elemsize 表示的是一个 object 的大小</span>
    n <span class="token operator">:=</span> s<span class="token punctuation">.</span>elemsize
    <span class="token keyword">if</span> n <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>
        <span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">"scanobject n == 0"</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>
    <span class="token comment">/*
		这里对大对象（这里的大对象与内存分配的有些许差异
		内存分配大对象指的是大于32KB的，这里指的是大于 128KB的）
		进行了进一步的区分
		maxobletBytes = 128 &lt;&lt; 10 = 128 KB
		意味着，当前 obj 的大小超过了 128 KB
		要进行一些优化操作
	*/</span>
    <span class="token keyword">if</span> n <span class="token operator">></span> maxObletBytes <span class="token punctuation">&#123;</span>
        <span class="token comment">// Large object. Break into oblets for better</span>
        <span class="token comment">// parallelism and lower latency.</span>
        <span class="token keyword">if</span> b <span class="token operator">==</span> s<span class="token punctuation">.</span><span class="token function">base</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token comment">// It's possible this is a noscan object (not</span>
            <span class="token comment">// from greyobject, but from other code</span>
            <span class="token comment">// paths), in which case we must *not* enqueue</span>
            <span class="token comment">// oblets since their bitmaps will be</span>
            <span class="token comment">// uninitialized.</span>
            <span class="token keyword">if</span> s<span class="token punctuation">.</span>spanclass<span class="token punctuation">.</span><span class="token function">noscan</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token comment">// Bypass the whole scan.</span>
                gcw<span class="token punctuation">.</span>bytesMarked <span class="token operator">+=</span> <span class="token function">uint64</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span>
                <span class="token keyword">return</span>
            <span class="token punctuation">&#125;</span>

            <span class="token comment">// Enqueue the other oblets to scan later.</span>
            <span class="token comment">// Some oblets may be in b's scalar tail, but</span>
            <span class="token comment">// these will be marked as "no more pointers",</span>
            <span class="token comment">// so we'll drop out immediately when we go to</span>
            <span class="token comment">// scan those.</span>
            <span class="token keyword">for</span> oblet <span class="token operator">:=</span> b <span class="token operator">+</span> maxObletBytes<span class="token punctuation">;</span> oblet <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">base</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span>s<span class="token punctuation">.</span>elemsize<span class="token punctuation">;</span> oblet <span class="token operator">+=</span> maxObletBytes <span class="token punctuation">&#123;</span>
                <span class="token keyword">if</span> <span class="token operator">!</span>gcw<span class="token punctuation">.</span><span class="token function">putFast</span><span class="token punctuation">(</span>oblet<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                    gcw<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>oblet<span class="token punctuation">)</span>
                <span class="token punctuation">&#125;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>

        <span class="token comment">// Compute the size of the oblet. Since this object</span>
        <span class="token comment">// must be a large object, s.base() is the beginning</span>
        <span class="token comment">// of the object.</span>
        n <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">base</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> s<span class="token punctuation">.</span>elemsize <span class="token operator">-</span> b
        <span class="token keyword">if</span> n <span class="token operator">></span> maxObletBytes <span class="token punctuation">&#123;</span>
            n <span class="token operator">=</span> maxObletBytes
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">var</span> i <span class="token builtin">uintptr</span>
    <span class="token comment">// i &lt; n 说明 mspan 中，只对当前这个对象进行扫描</span>
    <span class="token comment">// 执行完一次 for 循环，并不意味着扫描完当前这个对象了</span>
    <span class="token comment">// 只是检查了当前两个比特对应的一个字</span>
    <span class="token comment">// 除非当前这个对象是不需要扫描的即，bits&amp;bitScan == 0</span>
    <span class="token keyword">for</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token punctuation">,</span> hbits <span class="token operator">=</span> i<span class="token operator">+</span>sys<span class="token punctuation">.</span>PtrSize<span class="token punctuation">,</span> hbits<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// Load bits once. See CL 22712 and issue 16973 for discussion.</span>
        bits <span class="token operator">:=</span> hbits<span class="token punctuation">.</span><span class="token function">bits</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token comment">// 这里的两个 if 判断就好像两个卡尺</span>
        <span class="token comment">// 分别对高位和低位进行检查</span>
        <span class="token keyword">if</span> bits<span class="token operator">&amp;</span>bitScan <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">break</span> <span class="token comment">// no more pointers in this object</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">if</span> bits<span class="token operator">&amp;</span>bitPointer <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">continue</span> <span class="token comment">// not a pointer</span>
        <span class="token punctuation">&#125;</span>

        <span class="token comment">// Work here is duplicated in scanblock and above.</span>
        <span class="token comment">// If you make changes here, make changes there too.</span>
        <span class="token comment">/*
			设 fakeObj = (*uintptr)(unsafe.Pointer(b + i))
			对 fakeObj 解引用 --> *fakeObj
            	1.解出来结果 != 0，说明是一个指针
            	2.解出来结果 == 0，说明结果为 nil
        */</span>
        obj <span class="token operator">:=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token builtin">uintptr</span><span class="token punctuation">)</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>b <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span>


        <span class="token comment">// At this point we have extracted the next potential pointer.</span>
        <span class="token comment">// Quickly filter out nil and pointers back to the current object.</span>
        <span class="token comment">// 如果 obj 是一个指针，并且指向的不是当前 object</span>
        <span class="token comment">// 笔者理解：之所以要过滤掉当前的 object，</span>
        <span class="token comment">// 是因为当前这个 object 就是从 gcw 队列中取出来的</span>
        <span class="token comment">// 所以也就不需要再对该 obj 进行标记（入队）</span>
        <span class="token keyword">if</span> obj <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> obj<span class="token operator">-</span>b <span class="token operator">>=</span> n <span class="token punctuation">&#123;</span>
            <span class="token comment">// Test if obj points into the Go heap and, if so,</span>
            <span class="token comment">// mark the object.</span>
            <span class="token comment">// 检查 obj 是否指向了 Go 的堆，如果是，对这个 obj 进行标记</span>
            <span class="token comment">//</span>
            <span class="token comment">// Note that it's possible for findObject to</span>
            <span class="token comment">// fail if obj points to a just-allocated heap</span>
            <span class="token comment">// object because of a race with growing the</span>
            <span class="token comment">// heap. In this case, we know the object was</span>
            <span class="token comment">// just allocated and hence will be marked by</span>
            <span class="token comment">// allocation itself.</span>
            <span class="token keyword">if</span> obj<span class="token punctuation">,</span> span<span class="token punctuation">,</span> objIndex <span class="token operator">:=</span> <span class="token function">findObject</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> b<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span> obj <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>
                <span class="token function">greyobject</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> b<span class="token punctuation">,</span> i<span class="token punctuation">,</span> span<span class="token punctuation">,</span> gcw<span class="token punctuation">,</span> objIndex<span class="token punctuation">)</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token comment">// 记录刚刚被扫描的 obj 大小</span>
    gcw<span class="token punctuation">.</span>bytesMarked <span class="token operator">+=</span> <span class="token function">uint64</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span>
    <span class="token comment">// 积累 credit，到了 2000 就更新到全局 gcCrontroller 中</span>
    gcw<span class="token punctuation">.</span>scanWork <span class="token operator">+=</span> <span class="token function">int64</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="findObject"><a href="#findObject" class="headerlink" title="findObject"></a>findObject</h5><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">/*
	参数解释：
		refBase, refOff 主要 panic 用
	返回值解释：
		base: 表示 p 指针所在对象，在堆中的起始地址
		s: 表示 p 指针所在的 mspan
		objIndex: 表示包含 p 指针的对象在 mspan 中的位置
*/</span>
<span class="token comment">//go:nosplit</span>
<span class="token keyword">func</span> <span class="token function">findObject</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> refBase<span class="token punctuation">,</span> refOff <span class="token builtin">uintptr</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>base <span class="token builtin">uintptr</span><span class="token punctuation">,</span> s <span class="token operator">*</span>mspan<span class="token punctuation">,</span> objIndex <span class="token builtin">uintptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    s <span class="token operator">=</span> <span class="token function">spanOf</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span>

    <span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">)</span> <span class="token comment">// 省略检查代码</span>
    
    objIndex <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">objIndex</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span>
    base <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">base</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> objIndex<span class="token operator">*</span>s<span class="token punctuation">.</span>elemsize
    <span class="token keyword">return</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="markrootBlock"><a href="#markrootBlock" class="headerlink" title="markrootBlock"></a>markrootBlock</h5><h5 id="markrootFreeGStacks"><a href="#markrootFreeGStacks" class="headerlink" title="markrootFreeGStacks"></a>markrootFreeGStacks</h5><h5 id="markrootSpans"><a href="#markrootSpans" class="headerlink" title="markrootSpans"></a>markrootSpans</h5><h5 id="scanstack"><a href="#scanstack" class="headerlink" title="scanstack"></a>scanstack</h5><p>扫描 goroutine 栈</p>
<h5 id="scanblock"><a href="#scanblock" class="headerlink" title="scanblock"></a>scanblock</h5><h5 id="gcmarknewobject"><a href="#gcmarknewobject" class="headerlink" title="gcmarknewobject"></a>gcmarknewobject</h5><h5 id="gcMarkTinyAllocs"><a href="#gcMarkTinyAllocs" class="headerlink" title="gcMarkTinyAllocs"></a>gcMarkTinyAllocs</h5><h2 id="gcMarkDone"><a href="#gcMarkDone" class="headerlink" title="gcMarkDone"></a>gcMarkDone</h2><p>gcMarkDone 是一个过度的函数，是由 _GCMark 到 _GCMarkTermination 状态转换前要做的一些处理。此外，gcMarkDone 中会处理 writebarrier buffer，如果这时候将数据写入到了全局的标记队列中，那还需要继续执行标记工作。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// 如果所有的可达对象都已经被标记了（意味着没有任何灰色对象并且将来也不会有）</span>
<span class="token comment">// gcMarkDone 将 GC 的状态由 mark 转为 mark termination。</span>
<span class="token comment">// 否则（还有没被标记的灰色对象），gcMarkDone 会将所有本地队列中的对象推到全局工作队列中，</span>
<span class="token comment">// 这样其他的 worker 就可以知道还有活要干。</span>
<span class="token comment">// </span>
<span class="token comment">// This should be called when all local mark work has been drained and</span>
<span class="token comment">// there are no remaining workers. Specifically, when</span>
<span class="token comment">//</span>
<span class="token comment">//   work.nwait == work.nproc &amp;&amp; !gcMarkWorkAvailable(p)</span>
<span class="token comment">//</span>
<span class="token comment">// 调用 gcMarkDone 的上下文一定是可抢占的。</span>
<span class="token comment">//</span>
<span class="token comment">// Flushing local work is important because idle Ps may have local</span>
<span class="token comment">// work queued. This is the only way to make that work visible and</span>
<span class="token comment">// drive GC to completion.</span>
<span class="token comment">// </span>
<span class="token comment">// 刷新 P 的本地队列到全局队列中是十分重要的，因为 idle 状态的 P 可能在本地</span>
<span class="token comment">// 队列中有缓存。gcMarkDone 中是唯一的方式让这些本地队列中的对象可以被看到，</span>
<span class="token comment">// 促使 GC 完成。</span>
<span class="token comment">//</span>
<span class="token comment">// It is explicitly okay to have write barriers in this function. If</span>
<span class="token comment">// it does transition to mark termination, then all reachable objects</span>
<span class="token comment">// have been marked, so the write barrier cannot shade any more</span>
<span class="token comment">// objects.</span>
<span class="token keyword">func</span> <span class="token function">gcMarkDone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// Ensure only one thread is running the ragged barrier at a</span>
    <span class="token comment">// time.</span>
    <span class="token function">semacquire</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>work<span class="token punctuation">.</span>markDoneSema<span class="token punctuation">)</span>

    top<span class="token punctuation">:</span>
    <span class="token comment">// Re-check transition condition under transition lock.</span>
    <span class="token comment">//</span>
    <span class="token comment">// It's critical that this checks the global work queues are</span>
    <span class="token comment">// empty before performing the ragged barrier. Otherwise,</span>
    <span class="token comment">// there could be global work that a P could take after the P</span>
    <span class="token comment">// has passed the ragged barrier.</span>
    <span class="token keyword">if</span> <span class="token operator">!</span><span class="token punctuation">(</span>gcphase <span class="token operator">==</span> _GCmark <span class="token operator">&amp;&amp;</span> work<span class="token punctuation">.</span>nwait <span class="token operator">==</span> work<span class="token punctuation">.</span>nproc <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">gcMarkWorkAvailable</span><span class="token punctuation">(</span><span class="token boolean">nil</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">semrelease</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>work<span class="token punctuation">.</span>markDoneSema<span class="token punctuation">)</span>
        <span class="token keyword">return</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">// forEachP needs worldsema to execute, and we'll need it to</span>
    <span class="token comment">// stop the world later, so acquire worldsema now.</span>
    <span class="token function">semacquire</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>worldsema<span class="token punctuation">)</span>

    <span class="token comment">// Flush all local buffers and collect flushedWork flags.</span>
    gcMarkDoneFlushed <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token function">systemstack</span><span class="token punctuation">(</span><span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        gp <span class="token operator">:=</span> <span class="token function">getg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>m<span class="token punctuation">.</span>curg
        <span class="token comment">// Mark the user stack as preemptible so that it may be scanned.</span>
        <span class="token comment">// Otherwise, our attempt to force all P's to a safepoint could</span>
        <span class="token comment">// result in a deadlock as we attempt to preempt a worker that's</span>
        <span class="token comment">// trying to preempt us (e.g. for a stack scan).</span>
        <span class="token comment">/*
        	标记当前 gp 是可抢占的，目的是为了能够被扫描。当我们强制所有的 P 到达
        	一个 safepoint 可能会导致死锁。比如，我们想抢占一个 worker，同时
        	那个worker也在对我们执行抢占（对我们进行栈扫描）。
        */</span>
        <span class="token function">casgstatus</span><span class="token punctuation">(</span>gp<span class="token punctuation">,</span> _Grunning<span class="token punctuation">,</span> _Gwaiting<span class="token punctuation">)</span>
        <span class="token function">forEachP</span><span class="token punctuation">(</span><span class="token keyword">func</span><span class="token punctuation">(</span>_p_ <span class="token operator">*</span>p<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token comment">// Flush the write barrier buffer, since this may add</span>
            <span class="token comment">// work to the gcWork.</span>
            <span class="token comment">/*
	            1.获取当前 P 的 writebarrier buffer 中的内容
	            2.遍历buffer中的对象，标灰，标记 span
	            3.将灰色对象刷到全局的 work queue 中
	            4.清空 P 的 write barrier buffer
            */</span>
            <span class="token function">wbBufFlush1</span><span class="token punctuation">(</span>_p_<span class="token punctuation">)</span>

            <span class="token comment">// Flush the gcWork, since this may create global work</span>
            <span class="token comment">// and set the flushedWork flag.</span>
            <span class="token comment">//</span>
            <span class="token comment">// TODO(austin): Break up these workbufs to</span>
            <span class="token comment">// better distribute work.</span>
            <span class="token comment">// 这里处理的是 P 的本地队列</span>
            <span class="token comment">// 将本地队列中的内容刷到全局队列中</span>
            _p_<span class="token punctuation">.</span>gcw<span class="token punctuation">.</span><span class="token function">dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token comment">// Collect the flushedWork flag.</span>
            <span class="token comment">// flushedWork 记录当前 P 是否又将对象放入到全局workqueue</span>
            <span class="token keyword">if</span> _p_<span class="token punctuation">.</span>gcw<span class="token punctuation">.</span>flushedWork <span class="token punctuation">&#123;</span>
                atomic<span class="token punctuation">.</span><span class="token function">Xadd</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>gcMarkDoneFlushed<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
                _p_<span class="token punctuation">.</span>gcw<span class="token punctuation">.</span>flushedWork <span class="token operator">=</span> <span class="token boolean">false</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
        <span class="token function">casgstatus</span><span class="token punctuation">(</span>gp<span class="token punctuation">,</span> _Gwaiting<span class="token punctuation">,</span> _Grunning<span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>

    <span class="token comment">// 如果有 P 往全局队列放入对象，那还得将那些内容进行标记</span>
    <span class="token keyword">if</span> gcMarkDoneFlushed <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// More grey objects were discovered since the</span>
        <span class="token comment">// previous termination check, so there may be more</span>
        <span class="token comment">// work to do. Keep going. It's possible the</span>
        <span class="token comment">// transition condition became true again during the</span>
        <span class="token comment">// ragged barrier, so re-check it.</span>
        <span class="token function">semrelease</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>worldsema<span class="token punctuation">)</span>
        <span class="token keyword">goto</span> top
    <span class="token punctuation">&#125;</span>

    <span class="token comment">// There was no global work, no local work, and no Ps</span>
    <span class="token comment">// communicated work since we took markDoneSema. Therefore</span>
    <span class="token comment">// there are no grey objects and no more objects can be</span>
    <span class="token comment">// shaded. Transition to mark termination.</span>
    <span class="token comment">// 走到这一步意味着可以将状态转变为 markTermination</span>
    now <span class="token operator">:=</span> <span class="token function">nanotime</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    work<span class="token punctuation">.</span>tMarkTerm <span class="token operator">=</span> now
    work<span class="token punctuation">.</span>pauseStart <span class="token operator">=</span> now
    <span class="token function">getg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>m<span class="token punctuation">.</span>preemptoff <span class="token operator">=</span> <span class="token string">"gcing"</span>
    <span class="token keyword">if</span> trace<span class="token punctuation">.</span>enabled <span class="token punctuation">&#123;</span>
        <span class="token function">traceGCSTWStart</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">systemstack</span><span class="token punctuation">(</span>stopTheWorldWithSema<span class="token punctuation">)</span>
    <span class="token comment">// The gcphase is _GCmark, it will transition to _GCmarktermination</span>
    <span class="token comment">// below. The important thing is that the wb remains active until</span>
    <span class="token comment">// all marking is complete. This includes writes made by the GC.</span>

    <span class="token comment">// There is sometimes work left over when we enter mark termination due</span>
    <span class="token comment">// to write barriers performed after the completion barrier above.</span>
    <span class="token comment">// Detect this and resume concurrent mark. This is obviously</span>
    <span class="token comment">// unfortunate.</span>
    <span class="token comment">//</span>
    <span class="token comment">// See issue #27993 for details.</span>
    <span class="token comment">//</span>
    <span class="token comment">// Switch to the system stack to call wbBufFlush1, though in this case</span>
    <span class="token comment">// it doesn't matter because we're non-preemptible anyway.</span>
    restart <span class="token operator">:=</span> <span class="token boolean">false</span>
    <span class="token function">systemstack</span><span class="token punctuation">(</span><span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> p <span class="token operator">:=</span> <span class="token keyword">range</span> allp <span class="token punctuation">&#123;</span>
            <span class="token function">wbBufFlush1</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span>
            <span class="token keyword">if</span> <span class="token operator">!</span>p<span class="token punctuation">.</span>gcw<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                restart <span class="token operator">=</span> <span class="token boolean">true</span>
                <span class="token keyword">break</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> restart <span class="token punctuation">&#123;</span>
        <span class="token function">getg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>m<span class="token punctuation">.</span>preemptoff <span class="token operator">=</span> <span class="token string">""</span>
        <span class="token function">systemstack</span><span class="token punctuation">(</span><span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            now <span class="token operator">:=</span> <span class="token function">startTheWorldWithSema</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>
            work<span class="token punctuation">.</span>pauseNS <span class="token operator">+=</span> now <span class="token operator">-</span> work<span class="token punctuation">.</span>pauseStart
            memstats<span class="token punctuation">.</span>gcPauseDist<span class="token punctuation">.</span><span class="token function">record</span><span class="token punctuation">(</span>now <span class="token operator">-</span> work<span class="token punctuation">.</span>pauseStart<span class="token punctuation">)</span>
        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
        <span class="token function">semrelease</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>worldsema<span class="token punctuation">)</span>
        <span class="token keyword">goto</span> top
    <span class="token punctuation">&#125;</span>

    <span class="token comment">// Disable assists and background workers. We must do</span>
    <span class="token comment">// this before waking blocked assists.</span>
    atomic<span class="token punctuation">.</span><span class="token function">Store</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>gcBlackenEnabled<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>

    <span class="token comment">// Wake all blocked assists. These will run when we</span>
    <span class="token comment">// start the world again.</span>
    <span class="token comment">// 唤醒因协助标记而阻塞的 goroutine</span>
    <span class="token function">gcWakeAllAssists</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token comment">// Likewise, release the transition lock. Blocked</span>
    <span class="token comment">// workers and assists will run when we start the</span>
    <span class="token comment">// world again.</span>
    <span class="token function">semrelease</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>work<span class="token punctuation">.</span>markDoneSema<span class="token punctuation">)</span>

    <span class="token comment">// In STW mode, re-enable user goroutines. These will be</span>
    <span class="token comment">// queued to run after we start the world.</span>
    <span class="token function">schedEnableUser</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>

    <span class="token comment">// endCycle depends on all gcWork cache stats being flushed.</span>
    <span class="token comment">// The termination algorithm above ensured that up to</span>
    <span class="token comment">// allocations since the ragged barrier.</span>
    nextTriggerRatio <span class="token operator">:=</span> gcController<span class="token punctuation">.</span><span class="token function">endCycle</span><span class="token punctuation">(</span>work<span class="token punctuation">.</span>userForced<span class="token punctuation">)</span>

    <span class="token comment">// Perform mark termination. This will restart the world.</span>
    <span class="token function">gcMarkTermination</span><span class="token punctuation">(</span>nextTriggerRatio<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="番外篇"><a href="#番外篇" class="headerlink" title="番外篇"></a>番外篇</h2><h3 id="suspendG"><a href="#suspendG" class="headerlink" title="suspendG"></a>suspendG</h3><ul>
<li>从全局 g 队列中获取一个，这个 g 有可能是一下几种情况<ul>
<li>正在别的 P 上运行</li>
<li>正在进行系统调用</li>
<li>正在某个地方等待</li>
<li>已经是可执行状态</li>
<li>正在发生抢占</li>
<li>也可能是当前这个 gcMarkWorker</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">/*
    suspendG 在一个安全时刻暂停 goroutine 并且返回被挂起 goroutine 的状态。
    suspendG 的调用者拥有该 goroutine 的读权限直到调用的 resumeG。

    多个调用者在同一时刻想挂起同一个 goroutine 是安全的。
    The goroutine may execute between subsequent successful suspend operations.
    当前的实现为互斥访问 goroutine，因此多个调用者的访问会被串行化。
    然而，这样的目的是为了读共享，所以请不要依赖互斥访问。

    suspendG 一定要在 system stack 上调用并且当前 M 上的 goroutine 一定是可以被抢占的状态。这阻止了两个 goroutine 尝试相互挂起但是他们都处在非抢占状态下发生死锁的情况。虽然还有其他的方式可以解决死锁，但是这种是最简单的方式。
*/</span>
<span class="token comment">//go:systemstack</span>
<span class="token keyword">func</span> <span class="token function">suspendG</span><span class="token punctuation">(</span>gp <span class="token operator">*</span>g<span class="token punctuation">)</span> suspendGState <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> mp <span class="token operator">:=</span> <span class="token function">getg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>m<span class="token punctuation">;</span> mp<span class="token punctuation">.</span>curg <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token operator">&amp;&amp;</span> <span class="token function">readgstatus</span><span class="token punctuation">(</span>mp<span class="token punctuation">.</span>curg<span class="token punctuation">)</span> <span class="token operator">==</span> _Grunning <span class="token punctuation">&#123;</span>
        <span class="token comment">// Since we're on the system stack of this M, the user</span>
        <span class="token comment">// G is stuck at an unsafe point. If another goroutine</span>
        <span class="token comment">// were to try to preempt m.curg, it could deadlock.</span>
        <span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">"suspendG from non-preemptible goroutine"</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">// See https://golang.org/cl/21503 for justification of the yield delay.</span>
    <span class="token keyword">const</span> yieldDelay <span class="token operator">=</span> <span class="token number">10</span> <span class="token operator">*</span> <span class="token number">1000</span>
    <span class="token keyword">var</span> nextYield <span class="token builtin">int64</span>

    <span class="token comment">// Drive the goroutine to a preemption point.</span>
    stopped <span class="token operator">:=</span> <span class="token boolean">false</span>
    <span class="token keyword">var</span> asyncM <span class="token operator">*</span>m
    <span class="token keyword">var</span> asyncGen <span class="token builtin">uint32</span>
    <span class="token keyword">var</span> nextPreemptM <span class="token builtin">int64</span>
    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">switch</span> s <span class="token operator">:=</span> <span class="token function">readgstatus</span><span class="token punctuation">(</span>gp<span class="token punctuation">)</span><span class="token punctuation">;</span> s <span class="token punctuation">&#123;</span>
            <span class="token keyword">default</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> s<span class="token operator">&amp;</span>_Gscan <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>
                <span class="token comment">// Someone else is suspending it. Wait</span>
                <span class="token comment">// for them to finish.</span>
                <span class="token comment">//</span>
                <span class="token comment">// TODO: It would be nicer if we could</span>
                <span class="token comment">// coalesce suspends.</span>
                <span class="token keyword">break</span>
            <span class="token punctuation">&#125;</span>

            <span class="token function">dumpgstatus</span><span class="token punctuation">(</span>gp<span class="token punctuation">)</span>
            <span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">"invalid g status"</span><span class="token punctuation">)</span>

            <span class="token keyword">case</span> _Gdead<span class="token punctuation">:</span>
            <span class="token comment">// Nothing to suspend.</span>
            <span class="token comment">//</span>
            <span class="token comment">// preemptStop may need to be cleared, but</span>
            <span class="token comment">// doing that here could race with goroutine</span>
            <span class="token comment">// reuse. Instead, goexit0 clears it.</span>
            <span class="token keyword">return</span> suspendGState<span class="token punctuation">&#123;</span>dead<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">&#125;</span>

            <span class="token keyword">case</span> _Gcopystack<span class="token punctuation">:</span>
            <span class="token comment">// The stack is being copied. We need to wait</span>
            <span class="token comment">// until this is done.</span>

            <span class="token keyword">case</span> _Gpreempted<span class="token punctuation">:</span>
            <span class="token comment">// We (or someone else) suspended the G. Claim</span>
            <span class="token comment">// ownership of it by transitioning it to</span>
            <span class="token comment">// _Gwaiting.</span>
            <span class="token keyword">if</span> <span class="token operator">!</span><span class="token function">casGFromPreempted</span><span class="token punctuation">(</span>gp<span class="token punctuation">,</span> _Gpreempted<span class="token punctuation">,</span> _Gwaiting<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token keyword">break</span>
            <span class="token punctuation">&#125;</span>

            <span class="token comment">// We stopped the G, so we have to ready it later.</span>
            stopped <span class="token operator">=</span> <span class="token boolean">true</span>

            s <span class="token operator">=</span> _Gwaiting
            <span class="token keyword">fallthrough</span>

            <span class="token keyword">case</span> _Grunnable<span class="token punctuation">,</span> _Gsyscall<span class="token punctuation">,</span> _Gwaiting<span class="token punctuation">:</span>
            <span class="token comment">// Claim goroutine by setting scan bit.</span>
            <span class="token comment">// This may race with execution or readying of gp.</span>
            <span class="token comment">// The scan bit keeps it from transition state.</span>
            <span class="token keyword">if</span> <span class="token operator">!</span><span class="token function">castogscanstatus</span><span class="token punctuation">(</span>gp<span class="token punctuation">,</span> s<span class="token punctuation">,</span> s<span class="token operator">|</span>_Gscan<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token keyword">break</span>
            <span class="token punctuation">&#125;</span>

            <span class="token comment">// Clear the preemption request. It's safe to</span>
            <span class="token comment">// reset the stack guard because we hold the</span>
            <span class="token comment">// _Gscan bit and thus own the stack.</span>
            gp<span class="token punctuation">.</span>preemptStop <span class="token operator">=</span> <span class="token boolean">false</span>
            gp<span class="token punctuation">.</span>preempt <span class="token operator">=</span> <span class="token boolean">false</span>
            gp<span class="token punctuation">.</span>stackguard0 <span class="token operator">=</span> gp<span class="token punctuation">.</span>stack<span class="token punctuation">.</span>lo <span class="token operator">+</span> _StackGuard

            <span class="token comment">// The goroutine was already at a safe-point</span>
            <span class="token comment">// and we've now locked that in.</span>
            <span class="token comment">//</span>
            <span class="token comment">// TODO: It would be much better if we didn't</span>
            <span class="token comment">// leave it in _Gscan, but instead gently</span>
            <span class="token comment">// prevented its scheduling until resumption.</span>
            <span class="token comment">// Maybe we only use this to bump a suspended</span>
            <span class="token comment">// count and the scheduler skips suspended</span>
            <span class="token comment">// goroutines? That wouldn't be enough for</span>
            <span class="token comment">// &#123;_Gsyscall,_Gwaiting&#125; -> _Grunning. Maybe</span>
            <span class="token comment">// for all those transitions we need to check</span>
            <span class="token comment">// suspended and deschedule?</span>
            <span class="token keyword">return</span> suspendGState<span class="token punctuation">&#123;</span>g<span class="token punctuation">:</span> gp<span class="token punctuation">,</span> stopped<span class="token punctuation">:</span> stopped<span class="token punctuation">&#125;</span>

            <span class="token keyword">case</span> _Grunning<span class="token punctuation">:</span>
            <span class="token comment">// Optimization: if there is already a pending preemption request</span>
            <span class="token comment">// (from the previous loop iteration), don't bother with the atomics.</span>
            <span class="token keyword">if</span> gp<span class="token punctuation">.</span>preemptStop <span class="token operator">&amp;&amp;</span> gp<span class="token punctuation">.</span>preempt <span class="token operator">&amp;&amp;</span> gp<span class="token punctuation">.</span>stackguard0 <span class="token operator">==</span> stackPreempt <span class="token operator">&amp;&amp;</span> asyncM <span class="token operator">==</span> gp<span class="token punctuation">.</span>m <span class="token operator">&amp;&amp;</span> atomic<span class="token punctuation">.</span><span class="token function">Load</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>asyncM<span class="token punctuation">.</span>preemptGen<span class="token punctuation">)</span> <span class="token operator">==</span> asyncGen <span class="token punctuation">&#123;</span>
                <span class="token keyword">break</span>
            <span class="token punctuation">&#125;</span>

            <span class="token comment">// Temporarily block state transitions.</span>
            <span class="token keyword">if</span> <span class="token operator">!</span><span class="token function">castogscanstatus</span><span class="token punctuation">(</span>gp<span class="token punctuation">,</span> _Grunning<span class="token punctuation">,</span> _Gscanrunning<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token keyword">break</span>
            <span class="token punctuation">&#125;</span>

            <span class="token comment">// Request synchronous preemption.</span>
            gp<span class="token punctuation">.</span>preemptStop <span class="token operator">=</span> <span class="token boolean">true</span>
            gp<span class="token punctuation">.</span>preempt <span class="token operator">=</span> <span class="token boolean">true</span>
            gp<span class="token punctuation">.</span>stackguard0 <span class="token operator">=</span> stackPreempt

            <span class="token comment">// Prepare for asynchronous preemption.</span>
            asyncM2 <span class="token operator">:=</span> gp<span class="token punctuation">.</span>m
            asyncGen2 <span class="token operator">:=</span> atomic<span class="token punctuation">.</span><span class="token function">Load</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>asyncM2<span class="token punctuation">.</span>preemptGen<span class="token punctuation">)</span>
            needAsync <span class="token operator">:=</span> asyncM <span class="token operator">!=</span> asyncM2 <span class="token operator">||</span> asyncGen <span class="token operator">!=</span> asyncGen2
            asyncM <span class="token operator">=</span> asyncM2
            asyncGen <span class="token operator">=</span> asyncGen2

            <span class="token function">casfrom_Gscanstatus</span><span class="token punctuation">(</span>gp<span class="token punctuation">,</span> _Gscanrunning<span class="token punctuation">,</span> _Grunning<span class="token punctuation">)</span>

            <span class="token comment">// Send asynchronous preemption. We do this</span>
            <span class="token comment">// after CASing the G back to _Grunning</span>
            <span class="token comment">// because preemptM may be synchronous and we</span>
            <span class="token comment">// don't want to catch the G just spinning on</span>
            <span class="token comment">// its status.</span>
            <span class="token keyword">if</span> preemptMSupported <span class="token operator">&amp;&amp;</span> debug<span class="token punctuation">.</span>asyncpreemptoff <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> needAsync <span class="token punctuation">&#123;</span>
                <span class="token comment">// Rate limit preemptM calls. This is</span>
                <span class="token comment">// particularly important on Windows</span>
                <span class="token comment">// where preemptM is actually</span>
                <span class="token comment">// synchronous and the spin loop here</span>
                <span class="token comment">// can lead to live-lock.</span>
                now <span class="token operator">:=</span> <span class="token function">nanotime</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                <span class="token keyword">if</span> now <span class="token operator">>=</span> nextPreemptM <span class="token punctuation">&#123;</span>
                    nextPreemptM <span class="token operator">=</span> now <span class="token operator">+</span> yieldDelay<span class="token operator">/</span><span class="token number">2</span>
                    <span class="token function">preemptM</span><span class="token punctuation">(</span>asyncM<span class="token punctuation">)</span>
                <span class="token punctuation">&#125;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>

        <span class="token comment">// TODO: Don't busy wait. This loop should really only</span>
        <span class="token comment">// be a simple read/decide/CAS loop that only fails if</span>
        <span class="token comment">// there's an active race. Once the CAS succeeds, we</span>
        <span class="token comment">// should queue up the preemption (which will require</span>
        <span class="token comment">// it to be reliable in the _Grunning case, not</span>
        <span class="token comment">// best-effort) and then sleep until we're notified</span>
        <span class="token comment">// that the goroutine is suspended.</span>
        <span class="token keyword">if</span> i <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>
            nextYield <span class="token operator">=</span> <span class="token function">nanotime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> yieldDelay
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">if</span> <span class="token function">nanotime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> nextYield <span class="token punctuation">&#123;</span>
            <span class="token function">procyield</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
            <span class="token function">osyield</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
            nextYield <span class="token operator">=</span> <span class="token function">nanotime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> yieldDelay<span class="token operator">/</span><span class="token number">2</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="resumeG"><a href="#resumeG" class="headerlink" title="resumeG"></a>resumeG</h3><h3 id="税收与开支"><a href="#税收与开支" class="headerlink" title="税收与开支"></a>税收与开支</h3><ul>
<li>基本理念</li>
</ul>
<p>​        每个赋值器线程都应当参与一定的回收工作（即纳税）。同时也应当与回收器交替执行，以确保最小赋值器使用率的要求。    </p>
<p>​        回收器应可在赋值器执行间隙尽量多的执行回收工作（即尽量多的积累 credit，以供赋值器支出。）</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// gcFlushBgCredit flushes scanWork units of background scan work</span>
<span class="token comment">// credit. This first satisfies blocked assists on the</span>
<span class="token comment">// work.assistQueue and then flushes any remaining credit to</span>
<span class="token comment">// gcController.bgScanCredit.</span>
<span class="token comment">//</span>
<span class="token comment">// Write barriers are disallowed because this is used by gcDrain after</span>
<span class="token comment">// it has ensured that all work is drained and this must preserve that</span>
<span class="token comment">// condition.</span>
<span class="token comment">//</span>
<span class="token comment">//go:nowritebarrierrec</span>
<span class="token keyword">func</span> <span class="token function">gcFlushBgCredit</span><span class="token punctuation">(</span>scanWork <span class="token builtin">int64</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> work<span class="token punctuation">.</span>assistQueue<span class="token punctuation">.</span>q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// Fast path; there are no blocked assists. There's a</span>
        <span class="token comment">// small window here where an assist may add itself to</span>
        <span class="token comment">// the blocked queue and park. If that happens, we'll</span>
        <span class="token comment">// just get it on the next flush.</span>
        atomic<span class="token punctuation">.</span><span class="token function">Xaddint64</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>gcController<span class="token punctuation">.</span>bgScanCredit<span class="token punctuation">,</span> scanWork<span class="token punctuation">)</span>
        <span class="token keyword">return</span>
    <span class="token punctuation">&#125;</span>

    assistBytesPerWork <span class="token operator">:=</span> <span class="token function">float64frombits</span><span class="token punctuation">(</span>atomic<span class="token punctuation">.</span><span class="token function">Load64</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>gcController<span class="token punctuation">.</span>assistBytesPerWork<span class="token punctuation">)</span><span class="token punctuation">)</span>
    scanBytes <span class="token operator">:=</span> <span class="token function">int64</span><span class="token punctuation">(</span><span class="token function">float64</span><span class="token punctuation">(</span>scanWork<span class="token punctuation">)</span> <span class="token operator">*</span> assistBytesPerWork<span class="token punctuation">)</span>

    <span class="token function">lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>work<span class="token punctuation">.</span>assistQueue<span class="token punctuation">.</span>lock<span class="token punctuation">)</span>
    <span class="token keyword">for</span> <span class="token operator">!</span>work<span class="token punctuation">.</span>assistQueue<span class="token punctuation">.</span>q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> scanBytes <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>
        gp <span class="token operator">:=</span> work<span class="token punctuation">.</span>assistQueue<span class="token punctuation">.</span>q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token comment">// Note that gp.gcAssistBytes is negative because gp</span>
        <span class="token comment">// is in debt. Think carefully about the signs below.</span>
        <span class="token comment">// scanBytes+gp.gcAssistBytes 意味着足够支付债务</span>
        <span class="token keyword">if</span> scanBytes<span class="token operator">+</span>gp<span class="token punctuation">.</span>gcAssistBytes <span class="token operator">>=</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>
            <span class="token comment">// Satisfy this entire assist debt.</span>
            scanBytes <span class="token operator">+=</span> gp<span class="token punctuation">.</span>gcAssistBytes
            gp<span class="token punctuation">.</span>gcAssistBytes <span class="token operator">=</span> <span class="token number">0</span>
            <span class="token comment">// It's important that we *not* put gp in</span>
            <span class="token comment">// runnext. Otherwise, it's possible for user</span>
            <span class="token comment">// code to exploit the GC worker's high</span>
            <span class="token comment">// scheduler priority to get itself always run</span>
            <span class="token comment">// before other goroutines and always in the</span>
            <span class="token comment">// fresh quantum started by GC.</span>
            <span class="token comment">// 还债后唤醒这个 g</span>
            <span class="token function">ready</span><span class="token punctuation">(</span>gp<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
            <span class="token comment">// 没法完全支付债务，但是可以偿还一部分</span>
            <span class="token comment">// 偿还完成后，又放回了协助标记的队列中</span>
            <span class="token comment">// Partially satisfy this assist.</span>
            gp<span class="token punctuation">.</span>gcAssistBytes <span class="token operator">+=</span> scanBytes
            scanBytes <span class="token operator">=</span> <span class="token number">0</span>
            <span class="token comment">// As a heuristic, we move this assist to the</span>
            <span class="token comment">// back of the queue so that large assists</span>
            <span class="token comment">// can't clog up the assist queue and</span>
            <span class="token comment">// substantially delay small assists.</span>
            work<span class="token punctuation">.</span>assistQueue<span class="token punctuation">.</span>q<span class="token punctuation">.</span><span class="token function">pushBack</span><span class="token punctuation">(</span>gp<span class="token punctuation">)</span>
            <span class="token keyword">break</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
	
    <span class="token comment">// 如果仍然有剩余的 credit 就刷新到全局的 credit 中</span>
    <span class="token keyword">if</span> scanBytes <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// Convert from scan bytes back to work.</span>
        assistWorkPerByte <span class="token operator">:=</span> <span class="token function">float64frombits</span><span class="token punctuation">(</span>atomic<span class="token punctuation">.</span><span class="token function">Load64</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>gcController<span class="token punctuation">.</span>assistWorkPerByte<span class="token punctuation">)</span><span class="token punctuation">)</span>
        scanWork <span class="token operator">=</span> <span class="token function">int64</span><span class="token punctuation">(</span><span class="token function">float64</span><span class="token punctuation">(</span>scanBytes<span class="token punctuation">)</span> <span class="token operator">*</span> assistWorkPerByte<span class="token punctuation">)</span>
        atomic<span class="token punctuation">.</span><span class="token function">Xaddint64</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>gcController<span class="token punctuation">.</span>bgScanCredit<span class="token punctuation">,</span> scanWork<span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>work<span class="token punctuation">.</span>assistQueue<span class="token punctuation">.</span>lock<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><p>GC 真的是太难了… 感觉这些都还只是冰山一角，曹大讲过，GC 这部分量力而行，对于大部分程序员来说可以完整的把三色抽象、GC 流程给面试官描述出来，已经是很厉害了，如果他还了解一些理论基础，那算是相当不错了…</p>
<p>我们追求的不是得到别人的认可，而是对知识的渴望。严于律己，提高自己的职业素养。</p>

    </div>

    
    
    
        <div class="reward-container">
  <div></div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.png" alt="杨宝强 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.png" alt="杨宝强 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>杨宝强
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://bqyang.top/2021/GC/" title="GC 源码梳理">https://bqyang.top/2021/GC/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-Hans" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/GCComments/" rel="prev" title="GC from go comments">
      <i class="fa fa-chevron-left"></i> GC from go comments
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/HappyWeekend/" rel="next" title="Weekend">
      Weekend <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#GC-%E8%BF%9E%E8%BF%9E%E9%97%AE"><span class="nav-number">1.</span> <span class="nav-text">GC 连连问</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#GC-%E7%9A%84%E6%B5%81%E7%A8%8B%E9%98%B6%E6%AE%B5"><span class="nav-number">1.1.</span> <span class="nav-text">GC 的流程阶段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GC-%E7%9A%84%E8%A7%A6%E5%8F%91%E6%97%B6%E6%9C%BA"><span class="nav-number">1.2.</span> <span class="nav-text">GC 的触发时机</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GC-%E7%9A%84%E8%B5%B7%E7%82%B9"><span class="nav-number">1.3.</span> <span class="nav-text">GC 的起点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%80%81%E7%89%88%E6%9C%AC%E9%9C%80%E8%A6%81%E9%87%8D%E6%96%B0%E6%89%AB%E6%8F%8F%E6%A0%88%EF%BC%9F"><span class="nav-number">1.4.</span> <span class="nav-text">为什么老版本需要重新扫描栈？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GC-%E6%A0%87%E8%AE%B0%E7%9A%84%E6%A0%B9%E9%83%BD%E6%9C%89%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.5.</span> <span class="nav-text">GC 标记的根都有什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E7%8B%AC%E4%BD%BF%E7%94%A8-D-%E5%B1%8F%E9%9A%9C%E6%9C%89%E4%BD%95%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="nav-number">1.6.</span> <span class="nav-text">单独使用 D 屏障有何问题？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E7%8B%AC%E4%BD%BF%E7%94%A8-Y-%E5%B1%8F%E9%9A%9C%E6%9C%89%E4%BD%95%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="nav-number">1.7.</span> <span class="nav-text">单独使用 Y 屏障有何问题？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%B7%E5%90%88%E5%86%99%E5%B1%8F%E9%9A%9C%E6%98%AF%E6%80%8E%E4%B9%88%E4%B8%80%E5%9B%9E%E4%BA%8B%EF%BC%9F"><span class="nav-number">1.8.</span> <span class="nav-text">混合写屏障是怎么一回事？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%8F%E5%8A%A9%E6%A0%87%E8%AE%B0%E6%B5%81%E7%A8%8B"><span class="nav-number">1.9.</span> <span class="nav-text">协助标记流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BA%A4%E5%8F%89%E5%BC%95%E7%94%A8%E6%98%AF%E5%A6%82%E4%BD%95%E5%89%AA%E6%9E%9D%E7%9A%84%EF%BC%9F"><span class="nav-number">1.10.</span> <span class="nav-text">对象的交叉引用是如何剪枝的？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8E%E8%BF%90%E7%AE%97"><span class="nav-number">1.10.1.</span> <span class="nav-text">与运算</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%88%96%E8%BF%90%E7%AE%97"><span class="nav-number">1.10.2.</span> <span class="nav-text">或运算</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97"><span class="nav-number">1.10.3.</span> <span class="nav-text">异或运算</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GC-%E7%9A%84-CPU-%E4%BD%BF%E7%94%A8%E7%8E%87"><span class="nav-number">1.11.</span> <span class="nav-text">GC 的 CPU 使用率</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#gcTriggerKind"><span class="nav-number">1.12.</span> <span class="nav-text">gcTriggerKind</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#STW-%E6%97%B6%E9%97%B4%E6%80%8E%E4%B9%88%E7%AE%97%E5%87%BA%E6%9D%A5%E7%9A%84%EF%BC%9F"><span class="nav-number">1.13.</span> <span class="nav-text">STW 时间怎么算出来的？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GC-%E8%BF%87%E7%A8%8B%E4%B8%AD%E6%98%AF%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%B0%86%E5%AF%B9%E8%B1%A1%E6%A0%87%E8%AE%B0%E4%B8%BA%E9%BB%91%E8%89%B2%E7%9A%84"><span class="nav-number">1.14.</span> <span class="nav-text">GC 过程中是什么时候将对象标记为黑色的</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#gcStart-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90"><span class="nav-number">2.</span> <span class="nav-text">gcStart 源码剖析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#findRunnableGCWorker-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90"><span class="nav-number">3.</span> <span class="nav-text">findRunnableGCWorker 源码剖析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%96%E6%9E%90-gcBgMarkWorker-%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B"><span class="nav-number">4.</span> <span class="nav-text">剖析 gcBgMarkWorker 创建过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#notesleepg"><span class="nav-number">4.1.</span> <span class="nav-text">notesleepg</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#go-gcBgMarkWorker"><span class="nav-number">4.2.</span> <span class="nav-text">go gcBgMarkWorker</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E5%90%88%E7%9D%80%E7%9C%8B"><span class="nav-number">4.3.</span> <span class="nav-text">结合着看</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#gcMarkWorker-%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="nav-number">5.</span> <span class="nav-text">gcMarkWorker 执行过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#gcBgMarkWorker-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90"><span class="nav-number">5.1.</span> <span class="nav-text">gcBgMarkWorker 源码剖析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GC-%E6%A0%87%E8%AE%B0%E7%9A%84%E5%87%A0%E4%B8%AA%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F"><span class="nav-number">5.2.</span> <span class="nav-text">GC 标记的几个工作模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bitmap-%E4%B8%8E-ha-%E7%9A%84%E6%98%A0%E5%B0%84%E5%85%B3%E7%B3%BB%EF%BC%88%E6%A0%87%E8%AE%B0%E8%BF%87%E7%A8%8B%E7%94%A8%E5%88%B0%E7%9A%84%E4%BD%8D%E5%9B%BE%EF%BC%89"><span class="nav-number">5.3.</span> <span class="nav-text">bitmap 与 ha 的映射关系（标记过程用到的位图）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#bitmap-%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">5.3.1.</span> <span class="nav-text">bitmap 的使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#heapBitsForAddr"><span class="nav-number">5.3.2.</span> <span class="nav-text">heapBitsForAddr</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#gcDrain-%E6%A0%87%E8%AE%B0%E8%BF%87%E7%A8%8B"><span class="nav-number">5.4.</span> <span class="nav-text">gcDrain 标记过程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%87%E8%AE%B0%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%B9%B3%E8%A1%A1"><span class="nav-number">5.4.1.</span> <span class="nav-text">标记工作的平衡</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#balance"><span class="nav-number">5.4.1.1.</span> <span class="nav-text">balance</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#enlistWorker"><span class="nav-number">5.4.1.2.</span> <span class="nav-text">enlistWorker</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#handoff"><span class="nav-number">5.4.1.3.</span> <span class="nav-text">handoff</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#GC-%E8%BF%87%E7%A8%8B%E4%B8%AD-P-%E7%9A%84-gcw-%E9%98%9F%E5%88%97"><span class="nav-number">5.4.2.</span> <span class="nav-text">GC 过程中 P 的 gcw 队列</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#wbuf1-%E5%92%8C-wbuf2"><span class="nav-number">5.4.2.1.</span> <span class="nav-text">wbuf1 和 wbuf2</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#work-full-%E5%92%8C-work-empty"><span class="nav-number">5.4.2.2.</span> <span class="nav-text">work.full 和 work.empty</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#GC-%E8%BF%87%E7%A8%8B%E4%B8%AD%E8%B4%9F%E8%B4%A3%E6%A0%87%E8%AE%B0%E7%9A%84%E5%87%BD%E6%95%B0"><span class="nav-number">5.4.3.</span> <span class="nav-text">GC 过程中负责标记的函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#markroot"><span class="nav-number">5.4.3.1.</span> <span class="nav-text">markroot</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#scanobject"><span class="nav-number">5.4.3.2.</span> <span class="nav-text">scanobject</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#findObject"><span class="nav-number">5.4.3.3.</span> <span class="nav-text">findObject</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#markrootBlock"><span class="nav-number">5.4.3.4.</span> <span class="nav-text">markrootBlock</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#markrootFreeGStacks"><span class="nav-number">5.4.3.5.</span> <span class="nav-text">markrootFreeGStacks</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#markrootSpans"><span class="nav-number">5.4.3.6.</span> <span class="nav-text">markrootSpans</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#scanstack"><span class="nav-number">5.4.3.7.</span> <span class="nav-text">scanstack</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#scanblock"><span class="nav-number">5.4.3.8.</span> <span class="nav-text">scanblock</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#gcmarknewobject"><span class="nav-number">5.4.3.9.</span> <span class="nav-text">gcmarknewobject</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#gcMarkTinyAllocs"><span class="nav-number">5.4.3.10.</span> <span class="nav-text">gcMarkTinyAllocs</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#gcMarkDone"><span class="nav-number">6.</span> <span class="nav-text">gcMarkDone</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%95%AA%E5%A4%96%E7%AF%87"><span class="nav-number">7.</span> <span class="nav-text">番外篇</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#suspendG"><span class="nav-number">7.1.</span> <span class="nav-text">suspendG</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#resumeG"><span class="nav-number">7.2.</span> <span class="nav-text">resumeG</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A8%8E%E6%94%B6%E4%B8%8E%E5%BC%80%E6%94%AF"><span class="nav-number">7.3.</span> <span class="nav-text">税收与开支</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%98%E5%A4%96%E8%AF%9D"><span class="nav-number">8.</span> <span class="nav-text">题外话</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">杨宝强</p>
  <div class="site-description" itemprop="description">记录技术精进之路，记录生活的打情骂俏</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">15</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/clamyang" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;clamyang" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-Hans" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://xargin.com/" title="https:&#x2F;&#x2F;xargin.com" rel="noopener" target="_blank">Xargin</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://mytechshares.com/" title="https:&#x2F;&#x2F;mytechshares.com&#x2F;" rel="noopener" target="_blank">董泽润</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-car"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">杨宝强</span>
</div>
  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">京ICP备2021035561号-1 </a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '4bcae079402e9cc4ce7b',
      clientSecret: 'bc6b6ecab4d016f0a056df8253ad41b76b944084',
      repo        : 'blog_comments',
      owner       : 'clamyang',
      admin       : ['clamyang'],
      id          : '8c75e324ca94ae51aff0786cd626898c',
        language: 'en',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

</body>
</html>
