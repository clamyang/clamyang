<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="ä¸€ç‰©ä¸çŸ¥æ·±ä»¥ä¸ºè€»"><title>GC æºç æ¢³ç† | æ¨å®å¼ºçš„æŠ€æœ¯ç¬”è®°</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><div class="darkmode-toggle">ğŸŒ“</div><script>var prefersDarkMode = window.matchMedia('(prefers-color-scheme: dark)');
var toggle = document.querySelector('.darkmode-toggle');
var html = document.querySelector('html');

html.dataset.dark = localStorage.dark || prefersDarkMode.matches;

toggle.addEventListener('click', () => {
localStorage.dark = !(html.dataset.dark == 'true');
html.dataset.dark = localStorage.dark;
});</script><meta name="generator" content="Hexo 5.4.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">GC æºç æ¢³ç†</h1><a id="logo" href="/.">æ¨å®å¼ºçš„æŠ€æœ¯ç¬”è®°</a><p class="description">Coder Gopher Watcher</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> é¦–é¡µ</i></a><a href="/archives/"><i class="fa fa-archive"> å½’æ¡£</i></a><a href="/about/"><i class="fa fa-user"> å…³äº</i></a><a href="/atom.xml"><i class="fa fa-rss"> è®¢é˜…</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">GC æºç æ¢³ç†</h1><div class="post-meta">2021-12-02</div><div class="post-content"><p>Golang GC åƒåœ¾å›æ”¶çŸ¥è¯†ç‚¹æ€»ç»“ï¼Œæœ‰äº›å†…å®¹è¿˜æ²¡æœ‰å®Œæˆï¼Œåªæ˜¯æš‚æ—¶å†™ä¸Šäº†é—®é¢˜ï¼Œè¿˜æ²¡æ¥å¾—åŠæ¢³ç†ç›¸åº”çš„å†…å®¹ã€‚</p>
<span id="more"></span>

<h2 id="GC-è¿è¿é—®"><a href="#GC-è¿è¿é—®" class="headerlink" title="GC è¿è¿é—®"></a>GC è¿è¿é—®</h2><h3 id="GC-çš„æµç¨‹é˜¶æ®µ"><a href="#GC-çš„æµç¨‹é˜¶æ®µ" class="headerlink" title="GC çš„æµç¨‹é˜¶æ®µ"></a>GC çš„æµç¨‹é˜¶æ®µ</h3><ul>
<li>sweep termination</li>
<li>mark</li>
<li>mark termination</li>
<li>sweep</li>
</ul>
<p>æ³¨ï¼šåœ¨ä¸‹ä¸€æ¬¡ GC mark é˜¶æ®µå¼€å§‹ä¹‹å‰ï¼Œä¸€å®šè¦å®Œæˆä¸Šä¸€æ¬¡çš„æ¸…æ‰«å·¥ä½œã€‚æ‰€ä»¥æˆ‘ä»¬çœ‹åˆ°äº†ä¸€ä¸ª sweep termination  é˜¶æ®µã€‚æ ¹æœ¬åŸå› æ˜¯ Golang ä¸­é‡‡ç”¨çš„æ˜¯æƒ°æ€§æ¸…æ‰«çš„ã€‚</p>
<h3 id="GC-çš„è§¦å‘æ—¶æœº"><a href="#GC-çš„è§¦å‘æ—¶æœº" class="headerlink" title="GC çš„è§¦å‘æ—¶æœº"></a>GC çš„è§¦å‘æ—¶æœº</h3><p>1.runtime.GC æ‰‹åŠ¨è§¦å‘</p>
<p>2.mallocgc æ ¹æ®å†…å­˜åˆ†é…å¤§å°ï¼Œæ¯”å¦‚å½“å‰ä½¿ç”¨ 4Mï¼Œå½“å†…å­˜åˆ†é…åˆ°è¾¾ 8M æ—¶ï¼Œä¼šè§¦å‘ GCï¼Œè¿™ä¸ªç™¾åˆ†æ¯”æ˜¯å¯ä»¥è°ƒæ•´çš„ï¼Œé€šè¿‡ è®¾ç½® triggerRatio æŒ‡å®šè§¦å‘ GC çš„é˜ˆå€¼ go1.16.5 ä¸­ï¼Œæ˜¯ 7/8.0 = 87.5% </p>
<p>3.forcegchelper å®šæ—¶è§¦å‘ GC</p>
<p>mallocgc æ˜¯ä¸»è¦çš„è§¦å‘å‡½æ•°ã€‚</p>
<h3 id="GC-çš„èµ·ç‚¹"><a href="#GC-çš„èµ·ç‚¹" class="headerlink" title="GC çš„èµ·ç‚¹"></a>GC çš„èµ·ç‚¹</h3><p>gcStartï¼Œæ§åˆ¶ worker çš„æ•°é‡ï¼Œå  CPU çš„ 1/4ã€‚</p>
<h3 id="ä¸ºä»€ä¹ˆè€ç‰ˆæœ¬éœ€è¦é‡æ–°æ‰«ææ ˆï¼Ÿ"><a href="#ä¸ºä»€ä¹ˆè€ç‰ˆæœ¬éœ€è¦é‡æ–°æ‰«ææ ˆï¼Ÿ" class="headerlink" title="ä¸ºä»€ä¹ˆè€ç‰ˆæœ¬éœ€è¦é‡æ–°æ‰«ææ ˆï¼Ÿ"></a>ä¸ºä»€ä¹ˆè€ç‰ˆæœ¬éœ€è¦é‡æ–°æ‰«ææ ˆï¼Ÿ</h3><h3 id="GC-æ ‡è®°çš„æ ¹éƒ½æœ‰ä»€ä¹ˆï¼Ÿ"><a href="#GC-æ ‡è®°çš„æ ¹éƒ½æœ‰ä»€ä¹ˆï¼Ÿ" class="headerlink" title="GC æ ‡è®°çš„æ ¹éƒ½æœ‰ä»€ä¹ˆï¼Ÿ"></a>GC æ ‡è®°çš„æ ¹éƒ½æœ‰ä»€ä¹ˆï¼Ÿ</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// gcMarkRootPrepare queues root scanning jobs (stacks, globals, and</span></span><br><span class="line"><span class="comment">// some miscellany) and initializes scanning-related state.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The world must be stopped.</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	å†™åœ¨æœ€å‰è¾¹ï¼Œæˆ‘ä»¬å…³æ³¨çš„é‡ç‚¹åªæ˜¯ GCï¼Œ</span></span><br><span class="line"><span class="comment">	ä¸è¦è¿‡å¤šçš„è¢«å…¶ä»–çŸ¥è¯†ç‚¹æ‰€è’™è”½ï¼Œ</span></span><br><span class="line"><span class="comment">	æ¯”å¦‚è¿™é‡Œï¼Œæˆ‘ä»¬åªéœ€è¦çŸ¥é“ï¼Œæ ¹ä»å“ªé‡Œæ¥ï¼Œæ ¹éƒ½åŒ…å«ä»€ä¹ˆ</span></span><br><span class="line"><span class="comment">	å…¶å®ƒçš„éƒ½å¯ä»¥å¿½ç•¥ï¼ï¼</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcMarkRootPrepare</span><span class="params">()</span></span> &#123;</span><br><span class="line">    assertWorldStopped()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Compute how many data and BSS root blocks there are.</span></span><br><span class="line">    nBlocks := <span class="function"><span class="keyword">func</span><span class="params">(bytes <span class="keyword">uintptr</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">int</span>(divRoundUp(bytes, rootBlockBytes))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// åˆå§‹åŒ–éœ€è¦è¢«æ‰«æçš„ dataã€bss æ®µä¸ªæ•°</span></span><br><span class="line">    work.nDataRoots = <span class="number">0</span></span><br><span class="line">    work.nBSSRoots = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	æš‚æ—¶è®°å½•ä¸‹ç›®å‰çš„ç†è§£ï¼š</span></span><br><span class="line"><span class="comment">    	è¿™é‡Œçš„ bss data æ®µï¼Œæœ‰å¯èƒ½ä¼šå˜å¾—ï¼Œæ¯”å¦‚è¯´è¿›è¡ŒåŠ¨æ€é“¾æ¥çš„æ—¶å€™ï¼Œ</span></span><br><span class="line"><span class="comment">    	å°±ä¼šæŠŠé‚£ä¸ªè¢«é“¾æ¥çš„æ–‡ä»¶åŠ å…¥åˆ° activeModules ä¸­ï¼Œæ‰€ä»¥éƒ½æ˜¯é€šè¿‡</span></span><br><span class="line"><span class="comment">    	å‡½æ•°è°ƒç”¨çš„æ–¹å¼æ¥è·å–å¯¹åº”çš„æ•°æ®</span></span><br><span class="line"><span class="comment">    	æ³¨ï¼šä»–è¿™ä¸ªå¯¹æ€»æ•°çš„èµ‹å€¼æ“ä½œæœ‰ç‚¹è¿·æƒ‘ï¼Œä¸çŸ¥é“ä¸ºå•¥è¦è¿™æ ·å†™..</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Scan globals.</span></span><br><span class="line">    <span class="keyword">for</span> _, datap := <span class="keyword">range</span> activeModules() &#123;</span><br><span class="line">        nDataRoots := nBlocks(datap.edata - datap.data)</span><br><span class="line">        <span class="keyword">if</span> nDataRoots &gt; work.nDataRoots &#123;</span><br><span class="line">            work.nDataRoots = nDataRoots</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, datap := <span class="keyword">range</span> activeModules() &#123;</span><br><span class="line">        nBSSRoots := nBlocks(datap.ebss - datap.bss)</span><br><span class="line">        <span class="keyword">if</span> nBSSRoots &gt; work.nBSSRoots &#123;</span><br><span class="line">            work.nBSSRoots = nBSSRoots</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Scan span roots for finalizer specials.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// We depend on addfinalizer to mark objects that get</span></span><br><span class="line">    <span class="comment">// finalizers after root marking.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// We&#x27;re going to scan the whole heap (that was available at the time the</span></span><br><span class="line">    <span class="comment">// mark phase started, i.e. markArenas) for in-use spans which have specials.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Break up the work into arenas, and further into chunks.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Snapshot allArenas as markArenas. This snapshot is safe because allArenas</span></span><br><span class="line">    <span class="comment">// is append-only.</span></span><br><span class="line">    <span class="comment">// æ‰«ææ•´ä¸ª heapï¼Œå¯¹ allArenas åšå¿«ç…§</span></span><br><span class="line">    mheap_.markArenas = mheap_.allArenas[:<span class="built_in">len</span>(mheap_.allArenas):<span class="built_in">len</span>(mheap_.allArenas)]</span><br><span class="line">    <span class="comment">// è®¡ç®—éœ€è¦æ‰«æçš„ span æ•°é‡ï¼Œarena * ï¼ˆå•ä¸ª arena ä¸­ span çš„æ•°é‡ï¼‰</span></span><br><span class="line">    work.nSpanRoots = <span class="built_in">len</span>(mheap_.markArenas) * (pagesPerArena / pagesPerSpanRoot)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Scan stacks.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Gs may be created after this point, but it&#x27;s okay that we</span></span><br><span class="line">    <span class="comment">// ignore them because they begin life without any roots, so</span></span><br><span class="line">    <span class="comment">// there&#x27;s nothing to scan, and any roots they create during</span></span><br><span class="line">    <span class="comment">// the concurrent phase will be caught by the write barrier.</span></span><br><span class="line">    <span class="comment">// å¦‚æ³¨é‡Šæ‰€è¯´ï¼Œå°½ç®¡è¿™æ—¶å€™æœ‰ goroutine è¢«åˆ›å»ºï¼Œä¹Ÿä¸éœ€è¦æ‹…å¿ƒ</span></span><br><span class="line">    <span class="comment">// å› ä¸ºä»–ä»¬æ²¡æœ‰ rootï¼Œå³ä¸éœ€è¦æ‰«æã€‚å¦‚æœåœ¨å¹¶å‘é˜¶æ®µåˆ›å»ºå‡ºæ¥çš„ goroutineï¼Œ</span></span><br><span class="line">    <span class="comment">// è¿™ä¸ª G ä½¿ç”¨çš„ root ä¼šè¢« write barrier æ•è·åˆ°ã€‚</span></span><br><span class="line">    work.nStackRoots = <span class="keyword">int</span>(atomic.Loaduintptr(&amp;allglen))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// åˆå§‹åŒ–æ ‡è®°çš„å¼€å§‹ä½ç½®</span></span><br><span class="line">    work.markrootNext = <span class="number">0</span></span><br><span class="line">    <span class="comment">//ã€€è®¡ç®—æ‰€æœ‰æ ¹çš„æ•°é‡</span></span><br><span class="line">    <span class="comment">//ã€€åŒ…æ‹¬äº†ï¼šDataã€€æ®µï¼ŒBSSã€€æ®µ,span,ä»¥åŠ goroutine æ ˆ</span></span><br><span class="line">    work.markrootJobs = <span class="keyword">uint32</span>(fixedRootCount + work.nDataRoots + work.nBSSRoots + work.nSpanRoots + work.nStackRoots)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Calculate base indexes of each root type</span></span><br><span class="line">    <span class="comment">// markroot æ ‡è®°çš„æ—¶å€™ä¼šæ ¹æ®ä¸åŒçš„ i æ‰¾åˆ°ä¸åŒçš„æ ¹</span></span><br><span class="line">    work.baseData = <span class="keyword">uint32</span>(fixedRootCount)</span><br><span class="line">    work.baseBSS = work.baseData + <span class="keyword">uint32</span>(work.nDataRoots)</span><br><span class="line">    work.baseSpans = work.baseBSS + <span class="keyword">uint32</span>(work.nBSSRoots)</span><br><span class="line">    work.baseStacks = work.baseSpans + <span class="keyword">uint32</span>(work.nSpanRoots)</span><br><span class="line">    work.baseEnd = work.baseStacks + <span class="keyword">uint32</span>(work.nStackRoots)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>ç»“åˆä¸Šè¾¹ä»£ç æ¥çœ‹ï¼ŒGC æ ‡è®°è¿‡ç¨‹ä¸­æ¶‰åŠåˆ°çš„æ ¹æœ‰ï¼šå…¨å±€å˜é‡ï¼Œstackï¼Œheapï¼ˆspanï¼‰</li>
</ul>
<h3 id="å•ç‹¬ä½¿ç”¨-D-å±éšœæœ‰ä½•é—®é¢˜ï¼Ÿ"><a href="#å•ç‹¬ä½¿ç”¨-D-å±éšœæœ‰ä½•é—®é¢˜ï¼Ÿ" class="headerlink" title="å•ç‹¬ä½¿ç”¨ D å±éšœæœ‰ä½•é—®é¢˜ï¼Ÿ"></a>å•ç‹¬ä½¿ç”¨ D å±éšœæœ‰ä½•é—®é¢˜ï¼Ÿ</h3><h3 id="å•ç‹¬ä½¿ç”¨-Y-å±éšœæœ‰ä½•é—®é¢˜ï¼Ÿ"><a href="#å•ç‹¬ä½¿ç”¨-Y-å±éšœæœ‰ä½•é—®é¢˜ï¼Ÿ" class="headerlink" title="å•ç‹¬ä½¿ç”¨ Y å±éšœæœ‰ä½•é—®é¢˜ï¼Ÿ"></a>å•ç‹¬ä½¿ç”¨ Y å±éšœæœ‰ä½•é—®é¢˜ï¼Ÿ</h3><h3 id="æ··åˆå†™å±éšœæ˜¯æ€ä¹ˆä¸€å›äº‹ï¼Ÿ"><a href="#æ··åˆå†™å±éšœæ˜¯æ€ä¹ˆä¸€å›äº‹ï¼Ÿ" class="headerlink" title="æ··åˆå†™å±éšœæ˜¯æ€ä¹ˆä¸€å›äº‹ï¼Ÿ"></a>æ··åˆå†™å±éšœæ˜¯æ€ä¹ˆä¸€å›äº‹ï¼Ÿ</h3><h3 id="ååŠ©æ ‡è®°æµç¨‹"><a href="#ååŠ©æ ‡è®°æµç¨‹" class="headerlink" title="ååŠ©æ ‡è®°æµç¨‹"></a>ååŠ©æ ‡è®°æµç¨‹</h3><p>è¿™ä¸ªæ¶‰åŠåˆ° credit çš„æœºåˆ¶ï¼Œä¸€èˆ¬éƒ½æ˜¯ malloc ä¸­ credit ä¸å¤Ÿäº†ï¼Œæ‰è¿›è¡Œçš„ã€‚</p>
<h3 id="å¯¹è±¡çš„äº¤å‰å¼•ç”¨æ˜¯å¦‚ä½•å‰ªæçš„ï¼Ÿ"><a href="#å¯¹è±¡çš„äº¤å‰å¼•ç”¨æ˜¯å¦‚ä½•å‰ªæçš„ï¼Ÿ" class="headerlink" title="å¯¹è±¡çš„äº¤å‰å¼•ç”¨æ˜¯å¦‚ä½•å‰ªæçš„ï¼Ÿ"></a>å¯¹è±¡çš„äº¤å‰å¼•ç”¨æ˜¯å¦‚ä½•å‰ªæçš„ï¼Ÿ</h3><p>é€šè¿‡åŸå­æ“ä½œ <code>atomic.Or8</code> é¿å…äº†é‡å¤æ ‡è®°</p>
<h4 id="ä¸è¿ç®—"><a href="#ä¸è¿ç®—" class="headerlink" title="ä¸è¿ç®—"></a>ä¸è¿ç®—</h4><p>ä¸¤ä¸ªéƒ½æ˜¯ä¸€æ‰æ˜¯ä¸€</p>
<h4 id="æˆ–è¿ç®—"><a href="#æˆ–è¿ç®—" class="headerlink" title="æˆ–è¿ç®—"></a>æˆ–è¿ç®—</h4><p>æœ‰ä¸€ä¸ªæ˜¯ä¸€å°±æ˜¯ä¸€</p>
<h4 id="å¼‚æˆ–è¿ç®—"><a href="#å¼‚æˆ–è¿ç®—" class="headerlink" title="å¼‚æˆ–è¿ç®—"></a>å¼‚æˆ–è¿ç®—</h4><p>åŒé›¶å¼‚ä¸€</p>
<h3 id="GC-çš„-CPU-ä½¿ç”¨ç‡"><a href="#GC-çš„-CPU-ä½¿ç”¨ç‡" class="headerlink" title="GC çš„ CPU ä½¿ç”¨ç‡"></a>GC çš„ CPU ä½¿ç”¨ç‡</h3><ul>
<li>GC cpu ä½¿ç”¨ç‡ä¸»è¦ç”¨æ¥æ§åˆ¶ï¼Œå¯åŠ¨ mark worker çš„æ•°é‡</li>
</ul>
<p>mark worker count = gomaxprocs * 25%</p>
<p>å¦‚æœ gomaxprocs = 4ï¼Œé‚£ä¹ˆåªéœ€è¦å¯åŠ¨ä¸€ä¸ª markworker</p>
<p>å¯¹äºè®¡ç®—ç»“æœä¸ä¸ºæ•´æ•°çš„æƒ…å†µï¼Œæ¯”å¦‚ gomaxprocs = 6ï¼Œé‚£ä¹ˆ work count  = 1.5ï¼Œä¼šå¯¹ç»“æœ + 0.5 è¿›è¡Œ roundingï¼Œ ç„¶åé€šè¿‡è®¡ç®—è¯¯å·®æ˜¯å¦ &gt; 0.3 åˆ¤æ–­å¼€å‡ ä¸ªå…¨èŒ worker</p>
<p>2/1.5 -1 = 1/3 &gt; 0.3</p>
<h3 id="gcTriggerKind"><a href="#gcTriggerKind" class="headerlink" title="gcTriggerKind"></a>gcTriggerKind</h3><p>gc è§¦å‘ç±»å‹ï¼š</p>
<ul>
<li>gcTriggerHeap å†…å­˜åˆ°è¾¾é˜ˆå€¼</li>
<li>gcTriggerTime åˆ°è¾¾è§¦å‘æ—¶é—´</li>
<li>gcTriggerCycle å¯ä»¥ç†è§£ä¸ºç”¨æˆ·æ‰‹åŠ¨è§¦å‘ç±»å‹</li>
</ul>
<h3 id="STW-æ—¶é—´æ€ä¹ˆç®—å‡ºæ¥çš„ï¼Ÿ"><a href="#STW-æ—¶é—´æ€ä¹ˆç®—å‡ºæ¥çš„ï¼Ÿ" class="headerlink" title="STW æ—¶é—´æ€ä¹ˆç®—å‡ºæ¥çš„ï¼Ÿ"></a>STW æ—¶é—´æ€ä¹ˆç®—å‡ºæ¥çš„ï¼Ÿ</h3><h3 id="GC-è¿‡ç¨‹ä¸­æ˜¯ä»€ä¹ˆæ—¶å€™å°†å¯¹è±¡æ ‡è®°ä¸ºé»‘è‰²çš„"><a href="#GC-è¿‡ç¨‹ä¸­æ˜¯ä»€ä¹ˆæ—¶å€™å°†å¯¹è±¡æ ‡è®°ä¸ºé»‘è‰²çš„" class="headerlink" title="GC è¿‡ç¨‹ä¸­æ˜¯ä»€ä¹ˆæ—¶å€™å°†å¯¹è±¡æ ‡è®°ä¸ºé»‘è‰²çš„"></a>GC è¿‡ç¨‹ä¸­æ˜¯ä»€ä¹ˆæ—¶å€™å°†å¯¹è±¡æ ‡è®°ä¸ºé»‘è‰²çš„</h3><p>æ¢å¥è¯è¯´ï¼Œæ˜¯é€šè¿‡ä¿®æ”¹äº†ä»€ä¹ˆå˜é‡ï¼Œå°±ä»£è¡¨è¿™ä¸ªæŒ‡é’ˆè¢«æ ‡è®°ä¸ºé»‘è‰²ã€‚</p>
<p>è§£é‡Šå¦‚ä¸‹ï¼š</p>
<p>â€‹    é€šè¿‡æºç åˆ†æï¼Œæˆ‘ä»¬å¯ä»¥çŸ¥é“ï¼Œä»ç™½è‰²å¯¹è±¡åˆ°ç°è‰²å¯¹è±¡æ˜¯é€šè¿‡ greyobject æ¥å®ç°çš„ï¼ŒåŒäº‹ä¹Ÿèƒ½å¤ŸçŸ¥é“åœ¨ gcw é˜Ÿåˆ—ä¸­çš„å¯¹è±¡éƒ½æ˜¯ç°è‰²çš„ã€‚</p>
<p>â€‹    æ ‡è®°ä¸ºé»‘è‰²çš„è¿‡ç¨‹æ˜¯ä» gcw é˜Ÿåˆ—ä¸­å–å‡ºç°è‰²å¯¹è±¡ï¼Œå†éå†å…¶å­å¯¹è±¡å¹¶å°†å…¶æ ‡ç°ï¼Œä¹Ÿå³æ˜¯è¯´å½“ç°è‰²å¯¹è±¡å‡ºé˜Ÿçš„æ—¶å€™å°±è‡ªåŠ¨å˜æˆé»‘è‰²äº†ï¼Œå°±å®Œæˆäº†å°†ä¸€ä¸ªç°è‰²å¯¹è±¡æ ‡è®°ä½é»‘è‰²çš„è¿‡ç¨‹ï¼Œåœ¨ Go çš„æºç ä¸­ï¼Œå…¶å®å¹¶ä¸å­˜åœ¨çš„æŸä¸ªæ–¹æ³•æˆ–è€…æŸä¸ªæ ‡å¿—ä½ï¼Œæ¥è¡¨ç¤ºä¸€ä¸ªå¯¹è±¡æ˜¯é»‘è‰²çš„ã€‚</p>
<h2 id="gcStart-æºç å‰–æ"><a href="#gcStart-æºç å‰–æ" class="headerlink" title="gcStart æºç å‰–æ"></a>gcStart æºç å‰–æ</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// gcStart starts the GC. It transitions from _GCoff to _GCmark (if</span></span><br><span class="line"><span class="comment">// debug.gcstoptheworld == 0) or performs all of GC (if</span></span><br><span class="line"><span class="comment">// debug.gcstoptheworld != 0).</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This may return without performing this transition in some cases,</span></span><br><span class="line"><span class="comment">// such as when called on a system stack or with locks held.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// gcStart æ˜¯ GC çš„èµ·ç‚¹ï¼Œå¹¶å°† GC çš„çŠ¶æ€ç”± _GCoff åˆ‡æ¢åˆ° _GCmarkï¼Œ</span></span><br><span class="line"><span class="comment">// å¦‚æœ gcStart åœ¨ç³»ç»Ÿæ ˆä¸Šè¢«è°ƒç”¨æˆ–è€…æŒæœ‰é”çš„æ—¶å€™ï¼Œå°±ä¸ä¼šæ‰§è¡ŒçŠ¶æ€çš„æ”¹å˜ç›´æ¥è¿”å›äº†ã€‚</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcStart</span><span class="params">(trigger gcTrigger)</span></span> &#123;</span><br><span class="line">    <span class="comment">// Since this is called from malloc and malloc is called in</span></span><br><span class="line">    <span class="comment">// the guts of a number of libraries that might be holding</span></span><br><span class="line">    <span class="comment">// locks, don&#x27;t attempt to start GC in non-preemptible or</span></span><br><span class="line">    <span class="comment">// potentially unstable situations.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// å¦‚æœ gcStart æ˜¯ä» malloc è°ƒç”¨çš„ï¼Œå¹¶ä¸” malloc åˆæ˜¯è¢«å…¶ä»–çš„åº“è°ƒç”¨çš„ï¼Œ</span></span><br><span class="line">    <span class="comment">// è¿™ç§æƒ…å†µä¸‹å¯èƒ½ä¼šæŒæœ‰é”ï¼ˆmp.locks &gt; 1ï¼‰</span></span><br><span class="line">    <span class="comment">// ä¸è¦å†éæŠ¢å æˆ–è€…ä¸ç¨³å®šçš„æƒ…å†µä¸‹è°ƒç”¨ gcStart</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       æˆ‘çš„ç†è§£ï¼šå¦‚æœä¸æ˜¯éæŠ¢å æ¨¡å¼ï¼Œå¯èƒ½ä¼šå¯¼è‡´åé¢ stw æ—¶ï¼Œä¸€äº› g æ²¡æœ‰åŠæ³•åœæ­¢</span></span><br><span class="line"><span class="comment">       ä¼šå½±å“ GC çš„ç»“æœã€‚</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    mp := acquirem()</span><br><span class="line">    <span class="comment">// mp.locks &gt; 1 è¯´æ˜åœ¨ gcStart ä¹‹å‰å°±æŒæœ‰é”</span></span><br><span class="line">    <span class="comment">// mp.preemptoff != &quot;&quot; è¯´æ˜åœ¨ non-preempt æ¨¡å¼ä¸‹</span></span><br><span class="line">    <span class="keyword">if</span> gp := getg(); gp == mp.g0 || mp.locks &gt; <span class="number">1</span> || mp.preemptoff != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        releasem(mp)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    releasem(mp)</span><br><span class="line">    mp = <span class="literal">nil</span>	</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Pick up the remaining unswept/not being swept spans concurrently</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// This shouldn&#x27;t happen if we&#x27;re being invoked in background</span></span><br><span class="line">    <span class="comment">// mode since proportional sweep should have just finished</span></span><br><span class="line">    <span class="comment">// sweeping everything, but rounding errors, etc, may leave a</span></span><br><span class="line">    <span class="comment">// few spans unswept. In forced mode, this is necessary since</span></span><br><span class="line">    <span class="comment">// GC can be forced at any point in the sweeping cycle.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// We check the transition condition continuously here in case</span></span><br><span class="line">    <span class="comment">// this G gets delayed in to the next GC cycle.</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        trigger.test() æ£€æµ‹æ˜¯å¦æ»¡è¶³ GC çš„è§¦å‘æ¡ä»¶</span></span><br><span class="line"><span class="comment">        sweepone() æˆ‘çš„ç†è§£æ˜¯ï¼šæ¸…æ‰«ä¸Šæ¬¡ GC é—ç•™ä¸‹æ¥çš„ unswept çš„ span</span></span><br><span class="line"><span class="comment">        ï¼Ÿï¼Ÿ æ˜¯å¦å¯ä»¥ç†è§£æˆ sweep termination çš„é˜¶æ®µ </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">for</span> trigger.test() &amp;&amp; sweepone() != ^<span class="keyword">uintptr</span>(<span class="number">0</span>) &#123;</span><br><span class="line">        sweep.nbgsweep++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Perform GC initialization and the sweep termination</span></span><br><span class="line">    <span class="comment">// transition.</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	semaacquire çš„æ“ä½œï¼Œæ˜¯å¦å¯ä»¥ç†è§£ä¸ºï¼Œé€šè¿‡ atomic å»æ‰äº†é”ã€‚</span></span><br><span class="line"><span class="comment">		æ¢å¥è¯è¯´ï¼Œåªæœ‰è·å–äº†æŸä¸ª semaï¼Œæ‰èƒ½å¯¹ gc çŠ¶æ€è¿›è¡Œä¿®æ”¹ã€‚</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    semacquire(&amp;work.startSema)</span><br><span class="line">    <span class="comment">// Re-check transition condition under transition lock.</span></span><br><span class="line">    <span class="keyword">if</span> !trigger.test() &#123;</span><br><span class="line">        semrelease(&amp;work.startSema)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// For stats, check if this GC was forced by the user.</span></span><br><span class="line">    work.userForced = trigger.kind == gcTriggerCycle</span><br><span class="line"></span><br><span class="line">    <span class="comment">// In gcstoptheworld debug mode, upgrade the mode accordingly.</span></span><br><span class="line">    <span class="comment">// We do this after re-checking the transition condition so</span></span><br><span class="line">    <span class="comment">// that multiple goroutines that detect the heap trigger don&#x27;t</span></span><br><span class="line">    <span class="comment">// start multiple STW GCs.</span></span><br><span class="line">    <span class="comment">// å¦‚æœæ²¡å¼€å¯ GODEBUG éƒ½æ˜¯ gcBackgroundMode æ¨¡å¼</span></span><br><span class="line">    mode := gcBackgroundMode</span><br><span class="line">    <span class="keyword">if</span> debug.gcstoptheworld == <span class="number">1</span> &#123;</span><br><span class="line">        mode = gcForceMode</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> debug.gcstoptheworld == <span class="number">2</span> &#123;</span><br><span class="line">        mode = gcForceBlockMode</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ok, we&#x27;re doing it! Stop everybody else</span></span><br><span class="line">    <span class="comment">// è·å– STW éœ€è¦çš„ semaphore</span></span><br><span class="line">    semacquire(&amp;gcsema)</span><br><span class="line">    semacquire(&amp;worldsema)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">        traceGCStart()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check that all Ps have finished deferred mcache flushes.</span></span><br><span class="line">    <span class="comment">// TODO æ£€æŸ¥ P çš„ mcache</span></span><br><span class="line">    <span class="keyword">for</span> _, p := <span class="keyword">range</span> allp &#123;</span><br><span class="line">        <span class="keyword">if</span> fg := atomic.Load(&amp;p.mcache.flushGen); fg != mheap_.sweepgen &#123;</span><br><span class="line">            <span class="built_in">println</span>(<span class="string">&quot;runtime: p&quot;</span>, p.id, <span class="string">&quot;flushGen&quot;</span>, fg, <span class="string">&quot;!= sweepgen&quot;</span>, mheap_.sweepgen)</span><br><span class="line">            throw(<span class="string">&quot;p mcache not flushed&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// å¼€å¯ nproc ä¸ª gcMarkWorkerï¼ŒåŠ å…¥åˆ° workerPool ä¸­</span></span><br><span class="line">    <span class="comment">// åˆ›å»ºå®Œä¸€ä¸ª workerï¼Œä¼‘çœ ä¸€ä¸ª worker</span></span><br><span class="line">    <span class="comment">// ç”± schedule.findRunnableGCWorker å”¤é†’</span></span><br><span class="line">    gcBgMarkStartWorkers()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// é‡ç½®æ ‡å¿—ä½ï¼Œallg çš„æ ‡å¿—ä½ï¼ŒheapArena çš„æ ‡å¿—ä½</span></span><br><span class="line">    <span class="comment">// æ¸…ç©ºäº†æ¯ä¸€ä¸ª g çš„ AssistBytes</span></span><br><span class="line">    systemstack(gcResetMarkState)</span><br><span class="line"></span><br><span class="line">    work.stwprocs, work.maxprocs = gomaxprocs, gomaxprocs</span><br><span class="line">    <span class="keyword">if</span> work.stwprocs &gt; ncpu &#123;</span><br><span class="line">        <span class="comment">// This is used to compute CPU time of the STW phases,</span></span><br><span class="line">        <span class="comment">// so it can&#x27;t be more than ncpu, even if GOMAXPROCS is.</span></span><br><span class="line">        work.stwprocs = ncpu</span><br><span class="line">    &#125;</span><br><span class="line">    work.heap0 = atomic.Load64(&amp;memstats.heap_live)</span><br><span class="line">    work.pauseNS = <span class="number">0</span></span><br><span class="line">    work.mode = mode</span><br><span class="line"></span><br><span class="line">    now := nanotime()</span><br><span class="line">    work.tSweepTerm = now</span><br><span class="line">    work.pauseStart = now</span><br><span class="line">    <span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">        traceGCSTWStart(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// STW è°ƒç”¨è€…å¿…é¡»ä¸º stopTheWorldWithSema è·å– worldsema å¹¶ä¸” å…³é—­æŠ¢å </span></span><br><span class="line">    systemstack(stopTheWorldWithSema)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Finish sweep before we start concurrent scan.</span></span><br><span class="line">    <span class="comment">// ç¡®ä¿æœ¬æ¬¡ GC å¼€å§‹æ—¶ï¼Œå·²å®Œæˆä¸Šä¸€æ¬¡ GC çš„ sweep å·¥ä½œ</span></span><br><span class="line">    systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        finishsweep_m()</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// clearpools before we start the GC. If we wait they memory will not be</span></span><br><span class="line">    <span class="comment">// reclaimed until the next GC cycle.</span></span><br><span class="line">    <span class="comment">// 1.å¤„ç† sync.Pool</span></span><br><span class="line">    <span class="comment">// 2.æ¸…ç©º sudog cache</span></span><br><span class="line">    <span class="comment">// 3.æ¸…ç©º defer pools</span></span><br><span class="line">    clearpools()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// å¢åŠ  gc å‘¨æœŸæ•°</span></span><br><span class="line">    work.cycles++</span><br><span class="line"></span><br><span class="line">    <span class="comment">// å¼€å§‹æœ¬æ¬¡ gc å‘¨æœŸ</span></span><br><span class="line">    gcController.startCycle()</span><br><span class="line">    work.heapGoal = memstats.next_gc</span><br><span class="line"></span><br><span class="line">    <span class="comment">// In STW mode, disable scheduling of user Gs. This may also</span></span><br><span class="line">    <span class="comment">// disable scheduling of this goroutine, so it may block as</span></span><br><span class="line">    <span class="comment">// soon as we start the world again.</span></span><br><span class="line">    <span class="keyword">if</span> mode != gcBackgroundMode &#123;</span><br><span class="line">        schedEnableUser(<span class="literal">false</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Enter concurrent mark phase and enable</span></span><br><span class="line">    <span class="comment">// write barriers.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Because the world is stopped, all Ps will</span></span><br><span class="line">    <span class="comment">// observe that write barriers are enabled by</span></span><br><span class="line">    <span class="comment">// the time we start the world and begin</span></span><br><span class="line">    <span class="comment">// scanning.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Write barriers must be enabled before assists are</span></span><br><span class="line">    <span class="comment">// enabled because they must be enabled before</span></span><br><span class="line">    <span class="comment">// any non-leaf heap objects are marked. Since</span></span><br><span class="line">    <span class="comment">// allocations are blocked until assists can</span></span><br><span class="line">    <span class="comment">// happen, we want enable assists as early as</span></span><br><span class="line">    <span class="comment">// possible.</span></span><br><span class="line">    setGCPhase(_GCmark)</span><br><span class="line"></span><br><span class="line">    gcBgMarkPrepare() <span class="comment">// Must happen before assist enable.</span></span><br><span class="line">    gcMarkRootPrepare()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Mark all active tinyalloc blocks. Since we&#x27;re</span></span><br><span class="line">    <span class="comment">// allocating from these, they need to be black like</span></span><br><span class="line">    <span class="comment">// other allocations. The alternative is to blacken</span></span><br><span class="line">    <span class="comment">// the tiny block on every allocation from it, which</span></span><br><span class="line">    <span class="comment">// would slow down the tiny allocator.</span></span><br><span class="line">    gcMarkTinyAllocs()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// At this point all Ps have enabled the write</span></span><br><span class="line">    <span class="comment">// barrier, thus maintaining the no white to</span></span><br><span class="line">    <span class="comment">// black invariant. Enable mutator assists to</span></span><br><span class="line">    <span class="comment">// put back-pressure on fast allocating</span></span><br><span class="line">    <span class="comment">// mutators.</span></span><br><span class="line">    atomic.Store(&amp;gcBlackenEnabled, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Assists and workers can start the moment we start</span></span><br><span class="line">    <span class="comment">// the world.</span></span><br><span class="line">    gcController.markStartTime = now</span><br><span class="line"></span><br><span class="line">    <span class="comment">// In STW mode, we could block the instant systemstack</span></span><br><span class="line">    <span class="comment">// returns, so make sure we&#x27;re not preemptible.</span></span><br><span class="line">    mp = acquirem()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Concurrent mark.</span></span><br><span class="line">    systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        now = startTheWorldWithSema(trace.enabled)</span><br><span class="line">        work.pauseNS += now - work.pauseStart</span><br><span class="line">        work.tMark = now</span><br><span class="line">        memstats.gcPauseDist.record(now - work.pauseStart)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Release the world sema before Gosched() in STW mode</span></span><br><span class="line">    <span class="comment">// because we will need to reacquire it later but before</span></span><br><span class="line">    <span class="comment">// this goroutine becomes runnable again, and we could</span></span><br><span class="line">    <span class="comment">// self-deadlock otherwise.</span></span><br><span class="line">    semrelease(&amp;worldsema)</span><br><span class="line">    releasem(mp)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure we block instead of returning to user code</span></span><br><span class="line">    <span class="comment">// in STW mode.</span></span><br><span class="line">    <span class="keyword">if</span> mode != gcBackgroundMode &#123;</span><br><span class="line">        Gosched()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    semrelease(&amp;work.startSema)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="findRunnableGCWorker-æºç å‰–æ"><a href="#findRunnableGCWorker-æºç å‰–æ" class="headerlink" title="findRunnableGCWorker æºç å‰–æ"></a>findRunnableGCWorker æºç å‰–æ</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// findRunnableGCWorker returns a background mark worker for _p_ if it</span></span><br><span class="line"><span class="comment">// should be run. This must only be called when gcBlackenEnabled != 0.</span></span><br><span class="line"><span class="comment">// åªæœ‰åœ¨ gc å¼€å¯çš„æ—¶å€™æ‰ä¼šæ‰§è¡Œï¼ŒgcStart ä¸­è®¾ç½®ä¸º 1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *gcControllerState)</span> <span class="title">findRunnableGCWorker</span><span class="params">(_p_ *p)</span> *<span class="title">g</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> gcBlackenEnabled == <span class="number">0</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;gcControllerState.findRunnable: blackening not enabled&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> !gcMarkWorkAvailable(_p_) &#123;</span><br><span class="line">        <span class="comment">// No work to be done right now. This can happen at</span></span><br><span class="line">        <span class="comment">// the end of the mark phase when there are still</span></span><br><span class="line">        <span class="comment">// assists tapering off. Don&#x27;t bother running a worker</span></span><br><span class="line">        <span class="comment">// now because it&#x27;ll just return immediately.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Grab a worker before we commit to running below.</span></span><br><span class="line">    <span class="comment">// ä» workpool ä¸­å¼¹å‡ºä¸€ä¸ª gcMarkWorker</span></span><br><span class="line">    node := (*gcBgMarkWorkerNode)(gcBgMarkWorkerPool.pop())</span><br><span class="line">    <span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// There is at least one worker per P, so normally there are</span></span><br><span class="line">        <span class="comment">// enough workers to run on all Ps, if necessary. However, once</span></span><br><span class="line">        <span class="comment">// a worker enters gcMarkDone it may park without rejoining the</span></span><br><span class="line">        <span class="comment">// pool, thus freeing a P with no corresponding worker.</span></span><br><span class="line">        <span class="comment">// gcMarkDone never depends on another worker doing work, so it</span></span><br><span class="line">        <span class="comment">// is safe to simply do nothing here.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// If gcMarkDone bails out without completing the mark phase,</span></span><br><span class="line">        <span class="comment">// it will always do so with queued global work. Thus, that P</span></span><br><span class="line">        <span class="comment">// will be immediately eligible to re-run the worker G it was</span></span><br><span class="line">        <span class="comment">// just using, ensuring work can complete.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ç”¨äºè®¡ç®—è¯¥ markNode çš„å·¥ä½œæ¨¡å¼</span></span><br><span class="line">    <span class="comment">// &gt;  0 dedicatedMode</span></span><br><span class="line">    <span class="comment">// &lt;= 0 fractionalMode</span></span><br><span class="line">    decIfPositive := <span class="function"><span class="keyword">func</span><span class="params">(ptr *<span class="keyword">int64</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            v := atomic.Loadint64(ptr)</span><br><span class="line">            <span class="keyword">if</span> v &lt;= <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> atomic.Casint64(ptr, v, v<span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> decIfPositive(&amp;c.dedicatedMarkWorkersNeeded) &#123;</span><br><span class="line">        <span class="comment">// This P is now dedicated to marking until the end of</span></span><br><span class="line">        <span class="comment">// the concurrent mark phase.</span></span><br><span class="line">        _p_.gcMarkWorkerMode = gcMarkWorkerDedicatedMode</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> c.fractionalUtilizationGoal == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// No need for fractional workers.</span></span><br><span class="line">        gcBgMarkWorkerPool.push(&amp;node.node)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Is this P behind on the fractional utilization</span></span><br><span class="line">        <span class="comment">// goal?</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// This should be kept in sync with pollFractionalWorkerExit.</span></span><br><span class="line">        delta := nanotime() - c.markStartTime</span><br><span class="line">        <span class="keyword">if</span> delta &gt; <span class="number">0</span> &amp;&amp; <span class="keyword">float64</span>(_p_.gcFractionalMarkTime)/<span class="keyword">float64</span>(delta) &gt; c.fractionalUtilizationGoal &#123;</span><br><span class="line">            <span class="comment">// Nope. No need to run a fractional worker.</span></span><br><span class="line">            gcBgMarkWorkerPool.push(&amp;node.node)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Run a fractional worker.</span></span><br><span class="line">        _p_.gcMarkWorkerMode = gcMarkWorkerFractionalMode</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Run the background mark worker.</span></span><br><span class="line">    <span class="comment">// ä¿®æ”¹ workerg çš„çŠ¶æ€å¹¶è¿”å›</span></span><br><span class="line">    gp := node.gp.ptr()</span><br><span class="line">    casgstatus(gp, _Gwaiting, _Grunnable)</span><br><span class="line">    <span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">        traceGoUnpark(gp, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> gp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// gcMarkWorkAvailable reports whether executing a mark worker</span></span><br><span class="line"><span class="comment">// on p is potentially useful. p may be nil, in which case it only</span></span><br><span class="line"><span class="comment">// checks the global sources of work.</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	è¯¥å‡½æ•°ä¸»è¦ä½œç”¨ï¼šè¿”å›æ˜¯å¦æœ‰æ ‡è®°å·¥ä½œå¯ä»¥å¹²</span></span><br><span class="line"><span class="comment">	gcw pçš„é˜Ÿåˆ—</span></span><br><span class="line"><span class="comment">	work å…¨å±€é˜Ÿåˆ—</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcMarkWorkAvailable</span><span class="params">(p *p)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> p != <span class="literal">nil</span> &amp;&amp; !p.gcw.empty() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> !work.full.empty() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span> <span class="comment">// global work available</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> work.markrootNext &lt; work.markrootJobs &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span> <span class="comment">// root scan work available</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="å‰–æ-gcBgMarkWorker-åˆ›å»ºè¿‡ç¨‹"><a href="#å‰–æ-gcBgMarkWorker-åˆ›å»ºè¿‡ç¨‹" class="headerlink" title="å‰–æ gcBgMarkWorker åˆ›å»ºè¿‡ç¨‹"></a>å‰–æ gcBgMarkWorker åˆ›å»ºè¿‡ç¨‹</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// gcBgMarkStartWorkers prepares background mark worker goroutines. These</span></span><br><span class="line"><span class="comment">// goroutines will not run until the mark phase, but they must be started while</span></span><br><span class="line"><span class="comment">// the work is not stopped and from a regular G stack. The caller must hold</span></span><br><span class="line"><span class="comment">// worldsema.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcBgMarkStartWorkers</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Background marking is performed by per-P G&#x27;s. Ensure that each P has</span></span><br><span class="line">    <span class="comment">// a background GC G.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Worker Gs don&#x27;t exit if gomaxprocs is reduced. If it is raised</span></span><br><span class="line">    <span class="comment">// again, we can reuse the old workers; no need to create new workers.</span></span><br><span class="line">    <span class="keyword">for</span> gcBgMarkWorkerCount &lt; gomaxprocs &#123;</span><br><span class="line">        <span class="keyword">go</span> gcBgMarkWorker()</span><br><span class="line"></span><br><span class="line">        notetsleepg(&amp;work.bgMarkReady, <span class="number">-1</span>)</span><br><span class="line">        noteclear(&amp;work.bgMarkReady)</span><br><span class="line">        <span class="comment">// The worker is now guaranteed to be added to the pool before</span></span><br><span class="line">        <span class="comment">// its P&#x27;s next findRunnableGCWorker.</span></span><br><span class="line"></span><br><span class="line">        gcBgMarkWorkerCount++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>ç”±ä¸Šå¯çŸ¥ï¼Œæ‰€æœ‰ gcMarkWorker éƒ½æ˜¯é€šè¿‡è¯¥å‡½æ•°åˆ›å»ºçš„ï¼Œæˆ‘ä»¬éœ€è¦å…³æ³¨çš„æ˜¯ <code>notesleepg()</code> å’Œ <code>go gcBgMarkWorker</code> è¿™ä¸¤è¡Œä»£ç </li>
</ul>
<h3 id="notesleepg"><a href="#notesleepg" class="headerlink" title="notesleepg"></a><code>notesleepg</code></h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// same as runtimeÂ·notetsleep, but called on user g (not g0)</span></span><br><span class="line"><span class="comment">// calls only nosplit functions between entersyscallblock/exitsyscall</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">notetsleepg</span><span class="params">(n *note, ns <span class="keyword">int64</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    gp := getg()</span><br><span class="line">    <span class="keyword">if</span> gp == gp.m.g0 &#123;</span><br><span class="line">        throw(<span class="string">&quot;notetsleepg on g0&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// è¿™ä¸ªæˆ‘ä»¬åœ¨å­¦ä¹  timer çš„æ—¶å€™å·²ç»çœ‹è¿‡äº†</span></span><br><span class="line">    <span class="comment">// ä¸»è¦å°±æ˜¯æ‰§è¡Œ handoff</span></span><br><span class="line">    entersyscallblock()</span><br><span class="line">    <span class="comment">// è¿™é‡Œæ‰æ˜¯çœŸæ­£è¿›è¡Œç³»ç»Ÿè°ƒç”¨çš„åœ°æ–¹ï¼Œns = -1ï¼Œä¼šæ— ä¼‘æ­¢çš„ä¼‘çœ </span></span><br><span class="line">    <span class="comment">// ç›´åˆ°é€šè¿‡ wakeup å”¤é†’</span></span><br><span class="line">    ok := notetsleep_internal(n, ns)</span><br><span class="line">    <span class="comment">// ä¸Šè¿°ï¼Œé€šè¿‡ wakeup å”¤é†’åä¼šç»§ç»­æ‰§è¡Œè¿™å—ä»£ç </span></span><br><span class="line">    <span class="comment">// è¯¥å‡½æ•°ä¸»è¦æ˜¯ç»™åˆšåˆšå‰¥ç¦»çš„ GM æ‰¾ä¸€ä¸ª P</span></span><br><span class="line">    <span class="comment">// æ‰¾åˆ°äº†ï¼Œæ‰§è¡Œ</span></span><br><span class="line">    <span class="comment">// æ²¡æ‰¾åˆ°ï¼ŒæŠŠ g æ”¾åˆ°å…¨å±€é˜Ÿåˆ—</span></span><br><span class="line">    exitsyscall()</span><br><span class="line">    <span class="keyword">return</span> ok</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="go-gcBgMarkWorker"><a href="#go-gcBgMarkWorker" class="headerlink" title="go gcBgMarkWorker"></a><code>go gcBgMarkWorker</code></h3><ul>
<li>è¿™é‡Œåº”ç”¨åˆ° MPG è°ƒåº¦çš„çŸ¥è¯†ç‚¹ï¼Œæˆ‘ä»¬é€šè¿‡ go å…³é”®å­—æ–°å»ºä¸€ä¸ª goroutineï¼Œæ”¾å…¥ runnext ç­‰å¾…è¢«è°ƒåº¦ã€‚</li>
</ul>
<h3 id="ç»“åˆç€çœ‹"><a href="#ç»“åˆç€çœ‹" class="headerlink" title="ç»“åˆç€çœ‹"></a>ç»“åˆç€çœ‹</h3><p>æˆ‘ä»¬å‡è®¾ç°åœ¨åªæœ‰ä¸€ä¸ª Pï¼Œå³ <code>runtime.GOMAXPROCS(1)</code> ã€‚è¿™æ—¶æˆ‘ä»¬æ¥çœ‹ä¸Šè¿°ä»£ç ï¼Œå…¶æ‰§è¡Œè¿‡ç¨‹ä¸ºï¼š</p>
<ul>
<li>1.é€šè¿‡ <code>gcBgMarkStartWorkers</code> åˆ›å»º worker</li>
<li>2.worker è¢«æ”¾å…¥ runnext ç­‰å¾…è¢«è°ƒåº¦</li>
<li>3.æ‰§è¡Œ <code>notesleepg</code><ul>
<li>handoffp</li>
<li>futex &amp;&amp; timeout = -1</li>
<li>ç¬¬ 3 æ­¥æ‰§è¡Œå®Œæˆåï¼ŒGM å·²ç»ä» P ä¸Šå‰¥ç¦»</li>
</ul>
</li>
<li>4.handoffp ä¸­ä¼šå¯åŠ¨ä¸€ä¸ª M ç»§ç»­æ‰§è¡Œè°ƒåº¦å¾ªç¯</li>
<li>5.newM ä» P ä¸Šæ‰¾ G æ‰§è¡Œ</li>
<li>6.æ‹¿åˆ°æˆ‘ä»¬åˆšåˆšåˆ›å»ºçš„ newg</li>
<li>7.è¿›å…¥åˆ° <code>gcBgMarkWorker()</code> ä¸­æ‰§è¡Œ<ul>
<li>æ–°å»º node &amp;&amp; <strong>wakeup</strong> ä¼‘çœ çš„ GM</li>
<li>ç„¶å <code>gopark</code> æŒ‚èµ· worker ç­‰å¾…å”¤é†’</li>
</ul>
</li>
<li>8.ä¼‘çœ çš„ GM é†’æ¥å<ul>
<li>å°è¯•è·å– oldp</li>
<li>å¦‚æœè·å–ä¸åˆ°åˆ™ï¼Œå°è¯•è·å– idlep</li>
<li>å¦‚æœè·å–ä¸åˆ°åˆ™ï¼Œå°† g æ”¾å…¥å…¨å±€é˜Ÿåˆ—</li>
</ul>
</li>
<li>9.ç¬¬ 8 æ­¥ä¸­çš„ g è¢«è°ƒåº¦åï¼Œä¼šç»§ç»­æ‰§è¡Œ create worker çš„å·¥ä½œï¼Œå›åˆ°ç¬¬ 1 æ­¥ ç»§ç»­æ‰§è¡Œ</li>
</ul>
<h2 id="gcMarkWorker-æ‰§è¡Œè¿‡ç¨‹"><a href="#gcMarkWorker-æ‰§è¡Œè¿‡ç¨‹" class="headerlink" title="gcMarkWorker æ‰§è¡Œè¿‡ç¨‹"></a>gcMarkWorker æ‰§è¡Œè¿‡ç¨‹</h2><h3 id="gcBgMarkWorker-æºç å‰–æ"><a href="#gcBgMarkWorker-æºç å‰–æ" class="headerlink" title="gcBgMarkWorker æºç å‰–æ"></a>gcBgMarkWorker æºç å‰–æ</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcBgMarkWorker</span><span class="params">()</span></span> &#123;</span><br><span class="line">    gp := getg()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We pass node to a gopark unlock function, so it can&#x27;t be on</span></span><br><span class="line">    <span class="comment">// the stack (see gopark). Prevent deadlock from recursively</span></span><br><span class="line">    <span class="comment">// starting GC by disabling preemption.</span></span><br><span class="line">    gp.m.preemptoff = <span class="string">&quot;GC worker init&quot;</span></span><br><span class="line">    node := <span class="built_in">new</span>(gcBgMarkWorkerNode)</span><br><span class="line">    gp.m.preemptoff = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    node.gp.set(gp)</span><br><span class="line"></span><br><span class="line">    node.m.set(acquirem())</span><br><span class="line">    notewakeup(&amp;work.bgMarkReady)</span><br><span class="line">    <span class="comment">// After this point, the background mark worker is generally scheduled</span></span><br><span class="line">    <span class="comment">// cooperatively by gcController.findRunnableGCWorker. While performing</span></span><br><span class="line">    <span class="comment">// work on the P, preemption is disabled because we are working on</span></span><br><span class="line">    <span class="comment">// P-local work buffers. When the preempt flag is set, this puts itself</span></span><br><span class="line">    <span class="comment">// into _Gwaiting to be woken up by gcController.findRunnableGCWorker</span></span><br><span class="line">    <span class="comment">// at the appropriate time.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// When preemption is enabled (e.g., while in gcMarkDone), this worker</span></span><br><span class="line">    <span class="comment">// may be preempted and schedule as a _Grunnable G from a runq. That is</span></span><br><span class="line">    <span class="comment">// fine; it will eventually gopark again for further scheduling via</span></span><br><span class="line">    <span class="comment">// findRunnableGCWorker.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Since we disable preemption before notifying bgMarkReady, we</span></span><br><span class="line">    <span class="comment">// guarantee that this G will be in the worker pool for the next</span></span><br><span class="line">    <span class="comment">// findRunnableGCWorker. This isn&#x27;t strictly necessary, but it reduces</span></span><br><span class="line">    <span class="comment">// latency between _GCmark starting and the workers starting.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// Go to sleep until woken by</span></span><br><span class="line">        <span class="comment">// gcController.findRunnableGCWorker.</span></span><br><span class="line">        gopark(<span class="function"><span class="keyword">func</span><span class="params">(g *g, nodep unsafe.Pointer)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">            node := (*gcBgMarkWorkerNode)(nodep)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> mp := node.m.ptr(); mp != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="comment">// The worker G is no longer running; release</span></span><br><span class="line">                <span class="comment">// the M.</span></span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                <span class="comment">// N.B. it is _safe_ to release the M as soon</span></span><br><span class="line">                <span class="comment">// as we are no longer performing P-local mark</span></span><br><span class="line">                <span class="comment">// work.</span></span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                <span class="comment">// However, since we cooperatively stop work</span></span><br><span class="line">                <span class="comment">// when gp.preempt is set, if we releasem in</span></span><br><span class="line">                <span class="comment">// the loop then the following call to gopark</span></span><br><span class="line">                <span class="comment">// would immediately preempt the G. This is</span></span><br><span class="line">                <span class="comment">// also safe, but inefficient: the G must</span></span><br><span class="line">                <span class="comment">// schedule again only to enter gopark and park</span></span><br><span class="line">                <span class="comment">// again. Thus, we defer the release until</span></span><br><span class="line">                <span class="comment">// after parking the G.</span></span><br><span class="line">                releasem(mp)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Release this G to the pool.</span></span><br><span class="line">            gcBgMarkWorkerPool.push(&amp;node.node)</span><br><span class="line">            <span class="comment">// Note that at this point, the G may immediately be</span></span><br><span class="line">            <span class="comment">// rescheduled and may be running.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;, unsafe.Pointer(node), waitReasonGCWorkerIdle, traceEvGoBlock, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        	ä»¥ä¸Šä»£ç éƒ½å·²ç»è§£é‡Šè¿‡äº†</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        	TODO å…³äºåœ¨ GC æœŸé—´ä»€ä¹ˆæ—¶å€™å¯ä»¥æŠ¢å ï¼Œä»€ä¹ˆæ—¶å€™ç¦æ­¢æŠ¢å </span></span><br><span class="line"><span class="comment">        	è¿˜éœ€è¦è¿›ä¸€æ­¥ç ”ç©¶ï¼Œç›®å‰å¯ä»¥å…ˆæŠŠæ•´ä¸ªæµç¨‹æ¢³ç†ä¸‹æ¥</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Preemption must not occur here, or another G might see</span></span><br><span class="line">        <span class="comment">// p.gcMarkWorkerMode.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Disable preemption so we can use the gcw. If the</span></span><br><span class="line">        <span class="comment">// scheduler wants to preempt us, we&#x27;ll stop draining,</span></span><br><span class="line">        <span class="comment">// dispose the gcw, and then preempt.</span></span><br><span class="line">        node.m.set(acquirem())</span><br><span class="line">        pp := gp.m.p.ptr() <span class="comment">// P can&#x27;t change with preemption disabled.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// æ˜¯å¦å·²å¼€å¯æ ‡è®°</span></span><br><span class="line">        <span class="keyword">if</span> gcBlackenEnabled == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="built_in">println</span>(<span class="string">&quot;worker mode&quot;</span>, pp.gcMarkWorkerMode)</span><br><span class="line">            throw(<span class="string">&quot;gcBgMarkWorker: blackening not enabled&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// æ£€æŸ¥ markworker çš„ Mode</span></span><br><span class="line">        <span class="keyword">if</span> pp.gcMarkWorkerMode == gcMarkWorkerNotWorker &#123;</span><br><span class="line">            throw(<span class="string">&quot;gcBgMarkWorker: mode not set&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// è®°å½• worker æ ‡è®°çš„å¼€å§‹æ—¶é—´</span></span><br><span class="line">        startTime := nanotime()</span><br><span class="line">        pp.gcMarkWorkerStartTime = startTime</span><br><span class="line"></span><br><span class="line">        <span class="comment">// å°†ç­‰å¾…æ‰§è¡Œçš„ worker æ•°é‡å‡ä¸€</span></span><br><span class="line">        decnwait := atomic.Xadd(&amp;work.nwait, <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">if</span> decnwait == work.nproc &#123;</span><br><span class="line">            <span class="built_in">println</span>(<span class="string">&quot;runtime: work.nwait=&quot;</span>, decnwait, <span class="string">&quot;work.nproc=&quot;</span>, work.nproc)</span><br><span class="line">            throw(<span class="string">&quot;work.nwait was &gt; work.nproc&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="comment">// Mark our goroutine preemptible so its stack</span></span><br><span class="line">            <span class="comment">// can be scanned. This lets two mark workers</span></span><br><span class="line">            <span class="comment">// scan each other (otherwise, they would</span></span><br><span class="line">            <span class="comment">// deadlock). We must not modify anything on</span></span><br><span class="line">            <span class="comment">// the G stack. However, stack shrinking is</span></span><br><span class="line">            <span class="comment">// disabled for mark workers, so it is safe to</span></span><br><span class="line">            <span class="comment">// read from the G stack.</span></span><br><span class="line">            <span class="comment">// å…³äºè¿™é‡Œä¸ºä»€ä¹ˆæŠŠ G çš„ running çŠ¶æ€ä¿®æ”¹ä¸º waiting çŠ¶æ€</span></span><br><span class="line">            <span class="comment">// TODO éœ€è¦è¿›ä¸€æ­¥çš„ç ”ç©¶ï¼Œæ›¹å¤§è¯´è¦ç»“åˆ suspendG æ¥çœ‹</span></span><br><span class="line">            casgstatus(gp, _Grunning, _Gwaiting)</span><br><span class="line">            <span class="keyword">switch</span> pp.gcMarkWorkerMode &#123;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                	throw(<span class="string">&quot;gcBgMarkWorker: unexpected gcMarkWorkerMode&quot;</span>)</span><br><span class="line">                <span class="keyword">case</span> gcMarkWorkerDedicatedMode:</span><br><span class="line">                	gcDrain(&amp;pp.gcw, gcDrainUntilPreempt|gcDrainFlushBgCredit)</span><br><span class="line">                    <span class="keyword">if</span> gp.preempt &#123;</span><br><span class="line">                        <span class="comment">// We were preempted. This is</span></span><br><span class="line">                        <span class="comment">// a useful signal to kick</span></span><br><span class="line">                        <span class="comment">// everything out of the run</span></span><br><span class="line">                        <span class="comment">// queue so it can run</span></span><br><span class="line">                        <span class="comment">// somewhere else.</span></span><br><span class="line">                        <span class="keyword">if</span> drainQ, n := runqdrain(pp); n &gt; <span class="number">0</span> &#123;</span><br><span class="line">                            lock(&amp;sched.lock)</span><br><span class="line">                            globrunqputbatch(&amp;drainQ, <span class="keyword">int32</span>(n))</span><br><span class="line">                            unlock(&amp;sched.lock)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// Go back to draining, this time</span></span><br><span class="line">                    <span class="comment">// without preemption.</span></span><br><span class="line">                    gcDrain(&amp;pp.gcw, gcDrainFlushBgCredit)</span><br><span class="line">                <span class="keyword">case</span> gcMarkWorkerFractionalMode:</span><br><span class="line">                	gcDrain(&amp;pp.gcw, gcDrainFractional|gcDrainUntilPreempt|gcDrainFlushBgCredit)</span><br><span class="line">                <span class="keyword">case</span> gcMarkWorkerIdleMode:</span><br><span class="line">                	gcDrain(&amp;pp.gcw, gcDrainIdle|gcDrainUntilPreempt|gcDrainFlushBgCredit)</span><br><span class="line">            &#125;</span><br><span class="line">            casgstatus(gp, _Gwaiting, _Grunning)</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Account for time.</span></span><br><span class="line">        duration := nanotime() - startTime</span><br><span class="line">        <span class="keyword">switch</span> pp.gcMarkWorkerMode &#123;</span><br><span class="line">            <span class="keyword">case</span> gcMarkWorkerDedicatedMode:</span><br><span class="line">                atomic.Xaddint64(&amp;gcController.dedicatedMarkTime, duration)</span><br><span class="line">                atomic.Xaddint64(&amp;gcController.dedicatedMarkWorkersNeeded, <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">case</span> gcMarkWorkerFractionalMode:</span><br><span class="line">                atomic.Xaddint64(&amp;gcController.fractionalMarkTime, duration)</span><br><span class="line">                atomic.Xaddint64(&amp;pp.gcFractionalMarkTime, duration)</span><br><span class="line">            <span class="keyword">case</span> gcMarkWorkerIdleMode:</span><br><span class="line">                atomic.Xaddint64(&amp;gcController.idleMarkTime, duration)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Was this the last worker and did we run out</span></span><br><span class="line">        <span class="comment">// of work?</span></span><br><span class="line">        incnwait := atomic.Xadd(&amp;work.nwait, +<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> incnwait &gt; work.nproc &#123;</span><br><span class="line">            <span class="built_in">println</span>(<span class="string">&quot;runtime: p.gcMarkWorkerMode=&quot;</span>, pp.gcMarkWorkerMode,</span><br><span class="line">                    <span class="string">&quot;work.nwait=&quot;</span>, incnwait, <span class="string">&quot;work.nproc=&quot;</span>, work.nproc)</span><br><span class="line">            throw(<span class="string">&quot;work.nwait &gt; work.nproc&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We&#x27;ll releasem after this point and thus this P may run</span></span><br><span class="line">        <span class="comment">// something else. We must clear the worker mode to avoid</span></span><br><span class="line">        <span class="comment">// attributing the mode to a different (non-worker) G in</span></span><br><span class="line">        <span class="comment">// traceGoStart.</span></span><br><span class="line">        pp.gcMarkWorkerMode = gcMarkWorkerNotWorker</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If this worker reached a background mark completion</span></span><br><span class="line">        <span class="comment">// point, signal the main GC goroutine.</span></span><br><span class="line">        <span class="keyword">if</span> incnwait == work.nproc &amp;&amp; !gcMarkWorkAvailable(<span class="literal">nil</span>) &#123;</span><br><span class="line">            <span class="comment">// We don&#x27;t need the P-local buffers here, allow</span></span><br><span class="line">            <span class="comment">// preemption becuse we may schedule like a regular</span></span><br><span class="line">            <span class="comment">// goroutine in gcMarkDone (block on locks, etc).</span></span><br><span class="line">            releasem(node.m.ptr())</span><br><span class="line">            node.m.set(<span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">            gcMarkDone()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>gcMarkWorker çš„çŠ¶æ€ï¼ˆdedicated, fractionï¼‰è¿™ä¸ªçŠ¶æ€æ˜¯ç»‘å®šåœ¨ P ä¸Šï¼Œå¹¶ä¸æ˜¯ G çš„çŠ¶æ€ã€‚</li>
</ul>
<h3 id="GC-æ ‡è®°çš„å‡ ä¸ªå·¥ä½œæ¨¡å¼"><a href="#GC-æ ‡è®°çš„å‡ ä¸ªå·¥ä½œæ¨¡å¼" class="headerlink" title="GC æ ‡è®°çš„å‡ ä¸ªå·¥ä½œæ¨¡å¼"></a>GC æ ‡è®°çš„å‡ ä¸ªå·¥ä½œæ¨¡å¼</h3><ol>
<li>gcDrainFlushBgCredit: æŠŠ bgMarkWorker ç§¯ç´¯çš„ credit åˆ·æ–°åˆ°å…¨å±€çš„ gcController ä¸­ã€‚</li>
<li>gcDrainFractional: self-preempt è¡¨ç¤ºåœ¨è¾¾åˆ° fractional åè‡ªåŠ¨é€€å‡ºã€‚</li>
<li>gcDrainUntilPreempt: ä¸€ç›´æ‰§è¡Œï¼Œç›´åˆ°è¢«æŠ¢å ã€‚</li>
<li>gcDrainIdle: ä¸€ç›´æ‰§è¡Œï¼Œç›´åˆ°å…¶ä»–ä»»åŠ¡è¦åšã€‚</li>
</ol>
<h3 id="bitmap-ä¸-ha-çš„æ˜ å°„å…³ç³»ï¼ˆæ ‡è®°è¿‡ç¨‹ç”¨åˆ°çš„ä½å›¾ï¼‰"><a href="#bitmap-ä¸-ha-çš„æ˜ å°„å…³ç³»ï¼ˆæ ‡è®°è¿‡ç¨‹ç”¨åˆ°çš„ä½å›¾ï¼‰" class="headerlink" title="bitmap ä¸ ha çš„æ˜ å°„å…³ç³»ï¼ˆæ ‡è®°è¿‡ç¨‹ç”¨åˆ°çš„ä½å›¾ï¼‰"></a>bitmap ä¸ ha çš„æ˜ å°„å…³ç³»ï¼ˆæ ‡è®°è¿‡ç¨‹ç”¨åˆ°çš„ä½å›¾ï¼‰</h3><h4 id="bitmap-çš„ä½¿ç”¨"><a href="#bitmap-çš„ä½¿ç”¨" class="headerlink" title="bitmap çš„ä½¿ç”¨"></a>bitmap çš„ä½¿ç”¨</h4><p>ä¸¤ä¸ªæ¯”ç‰¹è¡¨ç¤ºä¸€ä¸ªå­—</p>
<p>ha 64 Mï¼Œbitmap 2 Mï¼Œbitmap ä¸­çš„ä¸€ä¸ªå­—èŠ‚å¯ä»¥è¡¨ç¤ºhaè¿ç»­4ä¸ªæŒ‡é’ˆçš„å†…å­˜å¤§å°ã€‚</p>
<p>0-4ï¼Œ1-5ï¼Œ 2-6ï¼Œ 3-7 </p>
<p>ä½ä½ bit ç”¨äºè¡¨ç¤ºæ˜¯å¦ä¸ºæŒ‡é’ˆï¼Œ0 ä¸ºéæŒ‡é’ˆï¼Œ1 ä¸ºæŒ‡é’ˆã€‚</p>
<p>é«˜ä½ bit ç”¨äºè¡¨ç¤ºæ˜¯å¦è¦ç»§ç»­æ‰«æè¯¥å¯¹è±¡ä¸­åç»­çš„å†…å®¹ï¼Œ0 ä¸ºä¸éœ€è¦ï¼Œ1 ä¸ºéœ€è¦ã€‚</p>
<p><img src="https://blogstatic.haohtml.com/uploads/2021/04/d2b5ca33bd970f64a6301fa75ae2eb22-6.png?x-oss-process=image/format,webp" alt="img"></p>
<h4 id="heapBitsForAddr"><a href="#heapBitsForAddr" class="headerlink" title="heapBitsForAddr"></a>heapBitsForAddr</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// heapBitsForAddr returns the heapBits for the address addr.</span></span><br><span class="line"><span class="comment">// The caller must ensure addr is in an allocated span.</span></span><br><span class="line"><span class="comment">// In particular, be careful not to point past the end of an object.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// nosplit because it is used during write barriers and must not be preempted.</span></span><br><span class="line"><span class="comment">//go:nosplit</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">heapBitsForAddr</span><span class="params">(addr <span class="keyword">uintptr</span>)</span> <span class="params">(h heapBits)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 2 bits per word, 4 pairs per byte, and a mask is hard coded.</span></span><br><span class="line">    <span class="comment">// å¦‚æ³¨é‡Šæ‰€è¯´ï¼Œä¸¤ä¸ªæ¯”ç‰¹å¯ä»¥ç”¨æ¥è¡¨ç¤ºä¸€ä¸ªå­—çš„å¤§å°</span></span><br><span class="line">    arena := arenaIndex(addr)</span><br><span class="line">    ha := mheap_.arenas[arena.l1()][arena.l2()]</span><br><span class="line">    <span class="comment">// The compiler uses a load for nil checking ha, but in this</span></span><br><span class="line">    <span class="comment">// case we&#x27;ll almost never hit that cache line again, so it</span></span><br><span class="line">    <span class="comment">// makes more sense to do a value check.</span></span><br><span class="line">    <span class="keyword">if</span> ha == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// addr is not in the heap. Return nil heapBits, which</span></span><br><span class="line">        <span class="comment">// we expect to crash in the caller.</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ç¬”è€…ç†è§£ï¼šä¹‹æ‰€ä»¥è¦ *4ï¼Œå°±æ˜¯å› ä¸º bitmap ä¸ ha çš„æ˜ å°„å…³ç³»</span></span><br><span class="line">    <span class="comment">// ä¸€å­—èŠ‚å¯ä»¥è¡¨ç¤ºå †ä¸Š 4 ä¸ªè¿ç»­çš„æŒ‡é’ˆå†…å­˜</span></span><br><span class="line">    h.bitp = &amp;ha.bitmap[(addr/(sys.PtrSize*<span class="number">4</span>))%heapArenaBitmapBytes]</span><br><span class="line">    <span class="comment">// ç¬”è€…ç†è§£ï¼šshift å°±åƒæ©ç ä¸€æ ·ï¼Œç”¨æ¥è®¡ç®—ä½ä½ä¸é«˜ä½æ¯”ç‰¹çš„ä½ç½®</span></span><br><span class="line">    <span class="comment">// &amp;3 çš„è¿ç®—ä¹Ÿèƒ½è¯´æ˜è¿™ä¸€ç‚¹ï¼Œ&amp;3 çš„ç»“æœåªèƒ½æ˜¯ 0 1 2 3ï¼Œ</span></span><br><span class="line">    <span class="comment">// è¿™é‡Œå°±å¯¹åº”ä¸Šäº† 8 æ¯”ç‰¹çš„ä½å››ä½</span></span><br><span class="line">    h.shift = <span class="keyword">uint32</span>((addr / sys.PtrSize) &amp; <span class="number">3</span>)</span><br><span class="line">    <span class="comment">// è®°å½•å½“å‰ arena çš„ä½ç½®</span></span><br><span class="line">    h.arena = <span class="keyword">uint32</span>(arena)</span><br><span class="line">    <span class="comment">// è®°å½•å½“å‰ arena å¯¹åº”çš„ bitmap ä¸­çš„æœ€åä¸€å­—èŠ‚</span></span><br><span class="line">    h.last = &amp;ha.bitmap[<span class="built_in">len</span>(ha.bitmap)<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// next returns the heapBits describing the next pointer-sized word in memory.</span></span><br><span class="line"><span class="comment">// That is, if h describes address p, h.next() describes p+ptrSize.</span></span><br><span class="line"><span class="comment">// Note that next does not modify h. The caller must record the result.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// å¦‚æ³¨é‡Šæ‰€æè¿°çš„ï¼Œnext å‡½æ•°ï¼Œè¿”å›æè¿°äº†åœ¨å†…å­˜ä¸­ä¸‹ä¸€ä¸ªæŒ‡é’ˆç±»å‹çš„wordçš„heapBits</span></span><br><span class="line"><span class="comment">// å¦‚æœ h è¡¨ç¤ºçš„æ˜¯æŒ‡é’ˆ p çš„åœ°å€ï¼Œé‚£ä¹ˆ h.next() è¡¨ç¤ºçš„å°±æ˜¯ p+ptrSize çš„heapBits</span></span><br><span class="line"><span class="comment">// nosplit because it is used during write barriers and must not be preempted.</span></span><br><span class="line"><span class="comment">//go:nosplit</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h heapBits)</span> <span class="title">next</span><span class="params">()</span> <span class="title">heapBits</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> h.shift &lt; <span class="number">3</span>*heapBitsShift &#123; <span class="comment">// åœ¨åŒä¸€å­—èŠ‚ä¸Šæ‰«æï¼Œå››ä¸ªè¿ç»­çš„ptrè¿˜æ²¡æ‰«æå®Œ</span></span><br><span class="line">        h.shift += heapBitsShift</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> h.bitp != h.last &#123;	<span class="comment">// å¦‚æœæ²¡æ‰«æåˆ°è¯¥ bitmap çš„æœ€åä¸€å­—èŠ‚ï¼Œé‚£ä¹ˆæ‰«æä¸‹ä¸€ä¸ªbyte</span></span><br><span class="line">        h.bitp, h.shift = add1(h.bitp), <span class="number">0</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;	<span class="comment">// æ­¤æ—¶ï¼Œå½“å‰å·²ç»æ‰«æå®Œäº†å½“å‰ ha çš„æ‰€æœ‰å†…å®¹ï¼Œç§»åŠ¨åˆ°ä¸‹ä¸€ä¸ª ha è¿›è¡Œæ‰«æ</span></span><br><span class="line">        <span class="comment">// Move to the next arena.</span></span><br><span class="line">        <span class="keyword">return</span> h.nextArena()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="gcDrain-æ ‡è®°è¿‡ç¨‹"><a href="#gcDrain-æ ‡è®°è¿‡ç¨‹" class="headerlink" title="gcDrain æ ‡è®°è¿‡ç¨‹"></a>gcDrain æ ‡è®°è¿‡ç¨‹</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// gcDrain æ‰«æ work buffer ä¸­çš„æ ¹èŠ‚ç‚¹å’Œå¯¹è±¡ï¼Œ</span></span><br><span class="line"><span class="comment">// gcDrain ä¼šå°†é˜Ÿåˆ—ä¸­æ‰€æœ‰çš„å¯¹è±¡æ ‡è®°ä¸ºç°è‰²ã€‚</span></span><br><span class="line"><span class="comment">// gcDrain å¯èƒ½åœ¨ GC ç»“æŸå‰è¿”å›ã€‚</span></span><br><span class="line"><span class="comment">// gcDrain çš„è°ƒç”¨è€…è´Ÿè´£å¹³è¡¡å½“å‰ P ä¸ å…¶ä»– P çš„æ ‡è®°å·¥ä½œã€‚</span></span><br><span class="line"><span class="comment">//go:nowritebarrier</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcDrain</span><span class="params">(gcw *gcWork, flags gcDrainFlags)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> !writeBarrier.needed &#123;</span><br><span class="line">        throw(<span class="string">&quot;gcDrain phase incorrect&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    gp := getg().m.curg</span><br><span class="line">    preemptible := flags&amp;gcDrainUntilPreempt != <span class="number">0</span></span><br><span class="line">    flushBgCredit := flags&amp;gcDrainFlushBgCredit != <span class="number">0</span></span><br><span class="line">    idle := flags&amp;gcDrainIdle != <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    initScanWork := gcw.scanWork</span><br><span class="line"></span><br><span class="line">    <span class="comment">// checkWork is the scan work before performing the next</span></span><br><span class="line">    <span class="comment">// self-preempt check.</span></span><br><span class="line">    checkWork := <span class="keyword">int64</span>(<span class="number">1</span>&lt;&lt;<span class="number">63</span> - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">var</span> check <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">bool</span></span></span><br><span class="line">    <span class="keyword">if</span> flags&amp;(gcDrainIdle|gcDrainFractional) != <span class="number">0</span> &#123;</span><br><span class="line">        checkWork = initScanWork + drainCheckThreshold</span><br><span class="line">        <span class="keyword">if</span> idle &#123;</span><br><span class="line">            check = pollWork</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> flags&amp;gcDrainFractional != <span class="number">0</span> &#123;</span><br><span class="line">            check = pollFractionalWorkerExit</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Drain root marking jobs.</span></span><br><span class="line">    <span class="comment">// åˆ¤æ–­å½“å‰æ ‡è®°çš„ä½ç½®æ˜¯å¦è¶…å‡ºäº†æ€»çš„æ ‡è®°æ•°é‡</span></span><br><span class="line">    <span class="keyword">if</span> work.markrootNext &lt; work.markrootJobs &#123;</span><br><span class="line">        <span class="comment">// Stop if we&#x27;re preemptible or if someone wants to STW.</span></span><br><span class="line">        <span class="keyword">for</span> !(gp.preempt &amp;&amp; (preemptible || atomic.Load(&amp;sched.gcwaiting) != <span class="number">0</span>)) &#123;</span><br><span class="line">            job := atomic.Xadd(&amp;work.markrootNext, +<span class="number">1</span>) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> job &gt;= work.markrootJobs &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// å¯¹ job ç´¢å¼•ä½ç½®çš„ root è¿›è¡Œæ ‡è®°å·¥ä½œ</span></span><br><span class="line">            markroot(gcw, job)</span><br><span class="line">            <span class="comment">// å®Œæˆä¸€ä¸ªæ ¹çš„æ ‡è®°å·¥ä½œï¼Œå°±å»æ£€æŸ¥</span></span><br><span class="line">            <span class="comment">// TODO æ˜¯å¦è¾¾åˆ°äº† fractional æˆ–è€… å…¶ä»–</span></span><br><span class="line">            <span class="keyword">if</span> check != <span class="literal">nil</span> &amp;&amp; check() &#123;</span><br><span class="line">                <span class="keyword">goto</span> done</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Drain heap marking jobs.</span></span><br><span class="line">    <span class="comment">// Stop if we&#x27;re preemptible or if someone wants to STW.</span></span><br><span class="line">    <span class="keyword">for</span> !(gp.preempt &amp;&amp; (preemptible || atomic.Load(&amp;sched.gcwaiting) != <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">// Try to keep work available on the global queue. We used to</span></span><br><span class="line">        <span class="comment">// check if there were waiting workers, but it&#x27;s better to</span></span><br><span class="line">        <span class="comment">// just keep work available than to make workers wait. In the</span></span><br><span class="line">        <span class="comment">// worst case, we&#x27;ll do O(log(_WorkbufSize)) unnecessary</span></span><br><span class="line">        <span class="comment">// balances.</span></span><br><span class="line">        <span class="comment">// å¹³è¡¡æ ‡è®°å·¥ä½œï¼Œè®©å®ƒæœ‰æ´»å¯å¹²æ¯”è®©å®ƒç­‰ç€è¦å¥½</span></span><br><span class="line">        <span class="keyword">if</span> work.full == <span class="number">0</span> &#123;</span><br><span class="line">            gcw.balance()</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ä» gcw é˜Ÿåˆ—ä¸­å–å€¼</span></span><br><span class="line">        b := gcw.tryGetFast()</span><br><span class="line">        <span class="keyword">if</span> b == <span class="number">0</span> &#123;</span><br><span class="line">            b = gcw.tryGet()</span><br><span class="line">            <span class="keyword">if</span> b == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="comment">// Flush the write barrier</span></span><br><span class="line">                <span class="comment">// buffer; this may create</span></span><br><span class="line">                <span class="comment">// more work.</span></span><br><span class="line">                å¦‚æœè¯´ wbuf ä¸­éƒ½æ²¡æœ‰ï¼Œå°†</span><br><span class="line">                wbBufFlush(<span class="literal">nil</span>, <span class="number">0</span>)</span><br><span class="line">                b = gcw.tryGet()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> b == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// Unable to get work.</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        scanobject(b, gcw)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Flush background scan work credit to the global</span></span><br><span class="line">        <span class="comment">// account if we&#x27;ve accumulated enough locally so</span></span><br><span class="line">        <span class="comment">// mutator assists can draw on it.</span></span><br><span class="line">        <span class="keyword">if</span> gcw.scanWork &gt;= gcCreditSlack &#123;</span><br><span class="line">            atomic.Xaddint64(&amp;gcController.scanWork, gcw.scanWork)</span><br><span class="line">            <span class="keyword">if</span> flushBgCredit &#123;</span><br><span class="line">                gcFlushBgCredit(gcw.scanWork - initScanWork)</span><br><span class="line">                initScanWork = <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">            checkWork -= gcw.scanWork</span><br><span class="line">            gcw.scanWork = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> checkWork &lt;= <span class="number">0</span> &#123;</span><br><span class="line">                checkWork += drainCheckThreshold</span><br><span class="line">                <span class="keyword">if</span> check != <span class="literal">nil</span> &amp;&amp; check() &#123;</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    done:</span><br><span class="line">    <span class="comment">// Flush remaining scan work credit.</span></span><br><span class="line">    <span class="keyword">if</span> gcw.scanWork &gt; <span class="number">0</span> &#123;</span><br><span class="line">        atomic.Xaddint64(&amp;gcController.scanWork, gcw.scanWork)</span><br><span class="line">        <span class="keyword">if</span> flushBgCredit &#123;</span><br><span class="line">            gcFlushBgCredit(gcw.scanWork - initScanWork)</span><br><span class="line">        &#125;</span><br><span class="line">        gcw.scanWork = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="æ ‡è®°å·¥ä½œçš„å¹³è¡¡"><a href="#æ ‡è®°å·¥ä½œçš„å¹³è¡¡" class="headerlink" title="æ ‡è®°å·¥ä½œçš„å¹³è¡¡"></a>æ ‡è®°å·¥ä½œçš„å¹³è¡¡</h4><h5 id="balance"><a href="#balance" class="headerlink" title="balance"></a>balance</h5><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// balance moves some work that&#x27;s cached in this gcWork back on the</span></span><br><span class="line"><span class="comment">// global queue.</span></span><br><span class="line"><span class="comment">// å°†ç¼“å­˜åœ¨ P gcw ä¸Šçš„æ ‡è®°ä»»åŠ¡ï¼Œé€‚å½“çš„ç§»åŠ¨åˆ°å…¨å±€queueä¸­</span></span><br><span class="line"><span class="comment">//go:nowritebarrierrec</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *gcWork)</span> <span class="title">balance</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// å¦‚æœ P çš„æœ¬åœ° wbf æ²¡æœ‰æ ‡è®°ä»»åŠ¡ï¼Œç›´æ¥è¿”å›</span></span><br><span class="line">    <span class="keyword">if</span> w.wbuf1 == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">   	1.å…ˆå¤„ç† wbuf2 ä¸­çš„æ•°æ®ï¼Œå¦‚æœæœ‰ï¼Œå°†æ•°æ®æ”¾å…¥åˆ°</span></span><br><span class="line"><span class="comment">   	å…¨å±€ work full é˜Ÿåˆ—ä¸­</span></span><br><span class="line"><span class="comment">   	2.æŸ¥çœ‹ wbuf1 ä¸­å¯¹è±¡æ•°é‡ï¼Œè¶…è¿‡å››ä¸ªï¼Œæ‰§è¡Œ handoff</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">    <span class="keyword">if</span> wbuf := w.wbuf2; wbuf.nobj != <span class="number">0</span> &#123;</span><br><span class="line">        putfull(wbuf)</span><br><span class="line">        w.flushedWork = <span class="literal">true</span></span><br><span class="line">        w.wbuf2 = getempty()</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> wbuf := w.wbuf1; wbuf.nobj &gt; <span class="number">4</span> &#123;</span><br><span class="line">        w.wbuf1 = handoff(wbuf)</span><br><span class="line">        w.flushedWork = <span class="literal">true</span> <span class="comment">// handoff did putfull</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// We flushed a buffer to the full list, so wake a worker.</span></span><br><span class="line">    <span class="keyword">if</span> gcphase == _GCmark &#123;</span><br><span class="line">        gcController.enlistWorker()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="enlistWorker"><a href="#enlistWorker" class="headerlink" title="enlistWorker"></a>enlistWorker</h5><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// enlistWorker encourages another dedicated mark worker to start on</span></span><br><span class="line"><span class="comment">// another P if there are spare worker slots. It is used by putfull</span></span><br><span class="line"><span class="comment">// when more work is made available.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//go:nowritebarrier</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *gcControllerState)</span> <span class="title">enlistWorker</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// If there are idle Ps, wake one so it will run an idle worker.</span></span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> This is suspected of causing deadlocks. See golang.org/issue/19112.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// if atomic.Load(&amp;sched.npidle) != 0 &amp;&amp; atomic.Load(&amp;sched.nmspinning) == 0 &#123;</span></span><br><span class="line">    <span class="comment">//    wakep()</span></span><br><span class="line">    <span class="comment">//    return</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// There are no idle Ps. If we need more dedicated workers,</span></span><br><span class="line">    <span class="comment">// try to preempt a running P so it will switch to a worker.</span></span><br><span class="line">    <span class="keyword">if</span> c.dedicatedMarkWorkersNeeded &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Pick a random other P to preempt.</span></span><br><span class="line">    <span class="keyword">if</span> gomaxprocs &lt;= <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    gp := getg()</span><br><span class="line">    <span class="keyword">if</span> gp == <span class="literal">nil</span> || gp.m == <span class="literal">nil</span> || gp.m.p == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    myID := gp.m.p.ptr().id</span><br><span class="line">    <span class="keyword">for</span> tries := <span class="number">0</span>; tries &lt; <span class="number">5</span>; tries++ &#123;</span><br><span class="line">        id := <span class="keyword">int32</span>(fastrandn(<span class="keyword">uint32</span>(gomaxprocs - <span class="number">1</span>)))</span><br><span class="line">        <span class="keyword">if</span> id &gt;= myID &#123;</span><br><span class="line">            id++</span><br><span class="line">        &#125;</span><br><span class="line">        p := allp[id]</span><br><span class="line">        <span class="keyword">if</span> p.status != _Prunning &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// æ‰§è¡ŒæŠ¢å </span></span><br><span class="line">        <span class="keyword">if</span> preemptone(p) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>â€‹    ä¸çŸ¥é“ä½ ä»¬æƒ³æ²¡æƒ³è¿‡è¿™æ ·ä¸€ä¸ªé—®é¢˜ï¼Œé€šè¿‡ preemptone å‡½æ•°è¿›è¡ŒæŠ¢å ï¼Œæ˜¯æ€ä¹ˆåšåˆ°å»å¯åŠ¨ä¸€ä¸ª gcMarkWorker çš„ï¼Ÿ</p>
<p>â€‹    å¦‚æœä½ æ²¡æƒ³åˆ°çš„è¯ï¼Œç»™ä½ ä¸€ç‚¹æç¤ºï¼Œå’Œè°ƒåº¦å¾ªç¯ç›¸å…³ã€‚</p>
<h5 id="handoff"><a href="#handoff" class="headerlink" title="handoff"></a>handoff</h5><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// åœ¨ wbuf ä¸­å¯¹è±¡æ•°é‡å¤§äº 4 æ—¶ï¼Œå°†å‰ä¸€åŠæ”¾å…¥åˆ°å…¨å±€ work full é˜Ÿåˆ—ä¸­</span></span><br><span class="line"><span class="comment">//go:nowritebarrier</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handoff</span><span class="params">(b *workbuf)</span> *<span class="title">workbuf</span></span> &#123;</span><br><span class="line">    <span class="comment">// Make new buffer with half of b&#x27;s pointers.</span></span><br><span class="line">    b1 := getempty()</span><br><span class="line">    n := b.nobj / <span class="number">2</span></span><br><span class="line">    b.nobj -= n</span><br><span class="line">    b1.nobj = n</span><br><span class="line">    <span class="comment">// é€šè¿‡è·å–ä¸€ä¸ªæ–°çš„ empty workbuf</span></span><br><span class="line">    <span class="comment">// å°†å‰ä¸€åŠæ”¾è¿›å»</span></span><br><span class="line">    memmove(unsafe.Pointer(&amp;b1.obj[<span class="number">0</span>]), unsafe.Pointer(&amp;b.obj[b.nobj]), <span class="keyword">uintptr</span>(n)*unsafe.Sizeof(b1.obj[<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Put b on full list - let first half of b get stolen.</span></span><br><span class="line">    putfull(b)</span><br><span class="line">    <span class="keyword">return</span> b1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="GC-è¿‡ç¨‹ä¸­-P-çš„-gcw-é˜Ÿåˆ—"><a href="#GC-è¿‡ç¨‹ä¸­-P-çš„-gcw-é˜Ÿåˆ—" class="headerlink" title="GC è¿‡ç¨‹ä¸­ P çš„ gcw é˜Ÿåˆ—"></a>GC è¿‡ç¨‹ä¸­ P çš„ gcw é˜Ÿåˆ—</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> P <span class="keyword">struct</span> &#123;</span><br><span class="line">    (...)</span><br><span class="line">    <span class="comment">// gcw is this P&#x27;s GC work buffer cache. The work buffer is</span></span><br><span class="line">    <span class="comment">// filled by write barriers, drained by mutator assists, and</span></span><br><span class="line">    <span class="comment">// disposed on certain GC state transitions.</span></span><br><span class="line">    gcw gcWork</span><br><span class="line">    (...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ä»¥ä¸‹æ˜¯ Go å®˜æ–¹å¯¹ gcw çš„æè¿°ï¼š</p>
<p>ä¸ºç°è‰²æŒ‡é’ˆå¯¹è±¡å®ç°äº†ä¸€ä¸ªç”Ÿäº§è€…/æ¶ˆè´¹è€…æ¨¡å‹ã€‚å¯¹è±¡è¢«æ ‡è®°ä¸ºç°è‰²åï¼Œæ”¾å…¥åˆ°é˜Ÿåˆ—ä¸­ã€‚å¯¹è±¡è¢«æ ‡è®°ä¸ºé»‘è‰²åï¼Œä¼šåœ¨é˜Ÿåˆ—ä¸­ç§»é™¤ã€‚</p>
<p>å†™å±éšœï¼Œæ ¹èŠ‚ç‚¹æ‰«æï¼Œæ ˆæ‰«æå’Œå¯¹è±¡æ‰«æè¿‡ç¨‹ä¼šäº§ç”Ÿç°è‰²å¯¹è±¡ã€‚scanning è¿‡ç¨‹ä¼šæ¶ˆè´¹ç°è‰²å¯¹è±¡çš„æŒ‡é’ˆå¹¶ä¸”æœ‰å¯èƒ½äº§ç”Ÿæ–°çš„ç°è‰²å¯¹è±¡æŒ‡é’ˆã€‚</p>
<p>gcWork ä¸ºåƒåœ¾å›æ”¶å™¨æä¾›äº†ä¸€ä¸ªç”Ÿäº§å’Œæ¶ˆè´¹çš„æ¥å£ã€‚</p>
<p>å¯ä»¥åœ¨ stack ä¸Šè¿™æ ·ä½¿ç”¨ gcWorkï¼š</p>
<ul>
<li>è°ƒç”¨ gcw.Put() è¿›è¡Œç”Ÿäº§ï¼Œè°ƒç”¨ gcw.tryGet() è¿›è¡Œæ¶ˆè´¹ã€‚</li>
</ul>
<p>é‡è¦çš„æ˜¯ï¼Œåœ¨ mark phase ä½¿ç”¨ gcWork å¯ä»¥é˜»æ­¢åƒåœ¾å›æ”¶å™¨ä» transitioning è½¬å˜ä¸º mark termination å› ä¸º gcWork å¯èƒ½åœ¨æœ¬åœ°ä¿å­˜ GC work buffersã€‚è¿™å¯ä»¥é€šè¿‡ç¦ç”¨æŠ¢å æ¥å®Œæˆã€‚</p>
<h5 id="wbuf1-å’Œ-wbuf2"><a href="#wbuf1-å’Œ-wbuf2" class="headerlink" title="wbuf1 å’Œ wbuf2"></a>wbuf1 å’Œ wbuf2</h5><p>å¯ä»¥å°† wbuf1 å’Œ wbuf2 æƒ³è±¡æˆä¸€å—æ ˆç©ºé—´ï¼Œç„¶åè¿™ä¿©è½®æµä½¿ç”¨ã€‚</p>
<p>å½“æˆ‘ä»¬å¼¹å‡ºé˜Ÿåˆ—ä¸­æœ€åä¸€ä¸ªæŒ‡é’ˆæ—¶ï¼Œæˆ‘ä»¬é€šè¿‡å¼•å…¥ä¸€ä¸ªæ–°çš„ç¼“å†²åŒºå¹¶ä¸¢å¼ƒä¸€ä¸ªç©ºç¼“å†²åŒºï¼ˆäº¤æ¢è¿™ä¸¤ä¸ªç¼“å†²åŒºï¼‰ï¼Œç„¶åå°† stack å‘ä¸Šç§»åŠ¨ä¸€ä¸ªæ–° bufferã€‚ å½“æˆ‘ä»¬å°†bufferséƒ½å¡«æ»¡äº†ï¼Œæˆ‘ä»¬é€šè¿‡å¼•å…¥ä¸€ä¸ªæ–°çš„ç©ºç¼“å†²åŒºå¹¶ä¸¢å¼ƒé‚£ä¸ªæ»¡çš„ç¼“å†²åŒºï¼Œç„¶åå°†stackå‘ä¸‹ç§»åŠ¨ä¸€ä¸ªæ–° bufferã€‚</p>
<p>è¿™æ ·æˆ‘ä»¬å°±æœ‰äº†ä¸€ä¸ªç¼“å†²åŒºçš„æ»åå€¼ï¼Œå®ƒå¯ä»¥å°†è·å–æˆ–æ”¾ç½®å·¥ä½œç¼“å†²åŒºçš„æˆæœ¬åˆ†æ‘Šåˆ°è‡³å°‘ä¸€ä¸ªå·¥ä½œç¼“å†²åŒºä¸Šï¼Œå¹¶å‡å°‘å…¨å±€å·¥ä½œåˆ—è¡¨ä¸Šçš„äº‰ç”¨ã€‚</p>
<p>wbuf1 æ°¸è¿œéƒ½æ˜¯æˆ‘ä»¬æ­£åœ¨æ“ä½œçš„é‚£ä¸ª bufferï¼Œwbuf2 æ˜¯æ¥ä¸‹æ¥è¦ä¸¢å¼ƒçš„ç¼“å†²åŒºã€‚</p>
<p>æ€»ç»“ï¼š</p>
<p>wbuf1 å’Œ wbuf2 éƒ½æ˜¯ç”¨æ¥å­˜å‚¨ç°è‰²æŒ‡é’ˆçš„ï¼Œwbuf1 æ˜¯æˆ‘ä»¬çœŸæ­£æ“ä½œçš„é‚£ä¸ªé˜Ÿåˆ—ï¼Œå…¥é˜Ÿå‡ºé˜Ÿæ“ä½œçš„éƒ½æ˜¯å®ƒï¼Œwbuf2 èµ·åˆ°çš„æ˜¯æ›¿æ¢ä½œç”¨ï¼Œå½“ wbuf1 ç©ºäº†ï¼Œæ›¿æ¢ wbuf2ï¼Œå½“ wbuf1 æ»¡äº†ï¼Œæ›¿æ¢ wbuf2ã€‚</p>
<h5 id="work-full-å’Œ-work-empty"><a href="#work-full-å’Œ-work-empty" class="headerlink" title="work.full å’Œ work.empty"></a>work.full å’Œ work.empty</h5><p>å…¨å±€ work ä¸­æœ‰ä¸¤ä¸ªé˜Ÿåˆ—ï¼Œfull å’Œ emptyï¼Œç°è‰²å¯¹è±¡å…¥é˜Ÿè¿‡ç¨‹ï¼š</p>
<p>fastPath: æ£€æŸ¥ wbuf1 æ˜¯å¦ä¸ºç©ºï¼Œæ˜¯å¦æ»¡äº†ï¼Œæ˜¯å°±è¿”å›ï¼›éƒ½ä¸æ˜¯ï¼Œå°†ç°è‰²å¯¹è±¡å…¥é˜Ÿã€‚<br>slowPathï¼šæ£€æŸ¥ wbuf1 æ˜¯å¦ä¸º nilï¼Œä¸º nilï¼Œæ‰§è¡Œåˆå§‹åŒ–ã€‚å¦åˆ™ï¼Œåˆ¤æ–­æ˜¯å¦æ»¡äº†ï¼Œæ»¡äº†ï¼Œäº¤æ¢ wbuf1 å’Œ wbuf2ï¼Œå†æ¬¡åˆ¤æ–­ wbuf1 æ˜¯å¦æ»¡äº†ï¼Œæ»¡äº†åŠ å…¥åˆ°å…¨å±€ full é˜Ÿåˆ—ä¸­ï¼Œç„¶åä» empty é˜Ÿåˆ—è·å–ä¸€ä¸ªç©ºçš„å¹¶èµ‹å€¼ç»™ wbuf1ï¼Œæœ€åæŠŠè¿™ä¸ªç°è‰²å¯¹è±¡å…¥é˜Ÿã€‚</p>
<h4 id="GC-è¿‡ç¨‹ä¸­è´Ÿè´£æ ‡è®°çš„å‡½æ•°"><a href="#GC-è¿‡ç¨‹ä¸­è´Ÿè´£æ ‡è®°çš„å‡½æ•°" class="headerlink" title="GC è¿‡ç¨‹ä¸­è´Ÿè´£æ ‡è®°çš„å‡½æ•°"></a>GC è¿‡ç¨‹ä¸­è´Ÿè´£æ ‡è®°çš„å‡½æ•°</h4><h5 id="markroot"><a href="#markroot" class="headerlink" title="markroot"></a>markroot</h5><p>markroot ä¸»è¦æ˜¯æ ¹æ®ä¸åŒçš„ i æ¥å®šä½è¦æ‰«æå“ªäº›åŒºåŸŸï¼Œå½“ i == 0 ï¼Œi == 1 æ—¶ï¼Œå¯¹åº”åˆ°ä»¥ä¸‹ä¸¤ç§æƒ…å†µï¼Œå…·ä½“çš„å«ä¹‰æš‚æ—¶è¿˜ä¸æ¸…æ™°ã€‚</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TODO äº†è§£è¿™ä¸¤ç§åˆ†åˆ«æ˜¯ä»€ä¹ˆ</span></span><br><span class="line"><span class="keyword">case</span> i == fixedRootFinalizers:</span><br><span class="line">   <span class="keyword">for</span> fb := allfin; fb != <span class="literal">nil</span>; fb = fb.alllink &#123;</span><br><span class="line">      cnt := <span class="keyword">uintptr</span>(atomic.Load(&amp;fb.cnt))</span><br><span class="line">      scanblock(<span class="keyword">uintptr</span>(unsafe.Pointer(&amp;fb.fin[<span class="number">0</span>])), cnt*unsafe.Sizeof(fb.fin[<span class="number">0</span>]), &amp;finptrmask[<span class="number">0</span>], gcw, <span class="literal">nil</span>)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> i == fixedRootFreeGStacks:</span><br><span class="line">   <span class="comment">// Switch to the system stack so we can call</span></span><br><span class="line">   <span class="comment">// stackfree.</span></span><br><span class="line">   systemstack(markrootFreeGStacks)</span><br></pre></td></tr></table></figure>

<h5 id="scanobject"><a href="#scanobject" class="headerlink" title="scanobject"></a>scanobject</h5><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// scanobject scans the object starting at b, adding pointers to gcw.</span></span><br><span class="line"><span class="comment">// b must point to the beginning of a heap object or an oblet.</span></span><br><span class="line"><span class="comment">// scanobject consults the GC bitmap for the pointer mask and the</span></span><br><span class="line"><span class="comment">// spans for the size of the object.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// å¦‚æ³¨é‡Šæ‰€å†™ï¼Œscanobject æ‰«æä» b ä¸ºèµ·å§‹åœ°å€çš„å¯¹è±¡ï¼Œå¹¶æ·»åŠ æŒ‡é’ˆåˆ° gcw é˜Ÿåˆ—ä¸­ã€‚</span></span><br><span class="line"><span class="comment">// b å¿…é¡»æŒ‡å‘å †å¯¹è±¡çš„èµ·å§‹åœ°å€ï¼Œæˆ–è€…ä¸€ä¸ª obletã€‚</span></span><br><span class="line"><span class="comment">//go:nowritebarrier</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">scanobject</span><span class="params">(b <span class="keyword">uintptr</span>, gcw *gcWork)</span></span> &#123;</span><br><span class="line">    <span class="comment">// Find the bits for b and the size of the object at b.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// b is either the beginning of an object, in which case this</span></span><br><span class="line">    <span class="comment">// is the size of the object to scan, or it points to an</span></span><br><span class="line">    <span class="comment">// oblet, in which case we compute the size to scan below.</span></span><br><span class="line">    <span class="comment">// è¿™ä¸ªå‡½æ•°å‰è¾¹å·²ç»è¯¦ç»†çš„åˆ†æè¿‡äº†ï¼Œæ²¡å•¥å¥½è¯´çš„</span></span><br><span class="line">    hbits := heapBitsForAddr(b)</span><br><span class="line">    <span class="comment">// æ‰¾åˆ°æŒ‡é’ˆ b å¯¹åº”çš„ mspan</span></span><br><span class="line">    s := spanOfUnchecked(b)</span><br><span class="line">    <span class="comment">// s.elemsize è¡¨ç¤ºçš„æ˜¯ä¸€ä¸ª object çš„å¤§å°</span></span><br><span class="line">    n := s.elemsize</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;scanobject n == 0&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">		è¿™é‡Œå¯¹å¤§å¯¹è±¡ï¼ˆè¿™é‡Œçš„å¤§å¯¹è±¡ä¸å†…å­˜åˆ†é…çš„æœ‰äº›è®¸å·®å¼‚</span></span><br><span class="line"><span class="comment">		å†…å­˜åˆ†é…å¤§å¯¹è±¡æŒ‡çš„æ˜¯å¤§äº32KBçš„ï¼Œè¿™é‡ŒæŒ‡çš„æ˜¯å¤§äº 128KBçš„ï¼‰</span></span><br><span class="line"><span class="comment">		è¿›è¡Œäº†è¿›ä¸€æ­¥çš„åŒºåˆ†</span></span><br><span class="line"><span class="comment">		maxobletBytes = 128 &lt;&lt; 10 = 128 KB</span></span><br><span class="line"><span class="comment">		æ„å‘³ç€ï¼Œå½“å‰ obj çš„å¤§å°è¶…è¿‡äº† 128 KB</span></span><br><span class="line"><span class="comment">		è¦è¿›è¡Œä¸€äº›ä¼˜åŒ–æ“ä½œ</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    <span class="keyword">if</span> n &gt; maxObletBytes &#123;</span><br><span class="line">        <span class="comment">// Large object. Break into oblets for better</span></span><br><span class="line">        <span class="comment">// parallelism and lower latency.</span></span><br><span class="line">        <span class="keyword">if</span> b == s.base() &#123;</span><br><span class="line">            <span class="comment">// It&#x27;s possible this is a noscan object (not</span></span><br><span class="line">            <span class="comment">// from greyobject, but from other code</span></span><br><span class="line">            <span class="comment">// paths), in which case we must *not* enqueue</span></span><br><span class="line">            <span class="comment">// oblets since their bitmaps will be</span></span><br><span class="line">            <span class="comment">// uninitialized.</span></span><br><span class="line">            <span class="keyword">if</span> s.spanclass.noscan() &#123;</span><br><span class="line">                <span class="comment">// Bypass the whole scan.</span></span><br><span class="line">                gcw.bytesMarked += <span class="keyword">uint64</span>(n)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Enqueue the other oblets to scan later.</span></span><br><span class="line">            <span class="comment">// Some oblets may be in b&#x27;s scalar tail, but</span></span><br><span class="line">            <span class="comment">// these will be marked as &quot;no more pointers&quot;,</span></span><br><span class="line">            <span class="comment">// so we&#x27;ll drop out immediately when we go to</span></span><br><span class="line">            <span class="comment">// scan those.</span></span><br><span class="line">            <span class="keyword">for</span> oblet := b + maxObletBytes; oblet &lt; s.base()+s.elemsize; oblet += maxObletBytes &#123;</span><br><span class="line">                <span class="keyword">if</span> !gcw.putFast(oblet) &#123;</span><br><span class="line">                    gcw.put(oblet)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Compute the size of the oblet. Since this object</span></span><br><span class="line">        <span class="comment">// must be a large object, s.base() is the beginning</span></span><br><span class="line">        <span class="comment">// of the object.</span></span><br><span class="line">        n = s.base() + s.elemsize - b</span><br><span class="line">        <span class="keyword">if</span> n &gt; maxObletBytes &#123;</span><br><span class="line">            n = maxObletBytes</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> i <span class="keyword">uintptr</span></span><br><span class="line">    <span class="comment">// i &lt; n è¯´æ˜ mspan ä¸­ï¼Œåªå¯¹å½“å‰è¿™ä¸ªå¯¹è±¡è¿›è¡Œæ‰«æ</span></span><br><span class="line">    <span class="comment">// æ‰§è¡Œå®Œä¸€æ¬¡ for å¾ªç¯ï¼Œå¹¶ä¸æ„å‘³ç€æ‰«æå®Œå½“å‰è¿™ä¸ªå¯¹è±¡äº†</span></span><br><span class="line">    <span class="comment">// åªæ˜¯æ£€æŸ¥äº†å½“å‰ä¸¤ä¸ªæ¯”ç‰¹å¯¹åº”çš„ä¸€ä¸ªå­—</span></span><br><span class="line">    <span class="comment">// é™¤éå½“å‰è¿™ä¸ªå¯¹è±¡æ˜¯ä¸éœ€è¦æ‰«æçš„å³ï¼Œbits&amp;bitScan == 0</span></span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">0</span>; i &lt; n; i, hbits = i+sys.PtrSize, hbits.next() &#123;</span><br><span class="line">        <span class="comment">// Load bits once. See CL 22712 and issue 16973 for discussion.</span></span><br><span class="line">        bits := hbits.bits()</span><br><span class="line">        <span class="comment">// è¿™é‡Œçš„ä¸¤ä¸ª if åˆ¤æ–­å°±å¥½åƒä¸¤ä¸ªå¡å°º</span></span><br><span class="line">        <span class="comment">// åˆ†åˆ«å¯¹é«˜ä½å’Œä½ä½è¿›è¡Œæ£€æŸ¥</span></span><br><span class="line">        <span class="keyword">if</span> bits&amp;bitScan == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">break</span> <span class="comment">// no more pointers in this object</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> bits&amp;bitPointer == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span> <span class="comment">// not a pointer</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Work here is duplicated in scanblock and above.</span></span><br><span class="line">        <span class="comment">// If you make changes here, make changes there too.</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">			è®¾ fakeObj = (*uintptr)(unsafe.Pointer(b + i))</span></span><br><span class="line"><span class="comment">			å¯¹ fakeObj è§£å¼•ç”¨ --&gt; *fakeObj</span></span><br><span class="line"><span class="comment">            	1.è§£å‡ºæ¥ç»“æœ != 0ï¼Œè¯´æ˜æ˜¯ä¸€ä¸ªæŒ‡é’ˆ</span></span><br><span class="line"><span class="comment">            	2.è§£å‡ºæ¥ç»“æœ == 0ï¼Œè¯´æ˜ç»“æœä¸º nil</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        obj := *(*<span class="keyword">uintptr</span>)(unsafe.Pointer(b + i))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// At this point we have extracted the next potential pointer.</span></span><br><span class="line">        <span class="comment">// Quickly filter out nil and pointers back to the current object.</span></span><br><span class="line">        <span class="comment">// å¦‚æœ obj æ˜¯ä¸€ä¸ªæŒ‡é’ˆï¼Œå¹¶ä¸”æŒ‡å‘çš„ä¸æ˜¯å½“å‰ object</span></span><br><span class="line">        <span class="comment">// ç¬”è€…ç†è§£ï¼šä¹‹æ‰€ä»¥è¦è¿‡æ»¤æ‰å½“å‰çš„ objectï¼Œ</span></span><br><span class="line">        <span class="comment">// æ˜¯å› ä¸ºå½“å‰è¿™ä¸ª object å°±æ˜¯ä» gcw é˜Ÿåˆ—ä¸­å–å‡ºæ¥çš„</span></span><br><span class="line">        <span class="comment">// æ‰€ä»¥ä¹Ÿå°±ä¸éœ€è¦å†å¯¹è¯¥ obj è¿›è¡Œæ ‡è®°ï¼ˆå…¥é˜Ÿï¼‰</span></span><br><span class="line">        <span class="keyword">if</span> obj != <span class="number">0</span> &amp;&amp; obj-b &gt;= n &#123;</span><br><span class="line">            <span class="comment">// Test if obj points into the Go heap and, if so,</span></span><br><span class="line">            <span class="comment">// mark the object.</span></span><br><span class="line">            <span class="comment">// æ£€æŸ¥ obj æ˜¯å¦æŒ‡å‘äº† Go çš„å †ï¼Œå¦‚æœæ˜¯ï¼Œå¯¹è¿™ä¸ª obj è¿›è¡Œæ ‡è®°</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// Note that it&#x27;s possible for findObject to</span></span><br><span class="line">            <span class="comment">// fail if obj points to a just-allocated heap</span></span><br><span class="line">            <span class="comment">// object because of a race with growing the</span></span><br><span class="line">            <span class="comment">// heap. In this case, we know the object was</span></span><br><span class="line">            <span class="comment">// just allocated and hence will be marked by</span></span><br><span class="line">            <span class="comment">// allocation itself.</span></span><br><span class="line">            <span class="keyword">if</span> obj, span, objIndex := findObject(obj, b, i); obj != <span class="number">0</span> &#123;</span><br><span class="line">                greyobject(obj, b, i, span, gcw, objIndex)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// è®°å½•åˆšåˆšè¢«æ‰«æçš„ obj å¤§å°</span></span><br><span class="line">    gcw.bytesMarked += <span class="keyword">uint64</span>(n)</span><br><span class="line">    <span class="comment">// ç§¯ç´¯ creditï¼Œåˆ°äº† 2000 å°±æ›´æ–°åˆ°å…¨å±€ gcCrontroller ä¸­</span></span><br><span class="line">    gcw.scanWork += <span class="keyword">int64</span>(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="findObject"><a href="#findObject" class="headerlink" title="findObject"></a>findObject</h5><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	å‚æ•°è§£é‡Šï¼š</span></span><br><span class="line"><span class="comment">		refBase, refOff ä¸»è¦ panic ç”¨</span></span><br><span class="line"><span class="comment">	è¿”å›å€¼è§£é‡Šï¼š</span></span><br><span class="line"><span class="comment">		base: è¡¨ç¤º p æŒ‡é’ˆæ‰€åœ¨å¯¹è±¡ï¼Œåœ¨å †ä¸­çš„èµ·å§‹åœ°å€</span></span><br><span class="line"><span class="comment">		s: è¡¨ç¤º p æŒ‡é’ˆæ‰€åœ¨çš„ mspan</span></span><br><span class="line"><span class="comment">		objIndex: è¡¨ç¤ºåŒ…å« p æŒ‡é’ˆçš„å¯¹è±¡åœ¨ mspan ä¸­çš„ä½ç½®</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//go:nosplit</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findObject</span><span class="params">(p, refBase, refOff <span class="keyword">uintptr</span>)</span> <span class="params">(base <span class="keyword">uintptr</span>, s *mspan, objIndex <span class="keyword">uintptr</span>)</span></span> &#123;</span><br><span class="line">    s = spanOf(p)</span><br><span class="line"></span><br><span class="line">    (...) <span class="comment">// çœç•¥æ£€æŸ¥ä»£ç </span></span><br><span class="line">    </span><br><span class="line">    objIndex = s.objIndex(p)</span><br><span class="line">    base = s.base() + objIndex*s.elemsize</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="markrootBlock"><a href="#markrootBlock" class="headerlink" title="markrootBlock"></a>markrootBlock</h5><h5 id="markrootFreeGStacks"><a href="#markrootFreeGStacks" class="headerlink" title="markrootFreeGStacks"></a>markrootFreeGStacks</h5><h5 id="markrootSpans"><a href="#markrootSpans" class="headerlink" title="markrootSpans"></a>markrootSpans</h5><h5 id="scanstack"><a href="#scanstack" class="headerlink" title="scanstack"></a>scanstack</h5><p>æ‰«æ goroutine æ ˆ</p>
<h5 id="scanblock"><a href="#scanblock" class="headerlink" title="scanblock"></a>scanblock</h5><h5 id="gcmarknewobject"><a href="#gcmarknewobject" class="headerlink" title="gcmarknewobject"></a>gcmarknewobject</h5><h5 id="gcMarkTinyAllocs"><a href="#gcMarkTinyAllocs" class="headerlink" title="gcMarkTinyAllocs"></a>gcMarkTinyAllocs</h5><h2 id="gcMarkDone"><a href="#gcMarkDone" class="headerlink" title="gcMarkDone"></a>gcMarkDone</h2><p>gcMarkDone æ˜¯ä¸€ä¸ªè¿‡åº¦çš„å‡½æ•°ï¼Œæ˜¯ç”± _GCMark åˆ° _GCMarkTermination çŠ¶æ€è½¬æ¢å‰è¦åšçš„ä¸€äº›å¤„ç†ã€‚æ­¤å¤–ï¼ŒgcMarkDone ä¸­ä¼šå¤„ç† writebarrier bufferï¼Œå¦‚æœè¿™æ—¶å€™å°†æ•°æ®å†™å…¥åˆ°äº†å…¨å±€çš„æ ‡è®°é˜Ÿåˆ—ä¸­ï¼Œé‚£è¿˜éœ€è¦ç»§ç»­æ‰§è¡Œæ ‡è®°å·¥ä½œã€‚</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// å¦‚æœæ‰€æœ‰çš„å¯è¾¾å¯¹è±¡éƒ½å·²ç»è¢«æ ‡è®°äº†ï¼ˆæ„å‘³ç€æ²¡æœ‰ä»»ä½•ç°è‰²å¯¹è±¡å¹¶ä¸”å°†æ¥ä¹Ÿä¸ä¼šæœ‰ï¼‰</span></span><br><span class="line"><span class="comment">// gcMarkDone å°† GC çš„çŠ¶æ€ç”± mark è½¬ä¸º mark terminationã€‚</span></span><br><span class="line"><span class="comment">// å¦åˆ™ï¼ˆè¿˜æœ‰æ²¡è¢«æ ‡è®°çš„ç°è‰²å¯¹è±¡ï¼‰ï¼ŒgcMarkDone ä¼šå°†æ‰€æœ‰æœ¬åœ°é˜Ÿåˆ—ä¸­çš„å¯¹è±¡æ¨åˆ°å…¨å±€å·¥ä½œé˜Ÿåˆ—ä¸­ï¼Œ</span></span><br><span class="line"><span class="comment">// è¿™æ ·å…¶ä»–çš„ worker å°±å¯ä»¥çŸ¥é“è¿˜æœ‰æ´»è¦å¹²ã€‚</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// This should be called when all local mark work has been drained and</span></span><br><span class="line"><span class="comment">// there are no remaining workers. Specifically, when</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   work.nwait == work.nproc &amp;&amp; !gcMarkWorkAvailable(p)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// è°ƒç”¨ gcMarkDone çš„ä¸Šä¸‹æ–‡ä¸€å®šæ˜¯å¯æŠ¢å çš„ã€‚</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Flushing local work is important because idle Ps may have local</span></span><br><span class="line"><span class="comment">// work queued. This is the only way to make that work visible and</span></span><br><span class="line"><span class="comment">// drive GC to completion.</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// åˆ·æ–° P çš„æœ¬åœ°é˜Ÿåˆ—åˆ°å…¨å±€é˜Ÿåˆ—ä¸­æ˜¯ååˆ†é‡è¦çš„ï¼Œå› ä¸º idle çŠ¶æ€çš„ P å¯èƒ½åœ¨æœ¬åœ°</span></span><br><span class="line"><span class="comment">// é˜Ÿåˆ—ä¸­æœ‰ç¼“å­˜ã€‚gcMarkDone ä¸­æ˜¯å”¯ä¸€çš„æ–¹å¼è®©è¿™äº›æœ¬åœ°é˜Ÿåˆ—ä¸­çš„å¯¹è±¡å¯ä»¥è¢«çœ‹åˆ°ï¼Œ</span></span><br><span class="line"><span class="comment">// ä¿ƒä½¿ GC å®Œæˆã€‚</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// It is explicitly okay to have write barriers in this function. If</span></span><br><span class="line"><span class="comment">// it does transition to mark termination, then all reachable objects</span></span><br><span class="line"><span class="comment">// have been marked, so the write barrier cannot shade any more</span></span><br><span class="line"><span class="comment">// objects.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcMarkDone</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Ensure only one thread is running the ragged barrier at a</span></span><br><span class="line">    <span class="comment">// time.</span></span><br><span class="line">    semacquire(&amp;work.markDoneSema)</span><br><span class="line"></span><br><span class="line">    top:</span><br><span class="line">    <span class="comment">// Re-check transition condition under transition lock.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// It&#x27;s critical that this checks the global work queues are</span></span><br><span class="line">    <span class="comment">// empty before performing the ragged barrier. Otherwise,</span></span><br><span class="line">    <span class="comment">// there could be global work that a P could take after the P</span></span><br><span class="line">    <span class="comment">// has passed the ragged barrier.</span></span><br><span class="line">    <span class="keyword">if</span> !(gcphase == _GCmark &amp;&amp; work.nwait == work.nproc &amp;&amp; !gcMarkWorkAvailable(<span class="literal">nil</span>)) &#123;</span><br><span class="line">        semrelease(&amp;work.markDoneSema)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// forEachP needs worldsema to execute, and we&#x27;ll need it to</span></span><br><span class="line">    <span class="comment">// stop the world later, so acquire worldsema now.</span></span><br><span class="line">    semacquire(&amp;worldsema)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Flush all local buffers and collect flushedWork flags.</span></span><br><span class="line">    gcMarkDoneFlushed = <span class="number">0</span></span><br><span class="line">    systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        gp := getg().m.curg</span><br><span class="line">        <span class="comment">// Mark the user stack as preemptible so that it may be scanned.</span></span><br><span class="line">        <span class="comment">// Otherwise, our attempt to force all P&#x27;s to a safepoint could</span></span><br><span class="line">        <span class="comment">// result in a deadlock as we attempt to preempt a worker that&#x27;s</span></span><br><span class="line">        <span class="comment">// trying to preempt us (e.g. for a stack scan).</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        	æ ‡è®°å½“å‰ gp æ˜¯å¯æŠ¢å çš„ï¼Œç›®çš„æ˜¯ä¸ºäº†èƒ½å¤Ÿè¢«æ‰«æã€‚å½“æˆ‘ä»¬å¼ºåˆ¶æ‰€æœ‰çš„ P åˆ°è¾¾</span></span><br><span class="line"><span class="comment">        	ä¸€ä¸ª safepoint å¯èƒ½ä¼šå¯¼è‡´æ­»é”ã€‚æ¯”å¦‚ï¼Œæˆ‘ä»¬æƒ³æŠ¢å ä¸€ä¸ª workerï¼ŒåŒæ—¶</span></span><br><span class="line"><span class="comment">        	é‚£ä¸ªworkerä¹Ÿåœ¨å¯¹æˆ‘ä»¬æ‰§è¡ŒæŠ¢å ï¼ˆå¯¹æˆ‘ä»¬è¿›è¡Œæ ˆæ‰«æï¼‰ã€‚</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        casgstatus(gp, _Grunning, _Gwaiting)</span><br><span class="line">        forEachP(<span class="function"><span class="keyword">func</span><span class="params">(_p_ *p)</span></span> &#123;</span><br><span class="line">            <span class="comment">// Flush the write barrier buffer, since this may add</span></span><br><span class="line">            <span class="comment">// work to the gcWork.</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">	            1.è·å–å½“å‰ P çš„ writebarrier buffer ä¸­çš„å†…å®¹</span></span><br><span class="line"><span class="comment">	            2.éå†bufferä¸­çš„å¯¹è±¡ï¼Œæ ‡ç°ï¼Œæ ‡è®° span</span></span><br><span class="line"><span class="comment">	            3.å°†ç°è‰²å¯¹è±¡åˆ·åˆ°å…¨å±€çš„ work queue ä¸­</span></span><br><span class="line"><span class="comment">	            4.æ¸…ç©º P çš„ write barrier buffer</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            wbBufFlush1(_p_)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Flush the gcWork, since this may create global work</span></span><br><span class="line">            <span class="comment">// and set the flushedWork flag.</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// TODO(austin): Break up these workbufs to</span></span><br><span class="line">            <span class="comment">// better distribute work.</span></span><br><span class="line">            <span class="comment">// è¿™é‡Œå¤„ç†çš„æ˜¯ P çš„æœ¬åœ°é˜Ÿåˆ—</span></span><br><span class="line">            <span class="comment">// å°†æœ¬åœ°é˜Ÿåˆ—ä¸­çš„å†…å®¹åˆ·åˆ°å…¨å±€é˜Ÿåˆ—ä¸­</span></span><br><span class="line">            _p_.gcw.dispose()</span><br><span class="line">            <span class="comment">// Collect the flushedWork flag.</span></span><br><span class="line">            <span class="comment">// flushedWork è®°å½•å½“å‰ P æ˜¯å¦åˆå°†å¯¹è±¡æ”¾å…¥åˆ°å…¨å±€workqueue</span></span><br><span class="line">            <span class="keyword">if</span> _p_.gcw.flushedWork &#123;</span><br><span class="line">                atomic.Xadd(&amp;gcMarkDoneFlushed, <span class="number">1</span>)</span><br><span class="line">                _p_.gcw.flushedWork = <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        casgstatus(gp, _Gwaiting, _Grunning)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// å¦‚æœæœ‰ P å¾€å…¨å±€é˜Ÿåˆ—æ”¾å…¥å¯¹è±¡ï¼Œé‚£è¿˜å¾—å°†é‚£äº›å†…å®¹è¿›è¡Œæ ‡è®°</span></span><br><span class="line">    <span class="keyword">if</span> gcMarkDoneFlushed != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// More grey objects were discovered since the</span></span><br><span class="line">        <span class="comment">// previous termination check, so there may be more</span></span><br><span class="line">        <span class="comment">// work to do. Keep going. It&#x27;s possible the</span></span><br><span class="line">        <span class="comment">// transition condition became true again during the</span></span><br><span class="line">        <span class="comment">// ragged barrier, so re-check it.</span></span><br><span class="line">        semrelease(&amp;worldsema)</span><br><span class="line">        <span class="keyword">goto</span> top</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// There was no global work, no local work, and no Ps</span></span><br><span class="line">    <span class="comment">// communicated work since we took markDoneSema. Therefore</span></span><br><span class="line">    <span class="comment">// there are no grey objects and no more objects can be</span></span><br><span class="line">    <span class="comment">// shaded. Transition to mark termination.</span></span><br><span class="line">    <span class="comment">// èµ°åˆ°è¿™ä¸€æ­¥æ„å‘³ç€å¯ä»¥å°†çŠ¶æ€è½¬å˜ä¸º markTermination</span></span><br><span class="line">    now := nanotime()</span><br><span class="line">    work.tMarkTerm = now</span><br><span class="line">    work.pauseStart = now</span><br><span class="line">    getg().m.preemptoff = <span class="string">&quot;gcing&quot;</span></span><br><span class="line">    <span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">        traceGCSTWStart(<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    systemstack(stopTheWorldWithSema)</span><br><span class="line">    <span class="comment">// The gcphase is _GCmark, it will transition to _GCmarktermination</span></span><br><span class="line">    <span class="comment">// below. The important thing is that the wb remains active until</span></span><br><span class="line">    <span class="comment">// all marking is complete. This includes writes made by the GC.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// There is sometimes work left over when we enter mark termination due</span></span><br><span class="line">    <span class="comment">// to write barriers performed after the completion barrier above.</span></span><br><span class="line">    <span class="comment">// Detect this and resume concurrent mark. This is obviously</span></span><br><span class="line">    <span class="comment">// unfortunate.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// See issue #27993 for details.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Switch to the system stack to call wbBufFlush1, though in this case</span></span><br><span class="line">    <span class="comment">// it doesn&#x27;t matter because we&#x27;re non-preemptible anyway.</span></span><br><span class="line">    restart := <span class="literal">false</span></span><br><span class="line">    systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> _, p := <span class="keyword">range</span> allp &#123;</span><br><span class="line">            wbBufFlush1(p)</span><br><span class="line">            <span class="keyword">if</span> !p.gcw.empty() &#123;</span><br><span class="line">                restart = <span class="literal">true</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span> restart &#123;</span><br><span class="line">        getg().m.preemptoff = <span class="string">&quot;&quot;</span></span><br><span class="line">        systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            now := startTheWorldWithSema(<span class="literal">true</span>)</span><br><span class="line">            work.pauseNS += now - work.pauseStart</span><br><span class="line">            memstats.gcPauseDist.record(now - work.pauseStart)</span><br><span class="line">        &#125;)</span><br><span class="line">        semrelease(&amp;worldsema)</span><br><span class="line">        <span class="keyword">goto</span> top</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Disable assists and background workers. We must do</span></span><br><span class="line">    <span class="comment">// this before waking blocked assists.</span></span><br><span class="line">    atomic.Store(&amp;gcBlackenEnabled, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wake all blocked assists. These will run when we</span></span><br><span class="line">    <span class="comment">// start the world again.</span></span><br><span class="line">    <span class="comment">// å”¤é†’å› ååŠ©æ ‡è®°è€Œé˜»å¡çš„ goroutine</span></span><br><span class="line">    gcWakeAllAssists()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Likewise, release the transition lock. Blocked</span></span><br><span class="line">    <span class="comment">// workers and assists will run when we start the</span></span><br><span class="line">    <span class="comment">// world again.</span></span><br><span class="line">    semrelease(&amp;work.markDoneSema)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// In STW mode, re-enable user goroutines. These will be</span></span><br><span class="line">    <span class="comment">// queued to run after we start the world.</span></span><br><span class="line">    schedEnableUser(<span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// endCycle depends on all gcWork cache stats being flushed.</span></span><br><span class="line">    <span class="comment">// The termination algorithm above ensured that up to</span></span><br><span class="line">    <span class="comment">// allocations since the ragged barrier.</span></span><br><span class="line">    nextTriggerRatio := gcController.endCycle(work.userForced)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Perform mark termination. This will restart the world.</span></span><br><span class="line">    gcMarkTermination(nextTriggerRatio)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ç•ªå¤–ç¯‡"><a href="#ç•ªå¤–ç¯‡" class="headerlink" title="ç•ªå¤–ç¯‡"></a>ç•ªå¤–ç¯‡</h2><h3 id="suspendG"><a href="#suspendG" class="headerlink" title="suspendG"></a>suspendG</h3><ul>
<li>ä»å…¨å±€ g é˜Ÿåˆ—ä¸­è·å–ä¸€ä¸ªï¼Œè¿™ä¸ª g æœ‰å¯èƒ½æ˜¯ä¸€ä¸‹å‡ ç§æƒ…å†µ<ul>
<li>æ­£åœ¨åˆ«çš„ P ä¸Šè¿è¡Œ</li>
<li>æ­£åœ¨è¿›è¡Œç³»ç»Ÿè°ƒç”¨</li>
<li>æ­£åœ¨æŸä¸ªåœ°æ–¹ç­‰å¾…</li>
<li>å·²ç»æ˜¯å¯æ‰§è¡ŒçŠ¶æ€</li>
<li>æ­£åœ¨å‘ç”ŸæŠ¢å </li>
<li>ä¹Ÿå¯èƒ½æ˜¯å½“å‰è¿™ä¸ª gcMarkWorker</li>
</ul>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    suspendG åœ¨ä¸€ä¸ªå®‰å…¨æ—¶åˆ»æš‚åœ goroutine å¹¶ä¸”è¿”å›è¢«æŒ‚èµ· goroutine çš„çŠ¶æ€ã€‚</span></span><br><span class="line"><span class="comment">    suspendG çš„è°ƒç”¨è€…æ‹¥æœ‰è¯¥ goroutine çš„è¯»æƒé™ç›´åˆ°è°ƒç”¨çš„ resumeGã€‚</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    å¤šä¸ªè°ƒç”¨è€…åœ¨åŒä¸€æ—¶åˆ»æƒ³æŒ‚èµ·åŒä¸€ä¸ª goroutine æ˜¯å®‰å…¨çš„ã€‚</span></span><br><span class="line"><span class="comment">    The goroutine may execute between subsequent successful suspend operations.</span></span><br><span class="line"><span class="comment">    å½“å‰çš„å®ç°ä¸ºäº’æ–¥è®¿é—® goroutineï¼Œå› æ­¤å¤šä¸ªè°ƒç”¨è€…çš„è®¿é—®ä¼šè¢«ä¸²è¡ŒåŒ–ã€‚</span></span><br><span class="line"><span class="comment">    ç„¶è€Œï¼Œè¿™æ ·çš„ç›®çš„æ˜¯ä¸ºäº†è¯»å…±äº«ï¼Œæ‰€ä»¥è¯·ä¸è¦ä¾èµ–äº’æ–¥è®¿é—®ã€‚</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    suspendG ä¸€å®šè¦åœ¨ system stack ä¸Šè°ƒç”¨å¹¶ä¸”å½“å‰ M ä¸Šçš„ goroutine ä¸€å®šæ˜¯å¯ä»¥è¢«æŠ¢å çš„çŠ¶æ€ã€‚è¿™é˜»æ­¢äº†ä¸¤ä¸ª goroutine å°è¯•ç›¸äº’æŒ‚èµ·ä½†æ˜¯ä»–ä»¬éƒ½å¤„åœ¨éæŠ¢å çŠ¶æ€ä¸‹å‘ç”Ÿæ­»é”çš„æƒ…å†µã€‚è™½ç„¶è¿˜æœ‰å…¶ä»–çš„æ–¹å¼å¯ä»¥è§£å†³æ­»é”ï¼Œä½†æ˜¯è¿™ç§æ˜¯æœ€ç®€å•çš„æ–¹å¼ã€‚</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//go:systemstack</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">suspendG</span><span class="params">(gp *g)</span> <span class="title">suspendGState</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> mp := getg().m; mp.curg != <span class="literal">nil</span> &amp;&amp; readgstatus(mp.curg) == _Grunning &#123;</span><br><span class="line">        <span class="comment">// Since we&#x27;re on the system stack of this M, the user</span></span><br><span class="line">        <span class="comment">// G is stuck at an unsafe point. If another goroutine</span></span><br><span class="line">        <span class="comment">// were to try to preempt m.curg, it could deadlock.</span></span><br><span class="line">        throw(<span class="string">&quot;suspendG from non-preemptible goroutine&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// See https://golang.org/cl/21503 for justification of the yield delay.</span></span><br><span class="line">    <span class="keyword">const</span> yieldDelay = <span class="number">10</span> * <span class="number">1000</span></span><br><span class="line">    <span class="keyword">var</span> nextYield <span class="keyword">int64</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Drive the goroutine to a preemption point.</span></span><br><span class="line">    stopped := <span class="literal">false</span></span><br><span class="line">    <span class="keyword">var</span> asyncM *m</span><br><span class="line">    <span class="keyword">var</span> asyncGen <span class="keyword">uint32</span></span><br><span class="line">    <span class="keyword">var</span> nextPreemptM <span class="keyword">int64</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; ; i++ &#123;</span><br><span class="line">        <span class="keyword">switch</span> s := readgstatus(gp); s &#123;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">if</span> s&amp;_Gscan != <span class="number">0</span> &#123;</span><br><span class="line">                <span class="comment">// Someone else is suspending it. Wait</span></span><br><span class="line">                <span class="comment">// for them to finish.</span></span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                <span class="comment">// <span class="doctag">TODO:</span> It would be nicer if we could</span></span><br><span class="line">                <span class="comment">// coalesce suspends.</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            dumpgstatus(gp)</span><br><span class="line">            throw(<span class="string">&quot;invalid g status&quot;</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> _Gdead:</span><br><span class="line">            <span class="comment">// Nothing to suspend.</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// preemptStop may need to be cleared, but</span></span><br><span class="line">            <span class="comment">// doing that here could race with goroutine</span></span><br><span class="line">            <span class="comment">// reuse. Instead, goexit0 clears it.</span></span><br><span class="line">            <span class="keyword">return</span> suspendGState&#123;dead: <span class="literal">true</span>&#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> _Gcopystack:</span><br><span class="line">            <span class="comment">// The stack is being copied. We need to wait</span></span><br><span class="line">            <span class="comment">// until this is done.</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> _Gpreempted:</span><br><span class="line">            <span class="comment">// We (or someone else) suspended the G. Claim</span></span><br><span class="line">            <span class="comment">// ownership of it by transitioning it to</span></span><br><span class="line">            <span class="comment">// _Gwaiting.</span></span><br><span class="line">            <span class="keyword">if</span> !casGFromPreempted(gp, _Gpreempted, _Gwaiting) &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// We stopped the G, so we have to ready it later.</span></span><br><span class="line">            stopped = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">            s = _Gwaiting</span><br><span class="line">            <span class="keyword">fallthrough</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> _Grunnable, _Gsyscall, _Gwaiting:</span><br><span class="line">            <span class="comment">// Claim goroutine by setting scan bit.</span></span><br><span class="line">            <span class="comment">// This may race with execution or readying of gp.</span></span><br><span class="line">            <span class="comment">// The scan bit keeps it from transition state.</span></span><br><span class="line">            <span class="keyword">if</span> !castogscanstatus(gp, s, s|_Gscan) &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Clear the preemption request. It&#x27;s safe to</span></span><br><span class="line">            <span class="comment">// reset the stack guard because we hold the</span></span><br><span class="line">            <span class="comment">// _Gscan bit and thus own the stack.</span></span><br><span class="line">            gp.preemptStop = <span class="literal">false</span></span><br><span class="line">            gp.preempt = <span class="literal">false</span></span><br><span class="line">            gp.stackguard0 = gp.stack.lo + _StackGuard</span><br><span class="line"></span><br><span class="line">            <span class="comment">// The goroutine was already at a safe-point</span></span><br><span class="line">            <span class="comment">// and we&#x27;ve now locked that in.</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> It would be much better if we didn&#x27;t</span></span><br><span class="line">            <span class="comment">// leave it in _Gscan, but instead gently</span></span><br><span class="line">            <span class="comment">// prevented its scheduling until resumption.</span></span><br><span class="line">            <span class="comment">// Maybe we only use this to bump a suspended</span></span><br><span class="line">            <span class="comment">// count and the scheduler skips suspended</span></span><br><span class="line">            <span class="comment">// goroutines? That wouldn&#x27;t be enough for</span></span><br><span class="line">            <span class="comment">// &#123;_Gsyscall,_Gwaiting&#125; -&gt; _Grunning. Maybe</span></span><br><span class="line">            <span class="comment">// for all those transitions we need to check</span></span><br><span class="line">            <span class="comment">// suspended and deschedule?</span></span><br><span class="line">            <span class="keyword">return</span> suspendGState&#123;g: gp, stopped: stopped&#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> _Grunning:</span><br><span class="line">            <span class="comment">// Optimization: if there is already a pending preemption request</span></span><br><span class="line">            <span class="comment">// (from the previous loop iteration), don&#x27;t bother with the atomics.</span></span><br><span class="line">            <span class="keyword">if</span> gp.preemptStop &amp;&amp; gp.preempt &amp;&amp; gp.stackguard0 == stackPreempt &amp;&amp; asyncM == gp.m &amp;&amp; atomic.Load(&amp;asyncM.preemptGen) == asyncGen &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Temporarily block state transitions.</span></span><br><span class="line">            <span class="keyword">if</span> !castogscanstatus(gp, _Grunning, _Gscanrunning) &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Request synchronous preemption.</span></span><br><span class="line">            gp.preemptStop = <span class="literal">true</span></span><br><span class="line">            gp.preempt = <span class="literal">true</span></span><br><span class="line">            gp.stackguard0 = stackPreempt</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Prepare for asynchronous preemption.</span></span><br><span class="line">            asyncM2 := gp.m</span><br><span class="line">            asyncGen2 := atomic.Load(&amp;asyncM2.preemptGen)</span><br><span class="line">            needAsync := asyncM != asyncM2 || asyncGen != asyncGen2</span><br><span class="line">            asyncM = asyncM2</span><br><span class="line">            asyncGen = asyncGen2</span><br><span class="line"></span><br><span class="line">            casfrom_Gscanstatus(gp, _Gscanrunning, _Grunning)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Send asynchronous preemption. We do this</span></span><br><span class="line">            <span class="comment">// after CASing the G back to _Grunning</span></span><br><span class="line">            <span class="comment">// because preemptM may be synchronous and we</span></span><br><span class="line">            <span class="comment">// don&#x27;t want to catch the G just spinning on</span></span><br><span class="line">            <span class="comment">// its status.</span></span><br><span class="line">            <span class="keyword">if</span> preemptMSupported &amp;&amp; debug.asyncpreemptoff == <span class="number">0</span> &amp;&amp; needAsync &#123;</span><br><span class="line">                <span class="comment">// Rate limit preemptM calls. This is</span></span><br><span class="line">                <span class="comment">// particularly important on Windows</span></span><br><span class="line">                <span class="comment">// where preemptM is actually</span></span><br><span class="line">                <span class="comment">// synchronous and the spin loop here</span></span><br><span class="line">                <span class="comment">// can lead to live-lock.</span></span><br><span class="line">                now := nanotime()</span><br><span class="line">                <span class="keyword">if</span> now &gt;= nextPreemptM &#123;</span><br><span class="line">                    nextPreemptM = now + yieldDelay/<span class="number">2</span></span><br><span class="line">                    preemptM(asyncM)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Don&#x27;t busy wait. This loop should really only</span></span><br><span class="line">        <span class="comment">// be a simple read/decide/CAS loop that only fails if</span></span><br><span class="line">        <span class="comment">// there&#x27;s an active race. Once the CAS succeeds, we</span></span><br><span class="line">        <span class="comment">// should queue up the preemption (which will require</span></span><br><span class="line">        <span class="comment">// it to be reliable in the _Grunning case, not</span></span><br><span class="line">        <span class="comment">// best-effort) and then sleep until we&#x27;re notified</span></span><br><span class="line">        <span class="comment">// that the goroutine is suspended.</span></span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">            nextYield = nanotime() + yieldDelay</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> nanotime() &lt; nextYield &#123;</span><br><span class="line">            procyield(<span class="number">10</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            osyield()</span><br><span class="line">            nextYield = nanotime() + yieldDelay/<span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="resumeG"><a href="#resumeG" class="headerlink" title="resumeG"></a>resumeG</h3><h3 id="ç¨æ”¶ä¸å¼€æ”¯"><a href="#ç¨æ”¶ä¸å¼€æ”¯" class="headerlink" title="ç¨æ”¶ä¸å¼€æ”¯"></a>ç¨æ”¶ä¸å¼€æ”¯</h3><ul>
<li>åŸºæœ¬ç†å¿µ</li>
</ul>
<p>â€‹        æ¯ä¸ªèµ‹å€¼å™¨çº¿ç¨‹éƒ½åº”å½“å‚ä¸ä¸€å®šçš„å›æ”¶å·¥ä½œï¼ˆå³çº³ç¨ï¼‰ã€‚åŒæ—¶ä¹Ÿåº”å½“ä¸å›æ”¶å™¨äº¤æ›¿æ‰§è¡Œï¼Œä»¥ç¡®ä¿æœ€å°èµ‹å€¼å™¨ä½¿ç”¨ç‡çš„è¦æ±‚ã€‚    </p>
<p>â€‹        å›æ”¶å™¨åº”å¯åœ¨èµ‹å€¼å™¨æ‰§è¡Œé—´éš™å°½é‡å¤šçš„æ‰§è¡Œå›æ”¶å·¥ä½œï¼ˆå³å°½é‡å¤šçš„ç§¯ç´¯ creditï¼Œä»¥ä¾›èµ‹å€¼å™¨æ”¯å‡ºã€‚ï¼‰</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// gcFlushBgCredit flushes scanWork units of background scan work</span></span><br><span class="line"><span class="comment">// credit. This first satisfies blocked assists on the</span></span><br><span class="line"><span class="comment">// work.assistQueue and then flushes any remaining credit to</span></span><br><span class="line"><span class="comment">// gcController.bgScanCredit.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Write barriers are disallowed because this is used by gcDrain after</span></span><br><span class="line"><span class="comment">// it has ensured that all work is drained and this must preserve that</span></span><br><span class="line"><span class="comment">// condition.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//go:nowritebarrierrec</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcFlushBgCredit</span><span class="params">(scanWork <span class="keyword">int64</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> work.assistQueue.q.empty() &#123;</span><br><span class="line">        <span class="comment">// Fast path; there are no blocked assists. There&#x27;s a</span></span><br><span class="line">        <span class="comment">// small window here where an assist may add itself to</span></span><br><span class="line">        <span class="comment">// the blocked queue and park. If that happens, we&#x27;ll</span></span><br><span class="line">        <span class="comment">// just get it on the next flush.</span></span><br><span class="line">        atomic.Xaddint64(&amp;gcController.bgScanCredit, scanWork)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    assistBytesPerWork := float64frombits(atomic.Load64(&amp;gcController.assistBytesPerWork))</span><br><span class="line">    scanBytes := <span class="keyword">int64</span>(<span class="keyword">float64</span>(scanWork) * assistBytesPerWork)</span><br><span class="line"></span><br><span class="line">    lock(&amp;work.assistQueue.lock)</span><br><span class="line">    <span class="keyword">for</span> !work.assistQueue.q.empty() &amp;&amp; scanBytes &gt; <span class="number">0</span> &#123;</span><br><span class="line">        gp := work.assistQueue.q.pop()</span><br><span class="line">        <span class="comment">// Note that gp.gcAssistBytes is negative because gp</span></span><br><span class="line">        <span class="comment">// is in debt. Think carefully about the signs below.</span></span><br><span class="line">        <span class="comment">// scanBytes+gp.gcAssistBytes æ„å‘³ç€è¶³å¤Ÿæ”¯ä»˜å€ºåŠ¡</span></span><br><span class="line">        <span class="keyword">if</span> scanBytes+gp.gcAssistBytes &gt;= <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// Satisfy this entire assist debt.</span></span><br><span class="line">            scanBytes += gp.gcAssistBytes</span><br><span class="line">            gp.gcAssistBytes = <span class="number">0</span></span><br><span class="line">            <span class="comment">// It&#x27;s important that we *not* put gp in</span></span><br><span class="line">            <span class="comment">// runnext. Otherwise, it&#x27;s possible for user</span></span><br><span class="line">            <span class="comment">// code to exploit the GC worker&#x27;s high</span></span><br><span class="line">            <span class="comment">// scheduler priority to get itself always run</span></span><br><span class="line">            <span class="comment">// before other goroutines and always in the</span></span><br><span class="line">            <span class="comment">// fresh quantum started by GC.</span></span><br><span class="line">            <span class="comment">// è¿˜å€ºåå”¤é†’è¿™ä¸ª g</span></span><br><span class="line">            ready(gp, <span class="number">0</span>, <span class="literal">false</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// æ²¡æ³•å®Œå…¨æ”¯ä»˜å€ºåŠ¡ï¼Œä½†æ˜¯å¯ä»¥å¿è¿˜ä¸€éƒ¨åˆ†</span></span><br><span class="line">            <span class="comment">// å¿è¿˜å®Œæˆåï¼Œåˆæ”¾å›äº†ååŠ©æ ‡è®°çš„é˜Ÿåˆ—ä¸­</span></span><br><span class="line">            <span class="comment">// Partially satisfy this assist.</span></span><br><span class="line">            gp.gcAssistBytes += scanBytes</span><br><span class="line">            scanBytes = <span class="number">0</span></span><br><span class="line">            <span class="comment">// As a heuristic, we move this assist to the</span></span><br><span class="line">            <span class="comment">// back of the queue so that large assists</span></span><br><span class="line">            <span class="comment">// can&#x27;t clog up the assist queue and</span></span><br><span class="line">            <span class="comment">// substantially delay small assists.</span></span><br><span class="line">            work.assistQueue.q.pushBack(gp)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// å¦‚æœä»ç„¶æœ‰å‰©ä½™çš„ credit å°±åˆ·æ–°åˆ°å…¨å±€çš„ credit ä¸­</span></span><br><span class="line">    <span class="keyword">if</span> scanBytes &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// Convert from scan bytes back to work.</span></span><br><span class="line">        assistWorkPerByte := float64frombits(atomic.Load64(&amp;gcController.assistWorkPerByte))</span><br><span class="line">        scanWork = <span class="keyword">int64</span>(<span class="keyword">float64</span>(scanBytes) * assistWorkPerByte)</span><br><span class="line">        atomic.Xaddint64(&amp;gcController.bgScanCredit, scanWork)</span><br><span class="line">    &#125;</span><br><span class="line">    unlock(&amp;work.assistQueue.lock)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="é¢˜å¤–è¯"><a href="#é¢˜å¤–è¯" class="headerlink" title="é¢˜å¤–è¯"></a>é¢˜å¤–è¯</h2><p>GC çœŸçš„æ˜¯å¤ªéš¾äº†â€¦ æ„Ÿè§‰è¿™äº›éƒ½è¿˜åªæ˜¯å†°å±±ä¸€è§’ï¼Œæ›¹å¤§è®²è¿‡ï¼ŒGC è¿™éƒ¨åˆ†é‡åŠ›è€Œè¡Œï¼Œå¯¹äºå¤§éƒ¨åˆ†ç¨‹åºå‘˜æ¥è¯´å¯ä»¥å®Œæ•´çš„æŠŠä¸‰è‰²æŠ½è±¡ã€GC æµç¨‹ç»™é¢è¯•å®˜æè¿°å‡ºæ¥ï¼Œå·²ç»æ˜¯å¾ˆå‰å®³äº†ï¼Œå¦‚æœä»–è¿˜äº†è§£ä¸€äº›ç†è®ºåŸºç¡€ï¼Œé‚£ç®—æ˜¯ç›¸å½“ä¸é”™äº†â€¦</p>
<p>æˆ‘ä»¬è¿½æ±‚çš„ä¸æ˜¯å¾—åˆ°åˆ«äººçš„è®¤å¯ï¼Œè€Œæ˜¯å¯¹çŸ¥è¯†çš„æ¸´æœ›ã€‚ä¸¥äºå¾‹å·±ï¼Œæé«˜è‡ªå·±çš„èŒä¸šç´ å…»ã€‚</p>
</div><div id="donate"><link rel="stylesheet" type="text/css" href="/css/donate.css?v=1.0.0"><script type="text/javascript" src="/js/donate.js?v=1.0.0" successtext="å¤åˆ¶æˆåŠŸ!"></script><a class="pos-f tr3" id="github" href="https://github.com/clamyang" target="_blank" title="Github"></a><div id="DonateText">Donate</div><ul class="list pos-f" id="donateBox"><li id="AliPay" qr="/img/AliPayQR.jpg"></li><li id="WeChat" qr="/img/WeChatQR.jpg"></li></ul><div class="pos-f left-100" id="QRBox"><div id="MainBox"></div></div></div><div class="post-copyright"><script type="text/javascript" src="/js/copyright.js?v=1.0.0" successtext="å¤åˆ¶æˆåŠŸ!"></script><link rel="stylesheet" type="text/css" href="/css/copyright.css?v=1.0.0"><p><span>æœ¬æ–‡æ ‡é¢˜ï¼š</span>GC æºç æ¢³ç†</p><p><span>æ–‡ç« ä½œè€…ï¼š</span>bqyang</p><p><span>å‘å¸ƒæ—¶é—´ï¼š</span>2021-12-02</p><p><span>æœ€åæ›´æ–°ï¼š</span>2022-01-12</p><p><span>åŸå§‹é“¾æ¥ï¼š</span><a href="/2021/language/golang/GC/">https://bqyang.top/2021/language/golang/GC/</a><span class="copy-path"><i class="fa fa-clipboard" data-clipboard-text="https://bqyang.top/2021/language/golang/GC/"></i></span></p><p><span>ç‰ˆæƒå£°æ˜ï¼š</span>The author owns the copyright, please indicate the source reproduced.</p></div><br><div class="tags"></div><div class="post-nav"><a class="pre" href="/2021/language/golang/preemptSchedule/">golang ä¸­çš„æŠ¢å </a><a class="next" href="/2021/language/golang/GCComments/">GC from go comments</a></div><script src="https://utteranc.es/client.js" repo="clamyang/blogs" issue-term="title" theme="github-light" crossorigin="anonymous" async> </script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://bqyang.top"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> æœ€è¿‘æ–‡ç« </i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2022/os/process/process/">æ“ä½œç³»ç»Ÿè¿›ç¨‹</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/new-words/">new words for me</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/os/linker&loader/">linker and loader</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/summary/HappyWeekend/">Weekend</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/vcs/git/git-rebase/">git rebase</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/os/elf/">elf æ–‡ä»¶æ ¼å¼</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/DDIA/">DDIA è¯»ä¹¦ç¬”è®°</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/contributeToYunion/">ç¬¬ä¸€æ¬¡ pr</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/summary/tips0309/">ä¸€ç‚¹æ€»ç»“</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/rpc/about-rpc-1/">å…³äº rpc çš„é‚£äº›äº‹ï¼ˆä¸€ï¼‰</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> å‹æƒ…é“¾æ¥</i></div><ul></ul><a href="http://www.xargin.com/" title="Xargin" target="_blank">Xargin</a><ul></ul><a href="https://mytechshares.com/" title="è‘£æ³½æ¶¦çš„æŠ€æœ¯ç¬”è®°" target="_blank">è‘£æ³½æ¶¦çš„æŠ€æœ¯ç¬”è®°</a><ul></ul><a href="https://hujingnb.com/" title="çƒŸè‰çš„é¦™å‘³" target="_blank">çƒŸè‰çš„é¦™å‘³</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright Â© 2022 <a href="/." rel="nofollow">æ¨å®å¼ºçš„æŠ€æœ¯ç¬”è®°.</a>Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://beian.miit.gov.cn/"> äº¬ICPå¤‡2021035561å·.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="å¤åˆ¶æˆåŠŸ!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>