<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="一物不知深以为耻"><title>GC 源码梳理 | 杨宝强的技术笔记</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><div class="darkmode-toggle">🌓</div><script>var prefersDarkMode = window.matchMedia('(prefers-color-scheme: dark)');
var toggle = document.querySelector('.darkmode-toggle');
var html = document.querySelector('html');

html.dataset.dark = localStorage.dark || prefersDarkMode.matches;

toggle.addEventListener('click', () => {
localStorage.dark = !(html.dataset.dark == 'true');
html.dataset.dark = localStorage.dark;
});</script><meta name="generator" content="Hexo 5.4.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">GC 源码梳理</h1><a id="logo" href="/.">杨宝强的技术笔记</a><p class="description">Coder Gopher Watcher</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">GC 源码梳理</h1><div class="post-meta">2021-12-02</div><div class="post-content"><p>Golang GC 垃圾回收知识点总结，有些内容还没有完成，只是暂时写上了问题，还没来得及梳理相应的内容。</p>
<span id="more"></span>

<h2 id="GC-连连问"><a href="#GC-连连问" class="headerlink" title="GC 连连问"></a>GC 连连问</h2><h3 id="GC-的流程阶段"><a href="#GC-的流程阶段" class="headerlink" title="GC 的流程阶段"></a>GC 的流程阶段</h3><ul>
<li>sweep termination</li>
<li>mark</li>
<li>mark termination</li>
<li>sweep</li>
</ul>
<p>注：在下一次 GC mark 阶段开始之前，一定要完成上一次的清扫工作。所以我们看到了一个 sweep termination  阶段。根本原因是 Golang 中采用的是惰性清扫的。</p>
<h3 id="GC-的触发时机"><a href="#GC-的触发时机" class="headerlink" title="GC 的触发时机"></a>GC 的触发时机</h3><p>1.runtime.GC 手动触发</p>
<p>2.mallocgc 根据内存分配大小，比如当前使用 4M，当内存分配到达 8M 时，会触发 GC，这个百分比是可以调整的，通过 设置 triggerRatio 指定触发 GC 的阈值 go1.16.5 中，是 7/8.0 = 87.5% </p>
<p>3.forcegchelper 定时触发 GC</p>
<p>mallocgc 是主要的触发函数。</p>
<h3 id="GC-的起点"><a href="#GC-的起点" class="headerlink" title="GC 的起点"></a>GC 的起点</h3><p>gcStart，控制 worker 的数量，占 CPU 的 1/4。</p>
<h3 id="为什么老版本需要重新扫描栈？"><a href="#为什么老版本需要重新扫描栈？" class="headerlink" title="为什么老版本需要重新扫描栈？"></a>为什么老版本需要重新扫描栈？</h3><h3 id="GC-标记的根都有什么？"><a href="#GC-标记的根都有什么？" class="headerlink" title="GC 标记的根都有什么？"></a>GC 标记的根都有什么？</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// gcMarkRootPrepare queues root scanning jobs (stacks, globals, and</span></span><br><span class="line"><span class="comment">// some miscellany) and initializes scanning-related state.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The world must be stopped.</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	写在最前边，我们关注的重点只是 GC，</span></span><br><span class="line"><span class="comment">	不要过多的被其他知识点所蒙蔽，</span></span><br><span class="line"><span class="comment">	比如这里，我们只需要知道，根从哪里来，根都包含什么</span></span><br><span class="line"><span class="comment">	其它的都可以忽略．．</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcMarkRootPrepare</span><span class="params">()</span></span> &#123;</span><br><span class="line">    assertWorldStopped()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Compute how many data and BSS root blocks there are.</span></span><br><span class="line">    nBlocks := <span class="function"><span class="keyword">func</span><span class="params">(bytes <span class="keyword">uintptr</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">int</span>(divRoundUp(bytes, rootBlockBytes))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化需要被扫描的 data、bss 段个数</span></span><br><span class="line">    work.nDataRoots = <span class="number">0</span></span><br><span class="line">    work.nBSSRoots = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	暂时记录下目前的理解：</span></span><br><span class="line"><span class="comment">    	这里的 bss data 段，有可能会变得，比如说进行动态链接的时候，</span></span><br><span class="line"><span class="comment">    	就会把那个被链接的文件加入到 activeModules 中，所以都是通过</span></span><br><span class="line"><span class="comment">    	函数调用的方式来获取对应的数据</span></span><br><span class="line"><span class="comment">    	注：他这个对总数的赋值操作有点迷惑，不知道为啥要这样写..</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Scan globals.</span></span><br><span class="line">    <span class="keyword">for</span> _, datap := <span class="keyword">range</span> activeModules() &#123;</span><br><span class="line">        nDataRoots := nBlocks(datap.edata - datap.data)</span><br><span class="line">        <span class="keyword">if</span> nDataRoots &gt; work.nDataRoots &#123;</span><br><span class="line">            work.nDataRoots = nDataRoots</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, datap := <span class="keyword">range</span> activeModules() &#123;</span><br><span class="line">        nBSSRoots := nBlocks(datap.ebss - datap.bss)</span><br><span class="line">        <span class="keyword">if</span> nBSSRoots &gt; work.nBSSRoots &#123;</span><br><span class="line">            work.nBSSRoots = nBSSRoots</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Scan span roots for finalizer specials.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// We depend on addfinalizer to mark objects that get</span></span><br><span class="line">    <span class="comment">// finalizers after root marking.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// We&#x27;re going to scan the whole heap (that was available at the time the</span></span><br><span class="line">    <span class="comment">// mark phase started, i.e. markArenas) for in-use spans which have specials.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Break up the work into arenas, and further into chunks.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Snapshot allArenas as markArenas. This snapshot is safe because allArenas</span></span><br><span class="line">    <span class="comment">// is append-only.</span></span><br><span class="line">    <span class="comment">// 扫描整个 heap，对 allArenas 做快照</span></span><br><span class="line">    mheap_.markArenas = mheap_.allArenas[:<span class="built_in">len</span>(mheap_.allArenas):<span class="built_in">len</span>(mheap_.allArenas)]</span><br><span class="line">    <span class="comment">// 计算需要扫描的 span 数量，arena * （单个 arena 中 span 的数量）</span></span><br><span class="line">    work.nSpanRoots = <span class="built_in">len</span>(mheap_.markArenas) * (pagesPerArena / pagesPerSpanRoot)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Scan stacks.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Gs may be created after this point, but it&#x27;s okay that we</span></span><br><span class="line">    <span class="comment">// ignore them because they begin life without any roots, so</span></span><br><span class="line">    <span class="comment">// there&#x27;s nothing to scan, and any roots they create during</span></span><br><span class="line">    <span class="comment">// the concurrent phase will be caught by the write barrier.</span></span><br><span class="line">    <span class="comment">// 如注释所说，尽管这时候有 goroutine 被创建，也不需要担心</span></span><br><span class="line">    <span class="comment">// 因为他们没有 root，即不需要扫描。如果在并发阶段创建出来的 goroutine，</span></span><br><span class="line">    <span class="comment">// 这个 G 使用的 root 会被 write barrier 捕获到。</span></span><br><span class="line">    work.nStackRoots = <span class="keyword">int</span>(atomic.Loaduintptr(&amp;allglen))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化标记的开始位置</span></span><br><span class="line">    work.markrootNext = <span class="number">0</span></span><br><span class="line">    <span class="comment">//　计算所有根的数量</span></span><br><span class="line">    <span class="comment">//　包括了：Data　段，BSS　段,span,以及 goroutine 栈</span></span><br><span class="line">    work.markrootJobs = <span class="keyword">uint32</span>(fixedRootCount + work.nDataRoots + work.nBSSRoots + work.nSpanRoots + work.nStackRoots)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Calculate base indexes of each root type</span></span><br><span class="line">    <span class="comment">// markroot 标记的时候会根据不同的 i 找到不同的根</span></span><br><span class="line">    work.baseData = <span class="keyword">uint32</span>(fixedRootCount)</span><br><span class="line">    work.baseBSS = work.baseData + <span class="keyword">uint32</span>(work.nDataRoots)</span><br><span class="line">    work.baseSpans = work.baseBSS + <span class="keyword">uint32</span>(work.nBSSRoots)</span><br><span class="line">    work.baseStacks = work.baseSpans + <span class="keyword">uint32</span>(work.nSpanRoots)</span><br><span class="line">    work.baseEnd = work.baseStacks + <span class="keyword">uint32</span>(work.nStackRoots)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>结合上边代码来看，GC 标记过程中涉及到的根有：全局变量，stack，heap（span）</li>
</ul>
<h3 id="单独使用-D-屏障有何问题？"><a href="#单独使用-D-屏障有何问题？" class="headerlink" title="单独使用 D 屏障有何问题？"></a>单独使用 D 屏障有何问题？</h3><h3 id="单独使用-Y-屏障有何问题？"><a href="#单独使用-Y-屏障有何问题？" class="headerlink" title="单独使用 Y 屏障有何问题？"></a>单独使用 Y 屏障有何问题？</h3><h3 id="混合写屏障是怎么一回事？"><a href="#混合写屏障是怎么一回事？" class="headerlink" title="混合写屏障是怎么一回事？"></a>混合写屏障是怎么一回事？</h3><h3 id="协助标记流程"><a href="#协助标记流程" class="headerlink" title="协助标记流程"></a>协助标记流程</h3><p>这个涉及到 credit 的机制，一般都是 malloc 中 credit 不够了，才进行的。</p>
<h3 id="对象的交叉引用是如何剪枝的？"><a href="#对象的交叉引用是如何剪枝的？" class="headerlink" title="对象的交叉引用是如何剪枝的？"></a>对象的交叉引用是如何剪枝的？</h3><p>通过原子操作 <code>atomic.Or8</code> 避免了重复标记</p>
<h4 id="与运算"><a href="#与运算" class="headerlink" title="与运算"></a>与运算</h4><p>两个都是一才是一</p>
<h4 id="或运算"><a href="#或运算" class="headerlink" title="或运算"></a>或运算</h4><p>有一个是一就是一</p>
<h4 id="异或运算"><a href="#异或运算" class="headerlink" title="异或运算"></a>异或运算</h4><p>同零异一</p>
<h3 id="GC-的-CPU-使用率"><a href="#GC-的-CPU-使用率" class="headerlink" title="GC 的 CPU 使用率"></a>GC 的 CPU 使用率</h3><ul>
<li>GC cpu 使用率主要用来控制，启动 mark worker 的数量</li>
</ul>
<p>mark worker count = gomaxprocs * 25%</p>
<p>如果 gomaxprocs = 4，那么只需要启动一个 markworker</p>
<p>对于计算结果不为整数的情况，比如 gomaxprocs = 6，那么 work count  = 1.5，会对结果 + 0.5 进行 rounding， 然后通过计算误差是否 &gt; 0.3 判断开几个全职 worker</p>
<p>2/1.5 -1 = 1/3 &gt; 0.3</p>
<h3 id="gcTriggerKind"><a href="#gcTriggerKind" class="headerlink" title="gcTriggerKind"></a>gcTriggerKind</h3><p>gc 触发类型：</p>
<ul>
<li>gcTriggerHeap 内存到达阈值</li>
<li>gcTriggerTime 到达触发时间</li>
<li>gcTriggerCycle 可以理解为用户手动触发类型</li>
</ul>
<h3 id="STW-时间怎么算出来的？"><a href="#STW-时间怎么算出来的？" class="headerlink" title="STW 时间怎么算出来的？"></a>STW 时间怎么算出来的？</h3><h3 id="GC-过程中是什么时候将对象标记为黑色的"><a href="#GC-过程中是什么时候将对象标记为黑色的" class="headerlink" title="GC 过程中是什么时候将对象标记为黑色的"></a>GC 过程中是什么时候将对象标记为黑色的</h3><p>换句话说，是通过修改了什么变量，就代表这个指针被标记为黑色。</p>
<p>解释如下：</p>
<p>​    通过源码分析，我们可以知道，从白色对象到灰色对象是通过 greyobject 来实现的，同事也能够知道在 gcw 队列中的对象都是灰色的。</p>
<p>​    标记为黑色的过程是从 gcw 队列中取出灰色对象，再遍历其子对象并将其标灰，也即是说当灰色对象出队的时候就自动变成黑色了，就完成了将一个灰色对象标记位黑色的过程，在 Go 的源码中，其实并不存在的某个方法或者某个标志位，来表示一个对象是黑色的。</p>
<h2 id="gcStart-源码剖析"><a href="#gcStart-源码剖析" class="headerlink" title="gcStart 源码剖析"></a>gcStart 源码剖析</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// gcStart starts the GC. It transitions from _GCoff to _GCmark (if</span></span><br><span class="line"><span class="comment">// debug.gcstoptheworld == 0) or performs all of GC (if</span></span><br><span class="line"><span class="comment">// debug.gcstoptheworld != 0).</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This may return without performing this transition in some cases,</span></span><br><span class="line"><span class="comment">// such as when called on a system stack or with locks held.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// gcStart 是 GC 的起点，并将 GC 的状态由 _GCoff 切换到 _GCmark，</span></span><br><span class="line"><span class="comment">// 如果 gcStart 在系统栈上被调用或者持有锁的时候，就不会执行状态的改变直接返回了。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcStart</span><span class="params">(trigger gcTrigger)</span></span> &#123;</span><br><span class="line">    <span class="comment">// Since this is called from malloc and malloc is called in</span></span><br><span class="line">    <span class="comment">// the guts of a number of libraries that might be holding</span></span><br><span class="line">    <span class="comment">// locks, don&#x27;t attempt to start GC in non-preemptible or</span></span><br><span class="line">    <span class="comment">// potentially unstable situations.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 gcStart 是从 malloc 调用的，并且 malloc 又是被其他的库调用的，</span></span><br><span class="line">    <span class="comment">// 这种情况下可能会持有锁（mp.locks &gt; 1）</span></span><br><span class="line">    <span class="comment">// 不要再非抢占或者不稳定的情况下调用 gcStart</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       我的理解：如果不是非抢占模式，可能会导致后面 stw 时，一些 g 没有办法停止</span></span><br><span class="line"><span class="comment">       会影响 GC 的结果。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    mp := acquirem()</span><br><span class="line">    <span class="comment">// mp.locks &gt; 1 说明在 gcStart 之前就持有锁</span></span><br><span class="line">    <span class="comment">// mp.preemptoff != &quot;&quot; 说明在 non-preempt 模式下</span></span><br><span class="line">    <span class="keyword">if</span> gp := getg(); gp == mp.g0 || mp.locks &gt; <span class="number">1</span> || mp.preemptoff != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        releasem(mp)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    releasem(mp)</span><br><span class="line">    mp = <span class="literal">nil</span>	</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Pick up the remaining unswept/not being swept spans concurrently</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// This shouldn&#x27;t happen if we&#x27;re being invoked in background</span></span><br><span class="line">    <span class="comment">// mode since proportional sweep should have just finished</span></span><br><span class="line">    <span class="comment">// sweeping everything, but rounding errors, etc, may leave a</span></span><br><span class="line">    <span class="comment">// few spans unswept. In forced mode, this is necessary since</span></span><br><span class="line">    <span class="comment">// GC can be forced at any point in the sweeping cycle.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// We check the transition condition continuously here in case</span></span><br><span class="line">    <span class="comment">// this G gets delayed in to the next GC cycle.</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        trigger.test() 检测是否满足 GC 的触发条件</span></span><br><span class="line"><span class="comment">        sweepone() 我的理解是：清扫上次 GC 遗留下来的 unswept 的 span</span></span><br><span class="line"><span class="comment">        ？？ 是否可以理解成 sweep termination 的阶段 </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">for</span> trigger.test() &amp;&amp; sweepone() != ^<span class="keyword">uintptr</span>(<span class="number">0</span>) &#123;</span><br><span class="line">        sweep.nbgsweep++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Perform GC initialization and the sweep termination</span></span><br><span class="line">    <span class="comment">// transition.</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	semaacquire 的操作，是否可以理解为，通过 atomic 去掉了锁。</span></span><br><span class="line"><span class="comment">		换句话说，只有获取了某个 sema，才能对 gc 状态进行修改。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    semacquire(&amp;work.startSema)</span><br><span class="line">    <span class="comment">// Re-check transition condition under transition lock.</span></span><br><span class="line">    <span class="keyword">if</span> !trigger.test() &#123;</span><br><span class="line">        semrelease(&amp;work.startSema)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// For stats, check if this GC was forced by the user.</span></span><br><span class="line">    work.userForced = trigger.kind == gcTriggerCycle</span><br><span class="line"></span><br><span class="line">    <span class="comment">// In gcstoptheworld debug mode, upgrade the mode accordingly.</span></span><br><span class="line">    <span class="comment">// We do this after re-checking the transition condition so</span></span><br><span class="line">    <span class="comment">// that multiple goroutines that detect the heap trigger don&#x27;t</span></span><br><span class="line">    <span class="comment">// start multiple STW GCs.</span></span><br><span class="line">    <span class="comment">// 如果没开启 GODEBUG 都是 gcBackgroundMode 模式</span></span><br><span class="line">    mode := gcBackgroundMode</span><br><span class="line">    <span class="keyword">if</span> debug.gcstoptheworld == <span class="number">1</span> &#123;</span><br><span class="line">        mode = gcForceMode</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> debug.gcstoptheworld == <span class="number">2</span> &#123;</span><br><span class="line">        mode = gcForceBlockMode</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ok, we&#x27;re doing it! Stop everybody else</span></span><br><span class="line">    <span class="comment">// 获取 STW 需要的 semaphore</span></span><br><span class="line">    semacquire(&amp;gcsema)</span><br><span class="line">    semacquire(&amp;worldsema)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">        traceGCStart()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check that all Ps have finished deferred mcache flushes.</span></span><br><span class="line">    <span class="comment">// TODO 检查 P 的 mcache</span></span><br><span class="line">    <span class="keyword">for</span> _, p := <span class="keyword">range</span> allp &#123;</span><br><span class="line">        <span class="keyword">if</span> fg := atomic.Load(&amp;p.mcache.flushGen); fg != mheap_.sweepgen &#123;</span><br><span class="line">            <span class="built_in">println</span>(<span class="string">&quot;runtime: p&quot;</span>, p.id, <span class="string">&quot;flushGen&quot;</span>, fg, <span class="string">&quot;!= sweepgen&quot;</span>, mheap_.sweepgen)</span><br><span class="line">            throw(<span class="string">&quot;p mcache not flushed&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开启 nproc 个 gcMarkWorker，加入到 workerPool 中</span></span><br><span class="line">    <span class="comment">// 创建完一个 worker，休眠一个 worker</span></span><br><span class="line">    <span class="comment">// 由 schedule.findRunnableGCWorker 唤醒</span></span><br><span class="line">    gcBgMarkStartWorkers()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置标志位，allg 的标志位，heapArena 的标志位</span></span><br><span class="line">    <span class="comment">// 清空了每一个 g 的 AssistBytes</span></span><br><span class="line">    systemstack(gcResetMarkState)</span><br><span class="line"></span><br><span class="line">    work.stwprocs, work.maxprocs = gomaxprocs, gomaxprocs</span><br><span class="line">    <span class="keyword">if</span> work.stwprocs &gt; ncpu &#123;</span><br><span class="line">        <span class="comment">// This is used to compute CPU time of the STW phases,</span></span><br><span class="line">        <span class="comment">// so it can&#x27;t be more than ncpu, even if GOMAXPROCS is.</span></span><br><span class="line">        work.stwprocs = ncpu</span><br><span class="line">    &#125;</span><br><span class="line">    work.heap0 = atomic.Load64(&amp;memstats.heap_live)</span><br><span class="line">    work.pauseNS = <span class="number">0</span></span><br><span class="line">    work.mode = mode</span><br><span class="line"></span><br><span class="line">    now := nanotime()</span><br><span class="line">    work.tSweepTerm = now</span><br><span class="line">    work.pauseStart = now</span><br><span class="line">    <span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">        traceGCSTWStart(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// STW 调用者必须为 stopTheWorldWithSema 获取 worldsema 并且 关闭抢占</span></span><br><span class="line">    systemstack(stopTheWorldWithSema)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Finish sweep before we start concurrent scan.</span></span><br><span class="line">    <span class="comment">// 确保本次 GC 开始时，已完成上一次 GC 的 sweep 工作</span></span><br><span class="line">    systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        finishsweep_m()</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// clearpools before we start the GC. If we wait they memory will not be</span></span><br><span class="line">    <span class="comment">// reclaimed until the next GC cycle.</span></span><br><span class="line">    <span class="comment">// 1.处理 sync.Pool</span></span><br><span class="line">    <span class="comment">// 2.清空 sudog cache</span></span><br><span class="line">    <span class="comment">// 3.清空 defer pools</span></span><br><span class="line">    clearpools()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加 gc 周期数</span></span><br><span class="line">    work.cycles++</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始本次 gc 周期</span></span><br><span class="line">    gcController.startCycle()</span><br><span class="line">    work.heapGoal = memstats.next_gc</span><br><span class="line"></span><br><span class="line">    <span class="comment">// In STW mode, disable scheduling of user Gs. This may also</span></span><br><span class="line">    <span class="comment">// disable scheduling of this goroutine, so it may block as</span></span><br><span class="line">    <span class="comment">// soon as we start the world again.</span></span><br><span class="line">    <span class="keyword">if</span> mode != gcBackgroundMode &#123;</span><br><span class="line">        schedEnableUser(<span class="literal">false</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Enter concurrent mark phase and enable</span></span><br><span class="line">    <span class="comment">// write barriers.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Because the world is stopped, all Ps will</span></span><br><span class="line">    <span class="comment">// observe that write barriers are enabled by</span></span><br><span class="line">    <span class="comment">// the time we start the world and begin</span></span><br><span class="line">    <span class="comment">// scanning.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Write barriers must be enabled before assists are</span></span><br><span class="line">    <span class="comment">// enabled because they must be enabled before</span></span><br><span class="line">    <span class="comment">// any non-leaf heap objects are marked. Since</span></span><br><span class="line">    <span class="comment">// allocations are blocked until assists can</span></span><br><span class="line">    <span class="comment">// happen, we want enable assists as early as</span></span><br><span class="line">    <span class="comment">// possible.</span></span><br><span class="line">    setGCPhase(_GCmark)</span><br><span class="line"></span><br><span class="line">    gcBgMarkPrepare() <span class="comment">// Must happen before assist enable.</span></span><br><span class="line">    gcMarkRootPrepare()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Mark all active tinyalloc blocks. Since we&#x27;re</span></span><br><span class="line">    <span class="comment">// allocating from these, they need to be black like</span></span><br><span class="line">    <span class="comment">// other allocations. The alternative is to blacken</span></span><br><span class="line">    <span class="comment">// the tiny block on every allocation from it, which</span></span><br><span class="line">    <span class="comment">// would slow down the tiny allocator.</span></span><br><span class="line">    gcMarkTinyAllocs()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// At this point all Ps have enabled the write</span></span><br><span class="line">    <span class="comment">// barrier, thus maintaining the no white to</span></span><br><span class="line">    <span class="comment">// black invariant. Enable mutator assists to</span></span><br><span class="line">    <span class="comment">// put back-pressure on fast allocating</span></span><br><span class="line">    <span class="comment">// mutators.</span></span><br><span class="line">    atomic.Store(&amp;gcBlackenEnabled, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Assists and workers can start the moment we start</span></span><br><span class="line">    <span class="comment">// the world.</span></span><br><span class="line">    gcController.markStartTime = now</span><br><span class="line"></span><br><span class="line">    <span class="comment">// In STW mode, we could block the instant systemstack</span></span><br><span class="line">    <span class="comment">// returns, so make sure we&#x27;re not preemptible.</span></span><br><span class="line">    mp = acquirem()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Concurrent mark.</span></span><br><span class="line">    systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        now = startTheWorldWithSema(trace.enabled)</span><br><span class="line">        work.pauseNS += now - work.pauseStart</span><br><span class="line">        work.tMark = now</span><br><span class="line">        memstats.gcPauseDist.record(now - work.pauseStart)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Release the world sema before Gosched() in STW mode</span></span><br><span class="line">    <span class="comment">// because we will need to reacquire it later but before</span></span><br><span class="line">    <span class="comment">// this goroutine becomes runnable again, and we could</span></span><br><span class="line">    <span class="comment">// self-deadlock otherwise.</span></span><br><span class="line">    semrelease(&amp;worldsema)</span><br><span class="line">    releasem(mp)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure we block instead of returning to user code</span></span><br><span class="line">    <span class="comment">// in STW mode.</span></span><br><span class="line">    <span class="keyword">if</span> mode != gcBackgroundMode &#123;</span><br><span class="line">        Gosched()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    semrelease(&amp;work.startSema)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="findRunnableGCWorker-源码剖析"><a href="#findRunnableGCWorker-源码剖析" class="headerlink" title="findRunnableGCWorker 源码剖析"></a>findRunnableGCWorker 源码剖析</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// findRunnableGCWorker returns a background mark worker for _p_ if it</span></span><br><span class="line"><span class="comment">// should be run. This must only be called when gcBlackenEnabled != 0.</span></span><br><span class="line"><span class="comment">// 只有在 gc 开启的时候才会执行，gcStart 中设置为 1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *gcControllerState)</span> <span class="title">findRunnableGCWorker</span><span class="params">(_p_ *p)</span> *<span class="title">g</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> gcBlackenEnabled == <span class="number">0</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;gcControllerState.findRunnable: blackening not enabled&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> !gcMarkWorkAvailable(_p_) &#123;</span><br><span class="line">        <span class="comment">// No work to be done right now. This can happen at</span></span><br><span class="line">        <span class="comment">// the end of the mark phase when there are still</span></span><br><span class="line">        <span class="comment">// assists tapering off. Don&#x27;t bother running a worker</span></span><br><span class="line">        <span class="comment">// now because it&#x27;ll just return immediately.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Grab a worker before we commit to running below.</span></span><br><span class="line">    <span class="comment">// 从 workpool 中弹出一个 gcMarkWorker</span></span><br><span class="line">    node := (*gcBgMarkWorkerNode)(gcBgMarkWorkerPool.pop())</span><br><span class="line">    <span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// There is at least one worker per P, so normally there are</span></span><br><span class="line">        <span class="comment">// enough workers to run on all Ps, if necessary. However, once</span></span><br><span class="line">        <span class="comment">// a worker enters gcMarkDone it may park without rejoining the</span></span><br><span class="line">        <span class="comment">// pool, thus freeing a P with no corresponding worker.</span></span><br><span class="line">        <span class="comment">// gcMarkDone never depends on another worker doing work, so it</span></span><br><span class="line">        <span class="comment">// is safe to simply do nothing here.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// If gcMarkDone bails out without completing the mark phase,</span></span><br><span class="line">        <span class="comment">// it will always do so with queued global work. Thus, that P</span></span><br><span class="line">        <span class="comment">// will be immediately eligible to re-run the worker G it was</span></span><br><span class="line">        <span class="comment">// just using, ensuring work can complete.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于计算该 markNode 的工作模式</span></span><br><span class="line">    <span class="comment">// &gt;  0 dedicatedMode</span></span><br><span class="line">    <span class="comment">// &lt;= 0 fractionalMode</span></span><br><span class="line">    decIfPositive := <span class="function"><span class="keyword">func</span><span class="params">(ptr *<span class="keyword">int64</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            v := atomic.Loadint64(ptr)</span><br><span class="line">            <span class="keyword">if</span> v &lt;= <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> atomic.Casint64(ptr, v, v<span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> decIfPositive(&amp;c.dedicatedMarkWorkersNeeded) &#123;</span><br><span class="line">        <span class="comment">// This P is now dedicated to marking until the end of</span></span><br><span class="line">        <span class="comment">// the concurrent mark phase.</span></span><br><span class="line">        _p_.gcMarkWorkerMode = gcMarkWorkerDedicatedMode</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> c.fractionalUtilizationGoal == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// No need for fractional workers.</span></span><br><span class="line">        gcBgMarkWorkerPool.push(&amp;node.node)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Is this P behind on the fractional utilization</span></span><br><span class="line">        <span class="comment">// goal?</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// This should be kept in sync with pollFractionalWorkerExit.</span></span><br><span class="line">        delta := nanotime() - c.markStartTime</span><br><span class="line">        <span class="keyword">if</span> delta &gt; <span class="number">0</span> &amp;&amp; <span class="keyword">float64</span>(_p_.gcFractionalMarkTime)/<span class="keyword">float64</span>(delta) &gt; c.fractionalUtilizationGoal &#123;</span><br><span class="line">            <span class="comment">// Nope. No need to run a fractional worker.</span></span><br><span class="line">            gcBgMarkWorkerPool.push(&amp;node.node)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Run a fractional worker.</span></span><br><span class="line">        _p_.gcMarkWorkerMode = gcMarkWorkerFractionalMode</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Run the background mark worker.</span></span><br><span class="line">    <span class="comment">// 修改 workerg 的状态并返回</span></span><br><span class="line">    gp := node.gp.ptr()</span><br><span class="line">    casgstatus(gp, _Gwaiting, _Grunnable)</span><br><span class="line">    <span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">        traceGoUnpark(gp, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> gp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// gcMarkWorkAvailable reports whether executing a mark worker</span></span><br><span class="line"><span class="comment">// on p is potentially useful. p may be nil, in which case it only</span></span><br><span class="line"><span class="comment">// checks the global sources of work.</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	该函数主要作用：返回是否有标记工作可以干</span></span><br><span class="line"><span class="comment">	gcw p的队列</span></span><br><span class="line"><span class="comment">	work 全局队列</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcMarkWorkAvailable</span><span class="params">(p *p)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> p != <span class="literal">nil</span> &amp;&amp; !p.gcw.empty() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> !work.full.empty() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span> <span class="comment">// global work available</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> work.markrootNext &lt; work.markrootJobs &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span> <span class="comment">// root scan work available</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="剖析-gcBgMarkWorker-创建过程"><a href="#剖析-gcBgMarkWorker-创建过程" class="headerlink" title="剖析 gcBgMarkWorker 创建过程"></a>剖析 gcBgMarkWorker 创建过程</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// gcBgMarkStartWorkers prepares background mark worker goroutines. These</span></span><br><span class="line"><span class="comment">// goroutines will not run until the mark phase, but they must be started while</span></span><br><span class="line"><span class="comment">// the work is not stopped and from a regular G stack. The caller must hold</span></span><br><span class="line"><span class="comment">// worldsema.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcBgMarkStartWorkers</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Background marking is performed by per-P G&#x27;s. Ensure that each P has</span></span><br><span class="line">    <span class="comment">// a background GC G.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Worker Gs don&#x27;t exit if gomaxprocs is reduced. If it is raised</span></span><br><span class="line">    <span class="comment">// again, we can reuse the old workers; no need to create new workers.</span></span><br><span class="line">    <span class="keyword">for</span> gcBgMarkWorkerCount &lt; gomaxprocs &#123;</span><br><span class="line">        <span class="keyword">go</span> gcBgMarkWorker()</span><br><span class="line"></span><br><span class="line">        notetsleepg(&amp;work.bgMarkReady, <span class="number">-1</span>)</span><br><span class="line">        noteclear(&amp;work.bgMarkReady)</span><br><span class="line">        <span class="comment">// The worker is now guaranteed to be added to the pool before</span></span><br><span class="line">        <span class="comment">// its P&#x27;s next findRunnableGCWorker.</span></span><br><span class="line"></span><br><span class="line">        gcBgMarkWorkerCount++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>由上可知，所有 gcMarkWorker 都是通过该函数创建的，我们需要关注的是 <code>notesleepg()</code> 和 <code>go gcBgMarkWorker</code> 这两行代码</li>
</ul>
<h3 id="notesleepg"><a href="#notesleepg" class="headerlink" title="notesleepg"></a><code>notesleepg</code></h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// same as runtime·notetsleep, but called on user g (not g0)</span></span><br><span class="line"><span class="comment">// calls only nosplit functions between entersyscallblock/exitsyscall</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">notetsleepg</span><span class="params">(n *note, ns <span class="keyword">int64</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    gp := getg()</span><br><span class="line">    <span class="keyword">if</span> gp == gp.m.g0 &#123;</span><br><span class="line">        throw(<span class="string">&quot;notetsleepg on g0&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这个我们在学习 timer 的时候已经看过了</span></span><br><span class="line">    <span class="comment">// 主要就是执行 handoff</span></span><br><span class="line">    entersyscallblock()</span><br><span class="line">    <span class="comment">// 这里才是真正进行系统调用的地方，ns = -1，会无休止的休眠</span></span><br><span class="line">    <span class="comment">// 直到通过 wakeup 唤醒</span></span><br><span class="line">    ok := notetsleep_internal(n, ns)</span><br><span class="line">    <span class="comment">// 上述，通过 wakeup 唤醒后会继续执行这块代码</span></span><br><span class="line">    <span class="comment">// 该函数主要是给刚刚剥离的 GM 找一个 P</span></span><br><span class="line">    <span class="comment">// 找到了，执行</span></span><br><span class="line">    <span class="comment">// 没找到，把 g 放到全局队列</span></span><br><span class="line">    exitsyscall()</span><br><span class="line">    <span class="keyword">return</span> ok</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="go-gcBgMarkWorker"><a href="#go-gcBgMarkWorker" class="headerlink" title="go gcBgMarkWorker"></a><code>go gcBgMarkWorker</code></h3><ul>
<li>这里应用到 MPG 调度的知识点，我们通过 go 关键字新建一个 goroutine，放入 runnext 等待被调度。</li>
</ul>
<h3 id="结合着看"><a href="#结合着看" class="headerlink" title="结合着看"></a>结合着看</h3><p>我们假设现在只有一个 P，即 <code>runtime.GOMAXPROCS(1)</code> 。这时我们来看上述代码，其执行过程为：</p>
<ul>
<li>1.通过 <code>gcBgMarkStartWorkers</code> 创建 worker</li>
<li>2.worker 被放入 runnext 等待被调度</li>
<li>3.执行 <code>notesleepg</code><ul>
<li>handoffp</li>
<li>futex &amp;&amp; timeout = -1</li>
<li>第 3 步执行完成后，GM 已经从 P 上剥离</li>
</ul>
</li>
<li>4.handoffp 中会启动一个 M 继续执行调度循环</li>
<li>5.newM 从 P 上找 G 执行</li>
<li>6.拿到我们刚刚创建的 newg</li>
<li>7.进入到 <code>gcBgMarkWorker()</code> 中执行<ul>
<li>新建 node &amp;&amp; <strong>wakeup</strong> 休眠的 GM</li>
<li>然后 <code>gopark</code> 挂起 worker 等待唤醒</li>
</ul>
</li>
<li>8.休眠的 GM 醒来后<ul>
<li>尝试获取 oldp</li>
<li>如果获取不到则，尝试获取 idlep</li>
<li>如果获取不到则，将 g 放入全局队列</li>
</ul>
</li>
<li>9.第 8 步中的 g 被调度后，会继续执行 create worker 的工作，回到第 1 步 继续执行</li>
</ul>
<h2 id="gcMarkWorker-执行过程"><a href="#gcMarkWorker-执行过程" class="headerlink" title="gcMarkWorker 执行过程"></a>gcMarkWorker 执行过程</h2><h3 id="gcBgMarkWorker-源码剖析"><a href="#gcBgMarkWorker-源码剖析" class="headerlink" title="gcBgMarkWorker 源码剖析"></a>gcBgMarkWorker 源码剖析</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcBgMarkWorker</span><span class="params">()</span></span> &#123;</span><br><span class="line">    gp := getg()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We pass node to a gopark unlock function, so it can&#x27;t be on</span></span><br><span class="line">    <span class="comment">// the stack (see gopark). Prevent deadlock from recursively</span></span><br><span class="line">    <span class="comment">// starting GC by disabling preemption.</span></span><br><span class="line">    gp.m.preemptoff = <span class="string">&quot;GC worker init&quot;</span></span><br><span class="line">    node := <span class="built_in">new</span>(gcBgMarkWorkerNode)</span><br><span class="line">    gp.m.preemptoff = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    node.gp.set(gp)</span><br><span class="line"></span><br><span class="line">    node.m.set(acquirem())</span><br><span class="line">    notewakeup(&amp;work.bgMarkReady)</span><br><span class="line">    <span class="comment">// After this point, the background mark worker is generally scheduled</span></span><br><span class="line">    <span class="comment">// cooperatively by gcController.findRunnableGCWorker. While performing</span></span><br><span class="line">    <span class="comment">// work on the P, preemption is disabled because we are working on</span></span><br><span class="line">    <span class="comment">// P-local work buffers. When the preempt flag is set, this puts itself</span></span><br><span class="line">    <span class="comment">// into _Gwaiting to be woken up by gcController.findRunnableGCWorker</span></span><br><span class="line">    <span class="comment">// at the appropriate time.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// When preemption is enabled (e.g., while in gcMarkDone), this worker</span></span><br><span class="line">    <span class="comment">// may be preempted and schedule as a _Grunnable G from a runq. That is</span></span><br><span class="line">    <span class="comment">// fine; it will eventually gopark again for further scheduling via</span></span><br><span class="line">    <span class="comment">// findRunnableGCWorker.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Since we disable preemption before notifying bgMarkReady, we</span></span><br><span class="line">    <span class="comment">// guarantee that this G will be in the worker pool for the next</span></span><br><span class="line">    <span class="comment">// findRunnableGCWorker. This isn&#x27;t strictly necessary, but it reduces</span></span><br><span class="line">    <span class="comment">// latency between _GCmark starting and the workers starting.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// Go to sleep until woken by</span></span><br><span class="line">        <span class="comment">// gcController.findRunnableGCWorker.</span></span><br><span class="line">        gopark(<span class="function"><span class="keyword">func</span><span class="params">(g *g, nodep unsafe.Pointer)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">            node := (*gcBgMarkWorkerNode)(nodep)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> mp := node.m.ptr(); mp != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="comment">// The worker G is no longer running; release</span></span><br><span class="line">                <span class="comment">// the M.</span></span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                <span class="comment">// N.B. it is _safe_ to release the M as soon</span></span><br><span class="line">                <span class="comment">// as we are no longer performing P-local mark</span></span><br><span class="line">                <span class="comment">// work.</span></span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                <span class="comment">// However, since we cooperatively stop work</span></span><br><span class="line">                <span class="comment">// when gp.preempt is set, if we releasem in</span></span><br><span class="line">                <span class="comment">// the loop then the following call to gopark</span></span><br><span class="line">                <span class="comment">// would immediately preempt the G. This is</span></span><br><span class="line">                <span class="comment">// also safe, but inefficient: the G must</span></span><br><span class="line">                <span class="comment">// schedule again only to enter gopark and park</span></span><br><span class="line">                <span class="comment">// again. Thus, we defer the release until</span></span><br><span class="line">                <span class="comment">// after parking the G.</span></span><br><span class="line">                releasem(mp)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Release this G to the pool.</span></span><br><span class="line">            gcBgMarkWorkerPool.push(&amp;node.node)</span><br><span class="line">            <span class="comment">// Note that at this point, the G may immediately be</span></span><br><span class="line">            <span class="comment">// rescheduled and may be running.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;, unsafe.Pointer(node), waitReasonGCWorkerIdle, traceEvGoBlock, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        	以上代码都已经解释过了</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        	TODO 关于在 GC 期间什么时候可以抢占，什么时候禁止抢占</span></span><br><span class="line"><span class="comment">        	还需要进一步研究，目前可以先把整个流程梳理下来</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Preemption must not occur here, or another G might see</span></span><br><span class="line">        <span class="comment">// p.gcMarkWorkerMode.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Disable preemption so we can use the gcw. If the</span></span><br><span class="line">        <span class="comment">// scheduler wants to preempt us, we&#x27;ll stop draining,</span></span><br><span class="line">        <span class="comment">// dispose the gcw, and then preempt.</span></span><br><span class="line">        node.m.set(acquirem())</span><br><span class="line">        pp := gp.m.p.ptr() <span class="comment">// P can&#x27;t change with preemption disabled.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 是否已开启标记</span></span><br><span class="line">        <span class="keyword">if</span> gcBlackenEnabled == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="built_in">println</span>(<span class="string">&quot;worker mode&quot;</span>, pp.gcMarkWorkerMode)</span><br><span class="line">            throw(<span class="string">&quot;gcBgMarkWorker: blackening not enabled&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查 markworker 的 Mode</span></span><br><span class="line">        <span class="keyword">if</span> pp.gcMarkWorkerMode == gcMarkWorkerNotWorker &#123;</span><br><span class="line">            throw(<span class="string">&quot;gcBgMarkWorker: mode not set&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录 worker 标记的开始时间</span></span><br><span class="line">        startTime := nanotime()</span><br><span class="line">        pp.gcMarkWorkerStartTime = startTime</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将等待执行的 worker 数量减一</span></span><br><span class="line">        decnwait := atomic.Xadd(&amp;work.nwait, <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">if</span> decnwait == work.nproc &#123;</span><br><span class="line">            <span class="built_in">println</span>(<span class="string">&quot;runtime: work.nwait=&quot;</span>, decnwait, <span class="string">&quot;work.nproc=&quot;</span>, work.nproc)</span><br><span class="line">            throw(<span class="string">&quot;work.nwait was &gt; work.nproc&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="comment">// Mark our goroutine preemptible so its stack</span></span><br><span class="line">            <span class="comment">// can be scanned. This lets two mark workers</span></span><br><span class="line">            <span class="comment">// scan each other (otherwise, they would</span></span><br><span class="line">            <span class="comment">// deadlock). We must not modify anything on</span></span><br><span class="line">            <span class="comment">// the G stack. However, stack shrinking is</span></span><br><span class="line">            <span class="comment">// disabled for mark workers, so it is safe to</span></span><br><span class="line">            <span class="comment">// read from the G stack.</span></span><br><span class="line">            <span class="comment">// 关于这里为什么把 G 的 running 状态修改为 waiting 状态</span></span><br><span class="line">            <span class="comment">// TODO 需要进一步的研究，曹大说要结合 suspendG 来看</span></span><br><span class="line">            casgstatus(gp, _Grunning, _Gwaiting)</span><br><span class="line">            <span class="keyword">switch</span> pp.gcMarkWorkerMode &#123;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                	throw(<span class="string">&quot;gcBgMarkWorker: unexpected gcMarkWorkerMode&quot;</span>)</span><br><span class="line">                <span class="keyword">case</span> gcMarkWorkerDedicatedMode:</span><br><span class="line">                	gcDrain(&amp;pp.gcw, gcDrainUntilPreempt|gcDrainFlushBgCredit)</span><br><span class="line">                    <span class="keyword">if</span> gp.preempt &#123;</span><br><span class="line">                        <span class="comment">// We were preempted. This is</span></span><br><span class="line">                        <span class="comment">// a useful signal to kick</span></span><br><span class="line">                        <span class="comment">// everything out of the run</span></span><br><span class="line">                        <span class="comment">// queue so it can run</span></span><br><span class="line">                        <span class="comment">// somewhere else.</span></span><br><span class="line">                        <span class="keyword">if</span> drainQ, n := runqdrain(pp); n &gt; <span class="number">0</span> &#123;</span><br><span class="line">                            lock(&amp;sched.lock)</span><br><span class="line">                            globrunqputbatch(&amp;drainQ, <span class="keyword">int32</span>(n))</span><br><span class="line">                            unlock(&amp;sched.lock)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// Go back to draining, this time</span></span><br><span class="line">                    <span class="comment">// without preemption.</span></span><br><span class="line">                    gcDrain(&amp;pp.gcw, gcDrainFlushBgCredit)</span><br><span class="line">                <span class="keyword">case</span> gcMarkWorkerFractionalMode:</span><br><span class="line">                	gcDrain(&amp;pp.gcw, gcDrainFractional|gcDrainUntilPreempt|gcDrainFlushBgCredit)</span><br><span class="line">                <span class="keyword">case</span> gcMarkWorkerIdleMode:</span><br><span class="line">                	gcDrain(&amp;pp.gcw, gcDrainIdle|gcDrainUntilPreempt|gcDrainFlushBgCredit)</span><br><span class="line">            &#125;</span><br><span class="line">            casgstatus(gp, _Gwaiting, _Grunning)</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Account for time.</span></span><br><span class="line">        duration := nanotime() - startTime</span><br><span class="line">        <span class="keyword">switch</span> pp.gcMarkWorkerMode &#123;</span><br><span class="line">            <span class="keyword">case</span> gcMarkWorkerDedicatedMode:</span><br><span class="line">                atomic.Xaddint64(&amp;gcController.dedicatedMarkTime, duration)</span><br><span class="line">                atomic.Xaddint64(&amp;gcController.dedicatedMarkWorkersNeeded, <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">case</span> gcMarkWorkerFractionalMode:</span><br><span class="line">                atomic.Xaddint64(&amp;gcController.fractionalMarkTime, duration)</span><br><span class="line">                atomic.Xaddint64(&amp;pp.gcFractionalMarkTime, duration)</span><br><span class="line">            <span class="keyword">case</span> gcMarkWorkerIdleMode:</span><br><span class="line">                atomic.Xaddint64(&amp;gcController.idleMarkTime, duration)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Was this the last worker and did we run out</span></span><br><span class="line">        <span class="comment">// of work?</span></span><br><span class="line">        incnwait := atomic.Xadd(&amp;work.nwait, +<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> incnwait &gt; work.nproc &#123;</span><br><span class="line">            <span class="built_in">println</span>(<span class="string">&quot;runtime: p.gcMarkWorkerMode=&quot;</span>, pp.gcMarkWorkerMode,</span><br><span class="line">                    <span class="string">&quot;work.nwait=&quot;</span>, incnwait, <span class="string">&quot;work.nproc=&quot;</span>, work.nproc)</span><br><span class="line">            throw(<span class="string">&quot;work.nwait &gt; work.nproc&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We&#x27;ll releasem after this point and thus this P may run</span></span><br><span class="line">        <span class="comment">// something else. We must clear the worker mode to avoid</span></span><br><span class="line">        <span class="comment">// attributing the mode to a different (non-worker) G in</span></span><br><span class="line">        <span class="comment">// traceGoStart.</span></span><br><span class="line">        pp.gcMarkWorkerMode = gcMarkWorkerNotWorker</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If this worker reached a background mark completion</span></span><br><span class="line">        <span class="comment">// point, signal the main GC goroutine.</span></span><br><span class="line">        <span class="keyword">if</span> incnwait == work.nproc &amp;&amp; !gcMarkWorkAvailable(<span class="literal">nil</span>) &#123;</span><br><span class="line">            <span class="comment">// We don&#x27;t need the P-local buffers here, allow</span></span><br><span class="line">            <span class="comment">// preemption becuse we may schedule like a regular</span></span><br><span class="line">            <span class="comment">// goroutine in gcMarkDone (block on locks, etc).</span></span><br><span class="line">            releasem(node.m.ptr())</span><br><span class="line">            node.m.set(<span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">            gcMarkDone()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>gcMarkWorker 的状态（dedicated, fraction）这个状态是绑定在 P 上，并不是 G 的状态。</li>
</ul>
<h3 id="GC-标记的几个工作模式"><a href="#GC-标记的几个工作模式" class="headerlink" title="GC 标记的几个工作模式"></a>GC 标记的几个工作模式</h3><ol>
<li>gcDrainFlushBgCredit: 把 bgMarkWorker 积累的 credit 刷新到全局的 gcController 中。</li>
<li>gcDrainFractional: self-preempt 表示在达到 fractional 后自动退出。</li>
<li>gcDrainUntilPreempt: 一直执行，直到被抢占。</li>
<li>gcDrainIdle: 一直执行，直到其他任务要做。</li>
</ol>
<h3 id="bitmap-与-ha-的映射关系（标记过程用到的位图）"><a href="#bitmap-与-ha-的映射关系（标记过程用到的位图）" class="headerlink" title="bitmap 与 ha 的映射关系（标记过程用到的位图）"></a>bitmap 与 ha 的映射关系（标记过程用到的位图）</h3><h4 id="bitmap-的使用"><a href="#bitmap-的使用" class="headerlink" title="bitmap 的使用"></a>bitmap 的使用</h4><p>两个比特表示一个字</p>
<p>ha 64 M，bitmap 2 M，bitmap 中的一个字节可以表示ha连续4个指针的内存大小。</p>
<p>0-4，1-5， 2-6， 3-7 </p>
<p>低位 bit 用于表示是否为指针，0 为非指针，1 为指针。</p>
<p>高位 bit 用于表示是否要继续扫描该对象中后续的内容，0 为不需要，1 为需要。</p>
<p><img src="https://blogstatic.haohtml.com/uploads/2021/04/d2b5ca33bd970f64a6301fa75ae2eb22-6.png?x-oss-process=image/format,webp" alt="img"></p>
<h4 id="heapBitsForAddr"><a href="#heapBitsForAddr" class="headerlink" title="heapBitsForAddr"></a>heapBitsForAddr</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// heapBitsForAddr returns the heapBits for the address addr.</span></span><br><span class="line"><span class="comment">// The caller must ensure addr is in an allocated span.</span></span><br><span class="line"><span class="comment">// In particular, be careful not to point past the end of an object.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// nosplit because it is used during write barriers and must not be preempted.</span></span><br><span class="line"><span class="comment">//go:nosplit</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">heapBitsForAddr</span><span class="params">(addr <span class="keyword">uintptr</span>)</span> <span class="params">(h heapBits)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 2 bits per word, 4 pairs per byte, and a mask is hard coded.</span></span><br><span class="line">    <span class="comment">// 如注释所说，两个比特可以用来表示一个字的大小</span></span><br><span class="line">    arena := arenaIndex(addr)</span><br><span class="line">    ha := mheap_.arenas[arena.l1()][arena.l2()]</span><br><span class="line">    <span class="comment">// The compiler uses a load for nil checking ha, but in this</span></span><br><span class="line">    <span class="comment">// case we&#x27;ll almost never hit that cache line again, so it</span></span><br><span class="line">    <span class="comment">// makes more sense to do a value check.</span></span><br><span class="line">    <span class="keyword">if</span> ha == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// addr is not in the heap. Return nil heapBits, which</span></span><br><span class="line">        <span class="comment">// we expect to crash in the caller.</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 笔者理解：之所以要 *4，就是因为 bitmap 与 ha 的映射关系</span></span><br><span class="line">    <span class="comment">// 一字节可以表示堆上 4 个连续的指针内存</span></span><br><span class="line">    h.bitp = &amp;ha.bitmap[(addr/(sys.PtrSize*<span class="number">4</span>))%heapArenaBitmapBytes]</span><br><span class="line">    <span class="comment">// 笔者理解：shift 就像掩码一样，用来计算低位与高位比特的位置</span></span><br><span class="line">    <span class="comment">// &amp;3 的运算也能说明这一点，&amp;3 的结果只能是 0 1 2 3，</span></span><br><span class="line">    <span class="comment">// 这里就对应上了 8 比特的低四位</span></span><br><span class="line">    h.shift = <span class="keyword">uint32</span>((addr / sys.PtrSize) &amp; <span class="number">3</span>)</span><br><span class="line">    <span class="comment">// 记录当前 arena 的位置</span></span><br><span class="line">    h.arena = <span class="keyword">uint32</span>(arena)</span><br><span class="line">    <span class="comment">// 记录当前 arena 对应的 bitmap 中的最后一字节</span></span><br><span class="line">    h.last = &amp;ha.bitmap[<span class="built_in">len</span>(ha.bitmap)<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// next returns the heapBits describing the next pointer-sized word in memory.</span></span><br><span class="line"><span class="comment">// That is, if h describes address p, h.next() describes p+ptrSize.</span></span><br><span class="line"><span class="comment">// Note that next does not modify h. The caller must record the result.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 如注释所描述的，next 函数，返回描述了在内存中下一个指针类型的word的heapBits</span></span><br><span class="line"><span class="comment">// 如果 h 表示的是指针 p 的地址，那么 h.next() 表示的就是 p+ptrSize 的heapBits</span></span><br><span class="line"><span class="comment">// nosplit because it is used during write barriers and must not be preempted.</span></span><br><span class="line"><span class="comment">//go:nosplit</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h heapBits)</span> <span class="title">next</span><span class="params">()</span> <span class="title">heapBits</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> h.shift &lt; <span class="number">3</span>*heapBitsShift &#123; <span class="comment">// 在同一字节上扫描，四个连续的ptr还没扫描完</span></span><br><span class="line">        h.shift += heapBitsShift</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> h.bitp != h.last &#123;	<span class="comment">// 如果没扫描到该 bitmap 的最后一字节，那么扫描下一个byte</span></span><br><span class="line">        h.bitp, h.shift = add1(h.bitp), <span class="number">0</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;	<span class="comment">// 此时，当前已经扫描完了当前 ha 的所有内容，移动到下一个 ha 进行扫描</span></span><br><span class="line">        <span class="comment">// Move to the next arena.</span></span><br><span class="line">        <span class="keyword">return</span> h.nextArena()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="gcDrain-标记过程"><a href="#gcDrain-标记过程" class="headerlink" title="gcDrain 标记过程"></a>gcDrain 标记过程</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// gcDrain 扫描 work buffer 中的根节点和对象，</span></span><br><span class="line"><span class="comment">// gcDrain 会将队列中所有的对象标记为灰色。</span></span><br><span class="line"><span class="comment">// gcDrain 可能在 GC 结束前返回。</span></span><br><span class="line"><span class="comment">// gcDrain 的调用者负责平衡当前 P 与 其他 P 的标记工作。</span></span><br><span class="line"><span class="comment">//go:nowritebarrier</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcDrain</span><span class="params">(gcw *gcWork, flags gcDrainFlags)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> !writeBarrier.needed &#123;</span><br><span class="line">        throw(<span class="string">&quot;gcDrain phase incorrect&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    gp := getg().m.curg</span><br><span class="line">    preemptible := flags&amp;gcDrainUntilPreempt != <span class="number">0</span></span><br><span class="line">    flushBgCredit := flags&amp;gcDrainFlushBgCredit != <span class="number">0</span></span><br><span class="line">    idle := flags&amp;gcDrainIdle != <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    initScanWork := gcw.scanWork</span><br><span class="line"></span><br><span class="line">    <span class="comment">// checkWork is the scan work before performing the next</span></span><br><span class="line">    <span class="comment">// self-preempt check.</span></span><br><span class="line">    checkWork := <span class="keyword">int64</span>(<span class="number">1</span>&lt;&lt;<span class="number">63</span> - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">var</span> check <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">bool</span></span></span><br><span class="line">    <span class="keyword">if</span> flags&amp;(gcDrainIdle|gcDrainFractional) != <span class="number">0</span> &#123;</span><br><span class="line">        checkWork = initScanWork + drainCheckThreshold</span><br><span class="line">        <span class="keyword">if</span> idle &#123;</span><br><span class="line">            check = pollWork</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> flags&amp;gcDrainFractional != <span class="number">0</span> &#123;</span><br><span class="line">            check = pollFractionalWorkerExit</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Drain root marking jobs.</span></span><br><span class="line">    <span class="comment">// 判断当前标记的位置是否超出了总的标记数量</span></span><br><span class="line">    <span class="keyword">if</span> work.markrootNext &lt; work.markrootJobs &#123;</span><br><span class="line">        <span class="comment">// Stop if we&#x27;re preemptible or if someone wants to STW.</span></span><br><span class="line">        <span class="keyword">for</span> !(gp.preempt &amp;&amp; (preemptible || atomic.Load(&amp;sched.gcwaiting) != <span class="number">0</span>)) &#123;</span><br><span class="line">            job := atomic.Xadd(&amp;work.markrootNext, +<span class="number">1</span>) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> job &gt;= work.markrootJobs &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 对 job 索引位置的 root 进行标记工作</span></span><br><span class="line">            markroot(gcw, job)</span><br><span class="line">            <span class="comment">// 完成一个根的标记工作，就去检查</span></span><br><span class="line">            <span class="comment">// TODO 是否达到了 fractional 或者 其他</span></span><br><span class="line">            <span class="keyword">if</span> check != <span class="literal">nil</span> &amp;&amp; check() &#123;</span><br><span class="line">                <span class="keyword">goto</span> done</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Drain heap marking jobs.</span></span><br><span class="line">    <span class="comment">// Stop if we&#x27;re preemptible or if someone wants to STW.</span></span><br><span class="line">    <span class="keyword">for</span> !(gp.preempt &amp;&amp; (preemptible || atomic.Load(&amp;sched.gcwaiting) != <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">// Try to keep work available on the global queue. We used to</span></span><br><span class="line">        <span class="comment">// check if there were waiting workers, but it&#x27;s better to</span></span><br><span class="line">        <span class="comment">// just keep work available than to make workers wait. In the</span></span><br><span class="line">        <span class="comment">// worst case, we&#x27;ll do O(log(_WorkbufSize)) unnecessary</span></span><br><span class="line">        <span class="comment">// balances.</span></span><br><span class="line">        <span class="comment">// 平衡标记工作，让它有活可干比让它等着要好</span></span><br><span class="line">        <span class="keyword">if</span> work.full == <span class="number">0</span> &#123;</span><br><span class="line">            gcw.balance()</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从 gcw 队列中取值</span></span><br><span class="line">        b := gcw.tryGetFast()</span><br><span class="line">        <span class="keyword">if</span> b == <span class="number">0</span> &#123;</span><br><span class="line">            b = gcw.tryGet()</span><br><span class="line">            <span class="keyword">if</span> b == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="comment">// Flush the write barrier</span></span><br><span class="line">                <span class="comment">// buffer; this may create</span></span><br><span class="line">                <span class="comment">// more work.</span></span><br><span class="line">                如果说 wbuf 中都没有，将</span><br><span class="line">                wbBufFlush(<span class="literal">nil</span>, <span class="number">0</span>)</span><br><span class="line">                b = gcw.tryGet()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> b == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// Unable to get work.</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        scanobject(b, gcw)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Flush background scan work credit to the global</span></span><br><span class="line">        <span class="comment">// account if we&#x27;ve accumulated enough locally so</span></span><br><span class="line">        <span class="comment">// mutator assists can draw on it.</span></span><br><span class="line">        <span class="keyword">if</span> gcw.scanWork &gt;= gcCreditSlack &#123;</span><br><span class="line">            atomic.Xaddint64(&amp;gcController.scanWork, gcw.scanWork)</span><br><span class="line">            <span class="keyword">if</span> flushBgCredit &#123;</span><br><span class="line">                gcFlushBgCredit(gcw.scanWork - initScanWork)</span><br><span class="line">                initScanWork = <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">            checkWork -= gcw.scanWork</span><br><span class="line">            gcw.scanWork = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> checkWork &lt;= <span class="number">0</span> &#123;</span><br><span class="line">                checkWork += drainCheckThreshold</span><br><span class="line">                <span class="keyword">if</span> check != <span class="literal">nil</span> &amp;&amp; check() &#123;</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    done:</span><br><span class="line">    <span class="comment">// Flush remaining scan work credit.</span></span><br><span class="line">    <span class="keyword">if</span> gcw.scanWork &gt; <span class="number">0</span> &#123;</span><br><span class="line">        atomic.Xaddint64(&amp;gcController.scanWork, gcw.scanWork)</span><br><span class="line">        <span class="keyword">if</span> flushBgCredit &#123;</span><br><span class="line">            gcFlushBgCredit(gcw.scanWork - initScanWork)</span><br><span class="line">        &#125;</span><br><span class="line">        gcw.scanWork = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="标记工作的平衡"><a href="#标记工作的平衡" class="headerlink" title="标记工作的平衡"></a>标记工作的平衡</h4><h5 id="balance"><a href="#balance" class="headerlink" title="balance"></a>balance</h5><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// balance moves some work that&#x27;s cached in this gcWork back on the</span></span><br><span class="line"><span class="comment">// global queue.</span></span><br><span class="line"><span class="comment">// 将缓存在 P gcw 上的标记任务，适当的移动到全局queue中</span></span><br><span class="line"><span class="comment">//go:nowritebarrierrec</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *gcWork)</span> <span class="title">balance</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 如果 P 的本地 wbf 没有标记任务，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> w.wbuf1 == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">   	1.先处理 wbuf2 中的数据，如果有，将数据放入到</span></span><br><span class="line"><span class="comment">   	全局 work full 队列中</span></span><br><span class="line"><span class="comment">   	2.查看 wbuf1 中对象数量，超过四个，执行 handoff</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">    <span class="keyword">if</span> wbuf := w.wbuf2; wbuf.nobj != <span class="number">0</span> &#123;</span><br><span class="line">        putfull(wbuf)</span><br><span class="line">        w.flushedWork = <span class="literal">true</span></span><br><span class="line">        w.wbuf2 = getempty()</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> wbuf := w.wbuf1; wbuf.nobj &gt; <span class="number">4</span> &#123;</span><br><span class="line">        w.wbuf1 = handoff(wbuf)</span><br><span class="line">        w.flushedWork = <span class="literal">true</span> <span class="comment">// handoff did putfull</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// We flushed a buffer to the full list, so wake a worker.</span></span><br><span class="line">    <span class="keyword">if</span> gcphase == _GCmark &#123;</span><br><span class="line">        gcController.enlistWorker()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="enlistWorker"><a href="#enlistWorker" class="headerlink" title="enlistWorker"></a>enlistWorker</h5><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// enlistWorker encourages another dedicated mark worker to start on</span></span><br><span class="line"><span class="comment">// another P if there are spare worker slots. It is used by putfull</span></span><br><span class="line"><span class="comment">// when more work is made available.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//go:nowritebarrier</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *gcControllerState)</span> <span class="title">enlistWorker</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// If there are idle Ps, wake one so it will run an idle worker.</span></span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> This is suspected of causing deadlocks. See golang.org/issue/19112.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// if atomic.Load(&amp;sched.npidle) != 0 &amp;&amp; atomic.Load(&amp;sched.nmspinning) == 0 &#123;</span></span><br><span class="line">    <span class="comment">//    wakep()</span></span><br><span class="line">    <span class="comment">//    return</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// There are no idle Ps. If we need more dedicated workers,</span></span><br><span class="line">    <span class="comment">// try to preempt a running P so it will switch to a worker.</span></span><br><span class="line">    <span class="keyword">if</span> c.dedicatedMarkWorkersNeeded &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Pick a random other P to preempt.</span></span><br><span class="line">    <span class="keyword">if</span> gomaxprocs &lt;= <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    gp := getg()</span><br><span class="line">    <span class="keyword">if</span> gp == <span class="literal">nil</span> || gp.m == <span class="literal">nil</span> || gp.m.p == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    myID := gp.m.p.ptr().id</span><br><span class="line">    <span class="keyword">for</span> tries := <span class="number">0</span>; tries &lt; <span class="number">5</span>; tries++ &#123;</span><br><span class="line">        id := <span class="keyword">int32</span>(fastrandn(<span class="keyword">uint32</span>(gomaxprocs - <span class="number">1</span>)))</span><br><span class="line">        <span class="keyword">if</span> id &gt;= myID &#123;</span><br><span class="line">            id++</span><br><span class="line">        &#125;</span><br><span class="line">        p := allp[id]</span><br><span class="line">        <span class="keyword">if</span> p.status != _Prunning &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 执行抢占</span></span><br><span class="line">        <span class="keyword">if</span> preemptone(p) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    不知道你们想没想过这样一个问题，通过 preemptone 函数进行抢占，是怎么做到去启动一个 gcMarkWorker 的？</p>
<p>​    如果你没想到的话，给你一点提示，和调度循环相关。</p>
<h5 id="handoff"><a href="#handoff" class="headerlink" title="handoff"></a>handoff</h5><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在 wbuf 中对象数量大于 4 时，将前一半放入到全局 work full 队列中</span></span><br><span class="line"><span class="comment">//go:nowritebarrier</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handoff</span><span class="params">(b *workbuf)</span> *<span class="title">workbuf</span></span> &#123;</span><br><span class="line">    <span class="comment">// Make new buffer with half of b&#x27;s pointers.</span></span><br><span class="line">    b1 := getempty()</span><br><span class="line">    n := b.nobj / <span class="number">2</span></span><br><span class="line">    b.nobj -= n</span><br><span class="line">    b1.nobj = n</span><br><span class="line">    <span class="comment">// 通过获取一个新的 empty workbuf</span></span><br><span class="line">    <span class="comment">// 将前一半放进去</span></span><br><span class="line">    memmove(unsafe.Pointer(&amp;b1.obj[<span class="number">0</span>]), unsafe.Pointer(&amp;b.obj[b.nobj]), <span class="keyword">uintptr</span>(n)*unsafe.Sizeof(b1.obj[<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Put b on full list - let first half of b get stolen.</span></span><br><span class="line">    putfull(b)</span><br><span class="line">    <span class="keyword">return</span> b1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="GC-过程中-P-的-gcw-队列"><a href="#GC-过程中-P-的-gcw-队列" class="headerlink" title="GC 过程中 P 的 gcw 队列"></a>GC 过程中 P 的 gcw 队列</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> P <span class="keyword">struct</span> &#123;</span><br><span class="line">    (...)</span><br><span class="line">    <span class="comment">// gcw is this P&#x27;s GC work buffer cache. The work buffer is</span></span><br><span class="line">    <span class="comment">// filled by write barriers, drained by mutator assists, and</span></span><br><span class="line">    <span class="comment">// disposed on certain GC state transitions.</span></span><br><span class="line">    gcw gcWork</span><br><span class="line">    (...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下是 Go 官方对 gcw 的描述：</p>
<p>为灰色指针对象实现了一个生产者/消费者模型。对象被标记为灰色后，放入到队列中。对象被标记为黑色后，会在队列中移除。</p>
<p>写屏障，根节点扫描，栈扫描和对象扫描过程会产生灰色对象。scanning 过程会消费灰色对象的指针并且有可能产生新的灰色对象指针。</p>
<p>gcWork 为垃圾回收器提供了一个生产和消费的接口。</p>
<p>可以在 stack 上这样使用 gcWork：</p>
<ul>
<li>调用 gcw.Put() 进行生产，调用 gcw.tryGet() 进行消费。</li>
</ul>
<p>重要的是，在 mark phase 使用 gcWork 可以阻止垃圾回收器从 transitioning 转变为 mark termination 因为 gcWork 可能在本地保存 GC work buffers。这可以通过禁用抢占来完成。</p>
<h5 id="wbuf1-和-wbuf2"><a href="#wbuf1-和-wbuf2" class="headerlink" title="wbuf1 和 wbuf2"></a>wbuf1 和 wbuf2</h5><p>可以将 wbuf1 和 wbuf2 想象成一块栈空间，然后这俩轮流使用。</p>
<p>当我们弹出队列中最后一个指针时，我们通过引入一个新的缓冲区并丢弃一个空缓冲区（交换这两个缓冲区），然后将 stack 向上移动一个新 buffer。 当我们将buffers都填满了，我们通过引入一个新的空缓冲区并丢弃那个满的缓冲区，然后将stack向下移动一个新 buffer。</p>
<p>这样我们就有了一个缓冲区的滞后值，它可以将获取或放置工作缓冲区的成本分摊到至少一个工作缓冲区上，并减少全局工作列表上的争用。</p>
<p>wbuf1 永远都是我们正在操作的那个 buffer，wbuf2 是接下来要丢弃的缓冲区。</p>
<p>总结：</p>
<p>wbuf1 和 wbuf2 都是用来存储灰色指针的，wbuf1 是我们真正操作的那个队列，入队出队操作的都是它，wbuf2 起到的是替换作用，当 wbuf1 空了，替换 wbuf2，当 wbuf1 满了，替换 wbuf2。</p>
<h5 id="work-full-和-work-empty"><a href="#work-full-和-work-empty" class="headerlink" title="work.full 和 work.empty"></a>work.full 和 work.empty</h5><p>全局 work 中有两个队列，full 和 empty，灰色对象入队过程：</p>
<p>fastPath: 检查 wbuf1 是否为空，是否满了，是就返回；都不是，将灰色对象入队。<br>slowPath：检查 wbuf1 是否为 nil，为 nil，执行初始化。否则，判断是否满了，满了，交换 wbuf1 和 wbuf2，再次判断 wbuf1 是否满了，满了加入到全局 full 队列中，然后从 empty 队列获取一个空的并赋值给 wbuf1，最后把这个灰色对象入队。</p>
<h4 id="GC-过程中负责标记的函数"><a href="#GC-过程中负责标记的函数" class="headerlink" title="GC 过程中负责标记的函数"></a>GC 过程中负责标记的函数</h4><h5 id="markroot"><a href="#markroot" class="headerlink" title="markroot"></a>markroot</h5><p>markroot 主要是根据不同的 i 来定位要扫描哪些区域，当 i == 0 ，i == 1 时，对应到以下两种情况，具体的含义暂时还不清晰。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TODO 了解这两种分别是什么</span></span><br><span class="line"><span class="keyword">case</span> i == fixedRootFinalizers:</span><br><span class="line">   <span class="keyword">for</span> fb := allfin; fb != <span class="literal">nil</span>; fb = fb.alllink &#123;</span><br><span class="line">      cnt := <span class="keyword">uintptr</span>(atomic.Load(&amp;fb.cnt))</span><br><span class="line">      scanblock(<span class="keyword">uintptr</span>(unsafe.Pointer(&amp;fb.fin[<span class="number">0</span>])), cnt*unsafe.Sizeof(fb.fin[<span class="number">0</span>]), &amp;finptrmask[<span class="number">0</span>], gcw, <span class="literal">nil</span>)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> i == fixedRootFreeGStacks:</span><br><span class="line">   <span class="comment">// Switch to the system stack so we can call</span></span><br><span class="line">   <span class="comment">// stackfree.</span></span><br><span class="line">   systemstack(markrootFreeGStacks)</span><br></pre></td></tr></table></figure>

<h5 id="scanobject"><a href="#scanobject" class="headerlink" title="scanobject"></a>scanobject</h5><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// scanobject scans the object starting at b, adding pointers to gcw.</span></span><br><span class="line"><span class="comment">// b must point to the beginning of a heap object or an oblet.</span></span><br><span class="line"><span class="comment">// scanobject consults the GC bitmap for the pointer mask and the</span></span><br><span class="line"><span class="comment">// spans for the size of the object.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 如注释所写，scanobject 扫描从 b 为起始地址的对象，并添加指针到 gcw 队列中。</span></span><br><span class="line"><span class="comment">// b 必须指向堆对象的起始地址，或者一个 oblet。</span></span><br><span class="line"><span class="comment">//go:nowritebarrier</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">scanobject</span><span class="params">(b <span class="keyword">uintptr</span>, gcw *gcWork)</span></span> &#123;</span><br><span class="line">    <span class="comment">// Find the bits for b and the size of the object at b.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// b is either the beginning of an object, in which case this</span></span><br><span class="line">    <span class="comment">// is the size of the object to scan, or it points to an</span></span><br><span class="line">    <span class="comment">// oblet, in which case we compute the size to scan below.</span></span><br><span class="line">    <span class="comment">// 这个函数前边已经详细的分析过了，没啥好说的</span></span><br><span class="line">    hbits := heapBitsForAddr(b)</span><br><span class="line">    <span class="comment">// 找到指针 b 对应的 mspan</span></span><br><span class="line">    s := spanOfUnchecked(b)</span><br><span class="line">    <span class="comment">// s.elemsize 表示的是一个 object 的大小</span></span><br><span class="line">    n := s.elemsize</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;scanobject n == 0&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">		这里对大对象（这里的大对象与内存分配的有些许差异</span></span><br><span class="line"><span class="comment">		内存分配大对象指的是大于32KB的，这里指的是大于 128KB的）</span></span><br><span class="line"><span class="comment">		进行了进一步的区分</span></span><br><span class="line"><span class="comment">		maxobletBytes = 128 &lt;&lt; 10 = 128 KB</span></span><br><span class="line"><span class="comment">		意味着，当前 obj 的大小超过了 128 KB</span></span><br><span class="line"><span class="comment">		要进行一些优化操作</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    <span class="keyword">if</span> n &gt; maxObletBytes &#123;</span><br><span class="line">        <span class="comment">// Large object. Break into oblets for better</span></span><br><span class="line">        <span class="comment">// parallelism and lower latency.</span></span><br><span class="line">        <span class="keyword">if</span> b == s.base() &#123;</span><br><span class="line">            <span class="comment">// It&#x27;s possible this is a noscan object (not</span></span><br><span class="line">            <span class="comment">// from greyobject, but from other code</span></span><br><span class="line">            <span class="comment">// paths), in which case we must *not* enqueue</span></span><br><span class="line">            <span class="comment">// oblets since their bitmaps will be</span></span><br><span class="line">            <span class="comment">// uninitialized.</span></span><br><span class="line">            <span class="keyword">if</span> s.spanclass.noscan() &#123;</span><br><span class="line">                <span class="comment">// Bypass the whole scan.</span></span><br><span class="line">                gcw.bytesMarked += <span class="keyword">uint64</span>(n)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Enqueue the other oblets to scan later.</span></span><br><span class="line">            <span class="comment">// Some oblets may be in b&#x27;s scalar tail, but</span></span><br><span class="line">            <span class="comment">// these will be marked as &quot;no more pointers&quot;,</span></span><br><span class="line">            <span class="comment">// so we&#x27;ll drop out immediately when we go to</span></span><br><span class="line">            <span class="comment">// scan those.</span></span><br><span class="line">            <span class="keyword">for</span> oblet := b + maxObletBytes; oblet &lt; s.base()+s.elemsize; oblet += maxObletBytes &#123;</span><br><span class="line">                <span class="keyword">if</span> !gcw.putFast(oblet) &#123;</span><br><span class="line">                    gcw.put(oblet)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Compute the size of the oblet. Since this object</span></span><br><span class="line">        <span class="comment">// must be a large object, s.base() is the beginning</span></span><br><span class="line">        <span class="comment">// of the object.</span></span><br><span class="line">        n = s.base() + s.elemsize - b</span><br><span class="line">        <span class="keyword">if</span> n &gt; maxObletBytes &#123;</span><br><span class="line">            n = maxObletBytes</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> i <span class="keyword">uintptr</span></span><br><span class="line">    <span class="comment">// i &lt; n 说明 mspan 中，只对当前这个对象进行扫描</span></span><br><span class="line">    <span class="comment">// 执行完一次 for 循环，并不意味着扫描完当前这个对象了</span></span><br><span class="line">    <span class="comment">// 只是检查了当前两个比特对应的一个字</span></span><br><span class="line">    <span class="comment">// 除非当前这个对象是不需要扫描的即，bits&amp;bitScan == 0</span></span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">0</span>; i &lt; n; i, hbits = i+sys.PtrSize, hbits.next() &#123;</span><br><span class="line">        <span class="comment">// Load bits once. See CL 22712 and issue 16973 for discussion.</span></span><br><span class="line">        bits := hbits.bits()</span><br><span class="line">        <span class="comment">// 这里的两个 if 判断就好像两个卡尺</span></span><br><span class="line">        <span class="comment">// 分别对高位和低位进行检查</span></span><br><span class="line">        <span class="keyword">if</span> bits&amp;bitScan == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">break</span> <span class="comment">// no more pointers in this object</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> bits&amp;bitPointer == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span> <span class="comment">// not a pointer</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Work here is duplicated in scanblock and above.</span></span><br><span class="line">        <span class="comment">// If you make changes here, make changes there too.</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">			设 fakeObj = (*uintptr)(unsafe.Pointer(b + i))</span></span><br><span class="line"><span class="comment">			对 fakeObj 解引用 --&gt; *fakeObj</span></span><br><span class="line"><span class="comment">            	1.解出来结果 != 0，说明是一个指针</span></span><br><span class="line"><span class="comment">            	2.解出来结果 == 0，说明结果为 nil</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        obj := *(*<span class="keyword">uintptr</span>)(unsafe.Pointer(b + i))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// At this point we have extracted the next potential pointer.</span></span><br><span class="line">        <span class="comment">// Quickly filter out nil and pointers back to the current object.</span></span><br><span class="line">        <span class="comment">// 如果 obj 是一个指针，并且指向的不是当前 object</span></span><br><span class="line">        <span class="comment">// 笔者理解：之所以要过滤掉当前的 object，</span></span><br><span class="line">        <span class="comment">// 是因为当前这个 object 就是从 gcw 队列中取出来的</span></span><br><span class="line">        <span class="comment">// 所以也就不需要再对该 obj 进行标记（入队）</span></span><br><span class="line">        <span class="keyword">if</span> obj != <span class="number">0</span> &amp;&amp; obj-b &gt;= n &#123;</span><br><span class="line">            <span class="comment">// Test if obj points into the Go heap and, if so,</span></span><br><span class="line">            <span class="comment">// mark the object.</span></span><br><span class="line">            <span class="comment">// 检查 obj 是否指向了 Go 的堆，如果是，对这个 obj 进行标记</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// Note that it&#x27;s possible for findObject to</span></span><br><span class="line">            <span class="comment">// fail if obj points to a just-allocated heap</span></span><br><span class="line">            <span class="comment">// object because of a race with growing the</span></span><br><span class="line">            <span class="comment">// heap. In this case, we know the object was</span></span><br><span class="line">            <span class="comment">// just allocated and hence will be marked by</span></span><br><span class="line">            <span class="comment">// allocation itself.</span></span><br><span class="line">            <span class="keyword">if</span> obj, span, objIndex := findObject(obj, b, i); obj != <span class="number">0</span> &#123;</span><br><span class="line">                greyobject(obj, b, i, span, gcw, objIndex)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录刚刚被扫描的 obj 大小</span></span><br><span class="line">    gcw.bytesMarked += <span class="keyword">uint64</span>(n)</span><br><span class="line">    <span class="comment">// 积累 credit，到了 2000 就更新到全局 gcCrontroller 中</span></span><br><span class="line">    gcw.scanWork += <span class="keyword">int64</span>(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="findObject"><a href="#findObject" class="headerlink" title="findObject"></a>findObject</h5><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	参数解释：</span></span><br><span class="line"><span class="comment">		refBase, refOff 主要 panic 用</span></span><br><span class="line"><span class="comment">	返回值解释：</span></span><br><span class="line"><span class="comment">		base: 表示 p 指针所在对象，在堆中的起始地址</span></span><br><span class="line"><span class="comment">		s: 表示 p 指针所在的 mspan</span></span><br><span class="line"><span class="comment">		objIndex: 表示包含 p 指针的对象在 mspan 中的位置</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//go:nosplit</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findObject</span><span class="params">(p, refBase, refOff <span class="keyword">uintptr</span>)</span> <span class="params">(base <span class="keyword">uintptr</span>, s *mspan, objIndex <span class="keyword">uintptr</span>)</span></span> &#123;</span><br><span class="line">    s = spanOf(p)</span><br><span class="line"></span><br><span class="line">    (...) <span class="comment">// 省略检查代码</span></span><br><span class="line">    </span><br><span class="line">    objIndex = s.objIndex(p)</span><br><span class="line">    base = s.base() + objIndex*s.elemsize</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="markrootBlock"><a href="#markrootBlock" class="headerlink" title="markrootBlock"></a>markrootBlock</h5><h5 id="markrootFreeGStacks"><a href="#markrootFreeGStacks" class="headerlink" title="markrootFreeGStacks"></a>markrootFreeGStacks</h5><h5 id="markrootSpans"><a href="#markrootSpans" class="headerlink" title="markrootSpans"></a>markrootSpans</h5><h5 id="scanstack"><a href="#scanstack" class="headerlink" title="scanstack"></a>scanstack</h5><p>扫描 goroutine 栈</p>
<h5 id="scanblock"><a href="#scanblock" class="headerlink" title="scanblock"></a>scanblock</h5><h5 id="gcmarknewobject"><a href="#gcmarknewobject" class="headerlink" title="gcmarknewobject"></a>gcmarknewobject</h5><h5 id="gcMarkTinyAllocs"><a href="#gcMarkTinyAllocs" class="headerlink" title="gcMarkTinyAllocs"></a>gcMarkTinyAllocs</h5><h2 id="gcMarkDone"><a href="#gcMarkDone" class="headerlink" title="gcMarkDone"></a>gcMarkDone</h2><p>gcMarkDone 是一个过度的函数，是由 _GCMark 到 _GCMarkTermination 状态转换前要做的一些处理。此外，gcMarkDone 中会处理 writebarrier buffer，如果这时候将数据写入到了全局的标记队列中，那还需要继续执行标记工作。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果所有的可达对象都已经被标记了（意味着没有任何灰色对象并且将来也不会有）</span></span><br><span class="line"><span class="comment">// gcMarkDone 将 GC 的状态由 mark 转为 mark termination。</span></span><br><span class="line"><span class="comment">// 否则（还有没被标记的灰色对象），gcMarkDone 会将所有本地队列中的对象推到全局工作队列中，</span></span><br><span class="line"><span class="comment">// 这样其他的 worker 就可以知道还有活要干。</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// This should be called when all local mark work has been drained and</span></span><br><span class="line"><span class="comment">// there are no remaining workers. Specifically, when</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   work.nwait == work.nproc &amp;&amp; !gcMarkWorkAvailable(p)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 调用 gcMarkDone 的上下文一定是可抢占的。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Flushing local work is important because idle Ps may have local</span></span><br><span class="line"><span class="comment">// work queued. This is the only way to make that work visible and</span></span><br><span class="line"><span class="comment">// drive GC to completion.</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// 刷新 P 的本地队列到全局队列中是十分重要的，因为 idle 状态的 P 可能在本地</span></span><br><span class="line"><span class="comment">// 队列中有缓存。gcMarkDone 中是唯一的方式让这些本地队列中的对象可以被看到，</span></span><br><span class="line"><span class="comment">// 促使 GC 完成。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// It is explicitly okay to have write barriers in this function. If</span></span><br><span class="line"><span class="comment">// it does transition to mark termination, then all reachable objects</span></span><br><span class="line"><span class="comment">// have been marked, so the write barrier cannot shade any more</span></span><br><span class="line"><span class="comment">// objects.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcMarkDone</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Ensure only one thread is running the ragged barrier at a</span></span><br><span class="line">    <span class="comment">// time.</span></span><br><span class="line">    semacquire(&amp;work.markDoneSema)</span><br><span class="line"></span><br><span class="line">    top:</span><br><span class="line">    <span class="comment">// Re-check transition condition under transition lock.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// It&#x27;s critical that this checks the global work queues are</span></span><br><span class="line">    <span class="comment">// empty before performing the ragged barrier. Otherwise,</span></span><br><span class="line">    <span class="comment">// there could be global work that a P could take after the P</span></span><br><span class="line">    <span class="comment">// has passed the ragged barrier.</span></span><br><span class="line">    <span class="keyword">if</span> !(gcphase == _GCmark &amp;&amp; work.nwait == work.nproc &amp;&amp; !gcMarkWorkAvailable(<span class="literal">nil</span>)) &#123;</span><br><span class="line">        semrelease(&amp;work.markDoneSema)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// forEachP needs worldsema to execute, and we&#x27;ll need it to</span></span><br><span class="line">    <span class="comment">// stop the world later, so acquire worldsema now.</span></span><br><span class="line">    semacquire(&amp;worldsema)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Flush all local buffers and collect flushedWork flags.</span></span><br><span class="line">    gcMarkDoneFlushed = <span class="number">0</span></span><br><span class="line">    systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        gp := getg().m.curg</span><br><span class="line">        <span class="comment">// Mark the user stack as preemptible so that it may be scanned.</span></span><br><span class="line">        <span class="comment">// Otherwise, our attempt to force all P&#x27;s to a safepoint could</span></span><br><span class="line">        <span class="comment">// result in a deadlock as we attempt to preempt a worker that&#x27;s</span></span><br><span class="line">        <span class="comment">// trying to preempt us (e.g. for a stack scan).</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        	标记当前 gp 是可抢占的，目的是为了能够被扫描。当我们强制所有的 P 到达</span></span><br><span class="line"><span class="comment">        	一个 safepoint 可能会导致死锁。比如，我们想抢占一个 worker，同时</span></span><br><span class="line"><span class="comment">        	那个worker也在对我们执行抢占（对我们进行栈扫描）。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        casgstatus(gp, _Grunning, _Gwaiting)</span><br><span class="line">        forEachP(<span class="function"><span class="keyword">func</span><span class="params">(_p_ *p)</span></span> &#123;</span><br><span class="line">            <span class="comment">// Flush the write barrier buffer, since this may add</span></span><br><span class="line">            <span class="comment">// work to the gcWork.</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">	            1.获取当前 P 的 writebarrier buffer 中的内容</span></span><br><span class="line"><span class="comment">	            2.遍历buffer中的对象，标灰，标记 span</span></span><br><span class="line"><span class="comment">	            3.将灰色对象刷到全局的 work queue 中</span></span><br><span class="line"><span class="comment">	            4.清空 P 的 write barrier buffer</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            wbBufFlush1(_p_)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Flush the gcWork, since this may create global work</span></span><br><span class="line">            <span class="comment">// and set the flushedWork flag.</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// TODO(austin): Break up these workbufs to</span></span><br><span class="line">            <span class="comment">// better distribute work.</span></span><br><span class="line">            <span class="comment">// 这里处理的是 P 的本地队列</span></span><br><span class="line">            <span class="comment">// 将本地队列中的内容刷到全局队列中</span></span><br><span class="line">            _p_.gcw.dispose()</span><br><span class="line">            <span class="comment">// Collect the flushedWork flag.</span></span><br><span class="line">            <span class="comment">// flushedWork 记录当前 P 是否又将对象放入到全局workqueue</span></span><br><span class="line">            <span class="keyword">if</span> _p_.gcw.flushedWork &#123;</span><br><span class="line">                atomic.Xadd(&amp;gcMarkDoneFlushed, <span class="number">1</span>)</span><br><span class="line">                _p_.gcw.flushedWork = <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        casgstatus(gp, _Gwaiting, _Grunning)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果有 P 往全局队列放入对象，那还得将那些内容进行标记</span></span><br><span class="line">    <span class="keyword">if</span> gcMarkDoneFlushed != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// More grey objects were discovered since the</span></span><br><span class="line">        <span class="comment">// previous termination check, so there may be more</span></span><br><span class="line">        <span class="comment">// work to do. Keep going. It&#x27;s possible the</span></span><br><span class="line">        <span class="comment">// transition condition became true again during the</span></span><br><span class="line">        <span class="comment">// ragged barrier, so re-check it.</span></span><br><span class="line">        semrelease(&amp;worldsema)</span><br><span class="line">        <span class="keyword">goto</span> top</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// There was no global work, no local work, and no Ps</span></span><br><span class="line">    <span class="comment">// communicated work since we took markDoneSema. Therefore</span></span><br><span class="line">    <span class="comment">// there are no grey objects and no more objects can be</span></span><br><span class="line">    <span class="comment">// shaded. Transition to mark termination.</span></span><br><span class="line">    <span class="comment">// 走到这一步意味着可以将状态转变为 markTermination</span></span><br><span class="line">    now := nanotime()</span><br><span class="line">    work.tMarkTerm = now</span><br><span class="line">    work.pauseStart = now</span><br><span class="line">    getg().m.preemptoff = <span class="string">&quot;gcing&quot;</span></span><br><span class="line">    <span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">        traceGCSTWStart(<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    systemstack(stopTheWorldWithSema)</span><br><span class="line">    <span class="comment">// The gcphase is _GCmark, it will transition to _GCmarktermination</span></span><br><span class="line">    <span class="comment">// below. The important thing is that the wb remains active until</span></span><br><span class="line">    <span class="comment">// all marking is complete. This includes writes made by the GC.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// There is sometimes work left over when we enter mark termination due</span></span><br><span class="line">    <span class="comment">// to write barriers performed after the completion barrier above.</span></span><br><span class="line">    <span class="comment">// Detect this and resume concurrent mark. This is obviously</span></span><br><span class="line">    <span class="comment">// unfortunate.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// See issue #27993 for details.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Switch to the system stack to call wbBufFlush1, though in this case</span></span><br><span class="line">    <span class="comment">// it doesn&#x27;t matter because we&#x27;re non-preemptible anyway.</span></span><br><span class="line">    restart := <span class="literal">false</span></span><br><span class="line">    systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> _, p := <span class="keyword">range</span> allp &#123;</span><br><span class="line">            wbBufFlush1(p)</span><br><span class="line">            <span class="keyword">if</span> !p.gcw.empty() &#123;</span><br><span class="line">                restart = <span class="literal">true</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span> restart &#123;</span><br><span class="line">        getg().m.preemptoff = <span class="string">&quot;&quot;</span></span><br><span class="line">        systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            now := startTheWorldWithSema(<span class="literal">true</span>)</span><br><span class="line">            work.pauseNS += now - work.pauseStart</span><br><span class="line">            memstats.gcPauseDist.record(now - work.pauseStart)</span><br><span class="line">        &#125;)</span><br><span class="line">        semrelease(&amp;worldsema)</span><br><span class="line">        <span class="keyword">goto</span> top</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Disable assists and background workers. We must do</span></span><br><span class="line">    <span class="comment">// this before waking blocked assists.</span></span><br><span class="line">    atomic.Store(&amp;gcBlackenEnabled, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wake all blocked assists. These will run when we</span></span><br><span class="line">    <span class="comment">// start the world again.</span></span><br><span class="line">    <span class="comment">// 唤醒因协助标记而阻塞的 goroutine</span></span><br><span class="line">    gcWakeAllAssists()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Likewise, release the transition lock. Blocked</span></span><br><span class="line">    <span class="comment">// workers and assists will run when we start the</span></span><br><span class="line">    <span class="comment">// world again.</span></span><br><span class="line">    semrelease(&amp;work.markDoneSema)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// In STW mode, re-enable user goroutines. These will be</span></span><br><span class="line">    <span class="comment">// queued to run after we start the world.</span></span><br><span class="line">    schedEnableUser(<span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// endCycle depends on all gcWork cache stats being flushed.</span></span><br><span class="line">    <span class="comment">// The termination algorithm above ensured that up to</span></span><br><span class="line">    <span class="comment">// allocations since the ragged barrier.</span></span><br><span class="line">    nextTriggerRatio := gcController.endCycle(work.userForced)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Perform mark termination. This will restart the world.</span></span><br><span class="line">    gcMarkTermination(nextTriggerRatio)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="番外篇"><a href="#番外篇" class="headerlink" title="番外篇"></a>番外篇</h2><h3 id="suspendG"><a href="#suspendG" class="headerlink" title="suspendG"></a>suspendG</h3><ul>
<li>从全局 g 队列中获取一个，这个 g 有可能是一下几种情况<ul>
<li>正在别的 P 上运行</li>
<li>正在进行系统调用</li>
<li>正在某个地方等待</li>
<li>已经是可执行状态</li>
<li>正在发生抢占</li>
<li>也可能是当前这个 gcMarkWorker</li>
</ul>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    suspendG 在一个安全时刻暂停 goroutine 并且返回被挂起 goroutine 的状态。</span></span><br><span class="line"><span class="comment">    suspendG 的调用者拥有该 goroutine 的读权限直到调用的 resumeG。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    多个调用者在同一时刻想挂起同一个 goroutine 是安全的。</span></span><br><span class="line"><span class="comment">    The goroutine may execute between subsequent successful suspend operations.</span></span><br><span class="line"><span class="comment">    当前的实现为互斥访问 goroutine，因此多个调用者的访问会被串行化。</span></span><br><span class="line"><span class="comment">    然而，这样的目的是为了读共享，所以请不要依赖互斥访问。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    suspendG 一定要在 system stack 上调用并且当前 M 上的 goroutine 一定是可以被抢占的状态。这阻止了两个 goroutine 尝试相互挂起但是他们都处在非抢占状态下发生死锁的情况。虽然还有其他的方式可以解决死锁，但是这种是最简单的方式。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//go:systemstack</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">suspendG</span><span class="params">(gp *g)</span> <span class="title">suspendGState</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> mp := getg().m; mp.curg != <span class="literal">nil</span> &amp;&amp; readgstatus(mp.curg) == _Grunning &#123;</span><br><span class="line">        <span class="comment">// Since we&#x27;re on the system stack of this M, the user</span></span><br><span class="line">        <span class="comment">// G is stuck at an unsafe point. If another goroutine</span></span><br><span class="line">        <span class="comment">// were to try to preempt m.curg, it could deadlock.</span></span><br><span class="line">        throw(<span class="string">&quot;suspendG from non-preemptible goroutine&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// See https://golang.org/cl/21503 for justification of the yield delay.</span></span><br><span class="line">    <span class="keyword">const</span> yieldDelay = <span class="number">10</span> * <span class="number">1000</span></span><br><span class="line">    <span class="keyword">var</span> nextYield <span class="keyword">int64</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Drive the goroutine to a preemption point.</span></span><br><span class="line">    stopped := <span class="literal">false</span></span><br><span class="line">    <span class="keyword">var</span> asyncM *m</span><br><span class="line">    <span class="keyword">var</span> asyncGen <span class="keyword">uint32</span></span><br><span class="line">    <span class="keyword">var</span> nextPreemptM <span class="keyword">int64</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; ; i++ &#123;</span><br><span class="line">        <span class="keyword">switch</span> s := readgstatus(gp); s &#123;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">if</span> s&amp;_Gscan != <span class="number">0</span> &#123;</span><br><span class="line">                <span class="comment">// Someone else is suspending it. Wait</span></span><br><span class="line">                <span class="comment">// for them to finish.</span></span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                <span class="comment">// <span class="doctag">TODO:</span> It would be nicer if we could</span></span><br><span class="line">                <span class="comment">// coalesce suspends.</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            dumpgstatus(gp)</span><br><span class="line">            throw(<span class="string">&quot;invalid g status&quot;</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> _Gdead:</span><br><span class="line">            <span class="comment">// Nothing to suspend.</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// preemptStop may need to be cleared, but</span></span><br><span class="line">            <span class="comment">// doing that here could race with goroutine</span></span><br><span class="line">            <span class="comment">// reuse. Instead, goexit0 clears it.</span></span><br><span class="line">            <span class="keyword">return</span> suspendGState&#123;dead: <span class="literal">true</span>&#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> _Gcopystack:</span><br><span class="line">            <span class="comment">// The stack is being copied. We need to wait</span></span><br><span class="line">            <span class="comment">// until this is done.</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> _Gpreempted:</span><br><span class="line">            <span class="comment">// We (or someone else) suspended the G. Claim</span></span><br><span class="line">            <span class="comment">// ownership of it by transitioning it to</span></span><br><span class="line">            <span class="comment">// _Gwaiting.</span></span><br><span class="line">            <span class="keyword">if</span> !casGFromPreempted(gp, _Gpreempted, _Gwaiting) &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// We stopped the G, so we have to ready it later.</span></span><br><span class="line">            stopped = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">            s = _Gwaiting</span><br><span class="line">            <span class="keyword">fallthrough</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> _Grunnable, _Gsyscall, _Gwaiting:</span><br><span class="line">            <span class="comment">// Claim goroutine by setting scan bit.</span></span><br><span class="line">            <span class="comment">// This may race with execution or readying of gp.</span></span><br><span class="line">            <span class="comment">// The scan bit keeps it from transition state.</span></span><br><span class="line">            <span class="keyword">if</span> !castogscanstatus(gp, s, s|_Gscan) &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Clear the preemption request. It&#x27;s safe to</span></span><br><span class="line">            <span class="comment">// reset the stack guard because we hold the</span></span><br><span class="line">            <span class="comment">// _Gscan bit and thus own the stack.</span></span><br><span class="line">            gp.preemptStop = <span class="literal">false</span></span><br><span class="line">            gp.preempt = <span class="literal">false</span></span><br><span class="line">            gp.stackguard0 = gp.stack.lo + _StackGuard</span><br><span class="line"></span><br><span class="line">            <span class="comment">// The goroutine was already at a safe-point</span></span><br><span class="line">            <span class="comment">// and we&#x27;ve now locked that in.</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> It would be much better if we didn&#x27;t</span></span><br><span class="line">            <span class="comment">// leave it in _Gscan, but instead gently</span></span><br><span class="line">            <span class="comment">// prevented its scheduling until resumption.</span></span><br><span class="line">            <span class="comment">// Maybe we only use this to bump a suspended</span></span><br><span class="line">            <span class="comment">// count and the scheduler skips suspended</span></span><br><span class="line">            <span class="comment">// goroutines? That wouldn&#x27;t be enough for</span></span><br><span class="line">            <span class="comment">// &#123;_Gsyscall,_Gwaiting&#125; -&gt; _Grunning. Maybe</span></span><br><span class="line">            <span class="comment">// for all those transitions we need to check</span></span><br><span class="line">            <span class="comment">// suspended and deschedule?</span></span><br><span class="line">            <span class="keyword">return</span> suspendGState&#123;g: gp, stopped: stopped&#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> _Grunning:</span><br><span class="line">            <span class="comment">// Optimization: if there is already a pending preemption request</span></span><br><span class="line">            <span class="comment">// (from the previous loop iteration), don&#x27;t bother with the atomics.</span></span><br><span class="line">            <span class="keyword">if</span> gp.preemptStop &amp;&amp; gp.preempt &amp;&amp; gp.stackguard0 == stackPreempt &amp;&amp; asyncM == gp.m &amp;&amp; atomic.Load(&amp;asyncM.preemptGen) == asyncGen &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Temporarily block state transitions.</span></span><br><span class="line">            <span class="keyword">if</span> !castogscanstatus(gp, _Grunning, _Gscanrunning) &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Request synchronous preemption.</span></span><br><span class="line">            gp.preemptStop = <span class="literal">true</span></span><br><span class="line">            gp.preempt = <span class="literal">true</span></span><br><span class="line">            gp.stackguard0 = stackPreempt</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Prepare for asynchronous preemption.</span></span><br><span class="line">            asyncM2 := gp.m</span><br><span class="line">            asyncGen2 := atomic.Load(&amp;asyncM2.preemptGen)</span><br><span class="line">            needAsync := asyncM != asyncM2 || asyncGen != asyncGen2</span><br><span class="line">            asyncM = asyncM2</span><br><span class="line">            asyncGen = asyncGen2</span><br><span class="line"></span><br><span class="line">            casfrom_Gscanstatus(gp, _Gscanrunning, _Grunning)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Send asynchronous preemption. We do this</span></span><br><span class="line">            <span class="comment">// after CASing the G back to _Grunning</span></span><br><span class="line">            <span class="comment">// because preemptM may be synchronous and we</span></span><br><span class="line">            <span class="comment">// don&#x27;t want to catch the G just spinning on</span></span><br><span class="line">            <span class="comment">// its status.</span></span><br><span class="line">            <span class="keyword">if</span> preemptMSupported &amp;&amp; debug.asyncpreemptoff == <span class="number">0</span> &amp;&amp; needAsync &#123;</span><br><span class="line">                <span class="comment">// Rate limit preemptM calls. This is</span></span><br><span class="line">                <span class="comment">// particularly important on Windows</span></span><br><span class="line">                <span class="comment">// where preemptM is actually</span></span><br><span class="line">                <span class="comment">// synchronous and the spin loop here</span></span><br><span class="line">                <span class="comment">// can lead to live-lock.</span></span><br><span class="line">                now := nanotime()</span><br><span class="line">                <span class="keyword">if</span> now &gt;= nextPreemptM &#123;</span><br><span class="line">                    nextPreemptM = now + yieldDelay/<span class="number">2</span></span><br><span class="line">                    preemptM(asyncM)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Don&#x27;t busy wait. This loop should really only</span></span><br><span class="line">        <span class="comment">// be a simple read/decide/CAS loop that only fails if</span></span><br><span class="line">        <span class="comment">// there&#x27;s an active race. Once the CAS succeeds, we</span></span><br><span class="line">        <span class="comment">// should queue up the preemption (which will require</span></span><br><span class="line">        <span class="comment">// it to be reliable in the _Grunning case, not</span></span><br><span class="line">        <span class="comment">// best-effort) and then sleep until we&#x27;re notified</span></span><br><span class="line">        <span class="comment">// that the goroutine is suspended.</span></span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">            nextYield = nanotime() + yieldDelay</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> nanotime() &lt; nextYield &#123;</span><br><span class="line">            procyield(<span class="number">10</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            osyield()</span><br><span class="line">            nextYield = nanotime() + yieldDelay/<span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="resumeG"><a href="#resumeG" class="headerlink" title="resumeG"></a>resumeG</h3><h3 id="税收与开支"><a href="#税收与开支" class="headerlink" title="税收与开支"></a>税收与开支</h3><ul>
<li>基本理念</li>
</ul>
<p>​        每个赋值器线程都应当参与一定的回收工作（即纳税）。同时也应当与回收器交替执行，以确保最小赋值器使用率的要求。    </p>
<p>​        回收器应可在赋值器执行间隙尽量多的执行回收工作（即尽量多的积累 credit，以供赋值器支出。）</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// gcFlushBgCredit flushes scanWork units of background scan work</span></span><br><span class="line"><span class="comment">// credit. This first satisfies blocked assists on the</span></span><br><span class="line"><span class="comment">// work.assistQueue and then flushes any remaining credit to</span></span><br><span class="line"><span class="comment">// gcController.bgScanCredit.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Write barriers are disallowed because this is used by gcDrain after</span></span><br><span class="line"><span class="comment">// it has ensured that all work is drained and this must preserve that</span></span><br><span class="line"><span class="comment">// condition.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//go:nowritebarrierrec</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcFlushBgCredit</span><span class="params">(scanWork <span class="keyword">int64</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> work.assistQueue.q.empty() &#123;</span><br><span class="line">        <span class="comment">// Fast path; there are no blocked assists. There&#x27;s a</span></span><br><span class="line">        <span class="comment">// small window here where an assist may add itself to</span></span><br><span class="line">        <span class="comment">// the blocked queue and park. If that happens, we&#x27;ll</span></span><br><span class="line">        <span class="comment">// just get it on the next flush.</span></span><br><span class="line">        atomic.Xaddint64(&amp;gcController.bgScanCredit, scanWork)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    assistBytesPerWork := float64frombits(atomic.Load64(&amp;gcController.assistBytesPerWork))</span><br><span class="line">    scanBytes := <span class="keyword">int64</span>(<span class="keyword">float64</span>(scanWork) * assistBytesPerWork)</span><br><span class="line"></span><br><span class="line">    lock(&amp;work.assistQueue.lock)</span><br><span class="line">    <span class="keyword">for</span> !work.assistQueue.q.empty() &amp;&amp; scanBytes &gt; <span class="number">0</span> &#123;</span><br><span class="line">        gp := work.assistQueue.q.pop()</span><br><span class="line">        <span class="comment">// Note that gp.gcAssistBytes is negative because gp</span></span><br><span class="line">        <span class="comment">// is in debt. Think carefully about the signs below.</span></span><br><span class="line">        <span class="comment">// scanBytes+gp.gcAssistBytes 意味着足够支付债务</span></span><br><span class="line">        <span class="keyword">if</span> scanBytes+gp.gcAssistBytes &gt;= <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// Satisfy this entire assist debt.</span></span><br><span class="line">            scanBytes += gp.gcAssistBytes</span><br><span class="line">            gp.gcAssistBytes = <span class="number">0</span></span><br><span class="line">            <span class="comment">// It&#x27;s important that we *not* put gp in</span></span><br><span class="line">            <span class="comment">// runnext. Otherwise, it&#x27;s possible for user</span></span><br><span class="line">            <span class="comment">// code to exploit the GC worker&#x27;s high</span></span><br><span class="line">            <span class="comment">// scheduler priority to get itself always run</span></span><br><span class="line">            <span class="comment">// before other goroutines and always in the</span></span><br><span class="line">            <span class="comment">// fresh quantum started by GC.</span></span><br><span class="line">            <span class="comment">// 还债后唤醒这个 g</span></span><br><span class="line">            ready(gp, <span class="number">0</span>, <span class="literal">false</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 没法完全支付债务，但是可以偿还一部分</span></span><br><span class="line">            <span class="comment">// 偿还完成后，又放回了协助标记的队列中</span></span><br><span class="line">            <span class="comment">// Partially satisfy this assist.</span></span><br><span class="line">            gp.gcAssistBytes += scanBytes</span><br><span class="line">            scanBytes = <span class="number">0</span></span><br><span class="line">            <span class="comment">// As a heuristic, we move this assist to the</span></span><br><span class="line">            <span class="comment">// back of the queue so that large assists</span></span><br><span class="line">            <span class="comment">// can&#x27;t clog up the assist queue and</span></span><br><span class="line">            <span class="comment">// substantially delay small assists.</span></span><br><span class="line">            work.assistQueue.q.pushBack(gp)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果仍然有剩余的 credit 就刷新到全局的 credit 中</span></span><br><span class="line">    <span class="keyword">if</span> scanBytes &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// Convert from scan bytes back to work.</span></span><br><span class="line">        assistWorkPerByte := float64frombits(atomic.Load64(&amp;gcController.assistWorkPerByte))</span><br><span class="line">        scanWork = <span class="keyword">int64</span>(<span class="keyword">float64</span>(scanBytes) * assistWorkPerByte)</span><br><span class="line">        atomic.Xaddint64(&amp;gcController.bgScanCredit, scanWork)</span><br><span class="line">    &#125;</span><br><span class="line">    unlock(&amp;work.assistQueue.lock)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><p>GC 真的是太难了… 感觉这些都还只是冰山一角，曹大讲过，GC 这部分量力而行，对于大部分程序员来说可以完整的把三色抽象、GC 流程给面试官描述出来，已经是很厉害了，如果他还了解一些理论基础，那算是相当不错了…</p>
<p>我们追求的不是得到别人的认可，而是对知识的渴望。严于律己，提高自己的职业素养。</p>
</div><div id="donate"><link rel="stylesheet" type="text/css" href="/css/donate.css?v=1.0.0"><script type="text/javascript" src="/js/donate.js?v=1.0.0" successtext="复制成功!"></script><a class="pos-f tr3" id="github" href="https://github.com/clamyang" target="_blank" title="Github"></a><div id="DonateText">Donate</div><ul class="list pos-f" id="donateBox"><li id="AliPay" qr="/img/AliPayQR.jpg"></li><li id="WeChat" qr="/img/WeChatQR.jpg"></li></ul><div class="pos-f left-100" id="QRBox"><div id="MainBox"></div></div></div><div class="post-copyright"><script type="text/javascript" src="/js/copyright.js?v=1.0.0" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copyright.css?v=1.0.0"><p><span>本文标题：</span>GC 源码梳理</p><p><span>文章作者：</span>bqyang</p><p><span>发布时间：</span>2021-12-02</p><p><span>最后更新：</span>2022-01-12</p><p><span>原始链接：</span><a href="/2021/language/golang/GC/">https://bqyang.top/2021/language/golang/GC/</a><span class="copy-path"><i class="fa fa-clipboard" data-clipboard-text="https://bqyang.top/2021/language/golang/GC/"></i></span></p><p><span>版权声明：</span>The author owns the copyright, please indicate the source reproduced.</p></div><br><div class="tags"></div><div class="post-nav"><a class="pre" href="/2021/language/golang/preemptSchedule/">golang 中的抢占</a><a class="next" href="/2021/language/golang/GCComments/">GC from go comments</a></div><script src="https://utteranc.es/client.js" repo="clamyang/blogs" issue-term="title" theme="github-light" crossorigin="anonymous" async> </script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://bqyang.top"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2022/os/process/process/">操作系统进程</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/new-words/">new words for me</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/os/linker&loader/">linker and loader</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/summary/HappyWeekend/">Weekend</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/vcs/git/git-rebase/">git rebase</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/os/elf/">elf 文件格式</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/DDIA/">DDIA 读书笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/contributeToYunion/">第一次 pr</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/summary/tips0309/">一点总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/rpc/about-rpc-1/">关于 rpc 的那些事（一）</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.xargin.com/" title="Xargin" target="_blank">Xargin</a><ul></ul><a href="https://mytechshares.com/" title="董泽润的技术笔记" target="_blank">董泽润的技术笔记</a><ul></ul><a href="https://hujingnb.com/" title="烟草的香味" target="_blank">烟草的香味</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2022 <a href="/." rel="nofollow">杨宝强的技术笔记.</a>Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://beian.miit.gov.cn/"> 京ICP备2021035561号.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>