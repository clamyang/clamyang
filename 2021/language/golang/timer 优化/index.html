<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="一物不知深以为耻"><title>timer 优化 | 杨宝强的技术笔记</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><div class="darkmode-toggle">🌓</div><script>var prefersDarkMode = window.matchMedia('(prefers-color-scheme: dark)');
var toggle = document.querySelector('.darkmode-toggle');
var html = document.querySelector('html');

html.dataset.dark = localStorage.dark || prefersDarkMode.matches;

toggle.addEventListener('click', () => {
localStorage.dark = !(html.dataset.dark == 'true');
html.dataset.dark = localStorage.dark;
});</script><meta name="generator" content="Hexo 5.4.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">timer 优化</h1><a id="logo" href="/.">杨宝强的技术笔记</a><p class="description">Gopher Watcher</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">timer 优化</h1><div class="post-meta">2021-12-06</div><div class="post-content"><p>我们已经知道了，老版本 timer 的性能瓶颈主要是在那把全局锁以及频繁的上下文切换上，今天我们看看 go 大佬们通过哪种方式进行优化的。<br>​</p>
<p>在这里解释一下为什么选择这几个版本，据我所知啊，从 1.10 版本以前都是像上一篇文中所描述的那样，在 1.10 版本开始就做了这个优化，但从 1.14 开始又对 timer 进行了优化，所以我选择了 1.8， 1.13， 1.14 这几个邻近的作为参考。</p>
<span id="more"></span>

<h2 id="go-1-13-中的优化"><a href="#go-1-13-中的优化" class="headerlink" title="go 1.13 中的优化"></a>go 1.13 中的优化</h2><h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3><ul>
<li>go version: go1.13</li>
<li>compute: linux, centos7</li>
</ul>
<h3 id="timer-结构的变化"><a href="#timer-结构的变化" class="headerlink" title="timer 结构的变化"></a>timer 结构的变化</h3><h5 id="go1-8"><a href="#go1-8" class="headerlink" title="go1.8"></a>go1.8</h5><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> timer <span class="keyword">struct</span> &#123;</span><br><span class="line">    i <span class="keyword">int</span> <span class="comment">// heap index</span></span><br><span class="line">    when   <span class="keyword">int64</span></span><br><span class="line">    period <span class="keyword">int64</span></span><br><span class="line">    f      <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">interface</span>&#123;&#125;, <span class="keyword">uintptr</span>)</span></span></span><br><span class="line">    arg    <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    seq    <span class="keyword">uintptr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="go1-13"><a href="#go1-13" class="headerlink" title="go1.13"></a>go1.13</h5><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> timer <span class="keyword">struct</span> &#123;</span><br><span class="line">    tb *timersBucket <span class="comment">// the bucket the timer lives in</span></span><br><span class="line">    i  <span class="keyword">int</span>           <span class="comment">// heap index</span></span><br><span class="line">    when   <span class="keyword">int64</span></span><br><span class="line">    period <span class="keyword">int64</span></span><br><span class="line">    f      <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">interface</span>&#123;&#125;, <span class="keyword">uintptr</span>)</span></span></span><br><span class="line">    arg    <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    seq    <span class="keyword">uintptr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在go1.13版本中添加了一个 tb 字段，表示当前这个 timer 是在哪个 bucket 中的，其余字段含义还是和老版本中的一致。<br>​</p>
<p>还记得老版本把新建的 <code>timer</code> 对象都放在哪里了吗？<code>一个全局的 timers 中</code> go1.13版本中将的 timers 拆分成了 64 个大小的 timers 数组，每一个里边包含了一个 bucket ，bucket 中再存放 timer 对象，至于为什么是 64 官方的解释如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// timersLen is the length of timers array.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Ideally, this would be set to GOMAXPROCS, but that would require</span></span><br><span class="line"><span class="comment">// dynamic reallocation</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The current value is a compromise between memory usage and performance</span></span><br><span class="line"><span class="comment">// that should cover the majority of GOMAXPROCS values used in the wild.</span></span><br><span class="line"><span class="keyword">const</span> timersLen = <span class="number">64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// timersLen is the length of timers array.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Ideally, this would be set to GOMAXPROCS, but that would require</span></span><br><span class="line"><span class="comment">// dynamic reallocation</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The current value is a compromise between memory usage and performance</span></span><br><span class="line"><span class="comment">// that should cover the majority of GOMAXPROCS values used in the wild.</span></span><br><span class="line"><span class="keyword">var</span> timers [timersLen]<span class="keyword">struct</span> &#123;</span><br><span class="line">    timersBucket</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The padding should eliminate false sharing</span></span><br><span class="line">    <span class="comment">// between timersBucket values.</span></span><br><span class="line">    pad [cpu.CacheLinePadSize - unsafe.Sizeof(timersBucket&#123;&#125;)%cpu.CacheLinePadSize]<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:notinheap</span></span><br><span class="line"><span class="keyword">type</span> timersBucket <span class="keyword">struct</span> &#123;</span><br><span class="line">    lock         mutex</span><br><span class="line">    gp           *g</span><br><span class="line">    created      <span class="keyword">bool</span></span><br><span class="line">    sleeping     <span class="keyword">bool</span></span><br><span class="line">    rescheduling <span class="keyword">bool</span></span><br><span class="line">    sleepUntil   <span class="keyword">int64</span></span><br><span class="line">    waitnote     note</span><br><span class="line">    t            []*timer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在添加 timer 对象时逻辑变成了，根据当前 p 的 id 对 timersLen 取模，得到了 p 对应的 timersBucket <code>id := uint8(getg().m.p.ptr().id) % _timersLen_</code><br>从这个优化的方法来看，以前是每个p去抢同一把锁，现在变成，每个p只会操作对应的 timersBucket（大多数情况下）。</p>
<ul>
<li><input disabled="" type="checkbox"> <strong>在超过 64 个 p 的时候，就会出现取模到同一个 bucket 中，这种情况在多核 cpu &gt; 64 上是没办法避免的</strong></li>
<li><input disabled="" type="checkbox"> <strong>可能还有 p 从别的 p 上偷 timer 的情况</strong></li>
</ul>
<p>接下里我们看下执行 timer 的 <code>timerproc</code><br>1.8 版本中，全局只有一个执行 timer 的 timerproc，可以理解为只有一个消费者。1.13 中修改为每个不同的 bucket 都会有一个对应的 bucket。举个例子，比如我们有 4 个 P，就说明我们会有 4 个 bucket 和 4 个 timerproc，每当通过 addtimer 添加时，都会往 p 对应的 bucket 中添加任务，timerproc 作为消费者从中找可执行的timer，如下图：<br><img src="https://gitee.com/yangbaoqiang/images/raw/master/blogpics/1636033788855-ece14ebf-e72d-4851-9a75-de7cd60d59ba.png" alt="image.png"></p>
<h3 id="timer-的“生产者”"><a href="#timer-的“生产者”" class="headerlink" title="timer 的“生产者”"></a>timer 的“生产者”</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如前所述，每个p对应不同的 timersBucket，那么在创建之前我们是不是应该先找到在哪个 p 上执行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *timer)</span> <span class="title">assignBucket</span><span class="params">()</span> *<span class="title">timersBucket</span></span> &#123;</span><br><span class="line">    id := <span class="keyword">uint8</span>(getg().m.p.ptr().id) % timersLen</span><br><span class="line">    t.tb = &amp;timers[id].timersBucket</span><br><span class="line">    <span class="keyword">return</span> t.tb</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 timer 添加到对应的 timersBucket 中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addtimer</span><span class="params">(t *timer)</span></span> &#123;</span><br><span class="line">    tb := t.assignBucket()</span><br><span class="line">    lock(&amp;tb.lock)</span><br><span class="line">    ok := tb.addtimerLocked(t)</span><br><span class="line">    unlock(&amp;tb.lock)</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        badTimer()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 咱们只把重点放在与以前不同的地方上</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tb *timersBucket)</span> <span class="title">addtimerLocked</span><span class="params">(t *timer)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> t.when &lt; <span class="number">0</span> &#123;</span><br><span class="line">        t.when = <span class="number">1</span>&lt;&lt;<span class="number">63</span> - <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    t.i = <span class="built_in">len</span>(tb.t)</span><br><span class="line">    tb.t = <span class="built_in">append</span>(tb.t, t) 		<span class="comment">// 添加到p对应的timersBucket中，而不是全局的 timers 中了</span></span><br><span class="line">    <span class="keyword">if</span> !siftupTimer(tb.t, t.i) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> t.i == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// siftup moved to top: new earliest deadline.</span></span><br><span class="line">        <span class="keyword">if</span> tb.sleeping &amp;&amp; tb.sleepUntil &gt; t.when &#123;</span><br><span class="line">            tb.sleeping = <span class="literal">false</span></span><br><span class="line">            notewakeup(&amp;tb.waitnote)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> tb.rescheduling &#123;</span><br><span class="line">            tb.rescheduling = <span class="literal">false</span></span><br><span class="line">            goready(tb.gp, <span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> !tb.created &#123;</span><br><span class="line">            <span class="comment">// 判断属于这个 tb 的 timerproc 是否启动了，</span></span><br><span class="line">            <span class="comment">// 区别于1.8版本是一个全局变量控制的，只有一个消费者，这里是每一个 tb 都有一个消费者</span></span><br><span class="line">            tb.created = <span class="literal">true</span></span><br><span class="line">            <span class="keyword">go</span> timerproc(tb)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="timer-的“消费者”"><a href="#timer-的“消费者”" class="headerlink" title="timer 的“消费者”"></a>timer 的“消费者”</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 主要的逻辑还是同 1.8 版本中一致的，不同的地方就是针对每个tb进行的操作，不是全局的 timers</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">timerproc</span><span class="params">(tb *timersBucket)</span></span> &#123;</span><br><span class="line">    tb.gp = getg()</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        lock(&amp;tb.lock)</span><br><span class="line">        tb.sleeping = <span class="literal">false</span></span><br><span class="line">        now := nanotime()</span><br><span class="line">        delta := <span class="keyword">int64</span>(<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(tb.t) == <span class="number">0</span> &#123;</span><br><span class="line">                delta = <span class="number">-1</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            t := tb.t[<span class="number">0</span>]</span><br><span class="line">            delta = t.when - now</span><br><span class="line">            <span class="keyword">if</span> delta &gt; <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            ok := <span class="literal">true</span></span><br><span class="line">            <span class="keyword">if</span> t.period &gt; <span class="number">0</span> &#123;</span><br><span class="line">                <span class="comment">// leave in heap but adjust next time to fire</span></span><br><span class="line">                t.when += t.period * (<span class="number">1</span> + -delta/t.period)</span><br><span class="line">                <span class="keyword">if</span> !siftdownTimer(tb.t, <span class="number">0</span>) &#123;</span><br><span class="line">                    ok = <span class="literal">false</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// remove from heap</span></span><br><span class="line">                last := <span class="built_in">len</span>(tb.t) - <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> last &gt; <span class="number">0</span> &#123;</span><br><span class="line">                    tb.t[<span class="number">0</span>] = tb.t[last]</span><br><span class="line">                    tb.t[<span class="number">0</span>].i = <span class="number">0</span></span><br><span class="line">                &#125;</span><br><span class="line">                tb.t[last] = <span class="literal">nil</span></span><br><span class="line">                tb.t = tb.t[:last]</span><br><span class="line">                <span class="keyword">if</span> last &gt; <span class="number">0</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> !siftdownTimer(tb.t, <span class="number">0</span>) &#123;</span><br><span class="line">                        ok = <span class="literal">false</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                t.i = <span class="number">-1</span> <span class="comment">// mark as removed</span></span><br><span class="line">            &#125;</span><br><span class="line">            f := t.f</span><br><span class="line">            arg := t.arg</span><br><span class="line">            seq := t.seq</span><br><span class="line">            unlock(&amp;tb.lock)</span><br><span class="line">            <span class="keyword">if</span> !ok &#123;</span><br><span class="line">                badTimer()</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">                raceacquire(unsafe.Pointer(t))</span><br><span class="line">            &#125;</span><br><span class="line">            f(arg, seq)</span><br><span class="line">            lock(&amp;tb.lock)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> delta &lt; <span class="number">0</span> || faketime &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// No timers left - put goroutine to sleep.</span></span><br><span class="line">            tb.rescheduling = <span class="literal">true</span></span><br><span class="line">            goparkunlock(&amp;tb.lock, waitReasonTimerGoroutineIdle, traceEvGoBlock, <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// At least one timer pending. Sleep until then.</span></span><br><span class="line">        tb.sleeping = <span class="literal">true</span></span><br><span class="line">        tb.sleepUntil = now + delta</span><br><span class="line">        noteclear(&amp;tb.waitnote)</span><br><span class="line">        unlock(&amp;tb.lock)</span><br><span class="line">        notetsleepg(&amp;tb.waitnote, delta)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相比于 1.8，1.13版本中还添加了一个 <code>modtimer(t *timer, when, period int64, f func(interface&#123;&#125;, uintptr), arg interface&#123;&#125;, seq uintptr)</code><br>modtimer 函数主要做了，将 t 从 tb 中删除，然后有 重新给它 加入进去</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modtimer</span><span class="params">(t *timer, when, period <span class="keyword">int64</span>, f <span class="keyword">func</span>(<span class="keyword">interface</span>&#123;&#125;, <span class="keyword">uintptr</span>)</span>, <span class="title">arg</span> <span class="title">interface</span></span>&#123;&#125;, seq <span class="keyword">uintptr</span>) &#123;</span><br><span class="line">    tb := t.tb</span><br><span class="line"></span><br><span class="line">    lock(&amp;tb.lock)</span><br><span class="line">    _, ok := tb.deltimerLocked(t)</span><br><span class="line">    <span class="keyword">if</span> ok &#123;</span><br><span class="line">        t.when = when</span><br><span class="line">        t.period = period</span><br><span class="line">        t.f = f</span><br><span class="line">        t.arg = arg</span><br><span class="line">        t.seq = seq</span><br><span class="line">        ok = tb.addtimerLocked(t)</span><br><span class="line">    &#125;</span><br><span class="line">    unlock(&amp;tb.lock)</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        badTimer()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 netpoll 中，有两处地方调用了这个函数，主要就是给 fd 调整超时处理使用的。</p>
<p>总的来说这个版本中的优化只是做了全局锁粒度的拆分，上下文切换带来额外的性能开销仍然没有得到优化，不过不要着急，1.14 版本中针对这个问题已经做了妥善的处理，我们马上就来看一下。<br>​</p>
<h2 id="go-1-14-中的优化"><a href="#go-1-14-中的优化" class="headerlink" title="go 1.14 中的优化"></a>go 1.14 中的优化</h2><h3 id="环境信息-1"><a href="#环境信息-1" class="headerlink" title="环境信息"></a>环境信息</h3><p>go version: go1.14.1<br>compute: linux, centos7</p>
<h3 id="timer-结构的变化-1"><a href="#timer-结构的变化-1" class="headerlink" title="timer 结构的变化"></a>timer 结构的变化</h3><p>以前的结构体都是全局变量，在 1.14 版本开始，timer 结构体就内嵌到了 P 中。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Package time knows the layout of this structure.</span></span><br><span class="line"><span class="comment">// If this struct changes, adjust ../time/sleep.go:/runtimeTimer.</span></span><br><span class="line"><span class="keyword">type</span> timer <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// If this timer is on a heap, which P&#x27;s heap it is on.</span></span><br><span class="line">    <span class="comment">// puintptr rather than *p to match uintptr in the versions</span></span><br><span class="line">    <span class="comment">// of this struct defined in other packages.</span></span><br><span class="line">    pp puintptr</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Timer wakes up at when, and then at when+period, ... (period &gt; 0 only)</span></span><br><span class="line">    <span class="comment">// each time calling f(arg, now) in the timer goroutine, so f must be</span></span><br><span class="line">    <span class="comment">// a well-behaved function and not block.</span></span><br><span class="line">    when   <span class="keyword">int64</span></span><br><span class="line">    period <span class="keyword">int64</span></span><br><span class="line">    f      <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">interface</span>&#123;&#125;, <span class="keyword">uintptr</span>)</span></span></span><br><span class="line">    arg    <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    seq    <span class="keyword">uintptr</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// What to set the when field to in timerModifiedXX status.</span></span><br><span class="line">    nextwhen <span class="keyword">int64</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// The status field holds one of the values below.</span></span><br><span class="line">    status <span class="keyword">uint32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> p <span class="keyword">struct</span> &#123;</span><br><span class="line">    id          <span class="keyword">int32</span></span><br><span class="line">    </span><br><span class="line">    (...)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Lock for timers. We normally access the timers while running</span></span><br><span class="line">    <span class="comment">// on this P, but the scheduler can also do it from a different P.</span></span><br><span class="line">    <span class="comment">// 讲道理，你p处理本地的 timer 用锁干什么？</span></span><br><span class="line">    <span class="comment">// 1.14 是可以偷 timer 的，这时候就变成了共享资源，访问的时候是一定要加锁的。</span></span><br><span class="line">    <span class="comment">// 上边注释（英文）说的也很清楚，这个是官方的解释</span></span><br><span class="line">    timersLock mutex</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Actions to take at some time. This is used to implement the</span></span><br><span class="line">    <span class="comment">// standard library&#x27;s time package.</span></span><br><span class="line">    <span class="comment">// Must hold timersLock to access.</span></span><br><span class="line">    timers []*timer</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Number of timers in P&#x27;s heap.</span></span><br><span class="line">    <span class="comment">// Modified using atomic instructions.</span></span><br><span class="line">    <span class="comment">// 记录当前 p 中 timer的总数量</span></span><br><span class="line">    numTimers <span class="keyword">uint32</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Number of timerModifiedEarlier timers on P&#x27;s heap.</span></span><br><span class="line">    <span class="comment">// This should only be modified while holding timersLock,</span></span><br><span class="line">    <span class="comment">// or while the timer status is in a transient state</span></span><br><span class="line">    <span class="comment">// such as timerModifying.</span></span><br><span class="line">    <span class="comment">// P 中 调整 when 的时间提前了的 timer 数量</span></span><br><span class="line">    adjustTimers <span class="keyword">uint32</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Number of timerDeleted timers in P&#x27;s heap.</span></span><br><span class="line">    <span class="comment">// Modified using atomic instructions.</span></span><br><span class="line">    <span class="comment">// 记录 p 中被删除的 timer 数量</span></span><br><span class="line">    deletedTimers <span class="keyword">uint32</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Race context used while executing timer functions.</span></span><br><span class="line">    timerRaceCtx <span class="keyword">uintptr</span></span><br><span class="line">    </span><br><span class="line">    (...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="timer-的“生产者”-1"><a href="#timer-的“生产者”-1" class="headerlink" title="timer 的“生产者”"></a>timer 的“生产者”</h3><p><code>... 基本上大同小异，只不过是加了一些状态</code><br>不过需要注意的一点是，1.14 中有了 timer 和 netpoll 的结合。我的理解是：<br>findrunnable 最后没有找到可执行的 g 的时候会再检查 netpoll。这个调用过程是阻塞的，阻塞 delta 这段时间，然后这时候比如说我通过 addtimer 加入新timer，就是假设哈，1s 后要执行，然后你那个阻塞过程要阻塞 3s，但这是在阻塞没有办法执行我们的 timer，然后这时候 addtimer 中的 wakenetpoller 就派上用场，通过 <code>netpollbreak</code> 中断那个阻塞调用，然后就回到 <code>findrunnable</code> 继续执行，及时响应那个近期的 timer 对象。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// addtimer:</span></span><br><span class="line"><span class="comment">//   timerNoStatus   -&gt; timerWaiting</span></span><br><span class="line"><span class="comment">//   anything else   -&gt; panic: invalid value</span></span><br><span class="line"><span class="comment">// deltimer:</span></span><br><span class="line"><span class="comment">//   timerWaiting         -&gt; timerModifying -&gt; timerDeleted</span></span><br><span class="line"><span class="comment">//   timerModifiedEarlier -&gt; timerModifying -&gt; timerDeleted</span></span><br><span class="line"><span class="comment">//   timerModifiedLater   -&gt; timerModifying -&gt; timerDeleted</span></span><br><span class="line"><span class="comment">//   timerNoStatus        -&gt; do nothing</span></span><br><span class="line"><span class="comment">//   timerDeleted         -&gt; do nothing</span></span><br><span class="line"><span class="comment">//   timerRemoving        -&gt; do nothing</span></span><br><span class="line"><span class="comment">//   timerRemoved         -&gt; do nothing</span></span><br><span class="line"><span class="comment">//   timerRunning         -&gt; wait until status changes</span></span><br><span class="line"><span class="comment">//   timerMoving          -&gt; wait until status changes</span></span><br><span class="line"><span class="comment">//   timerModifying       -&gt; wait until status changes</span></span><br><span class="line"><span class="comment">// modtimer:</span></span><br><span class="line"><span class="comment">//   timerWaiting    -&gt; timerModifying -&gt; timerModifiedXX</span></span><br><span class="line"><span class="comment">//   timerModifiedXX -&gt; timerModifying -&gt; timerModifiedYY</span></span><br><span class="line"><span class="comment">//   timerNoStatus   -&gt; timerModifying -&gt; timerWaiting</span></span><br><span class="line"><span class="comment">//   timerRemoved    -&gt; timerModifying -&gt; timerWaiting</span></span><br><span class="line"><span class="comment">//   timerDeleted    -&gt; timerModifying -&gt; timerModifiedXX</span></span><br><span class="line"><span class="comment">//   timerRunning    -&gt; wait until status changes</span></span><br><span class="line"><span class="comment">//   timerMoving     -&gt; wait until status changes</span></span><br><span class="line"><span class="comment">//   timerRemoving   -&gt; wait until status changes</span></span><br><span class="line"><span class="comment">//   timerModifying  -&gt; wait until status changes</span></span><br><span class="line"><span class="comment">// cleantimers (looks in P&#x27;s timer heap):</span></span><br><span class="line"><span class="comment">//   timerDeleted    -&gt; timerRemoving -&gt; timerRemoved</span></span><br><span class="line"><span class="comment">//   timerModifiedXX -&gt; timerMoving -&gt; timerWaiting</span></span><br><span class="line"><span class="comment">// adjusttimers (looks in P&#x27;s timer heap):</span></span><br><span class="line"><span class="comment">//   timerDeleted    -&gt; timerRemoving -&gt; timerRemoved</span></span><br><span class="line"><span class="comment">//   timerModifiedXX -&gt; timerMoving -&gt; timerWaiting</span></span><br><span class="line"><span class="comment">// runtimer (looks in P&#x27;s timer heap):</span></span><br><span class="line"><span class="comment">//   timerNoStatus   -&gt; panic: uninitialized timer</span></span><br><span class="line"><span class="comment">//   timerWaiting    -&gt; timerWaiting or</span></span><br><span class="line"><span class="comment">//   timerWaiting    -&gt; timerRunning -&gt; timerNoStatus or</span></span><br><span class="line"><span class="comment">//   timerWaiting    -&gt; timerRunning -&gt; timerWaiting</span></span><br><span class="line"><span class="comment">//   timerModifying  -&gt; wait until status changes</span></span><br><span class="line"><span class="comment">//   timerModifiedXX -&gt; timerMoving -&gt; timerWaiting</span></span><br><span class="line"><span class="comment">//   timerDeleted    -&gt; timerRemoving -&gt; timerRemoved</span></span><br><span class="line"><span class="comment">//   timerRunning    -&gt; panic: concurrent runtimer calls</span></span><br><span class="line"><span class="comment">//   timerRemoved    -&gt; panic: inconsistent timer heap</span></span><br><span class="line"><span class="comment">//   timerRemoving   -&gt; panic: inconsistent timer heap</span></span><br><span class="line"><span class="comment">//   timerMoving     -&gt; panic: inconsistent timer heap</span></span><br></pre></td></tr></table></figure>
<h3 id="timer-的“消费者”-1"><a href="#timer-的“消费者”-1" class="headerlink" title="timer 的“消费者”"></a>timer 的“消费者”</h3><p>新版本中的“消费者”有着非常重要的改变，<code>timerproc</code> 没了，首先我们要明确：<br>timerproc 不仅仅是一个函数，它是 runtime 创建的一个 goroutine，因此可知，以前的“消费者”就是一个 goroutine， 它并没有什么不同，同样被 <code>scheduler</code>调度。</p>
<p>1.14 中，直接给“消费者”升到“头等舱”，看你小子干活勤勤恳恳，scheduler说，你来我这上班吧，结果人家就去了。</p>
<p>1.14 中，timer 的消费者就是在调度循环的 <code>schedule</code> 中，其次就是 <code>sysmon</code> （sysmon作为兜底），我们看下源码，看看新版本的消费者是怎么“晋升”的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">schedule</span><span class="params">()</span></span> &#123;</span><br><span class="line">    (...) <span class="comment">// 省略安全检查</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 看看人家 timer 直接被安排到顶级位置</span></span><br><span class="line">    <span class="comment">// 调度循环上来就是先检查 timer</span></span><br><span class="line">    checkTimers(pp, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    (...)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> gp == <span class="literal">nil</span> &#123;</span><br><span class="line">        gp, inheritTime = findrunnable() <span class="comment">// blocks until work is available</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    (...)</span><br><span class="line">    </span><br><span class="line">    execute(gp, inheritTime)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以得出结论，新版本的“消费者” 从 goroutine 级别 转变到 函数级别。</p>
<h4 id="checkTimers"><a href="#checkTimers" class="headerlink" title="checkTimers()"></a>checkTimers()</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// checkTimers runs any timers for the P that are ready.</span></span><br><span class="line"><span class="comment">// If now is not 0 it is the current time.</span></span><br><span class="line"><span class="comment">// It returns the current time or 0 if it is not known,</span></span><br><span class="line"><span class="comment">// and the time when the next timer should run or 0 if there is no next timer,</span></span><br><span class="line"><span class="comment">// and reports whether it ran any timers.</span></span><br><span class="line"><span class="comment">// If the time when the next timer should run is not 0,</span></span><br><span class="line"><span class="comment">// it is always larger than the returned time.</span></span><br><span class="line"><span class="comment">// We pass now in and out to avoid extra calls of nanotime.</span></span><br><span class="line"><span class="comment">//go:yeswritebarrierrec</span></span><br><span class="line"><span class="comment">// rnow			</span></span><br><span class="line"><span class="comment">// pollUntil	0 表示没有下一个 timer，非 0 表示下一个timer的等待时间</span></span><br><span class="line"><span class="comment">// ran			表示是否执行了 timer</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkTimers</span><span class="params">(pp *p, now <span class="keyword">int64</span>)</span> <span class="params">(rnow, pollUntil <span class="keyword">int64</span>, ran <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// If there are no timers to adjust, and the first timer on</span></span><br><span class="line">    <span class="comment">// the heap is not yet ready to run, then there is nothing to do.</span></span><br><span class="line">    <span class="keyword">if</span> atomic.Load(&amp;pp.adjustTimers) == <span class="number">0</span> &#123;</span><br><span class="line">        next := <span class="keyword">int64</span>(atomic.Load64(&amp;pp.timer0When))</span><br><span class="line">        <span class="keyword">if</span> next == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> now, <span class="number">0</span>, <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> now == <span class="number">0</span> &#123;</span><br><span class="line">            now = nanotime()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> now &lt; next &#123;</span><br><span class="line">            <span class="comment">// Next timer is not ready to run.</span></span><br><span class="line">            <span class="comment">// But keep going if we would clear deleted timers.</span></span><br><span class="line">            <span class="comment">// This corresponds to the condition below where</span></span><br><span class="line">            <span class="comment">// we decide whether to call clearDeletedTimers.</span></span><br><span class="line">            <span class="comment">// 尽可能找机会清理 timer</span></span><br><span class="line">            <span class="keyword">if</span> pp != getg().m.p.ptr() || <span class="keyword">int</span>(atomic.Load(&amp;pp.deletedTimers)) &lt;= <span class="keyword">int</span>(atomic.Load(&amp;pp.numTimers)/<span class="number">4</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> now, next, <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lock(&amp;pp.timersLock)</span><br><span class="line"></span><br><span class="line">    adjusttimers(pp)</span><br><span class="line"></span><br><span class="line">    rnow = now</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(pp.timers) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> rnow == <span class="number">0</span> &#123;</span><br><span class="line">            rnow = nanotime()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">len</span>(pp.timers) &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// Note that runtimer may temporarily unlock</span></span><br><span class="line">            <span class="comment">// pp.timersLock.</span></span><br><span class="line">            <span class="keyword">if</span> tw := runtimer(pp, rnow); tw != <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> tw &gt; <span class="number">0</span> &#123;</span><br><span class="line">                    pollUntil = tw</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            ran = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If this is the local P, and there are a lot of deleted timers,</span></span><br><span class="line">    <span class="comment">// clear them out. We only do this for the local P to reduce</span></span><br><span class="line">    <span class="comment">// lock contention on timersLock.</span></span><br><span class="line">    <span class="keyword">if</span> pp == getg().m.p.ptr() &amp;&amp; <span class="keyword">int</span>(atomic.Load(&amp;pp.deletedTimers)) &gt; <span class="built_in">len</span>(pp.timers)/<span class="number">4</span> &#123;</span><br><span class="line">        clearDeletedTimers(pp)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    unlock(&amp;pp.timersLock)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rnow, pollUntil, ran</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述 <code>checkTimers</code> 中，通过 <code>adjusttimers</code> 调整当前 p 的 timers 数组，我们看一下它的实现</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// adjusttimers looks through the timers in the current P&#x27;s heap for</span></span><br><span class="line"><span class="comment">// any timers that have been modified to run earlier, and puts them in</span></span><br><span class="line"><span class="comment">// the correct place in the heap. While looking for those timers,</span></span><br><span class="line"><span class="comment">// it also moves timers that have been modified to run later,</span></span><br><span class="line"><span class="comment">// and removes deleted timers. The caller must have locked the timers for pp.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">adjusttimers</span><span class="params">(pp *p)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 判断当前 p 是否有 timer</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(pp.timers) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> atomic.Load(&amp;pp.adjustTimers) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> verifyTimers &#123;</span><br><span class="line">            verifyTimerHeap(pp)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 存放需要移动的 timer</span></span><br><span class="line">    <span class="keyword">var</span> moved []*timer</span><br><span class="line">loop:</span><br><span class="line">    <span class="comment">// 遍历当前 p 的 timers</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(pp.timers); i++ &#123;</span><br><span class="line">        t := pp.timers[i]</span><br><span class="line">        <span class="keyword">if</span> t.pp.ptr() != pp &#123;</span><br><span class="line">            throw(<span class="string">&quot;adjusttimers: bad p&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断当前 timer 的状态</span></span><br><span class="line">        <span class="keyword">switch</span> s := atomic.Load(&amp;t.status); s &#123;</span><br><span class="line">        <span class="comment">// 表示 timer 需要删除，但是还没有删除呢</span></span><br><span class="line">        <span class="keyword">case</span> timerDeleted:</span><br><span class="line">            <span class="comment">// 修改 timer 的状态为，正在删除中 timerRemoving</span></span><br><span class="line">            <span class="keyword">if</span> atomic.Cas(&amp;t.status, s, timerRemoving) &#123;</span><br><span class="line">                <span class="comment">// 执行删除操作</span></span><br><span class="line">                dodeltimer(pp, i)</span><br><span class="line">                <span class="comment">// 修改 timer 的状态为，已删除 timerRemoved</span></span><br><span class="line">                <span class="keyword">if</span> !atomic.Cas(&amp;t.status, timerRemoving, timerRemoved) &#123;</span><br><span class="line">                    badTimer()</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 修改待删除 timer 的数量 pp.deletedTimers - 1</span></span><br><span class="line">                atomic.Xadd(&amp;pp.deletedTimers, <span class="number">-1</span>)</span><br><span class="line">                <span class="comment">// Look at this heap position again.</span></span><br><span class="line">                <span class="comment">// 思考一下就可以知道，为什么需要再次检查当前这个位置的 timer</span></span><br><span class="line">                <span class="comment">// 通过 dodeltimer 将索引为 i 的 timer 删除后，我们知道的是</span></span><br><span class="line">                <span class="comment">// 假设总数量为 n, [0, i) 之前的元素不需要改变，删掉第 I 个后</span></span><br><span class="line">                <span class="comment">// 需要在 [i,n-1) 里边中选一个填补 i 的位置，所以需要重新检查一次</span></span><br><span class="line">                i--</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">// 表示 timer 的等待时间被调整了</span></span><br><span class="line">        <span class="comment">// timerModifiedEarlier 向前调整</span></span><br><span class="line">        <span class="comment">// timerModifiedLater 向后调整</span></span><br><span class="line">        <span class="keyword">case</span> timerModifiedEarlier, timerModifiedLater:</span><br><span class="line">            <span class="comment">// 因为调整了 timer 的时间点，所以需要重新调整该 timer 在堆中的位置</span></span><br><span class="line">            <span class="comment">// 修改 timer 状态为，移动中 timerMoving</span></span><br><span class="line">            <span class="keyword">if</span> atomic.Cas(&amp;t.status, s, timerMoving) &#123;</span><br><span class="line">                <span class="comment">// Now we can change the when field.</span></span><br><span class="line">                t.when = t.nextwhen</span><br><span class="line">                <span class="comment">// Take t off the heap, and hold onto it.</span></span><br><span class="line">                <span class="comment">// We don&#x27;t add it back yet because the</span></span><br><span class="line">                <span class="comment">// heap manipulation could cause our</span></span><br><span class="line">                <span class="comment">// loop to skip some other timer.</span></span><br><span class="line">                dodeltimer(pp, i)</span><br><span class="line">                <span class="comment">// 将这个 timer 加入到需要移动的 timer 当中</span></span><br><span class="line">                moved = <span class="built_in">append</span>(moved, t)</span><br><span class="line">                <span class="keyword">if</span> s == timerModifiedEarlier &#123;</span><br><span class="line">                    <span class="keyword">if</span> n := atomic.Xadd(&amp;pp.adjustTimers, <span class="number">-1</span>); <span class="keyword">int32</span>(n) &lt;= <span class="number">0</span> &#123;</span><br><span class="line">                        <span class="keyword">break</span> loop</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// Look at this heap position again.</span></span><br><span class="line">                i--</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">case</span> timerNoStatus, timerRunning, timerRemoving, timerRemoved, timerMoving:</span><br><span class="line">            badTimer()</span><br><span class="line">        <span class="keyword">case</span> timerWaiting:</span><br><span class="line">            <span class="comment">// OK, nothing to do.</span></span><br><span class="line">        <span class="keyword">case</span> timerModifying:</span><br><span class="line">            <span class="comment">// Check again after modification is complete.</span></span><br><span class="line">            osyield()</span><br><span class="line">            i--</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            badTimer()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(moved) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 将 timer 重新加入到当前 p 的 timers 中</span></span><br><span class="line">        <span class="comment">// 并且按照小顶堆进行排序</span></span><br><span class="line">        addAdjustedTimers(pp, moved)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> verifyTimers &#123;</span><br><span class="line">        verifyTimerHeap(pp)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们再看一下 <code>checkTimers</code> 函数末尾的位置，就是要真正执行 timer 的时候了，通过 <code>runtimer</code> 来执行 p 中的 timer</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// runtimer examines the first timer in timers. If it is ready based on now,</span></span><br><span class="line"><span class="comment">// it runs the timer and removes or updates it.</span></span><br><span class="line"><span class="comment">// Returns 0 if it ran a timer, -1 if there are no more timers, or the time</span></span><br><span class="line"><span class="comment">// when the first timer should run.</span></span><br><span class="line"><span class="comment">// The caller must have locked the timers for pp.</span></span><br><span class="line"><span class="comment">// If a timer is run, this will temporarily unlock the timers.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	根据上述注释可以了解到:</span></span><br><span class="line"><span class="comment">	返回值 = 0;  表示执行了一个 timer</span></span><br><span class="line"><span class="comment">	返回值 = -1; 表示 p 中没有 timer 了</span></span><br><span class="line"><span class="comment">	返回值 &gt; 0;  表示第一个 timer 要执行的时间点</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	（这里的源码就不做过多分析了，没有什么可说的，基本上都覆盖到了）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//go:systemstack</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runtimer</span><span class="params">(pp *p, now <span class="keyword">int64</span>)</span> <span class="title">int64</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        t := pp.timers[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> t.pp.ptr() != pp &#123;</span><br><span class="line">            throw(<span class="string">&quot;runtimer: bad p&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">switch</span> s := atomic.Load(&amp;t.status); s &#123;</span><br><span class="line">        <span class="keyword">case</span> timerWaiting:</span><br><span class="line">            <span class="keyword">if</span> t.when &gt; now &#123;</span><br><span class="line">                <span class="comment">// Not ready to run.</span></span><br><span class="line">                <span class="keyword">return</span> t.when</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> !atomic.Cas(&amp;t.status, s, timerRunning) &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Note that runOneTimer may temporarily unlock</span></span><br><span class="line">            <span class="comment">// pp.timersLock.</span></span><br><span class="line">            runOneTimer(pp, t, now)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> timerDeleted:</span><br><span class="line">            <span class="keyword">if</span> !atomic.Cas(&amp;t.status, s, timerRemoving) &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            dodeltimer0(pp)</span><br><span class="line">            <span class="keyword">if</span> !atomic.Cas(&amp;t.status, timerRemoving, timerRemoved) &#123;</span><br><span class="line">                badTimer()</span><br><span class="line">            &#125;</span><br><span class="line">            atomic.Xadd(&amp;pp.deletedTimers, <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(pp.timers) == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> timerModifiedEarlier, timerModifiedLater:</span><br><span class="line">            <span class="keyword">if</span> !atomic.Cas(&amp;t.status, s, timerMoving) &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            t.when = t.nextwhen</span><br><span class="line">            dodeltimer0(pp)</span><br><span class="line">            doaddtimer(pp, t)</span><br><span class="line">            <span class="keyword">if</span> s == timerModifiedEarlier &#123;</span><br><span class="line">                atomic.Xadd(&amp;pp.adjustTimers, <span class="number">-1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> !atomic.Cas(&amp;t.status, timerMoving, timerWaiting) &#123;</span><br><span class="line">                badTimer()</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> timerModifying:</span><br><span class="line">            <span class="comment">// Wait for modification to complete.</span></span><br><span class="line">            osyield()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> timerNoStatus, timerRemoved:</span><br><span class="line">            <span class="comment">// Should not see a new or inactive timer on the heap.</span></span><br><span class="line">            badTimer()</span><br><span class="line">        <span class="keyword">case</span> timerRunning, timerRemoving, timerMoving:</span><br><span class="line">            <span class="comment">// These should only be set when timers are locked,</span></span><br><span class="line">            <span class="comment">// and we didn&#x27;t do it.</span></span><br><span class="line">            badTimer()</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            badTimer()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>截止到目前为止，我们已经把 <code>checkTimers</code> 给分析完了。</p>
<h3 id="偷-timer"><a href="#偷-timer" class="headerlink" title="偷 timer"></a>偷 timer</h3><p>这里的偷 timer 不是说把 另一个 p 的 timer 偷到我本地后再执行，而是在当前这个 p ，执行其他 p timer。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 截取部分 findrunnable 代码</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">4</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> enum := stealOrder.start(fastrand()); !enum.done(); enum.next() &#123;</span><br><span class="line">            (...)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">2</span> &amp;&amp; shouldStealTimers(p2) &#123;</span><br><span class="line">                tnow, w, ran := checkTimers(p2, now)</span><br><span class="line">                (...)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="后语"><a href="#后语" class="headerlink" title="后语"></a>后语</h2><p>给大家分享一下我在整理过程中的参考资料吧：<br><em>1.luozhiyun Go中定时器实现原理及源码解析</em><br>   <a target="_blank" rel="noopener" href="https://www.cnblogs.com/luozhiyun/p/14494540.html"><em>https://www.cnblogs.com/luozhiyun/p/14494540.html</em></a><br><em>2.猪吃鱼 Netpoll 解析</em><br>   <a target="_blank" rel="noopener" href="https://www.pefish.club/2020/05/04/Golang/1011Netpoll%E8%A7%A3%E6%9E%90/"><em>https://www.pefish.club/2020/05/04/Golang/1011Netpoll%E8%A7%A3%E6%9E%90/</em></a><br><em>3.issues<br>   <a target="_blank" rel="noopener" href="https://github.com/golang/go/issues/6239"><em>https://github.com/golang/go/issues/6239</em></a><br>4.峰云就她了  go1.14基于netpoll定时器实现原理</em><br>   <a target="_blank" rel="noopener" href="http://xiaorui.cc/archives/6483"><em>http://xiaorui.cc/archives/6483</em></a></p>
</div><div id="donate"><link rel="stylesheet" type="text/css" href="/css/donate.css?v=1.0.0"><script type="text/javascript" src="/js/donate.js?v=1.0.0" successtext="复制成功!"></script><a class="pos-f tr3" id="github" href="https://github.com/clamyang" target="_blank" title="Github"></a><div id="DonateText">Donate</div><ul class="list pos-f" id="donateBox"><li id="AliPay" qr="/img/AliPayQR.jpg"></li><li id="WeChat" qr="/img/WeChatQR.jpg"></li></ul><div class="pos-f left-100" id="QRBox"><div id="MainBox"></div></div></div><div class="post-copyright"><script type="text/javascript" src="/js/copyright.js?v=1.0.0" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copyright.css?v=1.0.0"><p><span>本文标题：</span>timer 优化</p><p><span>文章作者：</span>bqyang</p><p><span>发布时间：</span>2021-12-06</p><p><span>最后更新：</span>2022-07-11</p><p><span>原始链接：</span><a href="/2021/language/golang/timer 优化/">https://bqyang.top/2021/language/golang/timer%20%E4%BC%98%E5%8C%96/</a><span class="copy-path"><i class="fa fa-clipboard" data-clipboard-text="https://bqyang.top/2021/language/golang/timer%20%E4%BC%98%E5%8C%96/"></i></span></p><p><span>版权声明：</span>The author owns the copyright, please indicate the source reproduced.</p></div><br><div class="tags"></div><div class="post-nav"><a class="pre" href="/2021/os/elf/">elf 文件格式</a><a class="next" href="/2021/language/golang/timer%20%E6%B5%85%E6%9E%90/">timer 源码分析</a></div><script src="https://utteranc.es/client.js" repo="clamyang/blogs" issue-term="title" theme="github-light" crossorigin="anonymous" async> </script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://bqyang.top"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2022/leetcode/backtracking/backtracking/">回溯算法学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/summary/about-221025/">刷题还是挺有意思的</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/socket/">使用 C 搭建 Server</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/epoll/">epoll 文档翻译</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/k8s/k8s/">搭建 Kubernetes 集群</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/language/golang/large-alloc/">Go 大对象分配探索</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/language/golang/memory-alloc/">Go 内存分配器</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/os/memory/free-space-manage/">free space management</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/k8s/k8s-storage-source-code/">k8s pv pvc 源码</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/design-pattern/Structural/composite/">组合模式</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.xargin.com/" title="Xargin" target="_blank">Xargin</a><ul></ul><a href="https://mytechshares.com/" title="董泽润的技术笔记" target="_blank">董泽润的技术笔记</a><ul></ul><a href="https://hujingnb.com/" title="烟草的香味" target="_blank">烟草的香味</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2022 <a href="/." rel="nofollow">杨宝强的技术笔记.</a>Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://beian.miit.gov.cn/"> 京ICP备2021035561号.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>