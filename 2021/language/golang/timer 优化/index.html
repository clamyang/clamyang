<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="ä¸€ç‰©ä¸çŸ¥æ·±ä»¥ä¸ºè€»"><title>timer ä¼˜åŒ– | æ¨å®å¼ºçš„æŠ€æœ¯ç¬”è®°</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><div class="darkmode-toggle">ğŸŒ“</div><script>var prefersDarkMode = window.matchMedia('(prefers-color-scheme: dark)');
var toggle = document.querySelector('.darkmode-toggle');
var html = document.querySelector('html');

html.dataset.dark = localStorage.dark || prefersDarkMode.matches;

toggle.addEventListener('click', () => {
localStorage.dark = !(html.dataset.dark == 'true');
html.dataset.dark = localStorage.dark;
});</script><meta name="generator" content="Hexo 5.4.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">timer ä¼˜åŒ–</h1><a id="logo" href="/.">æ¨å®å¼ºçš„æŠ€æœ¯ç¬”è®°</a><p class="description">Gopher Watcher</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> é¦–é¡µ</i></a><a href="/archives/"><i class="fa fa-archive"> å½’æ¡£</i></a><a href="/about/"><i class="fa fa-user"> å…³äº</i></a><a href="/atom.xml"><i class="fa fa-rss"> è®¢é˜…</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">timer ä¼˜åŒ–</h1><div class="post-meta">2021-12-06</div><div class="post-content"><p>æˆ‘ä»¬å·²ç»çŸ¥é“äº†ï¼Œè€ç‰ˆæœ¬ timer çš„æ€§èƒ½ç“¶é¢ˆä¸»è¦æ˜¯åœ¨é‚£æŠŠå…¨å±€é”ä»¥åŠé¢‘ç¹çš„ä¸Šä¸‹æ–‡åˆ‡æ¢ä¸Šï¼Œä»Šå¤©æˆ‘ä»¬çœ‹çœ‹ go å¤§ä½¬ä»¬é€šè¿‡å“ªç§æ–¹å¼è¿›è¡Œä¼˜åŒ–çš„ã€‚<br>â€‹</p>
<p>åœ¨è¿™é‡Œè§£é‡Šä¸€ä¸‹ä¸ºä»€ä¹ˆé€‰æ‹©è¿™å‡ ä¸ªç‰ˆæœ¬ï¼Œæ®æˆ‘æ‰€çŸ¥å•Šï¼Œä» 1.10 ç‰ˆæœ¬ä»¥å‰éƒ½æ˜¯åƒä¸Šä¸€ç¯‡æ–‡ä¸­æ‰€æè¿°çš„é‚£æ ·ï¼Œåœ¨ 1.10 ç‰ˆæœ¬å¼€å§‹å°±åšäº†è¿™ä¸ªä¼˜åŒ–ï¼Œä½†ä» 1.14 å¼€å§‹åˆå¯¹ timer è¿›è¡Œäº†ä¼˜åŒ–ï¼Œæ‰€ä»¥æˆ‘é€‰æ‹©äº† 1.8ï¼Œ 1.13ï¼Œ 1.14 è¿™å‡ ä¸ªé‚»è¿‘çš„ä½œä¸ºå‚è€ƒã€‚</p>
<span id="more"></span>

<h2 id="go-1-13-ä¸­çš„ä¼˜åŒ–"><a href="#go-1-13-ä¸­çš„ä¼˜åŒ–" class="headerlink" title="go 1.13 ä¸­çš„ä¼˜åŒ–"></a>go 1.13 ä¸­çš„ä¼˜åŒ–</h2><h3 id="ç¯å¢ƒä¿¡æ¯"><a href="#ç¯å¢ƒä¿¡æ¯" class="headerlink" title="ç¯å¢ƒä¿¡æ¯"></a>ç¯å¢ƒä¿¡æ¯</h3><ul>
<li>go version: go1.13</li>
<li>compute: linux, centos7</li>
</ul>
<h3 id="timer-ç»“æ„çš„å˜åŒ–"><a href="#timer-ç»“æ„çš„å˜åŒ–" class="headerlink" title="timer ç»“æ„çš„å˜åŒ–"></a>timer ç»“æ„çš„å˜åŒ–</h3><h5 id="go1-8"><a href="#go1-8" class="headerlink" title="go1.8"></a>go1.8</h5><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> timer <span class="keyword">struct</span> &#123;</span><br><span class="line">    i <span class="keyword">int</span> <span class="comment">// heap index</span></span><br><span class="line">    when   <span class="keyword">int64</span></span><br><span class="line">    period <span class="keyword">int64</span></span><br><span class="line">    f      <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">interface</span>&#123;&#125;, <span class="keyword">uintptr</span>)</span></span></span><br><span class="line">    arg    <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    seq    <span class="keyword">uintptr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="go1-13"><a href="#go1-13" class="headerlink" title="go1.13"></a>go1.13</h5><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> timer <span class="keyword">struct</span> &#123;</span><br><span class="line">    tb *timersBucket <span class="comment">// the bucket the timer lives in</span></span><br><span class="line">    i  <span class="keyword">int</span>           <span class="comment">// heap index</span></span><br><span class="line">    when   <span class="keyword">int64</span></span><br><span class="line">    period <span class="keyword">int64</span></span><br><span class="line">    f      <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">interface</span>&#123;&#125;, <span class="keyword">uintptr</span>)</span></span></span><br><span class="line">    arg    <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    seq    <span class="keyword">uintptr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>åœ¨go1.13ç‰ˆæœ¬ä¸­æ·»åŠ äº†ä¸€ä¸ª tb å­—æ®µï¼Œè¡¨ç¤ºå½“å‰è¿™ä¸ª timer æ˜¯åœ¨å“ªä¸ª bucket ä¸­çš„ï¼Œå…¶ä½™å­—æ®µå«ä¹‰è¿˜æ˜¯å’Œè€ç‰ˆæœ¬ä¸­çš„ä¸€è‡´ã€‚<br>â€‹</p>
<p>è¿˜è®°å¾—è€ç‰ˆæœ¬æŠŠæ–°å»ºçš„ <code>timer</code> å¯¹è±¡éƒ½æ”¾åœ¨å“ªé‡Œäº†å—ï¼Ÿ<code>ä¸€ä¸ªå…¨å±€çš„ timers ä¸­</code> go1.13ç‰ˆæœ¬ä¸­å°†çš„ timers æ‹†åˆ†æˆäº† 64 ä¸ªå¤§å°çš„ timers æ•°ç»„ï¼Œæ¯ä¸€ä¸ªé‡Œè¾¹åŒ…å«äº†ä¸€ä¸ª bucket ï¼Œbucket ä¸­å†å­˜æ”¾ timer å¯¹è±¡ï¼Œè‡³äºä¸ºä»€ä¹ˆæ˜¯ 64 å®˜æ–¹çš„è§£é‡Šå¦‚ä¸‹ï¼š</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// timersLen is the length of timers array.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Ideally, this would be set to GOMAXPROCS, but that would require</span></span><br><span class="line"><span class="comment">// dynamic reallocation</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The current value is a compromise between memory usage and performance</span></span><br><span class="line"><span class="comment">// that should cover the majority of GOMAXPROCS values used in the wild.</span></span><br><span class="line"><span class="keyword">const</span> timersLen = <span class="number">64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// timersLen is the length of timers array.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Ideally, this would be set to GOMAXPROCS, but that would require</span></span><br><span class="line"><span class="comment">// dynamic reallocation</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The current value is a compromise between memory usage and performance</span></span><br><span class="line"><span class="comment">// that should cover the majority of GOMAXPROCS values used in the wild.</span></span><br><span class="line"><span class="keyword">var</span> timers [timersLen]<span class="keyword">struct</span> &#123;</span><br><span class="line">    timersBucket</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The padding should eliminate false sharing</span></span><br><span class="line">    <span class="comment">// between timersBucket values.</span></span><br><span class="line">    pad [cpu.CacheLinePadSize - unsafe.Sizeof(timersBucket&#123;&#125;)%cpu.CacheLinePadSize]<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:notinheap</span></span><br><span class="line"><span class="keyword">type</span> timersBucket <span class="keyword">struct</span> &#123;</span><br><span class="line">    lock         mutex</span><br><span class="line">    gp           *g</span><br><span class="line">    created      <span class="keyword">bool</span></span><br><span class="line">    sleeping     <span class="keyword">bool</span></span><br><span class="line">    rescheduling <span class="keyword">bool</span></span><br><span class="line">    sleepUntil   <span class="keyword">int64</span></span><br><span class="line">    waitnote     note</span><br><span class="line">    t            []*timer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>åœ¨æ·»åŠ  timer å¯¹è±¡æ—¶é€»è¾‘å˜æˆäº†ï¼Œæ ¹æ®å½“å‰ p çš„ id å¯¹ timersLen å–æ¨¡ï¼Œå¾—åˆ°äº† p å¯¹åº”çš„ timersBucket <code>id := uint8(getg().m.p.ptr().id) % _timersLen_</code><br>ä»è¿™ä¸ªä¼˜åŒ–çš„æ–¹æ³•æ¥çœ‹ï¼Œä»¥å‰æ˜¯æ¯ä¸ªpå»æŠ¢åŒä¸€æŠŠé”ï¼Œç°åœ¨å˜æˆï¼Œæ¯ä¸ªpåªä¼šæ“ä½œå¯¹åº”çš„ timersBucketï¼ˆå¤§å¤šæ•°æƒ…å†µä¸‹ï¼‰ã€‚</p>
<ul>
<li><input disabled="" type="checkbox"> <strong>åœ¨è¶…è¿‡ 64 ä¸ª p çš„æ—¶å€™ï¼Œå°±ä¼šå‡ºç°å–æ¨¡åˆ°åŒä¸€ä¸ª bucket ä¸­ï¼Œè¿™ç§æƒ…å†µåœ¨å¤šæ ¸ cpu &gt; 64 ä¸Šæ˜¯æ²¡åŠæ³•é¿å…çš„</strong></li>
<li><input disabled="" type="checkbox"> <strong>å¯èƒ½è¿˜æœ‰ p ä»åˆ«çš„ p ä¸Šå· timer çš„æƒ…å†µ</strong></li>
</ul>
<p>æ¥ä¸‹é‡Œæˆ‘ä»¬çœ‹ä¸‹æ‰§è¡Œ timer çš„ <code>timerproc</code><br>1.8 ç‰ˆæœ¬ä¸­ï¼Œå…¨å±€åªæœ‰ä¸€ä¸ªæ‰§è¡Œ timer çš„ timerprocï¼Œå¯ä»¥ç†è§£ä¸ºåªæœ‰ä¸€ä¸ªæ¶ˆè´¹è€…ã€‚1.13 ä¸­ä¿®æ”¹ä¸ºæ¯ä¸ªä¸åŒçš„ bucket éƒ½ä¼šæœ‰ä¸€ä¸ªå¯¹åº”çš„ bucketã€‚ä¸¾ä¸ªä¾‹å­ï¼Œæ¯”å¦‚æˆ‘ä»¬æœ‰ 4 ä¸ª Pï¼Œå°±è¯´æ˜æˆ‘ä»¬ä¼šæœ‰ 4 ä¸ª bucket å’Œ 4 ä¸ª timerprocï¼Œæ¯å½“é€šè¿‡ addtimer æ·»åŠ æ—¶ï¼Œéƒ½ä¼šå¾€ p å¯¹åº”çš„ bucket ä¸­æ·»åŠ ä»»åŠ¡ï¼Œtimerproc ä½œä¸ºæ¶ˆè´¹è€…ä»ä¸­æ‰¾å¯æ‰§è¡Œçš„timerï¼Œå¦‚ä¸‹å›¾ï¼š<br><img src="https://gitee.com/yangbaoqiang/images/raw/master/blogpics/1636033788855-ece14ebf-e72d-4851-9a75-de7cd60d59ba.png" alt="image.png"></p>
<h3 id="timer-çš„â€œç”Ÿäº§è€…â€"><a href="#timer-çš„â€œç”Ÿäº§è€…â€" class="headerlink" title="timer çš„â€œç”Ÿäº§è€…â€"></a>timer çš„â€œç”Ÿäº§è€…â€</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// å¦‚å‰æ‰€è¿°ï¼Œæ¯ä¸ªpå¯¹åº”ä¸åŒçš„ timersBucketï¼Œé‚£ä¹ˆåœ¨åˆ›å»ºä¹‹å‰æˆ‘ä»¬æ˜¯ä¸æ˜¯åº”è¯¥å…ˆæ‰¾åˆ°åœ¨å“ªä¸ª p ä¸Šæ‰§è¡Œ</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *timer)</span> <span class="title">assignBucket</span><span class="params">()</span> *<span class="title">timersBucket</span></span> &#123;</span><br><span class="line">    id := <span class="keyword">uint8</span>(getg().m.p.ptr().id) % timersLen</span><br><span class="line">    t.tb = &amp;timers[id].timersBucket</span><br><span class="line">    <span class="keyword">return</span> t.tb</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// å°† timer æ·»åŠ åˆ°å¯¹åº”çš„ timersBucket ä¸­</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addtimer</span><span class="params">(t *timer)</span></span> &#123;</span><br><span class="line">    tb := t.assignBucket()</span><br><span class="line">    lock(&amp;tb.lock)</span><br><span class="line">    ok := tb.addtimerLocked(t)</span><br><span class="line">    unlock(&amp;tb.lock)</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        badTimer()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// å’±ä»¬åªæŠŠé‡ç‚¹æ”¾åœ¨ä¸ä»¥å‰ä¸åŒçš„åœ°æ–¹ä¸Š</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tb *timersBucket)</span> <span class="title">addtimerLocked</span><span class="params">(t *timer)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> t.when &lt; <span class="number">0</span> &#123;</span><br><span class="line">        t.when = <span class="number">1</span>&lt;&lt;<span class="number">63</span> - <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    t.i = <span class="built_in">len</span>(tb.t)</span><br><span class="line">    tb.t = <span class="built_in">append</span>(tb.t, t) 		<span class="comment">// æ·»åŠ åˆ°på¯¹åº”çš„timersBucketä¸­ï¼Œè€Œä¸æ˜¯å…¨å±€çš„ timers ä¸­äº†</span></span><br><span class="line">    <span class="keyword">if</span> !siftupTimer(tb.t, t.i) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> t.i == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// siftup moved to top: new earliest deadline.</span></span><br><span class="line">        <span class="keyword">if</span> tb.sleeping &amp;&amp; tb.sleepUntil &gt; t.when &#123;</span><br><span class="line">            tb.sleeping = <span class="literal">false</span></span><br><span class="line">            notewakeup(&amp;tb.waitnote)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> tb.rescheduling &#123;</span><br><span class="line">            tb.rescheduling = <span class="literal">false</span></span><br><span class="line">            goready(tb.gp, <span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> !tb.created &#123;</span><br><span class="line">            <span class="comment">// åˆ¤æ–­å±äºè¿™ä¸ª tb çš„ timerproc æ˜¯å¦å¯åŠ¨äº†ï¼Œ</span></span><br><span class="line">            <span class="comment">// åŒºåˆ«äº1.8ç‰ˆæœ¬æ˜¯ä¸€ä¸ªå…¨å±€å˜é‡æ§åˆ¶çš„ï¼Œåªæœ‰ä¸€ä¸ªæ¶ˆè´¹è€…ï¼Œè¿™é‡Œæ˜¯æ¯ä¸€ä¸ª tb éƒ½æœ‰ä¸€ä¸ªæ¶ˆè´¹è€…</span></span><br><span class="line">            tb.created = <span class="literal">true</span></span><br><span class="line">            <span class="keyword">go</span> timerproc(tb)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="timer-çš„â€œæ¶ˆè´¹è€…â€"><a href="#timer-çš„â€œæ¶ˆè´¹è€…â€" class="headerlink" title="timer çš„â€œæ¶ˆè´¹è€…â€"></a>timer çš„â€œæ¶ˆè´¹è€…â€</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ä¸»è¦çš„é€»è¾‘è¿˜æ˜¯åŒ 1.8 ç‰ˆæœ¬ä¸­ä¸€è‡´çš„ï¼Œä¸åŒçš„åœ°æ–¹å°±æ˜¯é’ˆå¯¹æ¯ä¸ªtbè¿›è¡Œçš„æ“ä½œï¼Œä¸æ˜¯å…¨å±€çš„ timers</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">timerproc</span><span class="params">(tb *timersBucket)</span></span> &#123;</span><br><span class="line">    tb.gp = getg()</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        lock(&amp;tb.lock)</span><br><span class="line">        tb.sleeping = <span class="literal">false</span></span><br><span class="line">        now := nanotime()</span><br><span class="line">        delta := <span class="keyword">int64</span>(<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(tb.t) == <span class="number">0</span> &#123;</span><br><span class="line">                delta = <span class="number">-1</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            t := tb.t[<span class="number">0</span>]</span><br><span class="line">            delta = t.when - now</span><br><span class="line">            <span class="keyword">if</span> delta &gt; <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            ok := <span class="literal">true</span></span><br><span class="line">            <span class="keyword">if</span> t.period &gt; <span class="number">0</span> &#123;</span><br><span class="line">                <span class="comment">// leave in heap but adjust next time to fire</span></span><br><span class="line">                t.when += t.period * (<span class="number">1</span> + -delta/t.period)</span><br><span class="line">                <span class="keyword">if</span> !siftdownTimer(tb.t, <span class="number">0</span>) &#123;</span><br><span class="line">                    ok = <span class="literal">false</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// remove from heap</span></span><br><span class="line">                last := <span class="built_in">len</span>(tb.t) - <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> last &gt; <span class="number">0</span> &#123;</span><br><span class="line">                    tb.t[<span class="number">0</span>] = tb.t[last]</span><br><span class="line">                    tb.t[<span class="number">0</span>].i = <span class="number">0</span></span><br><span class="line">                &#125;</span><br><span class="line">                tb.t[last] = <span class="literal">nil</span></span><br><span class="line">                tb.t = tb.t[:last]</span><br><span class="line">                <span class="keyword">if</span> last &gt; <span class="number">0</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> !siftdownTimer(tb.t, <span class="number">0</span>) &#123;</span><br><span class="line">                        ok = <span class="literal">false</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                t.i = <span class="number">-1</span> <span class="comment">// mark as removed</span></span><br><span class="line">            &#125;</span><br><span class="line">            f := t.f</span><br><span class="line">            arg := t.arg</span><br><span class="line">            seq := t.seq</span><br><span class="line">            unlock(&amp;tb.lock)</span><br><span class="line">            <span class="keyword">if</span> !ok &#123;</span><br><span class="line">                badTimer()</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">                raceacquire(unsafe.Pointer(t))</span><br><span class="line">            &#125;</span><br><span class="line">            f(arg, seq)</span><br><span class="line">            lock(&amp;tb.lock)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> delta &lt; <span class="number">0</span> || faketime &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// No timers left - put goroutine to sleep.</span></span><br><span class="line">            tb.rescheduling = <span class="literal">true</span></span><br><span class="line">            goparkunlock(&amp;tb.lock, waitReasonTimerGoroutineIdle, traceEvGoBlock, <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// At least one timer pending. Sleep until then.</span></span><br><span class="line">        tb.sleeping = <span class="literal">true</span></span><br><span class="line">        tb.sleepUntil = now + delta</span><br><span class="line">        noteclear(&amp;tb.waitnote)</span><br><span class="line">        unlock(&amp;tb.lock)</span><br><span class="line">        notetsleepg(&amp;tb.waitnote, delta)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ç›¸æ¯”äº 1.8ï¼Œ1.13ç‰ˆæœ¬ä¸­è¿˜æ·»åŠ äº†ä¸€ä¸ª <code>modtimer(t *timer, when, period int64, f func(interface&#123;&#125;, uintptr), arg interface&#123;&#125;, seq uintptr)</code><br>modtimer å‡½æ•°ä¸»è¦åšäº†ï¼Œå°† t ä» tb ä¸­åˆ é™¤ï¼Œç„¶åæœ‰ é‡æ–°ç»™å®ƒ åŠ å…¥è¿›å»</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modtimer</span><span class="params">(t *timer, when, period <span class="keyword">int64</span>, f <span class="keyword">func</span>(<span class="keyword">interface</span>&#123;&#125;, <span class="keyword">uintptr</span>)</span>, <span class="title">arg</span> <span class="title">interface</span></span>&#123;&#125;, seq <span class="keyword">uintptr</span>) &#123;</span><br><span class="line">    tb := t.tb</span><br><span class="line"></span><br><span class="line">    lock(&amp;tb.lock)</span><br><span class="line">    _, ok := tb.deltimerLocked(t)</span><br><span class="line">    <span class="keyword">if</span> ok &#123;</span><br><span class="line">        t.when = when</span><br><span class="line">        t.period = period</span><br><span class="line">        t.f = f</span><br><span class="line">        t.arg = arg</span><br><span class="line">        t.seq = seq</span><br><span class="line">        ok = tb.addtimerLocked(t)</span><br><span class="line">    &#125;</span><br><span class="line">    unlock(&amp;tb.lock)</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        badTimer()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>åœ¨ netpoll ä¸­ï¼Œæœ‰ä¸¤å¤„åœ°æ–¹è°ƒç”¨äº†è¿™ä¸ªå‡½æ•°ï¼Œä¸»è¦å°±æ˜¯ç»™ fd è°ƒæ•´è¶…æ—¶å¤„ç†ä½¿ç”¨çš„ã€‚</p>
<p>æ€»çš„æ¥è¯´è¿™ä¸ªç‰ˆæœ¬ä¸­çš„ä¼˜åŒ–åªæ˜¯åšäº†å…¨å±€é”ç²’åº¦çš„æ‹†åˆ†ï¼Œä¸Šä¸‹æ–‡åˆ‡æ¢å¸¦æ¥é¢å¤–çš„æ€§èƒ½å¼€é”€ä»ç„¶æ²¡æœ‰å¾—åˆ°ä¼˜åŒ–ï¼Œä¸è¿‡ä¸è¦ç€æ€¥ï¼Œ1.14 ç‰ˆæœ¬ä¸­é’ˆå¯¹è¿™ä¸ªé—®é¢˜å·²ç»åšäº†å¦¥å–„çš„å¤„ç†ï¼Œæˆ‘ä»¬é©¬ä¸Šå°±æ¥çœ‹ä¸€ä¸‹ã€‚<br>â€‹</p>
<h2 id="go-1-14-ä¸­çš„ä¼˜åŒ–"><a href="#go-1-14-ä¸­çš„ä¼˜åŒ–" class="headerlink" title="go 1.14 ä¸­çš„ä¼˜åŒ–"></a>go 1.14 ä¸­çš„ä¼˜åŒ–</h2><h3 id="ç¯å¢ƒä¿¡æ¯-1"><a href="#ç¯å¢ƒä¿¡æ¯-1" class="headerlink" title="ç¯å¢ƒä¿¡æ¯"></a>ç¯å¢ƒä¿¡æ¯</h3><p>go version: go1.14.1<br>compute: linux, centos7</p>
<h3 id="timer-ç»“æ„çš„å˜åŒ–-1"><a href="#timer-ç»“æ„çš„å˜åŒ–-1" class="headerlink" title="timer ç»“æ„çš„å˜åŒ–"></a>timer ç»“æ„çš„å˜åŒ–</h3><p>ä»¥å‰çš„ç»“æ„ä½“éƒ½æ˜¯å…¨å±€å˜é‡ï¼Œåœ¨ 1.14 ç‰ˆæœ¬å¼€å§‹ï¼Œtimer ç»“æ„ä½“å°±å†…åµŒåˆ°äº† P ä¸­ã€‚</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Package time knows the layout of this structure.</span></span><br><span class="line"><span class="comment">// If this struct changes, adjust ../time/sleep.go:/runtimeTimer.</span></span><br><span class="line"><span class="keyword">type</span> timer <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// If this timer is on a heap, which P&#x27;s heap it is on.</span></span><br><span class="line">    <span class="comment">// puintptr rather than *p to match uintptr in the versions</span></span><br><span class="line">    <span class="comment">// of this struct defined in other packages.</span></span><br><span class="line">    pp puintptr</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Timer wakes up at when, and then at when+period, ... (period &gt; 0 only)</span></span><br><span class="line">    <span class="comment">// each time calling f(arg, now) in the timer goroutine, so f must be</span></span><br><span class="line">    <span class="comment">// a well-behaved function and not block.</span></span><br><span class="line">    when   <span class="keyword">int64</span></span><br><span class="line">    period <span class="keyword">int64</span></span><br><span class="line">    f      <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">interface</span>&#123;&#125;, <span class="keyword">uintptr</span>)</span></span></span><br><span class="line">    arg    <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    seq    <span class="keyword">uintptr</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// What to set the when field to in timerModifiedXX status.</span></span><br><span class="line">    nextwhen <span class="keyword">int64</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// The status field holds one of the values below.</span></span><br><span class="line">    status <span class="keyword">uint32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> p <span class="keyword">struct</span> &#123;</span><br><span class="line">    id          <span class="keyword">int32</span></span><br><span class="line">    </span><br><span class="line">    (...)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Lock for timers. We normally access the timers while running</span></span><br><span class="line">    <span class="comment">// on this P, but the scheduler can also do it from a different P.</span></span><br><span class="line">    <span class="comment">// è®²é“ç†ï¼Œä½ på¤„ç†æœ¬åœ°çš„ timer ç”¨é”å¹²ä»€ä¹ˆï¼Ÿ</span></span><br><span class="line">    <span class="comment">// 1.14 æ˜¯å¯ä»¥å· timer çš„ï¼Œè¿™æ—¶å€™å°±å˜æˆäº†å…±äº«èµ„æºï¼Œè®¿é—®çš„æ—¶å€™æ˜¯ä¸€å®šè¦åŠ é”çš„ã€‚</span></span><br><span class="line">    <span class="comment">// ä¸Šè¾¹æ³¨é‡Šï¼ˆè‹±æ–‡ï¼‰è¯´çš„ä¹Ÿå¾ˆæ¸…æ¥šï¼Œè¿™ä¸ªæ˜¯å®˜æ–¹çš„è§£é‡Š</span></span><br><span class="line">    timersLock mutex</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Actions to take at some time. This is used to implement the</span></span><br><span class="line">    <span class="comment">// standard library&#x27;s time package.</span></span><br><span class="line">    <span class="comment">// Must hold timersLock to access.</span></span><br><span class="line">    timers []*timer</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Number of timers in P&#x27;s heap.</span></span><br><span class="line">    <span class="comment">// Modified using atomic instructions.</span></span><br><span class="line">    <span class="comment">// è®°å½•å½“å‰ p ä¸­ timerçš„æ€»æ•°é‡</span></span><br><span class="line">    numTimers <span class="keyword">uint32</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Number of timerModifiedEarlier timers on P&#x27;s heap.</span></span><br><span class="line">    <span class="comment">// This should only be modified while holding timersLock,</span></span><br><span class="line">    <span class="comment">// or while the timer status is in a transient state</span></span><br><span class="line">    <span class="comment">// such as timerModifying.</span></span><br><span class="line">    <span class="comment">// P ä¸­ è°ƒæ•´ when çš„æ—¶é—´æå‰äº†çš„ timer æ•°é‡</span></span><br><span class="line">    adjustTimers <span class="keyword">uint32</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Number of timerDeleted timers in P&#x27;s heap.</span></span><br><span class="line">    <span class="comment">// Modified using atomic instructions.</span></span><br><span class="line">    <span class="comment">// è®°å½• p ä¸­è¢«åˆ é™¤çš„ timer æ•°é‡</span></span><br><span class="line">    deletedTimers <span class="keyword">uint32</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Race context used while executing timer functions.</span></span><br><span class="line">    timerRaceCtx <span class="keyword">uintptr</span></span><br><span class="line">    </span><br><span class="line">    (...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="timer-çš„â€œç”Ÿäº§è€…â€-1"><a href="#timer-çš„â€œç”Ÿäº§è€…â€-1" class="headerlink" title="timer çš„â€œç”Ÿäº§è€…â€"></a>timer çš„â€œç”Ÿäº§è€…â€</h3><p><code>... åŸºæœ¬ä¸Šå¤§åŒå°å¼‚ï¼Œåªä¸è¿‡æ˜¯åŠ äº†ä¸€äº›çŠ¶æ€</code><br>ä¸è¿‡éœ€è¦æ³¨æ„çš„ä¸€ç‚¹æ˜¯ï¼Œ1.14 ä¸­æœ‰äº† timer å’Œ netpoll çš„ç»“åˆã€‚æˆ‘çš„ç†è§£æ˜¯ï¼š<br>findrunnable æœ€åæ²¡æœ‰æ‰¾åˆ°å¯æ‰§è¡Œçš„ g çš„æ—¶å€™ä¼šå†æ£€æŸ¥ netpollã€‚è¿™ä¸ªè°ƒç”¨è¿‡ç¨‹æ˜¯é˜»å¡çš„ï¼Œé˜»å¡ delta è¿™æ®µæ—¶é—´ï¼Œç„¶åè¿™æ—¶å€™æ¯”å¦‚è¯´æˆ‘é€šè¿‡ addtimer åŠ å…¥æ–°timerï¼Œå°±æ˜¯å‡è®¾å“ˆï¼Œ1s åè¦æ‰§è¡Œï¼Œç„¶åä½ é‚£ä¸ªé˜»å¡è¿‡ç¨‹è¦é˜»å¡ 3sï¼Œä½†è¿™æ˜¯åœ¨é˜»å¡æ²¡æœ‰åŠæ³•æ‰§è¡Œæˆ‘ä»¬çš„ timerï¼Œç„¶åè¿™æ—¶å€™ addtimer ä¸­çš„ wakenetpoller å°±æ´¾ä¸Šç”¨åœºï¼Œé€šè¿‡ <code>netpollbreak</code> ä¸­æ–­é‚£ä¸ªé˜»å¡è°ƒç”¨ï¼Œç„¶åå°±å›åˆ° <code>findrunnable</code> ç»§ç»­æ‰§è¡Œï¼ŒåŠæ—¶å“åº”é‚£ä¸ªè¿‘æœŸçš„ timer å¯¹è±¡ã€‚</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// addtimer:</span></span><br><span class="line"><span class="comment">//   timerNoStatus   -&gt; timerWaiting</span></span><br><span class="line"><span class="comment">//   anything else   -&gt; panic: invalid value</span></span><br><span class="line"><span class="comment">// deltimer:</span></span><br><span class="line"><span class="comment">//   timerWaiting         -&gt; timerModifying -&gt; timerDeleted</span></span><br><span class="line"><span class="comment">//   timerModifiedEarlier -&gt; timerModifying -&gt; timerDeleted</span></span><br><span class="line"><span class="comment">//   timerModifiedLater   -&gt; timerModifying -&gt; timerDeleted</span></span><br><span class="line"><span class="comment">//   timerNoStatus        -&gt; do nothing</span></span><br><span class="line"><span class="comment">//   timerDeleted         -&gt; do nothing</span></span><br><span class="line"><span class="comment">//   timerRemoving        -&gt; do nothing</span></span><br><span class="line"><span class="comment">//   timerRemoved         -&gt; do nothing</span></span><br><span class="line"><span class="comment">//   timerRunning         -&gt; wait until status changes</span></span><br><span class="line"><span class="comment">//   timerMoving          -&gt; wait until status changes</span></span><br><span class="line"><span class="comment">//   timerModifying       -&gt; wait until status changes</span></span><br><span class="line"><span class="comment">// modtimer:</span></span><br><span class="line"><span class="comment">//   timerWaiting    -&gt; timerModifying -&gt; timerModifiedXX</span></span><br><span class="line"><span class="comment">//   timerModifiedXX -&gt; timerModifying -&gt; timerModifiedYY</span></span><br><span class="line"><span class="comment">//   timerNoStatus   -&gt; timerModifying -&gt; timerWaiting</span></span><br><span class="line"><span class="comment">//   timerRemoved    -&gt; timerModifying -&gt; timerWaiting</span></span><br><span class="line"><span class="comment">//   timerDeleted    -&gt; timerModifying -&gt; timerModifiedXX</span></span><br><span class="line"><span class="comment">//   timerRunning    -&gt; wait until status changes</span></span><br><span class="line"><span class="comment">//   timerMoving     -&gt; wait until status changes</span></span><br><span class="line"><span class="comment">//   timerRemoving   -&gt; wait until status changes</span></span><br><span class="line"><span class="comment">//   timerModifying  -&gt; wait until status changes</span></span><br><span class="line"><span class="comment">// cleantimers (looks in P&#x27;s timer heap):</span></span><br><span class="line"><span class="comment">//   timerDeleted    -&gt; timerRemoving -&gt; timerRemoved</span></span><br><span class="line"><span class="comment">//   timerModifiedXX -&gt; timerMoving -&gt; timerWaiting</span></span><br><span class="line"><span class="comment">// adjusttimers (looks in P&#x27;s timer heap):</span></span><br><span class="line"><span class="comment">//   timerDeleted    -&gt; timerRemoving -&gt; timerRemoved</span></span><br><span class="line"><span class="comment">//   timerModifiedXX -&gt; timerMoving -&gt; timerWaiting</span></span><br><span class="line"><span class="comment">// runtimer (looks in P&#x27;s timer heap):</span></span><br><span class="line"><span class="comment">//   timerNoStatus   -&gt; panic: uninitialized timer</span></span><br><span class="line"><span class="comment">//   timerWaiting    -&gt; timerWaiting or</span></span><br><span class="line"><span class="comment">//   timerWaiting    -&gt; timerRunning -&gt; timerNoStatus or</span></span><br><span class="line"><span class="comment">//   timerWaiting    -&gt; timerRunning -&gt; timerWaiting</span></span><br><span class="line"><span class="comment">//   timerModifying  -&gt; wait until status changes</span></span><br><span class="line"><span class="comment">//   timerModifiedXX -&gt; timerMoving -&gt; timerWaiting</span></span><br><span class="line"><span class="comment">//   timerDeleted    -&gt; timerRemoving -&gt; timerRemoved</span></span><br><span class="line"><span class="comment">//   timerRunning    -&gt; panic: concurrent runtimer calls</span></span><br><span class="line"><span class="comment">//   timerRemoved    -&gt; panic: inconsistent timer heap</span></span><br><span class="line"><span class="comment">//   timerRemoving   -&gt; panic: inconsistent timer heap</span></span><br><span class="line"><span class="comment">//   timerMoving     -&gt; panic: inconsistent timer heap</span></span><br></pre></td></tr></table></figure>
<h3 id="timer-çš„â€œæ¶ˆè´¹è€…â€-1"><a href="#timer-çš„â€œæ¶ˆè´¹è€…â€-1" class="headerlink" title="timer çš„â€œæ¶ˆè´¹è€…â€"></a>timer çš„â€œæ¶ˆè´¹è€…â€</h3><p>æ–°ç‰ˆæœ¬ä¸­çš„â€œæ¶ˆè´¹è€…â€æœ‰ç€éå¸¸é‡è¦çš„æ”¹å˜ï¼Œ<code>timerproc</code> æ²¡äº†ï¼Œé¦–å…ˆæˆ‘ä»¬è¦æ˜ç¡®ï¼š<br>timerproc ä¸ä»…ä»…æ˜¯ä¸€ä¸ªå‡½æ•°ï¼Œå®ƒæ˜¯ runtime åˆ›å»ºçš„ä¸€ä¸ª goroutineï¼Œå› æ­¤å¯çŸ¥ï¼Œä»¥å‰çš„â€œæ¶ˆè´¹è€…â€å°±æ˜¯ä¸€ä¸ª goroutineï¼Œ å®ƒå¹¶æ²¡æœ‰ä»€ä¹ˆä¸åŒï¼ŒåŒæ ·è¢« <code>scheduler</code>è°ƒåº¦ã€‚</p>
<p>1.14 ä¸­ï¼Œç›´æ¥ç»™â€œæ¶ˆè´¹è€…â€å‡åˆ°â€œå¤´ç­‰èˆ±â€ï¼Œçœ‹ä½ å°å­å¹²æ´»å‹¤å‹¤æ³æ³ï¼Œschedulerè¯´ï¼Œä½ æ¥æˆ‘è¿™ä¸Šç­å§ï¼Œç»“æœäººå®¶å°±å»äº†ã€‚</p>
<p>1.14 ä¸­ï¼Œtimer çš„æ¶ˆè´¹è€…å°±æ˜¯åœ¨è°ƒåº¦å¾ªç¯çš„ <code>schedule</code> ä¸­ï¼Œå…¶æ¬¡å°±æ˜¯ <code>sysmon</code> ï¼ˆsysmonä½œä¸ºå…œåº•ï¼‰ï¼Œæˆ‘ä»¬çœ‹ä¸‹æºç ï¼Œçœ‹çœ‹æ–°ç‰ˆæœ¬çš„æ¶ˆè´¹è€…æ˜¯æ€ä¹ˆâ€œæ™‹å‡â€çš„ã€‚</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">schedule</span><span class="params">()</span></span> &#123;</span><br><span class="line">    (...) <span class="comment">// çœç•¥å®‰å…¨æ£€æŸ¥</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// çœ‹çœ‹äººå®¶ timer ç›´æ¥è¢«å®‰æ’åˆ°é¡¶çº§ä½ç½®</span></span><br><span class="line">    <span class="comment">// è°ƒåº¦å¾ªç¯ä¸Šæ¥å°±æ˜¯å…ˆæ£€æŸ¥ timer</span></span><br><span class="line">    checkTimers(pp, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    (...)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> gp == <span class="literal">nil</span> &#123;</span><br><span class="line">        gp, inheritTime = findrunnable() <span class="comment">// blocks until work is available</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    (...)</span><br><span class="line">    </span><br><span class="line">    execute(gp, inheritTime)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>å¯ä»¥å¾—å‡ºç»“è®ºï¼Œæ–°ç‰ˆæœ¬çš„â€œæ¶ˆè´¹è€…â€ ä» goroutine çº§åˆ« è½¬å˜åˆ° å‡½æ•°çº§åˆ«ã€‚</p>
<h4 id="checkTimers"><a href="#checkTimers" class="headerlink" title="checkTimers()"></a>checkTimers()</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// checkTimers runs any timers for the P that are ready.</span></span><br><span class="line"><span class="comment">// If now is not 0 it is the current time.</span></span><br><span class="line"><span class="comment">// It returns the current time or 0 if it is not known,</span></span><br><span class="line"><span class="comment">// and the time when the next timer should run or 0 if there is no next timer,</span></span><br><span class="line"><span class="comment">// and reports whether it ran any timers.</span></span><br><span class="line"><span class="comment">// If the time when the next timer should run is not 0,</span></span><br><span class="line"><span class="comment">// it is always larger than the returned time.</span></span><br><span class="line"><span class="comment">// We pass now in and out to avoid extra calls of nanotime.</span></span><br><span class="line"><span class="comment">//go:yeswritebarrierrec</span></span><br><span class="line"><span class="comment">// rnow			</span></span><br><span class="line"><span class="comment">// pollUntil	0 è¡¨ç¤ºæ²¡æœ‰ä¸‹ä¸€ä¸ª timerï¼Œé 0 è¡¨ç¤ºä¸‹ä¸€ä¸ªtimerçš„ç­‰å¾…æ—¶é—´</span></span><br><span class="line"><span class="comment">// ran			è¡¨ç¤ºæ˜¯å¦æ‰§è¡Œäº† timer</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkTimers</span><span class="params">(pp *p, now <span class="keyword">int64</span>)</span> <span class="params">(rnow, pollUntil <span class="keyword">int64</span>, ran <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// If there are no timers to adjust, and the first timer on</span></span><br><span class="line">    <span class="comment">// the heap is not yet ready to run, then there is nothing to do.</span></span><br><span class="line">    <span class="keyword">if</span> atomic.Load(&amp;pp.adjustTimers) == <span class="number">0</span> &#123;</span><br><span class="line">        next := <span class="keyword">int64</span>(atomic.Load64(&amp;pp.timer0When))</span><br><span class="line">        <span class="keyword">if</span> next == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> now, <span class="number">0</span>, <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> now == <span class="number">0</span> &#123;</span><br><span class="line">            now = nanotime()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> now &lt; next &#123;</span><br><span class="line">            <span class="comment">// Next timer is not ready to run.</span></span><br><span class="line">            <span class="comment">// But keep going if we would clear deleted timers.</span></span><br><span class="line">            <span class="comment">// This corresponds to the condition below where</span></span><br><span class="line">            <span class="comment">// we decide whether to call clearDeletedTimers.</span></span><br><span class="line">            <span class="comment">// å°½å¯èƒ½æ‰¾æœºä¼šæ¸…ç† timer</span></span><br><span class="line">            <span class="keyword">if</span> pp != getg().m.p.ptr() || <span class="keyword">int</span>(atomic.Load(&amp;pp.deletedTimers)) &lt;= <span class="keyword">int</span>(atomic.Load(&amp;pp.numTimers)/<span class="number">4</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> now, next, <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lock(&amp;pp.timersLock)</span><br><span class="line"></span><br><span class="line">    adjusttimers(pp)</span><br><span class="line"></span><br><span class="line">    rnow = now</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(pp.timers) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> rnow == <span class="number">0</span> &#123;</span><br><span class="line">            rnow = nanotime()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">len</span>(pp.timers) &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// Note that runtimer may temporarily unlock</span></span><br><span class="line">            <span class="comment">// pp.timersLock.</span></span><br><span class="line">            <span class="keyword">if</span> tw := runtimer(pp, rnow); tw != <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> tw &gt; <span class="number">0</span> &#123;</span><br><span class="line">                    pollUntil = tw</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            ran = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If this is the local P, and there are a lot of deleted timers,</span></span><br><span class="line">    <span class="comment">// clear them out. We only do this for the local P to reduce</span></span><br><span class="line">    <span class="comment">// lock contention on timersLock.</span></span><br><span class="line">    <span class="keyword">if</span> pp == getg().m.p.ptr() &amp;&amp; <span class="keyword">int</span>(atomic.Load(&amp;pp.deletedTimers)) &gt; <span class="built_in">len</span>(pp.timers)/<span class="number">4</span> &#123;</span><br><span class="line">        clearDeletedTimers(pp)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    unlock(&amp;pp.timersLock)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rnow, pollUntil, ran</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>åœ¨ä¸Šè¿° <code>checkTimers</code> ä¸­ï¼Œé€šè¿‡ <code>adjusttimers</code> è°ƒæ•´å½“å‰ p çš„ timers æ•°ç»„ï¼Œæˆ‘ä»¬çœ‹ä¸€ä¸‹å®ƒçš„å®ç°</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// adjusttimers looks through the timers in the current P&#x27;s heap for</span></span><br><span class="line"><span class="comment">// any timers that have been modified to run earlier, and puts them in</span></span><br><span class="line"><span class="comment">// the correct place in the heap. While looking for those timers,</span></span><br><span class="line"><span class="comment">// it also moves timers that have been modified to run later,</span></span><br><span class="line"><span class="comment">// and removes deleted timers. The caller must have locked the timers for pp.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">adjusttimers</span><span class="params">(pp *p)</span></span> &#123;</span><br><span class="line">    <span class="comment">// åˆ¤æ–­å½“å‰ p æ˜¯å¦æœ‰ timer</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(pp.timers) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> atomic.Load(&amp;pp.adjustTimers) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> verifyTimers &#123;</span><br><span class="line">            verifyTimerHeap(pp)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// å­˜æ”¾éœ€è¦ç§»åŠ¨çš„ timer</span></span><br><span class="line">    <span class="keyword">var</span> moved []*timer</span><br><span class="line">loop:</span><br><span class="line">    <span class="comment">// éå†å½“å‰ p çš„ timers</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(pp.timers); i++ &#123;</span><br><span class="line">        t := pp.timers[i]</span><br><span class="line">        <span class="keyword">if</span> t.pp.ptr() != pp &#123;</span><br><span class="line">            throw(<span class="string">&quot;adjusttimers: bad p&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// åˆ¤æ–­å½“å‰ timer çš„çŠ¶æ€</span></span><br><span class="line">        <span class="keyword">switch</span> s := atomic.Load(&amp;t.status); s &#123;</span><br><span class="line">        <span class="comment">// è¡¨ç¤º timer éœ€è¦åˆ é™¤ï¼Œä½†æ˜¯è¿˜æ²¡æœ‰åˆ é™¤å‘¢</span></span><br><span class="line">        <span class="keyword">case</span> timerDeleted:</span><br><span class="line">            <span class="comment">// ä¿®æ”¹ timer çš„çŠ¶æ€ä¸ºï¼Œæ­£åœ¨åˆ é™¤ä¸­ timerRemoving</span></span><br><span class="line">            <span class="keyword">if</span> atomic.Cas(&amp;t.status, s, timerRemoving) &#123;</span><br><span class="line">                <span class="comment">// æ‰§è¡Œåˆ é™¤æ“ä½œ</span></span><br><span class="line">                dodeltimer(pp, i)</span><br><span class="line">                <span class="comment">// ä¿®æ”¹ timer çš„çŠ¶æ€ä¸ºï¼Œå·²åˆ é™¤ timerRemoved</span></span><br><span class="line">                <span class="keyword">if</span> !atomic.Cas(&amp;t.status, timerRemoving, timerRemoved) &#123;</span><br><span class="line">                    badTimer()</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// ä¿®æ”¹å¾…åˆ é™¤ timer çš„æ•°é‡ pp.deletedTimers - 1</span></span><br><span class="line">                atomic.Xadd(&amp;pp.deletedTimers, <span class="number">-1</span>)</span><br><span class="line">                <span class="comment">// Look at this heap position again.</span></span><br><span class="line">                <span class="comment">// æ€è€ƒä¸€ä¸‹å°±å¯ä»¥çŸ¥é“ï¼Œä¸ºä»€ä¹ˆéœ€è¦å†æ¬¡æ£€æŸ¥å½“å‰è¿™ä¸ªä½ç½®çš„ timer</span></span><br><span class="line">                <span class="comment">// é€šè¿‡ dodeltimer å°†ç´¢å¼•ä¸º i çš„ timer åˆ é™¤åï¼Œæˆ‘ä»¬çŸ¥é“çš„æ˜¯</span></span><br><span class="line">                <span class="comment">// å‡è®¾æ€»æ•°é‡ä¸º n, [0, i) ä¹‹å‰çš„å…ƒç´ ä¸éœ€è¦æ”¹å˜ï¼Œåˆ æ‰ç¬¬ I ä¸ªå</span></span><br><span class="line">                <span class="comment">// éœ€è¦åœ¨ [i,n-1) é‡Œè¾¹ä¸­é€‰ä¸€ä¸ªå¡«è¡¥ i çš„ä½ç½®ï¼Œæ‰€ä»¥éœ€è¦é‡æ–°æ£€æŸ¥ä¸€æ¬¡</span></span><br><span class="line">                i--</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">// è¡¨ç¤º timer çš„ç­‰å¾…æ—¶é—´è¢«è°ƒæ•´äº†</span></span><br><span class="line">        <span class="comment">// timerModifiedEarlier å‘å‰è°ƒæ•´</span></span><br><span class="line">        <span class="comment">// timerModifiedLater å‘åè°ƒæ•´</span></span><br><span class="line">        <span class="keyword">case</span> timerModifiedEarlier, timerModifiedLater:</span><br><span class="line">            <span class="comment">// å› ä¸ºè°ƒæ•´äº† timer çš„æ—¶é—´ç‚¹ï¼Œæ‰€ä»¥éœ€è¦é‡æ–°è°ƒæ•´è¯¥ timer åœ¨å †ä¸­çš„ä½ç½®</span></span><br><span class="line">            <span class="comment">// ä¿®æ”¹ timer çŠ¶æ€ä¸ºï¼Œç§»åŠ¨ä¸­ timerMoving</span></span><br><span class="line">            <span class="keyword">if</span> atomic.Cas(&amp;t.status, s, timerMoving) &#123;</span><br><span class="line">                <span class="comment">// Now we can change the when field.</span></span><br><span class="line">                t.when = t.nextwhen</span><br><span class="line">                <span class="comment">// Take t off the heap, and hold onto it.</span></span><br><span class="line">                <span class="comment">// We don&#x27;t add it back yet because the</span></span><br><span class="line">                <span class="comment">// heap manipulation could cause our</span></span><br><span class="line">                <span class="comment">// loop to skip some other timer.</span></span><br><span class="line">                dodeltimer(pp, i)</span><br><span class="line">                <span class="comment">// å°†è¿™ä¸ª timer åŠ å…¥åˆ°éœ€è¦ç§»åŠ¨çš„ timer å½“ä¸­</span></span><br><span class="line">                moved = <span class="built_in">append</span>(moved, t)</span><br><span class="line">                <span class="keyword">if</span> s == timerModifiedEarlier &#123;</span><br><span class="line">                    <span class="keyword">if</span> n := atomic.Xadd(&amp;pp.adjustTimers, <span class="number">-1</span>); <span class="keyword">int32</span>(n) &lt;= <span class="number">0</span> &#123;</span><br><span class="line">                        <span class="keyword">break</span> loop</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// Look at this heap position again.</span></span><br><span class="line">                i--</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">case</span> timerNoStatus, timerRunning, timerRemoving, timerRemoved, timerMoving:</span><br><span class="line">            badTimer()</span><br><span class="line">        <span class="keyword">case</span> timerWaiting:</span><br><span class="line">            <span class="comment">// OK, nothing to do.</span></span><br><span class="line">        <span class="keyword">case</span> timerModifying:</span><br><span class="line">            <span class="comment">// Check again after modification is complete.</span></span><br><span class="line">            osyield()</span><br><span class="line">            i--</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            badTimer()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(moved) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// å°† timer é‡æ–°åŠ å…¥åˆ°å½“å‰ p çš„ timers ä¸­</span></span><br><span class="line">        <span class="comment">// å¹¶ä¸”æŒ‰ç…§å°é¡¶å †è¿›è¡Œæ’åº</span></span><br><span class="line">        addAdjustedTimers(pp, moved)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> verifyTimers &#123;</span><br><span class="line">        verifyTimerHeap(pp)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ç„¶åæˆ‘ä»¬å†çœ‹ä¸€ä¸‹ <code>checkTimers</code> å‡½æ•°æœ«å°¾çš„ä½ç½®ï¼Œå°±æ˜¯è¦çœŸæ­£æ‰§è¡Œ timer çš„æ—¶å€™äº†ï¼Œé€šè¿‡ <code>runtimer</code> æ¥æ‰§è¡Œ p ä¸­çš„ timer</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// runtimer examines the first timer in timers. If it is ready based on now,</span></span><br><span class="line"><span class="comment">// it runs the timer and removes or updates it.</span></span><br><span class="line"><span class="comment">// Returns 0 if it ran a timer, -1 if there are no more timers, or the time</span></span><br><span class="line"><span class="comment">// when the first timer should run.</span></span><br><span class="line"><span class="comment">// The caller must have locked the timers for pp.</span></span><br><span class="line"><span class="comment">// If a timer is run, this will temporarily unlock the timers.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	æ ¹æ®ä¸Šè¿°æ³¨é‡Šå¯ä»¥äº†è§£åˆ°:</span></span><br><span class="line"><span class="comment">	è¿”å›å€¼ = 0;  è¡¨ç¤ºæ‰§è¡Œäº†ä¸€ä¸ª timer</span></span><br><span class="line"><span class="comment">	è¿”å›å€¼ = -1; è¡¨ç¤º p ä¸­æ²¡æœ‰ timer äº†</span></span><br><span class="line"><span class="comment">	è¿”å›å€¼ &gt; 0;  è¡¨ç¤ºç¬¬ä¸€ä¸ª timer è¦æ‰§è¡Œçš„æ—¶é—´ç‚¹</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	ï¼ˆè¿™é‡Œçš„æºç å°±ä¸åšè¿‡å¤šåˆ†æäº†ï¼Œæ²¡æœ‰ä»€ä¹ˆå¯è¯´çš„ï¼ŒåŸºæœ¬ä¸Šéƒ½è¦†ç›–åˆ°äº†ï¼‰</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//go:systemstack</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runtimer</span><span class="params">(pp *p, now <span class="keyword">int64</span>)</span> <span class="title">int64</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        t := pp.timers[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> t.pp.ptr() != pp &#123;</span><br><span class="line">            throw(<span class="string">&quot;runtimer: bad p&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">switch</span> s := atomic.Load(&amp;t.status); s &#123;</span><br><span class="line">        <span class="keyword">case</span> timerWaiting:</span><br><span class="line">            <span class="keyword">if</span> t.when &gt; now &#123;</span><br><span class="line">                <span class="comment">// Not ready to run.</span></span><br><span class="line">                <span class="keyword">return</span> t.when</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> !atomic.Cas(&amp;t.status, s, timerRunning) &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Note that runOneTimer may temporarily unlock</span></span><br><span class="line">            <span class="comment">// pp.timersLock.</span></span><br><span class="line">            runOneTimer(pp, t, now)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> timerDeleted:</span><br><span class="line">            <span class="keyword">if</span> !atomic.Cas(&amp;t.status, s, timerRemoving) &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            dodeltimer0(pp)</span><br><span class="line">            <span class="keyword">if</span> !atomic.Cas(&amp;t.status, timerRemoving, timerRemoved) &#123;</span><br><span class="line">                badTimer()</span><br><span class="line">            &#125;</span><br><span class="line">            atomic.Xadd(&amp;pp.deletedTimers, <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(pp.timers) == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> timerModifiedEarlier, timerModifiedLater:</span><br><span class="line">            <span class="keyword">if</span> !atomic.Cas(&amp;t.status, s, timerMoving) &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            t.when = t.nextwhen</span><br><span class="line">            dodeltimer0(pp)</span><br><span class="line">            doaddtimer(pp, t)</span><br><span class="line">            <span class="keyword">if</span> s == timerModifiedEarlier &#123;</span><br><span class="line">                atomic.Xadd(&amp;pp.adjustTimers, <span class="number">-1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> !atomic.Cas(&amp;t.status, timerMoving, timerWaiting) &#123;</span><br><span class="line">                badTimer()</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> timerModifying:</span><br><span class="line">            <span class="comment">// Wait for modification to complete.</span></span><br><span class="line">            osyield()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> timerNoStatus, timerRemoved:</span><br><span class="line">            <span class="comment">// Should not see a new or inactive timer on the heap.</span></span><br><span class="line">            badTimer()</span><br><span class="line">        <span class="keyword">case</span> timerRunning, timerRemoving, timerMoving:</span><br><span class="line">            <span class="comment">// These should only be set when timers are locked,</span></span><br><span class="line">            <span class="comment">// and we didn&#x27;t do it.</span></span><br><span class="line">            badTimer()</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            badTimer()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>æˆªæ­¢åˆ°ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘ä»¬å·²ç»æŠŠ <code>checkTimers</code> ç»™åˆ†æå®Œäº†ã€‚</p>
<h3 id="å·-timer"><a href="#å·-timer" class="headerlink" title="å· timer"></a>å· timer</h3><p>è¿™é‡Œçš„å· timer ä¸æ˜¯è¯´æŠŠ å¦ä¸€ä¸ª p çš„ timer å·åˆ°æˆ‘æœ¬åœ°åå†æ‰§è¡Œï¼Œè€Œæ˜¯åœ¨å½“å‰è¿™ä¸ª p ï¼Œæ‰§è¡Œå…¶ä»– p timerã€‚</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// æˆªå–éƒ¨åˆ† findrunnable ä»£ç </span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">4</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> enum := stealOrder.start(fastrand()); !enum.done(); enum.next() &#123;</span><br><span class="line">            (...)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">2</span> &amp;&amp; shouldStealTimers(p2) &#123;</span><br><span class="line">                tnow, w, ran := checkTimers(p2, now)</span><br><span class="line">                (...)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="åè¯­"><a href="#åè¯­" class="headerlink" title="åè¯­"></a>åè¯­</h2><p>ç»™å¤§å®¶åˆ†äº«ä¸€ä¸‹æˆ‘åœ¨æ•´ç†è¿‡ç¨‹ä¸­çš„å‚è€ƒèµ„æ–™å§ï¼š<br><em>1.luozhiyun Goä¸­å®šæ—¶å™¨å®ç°åŸç†åŠæºç è§£æ</em><br>   <a target="_blank" rel="noopener" href="https://www.cnblogs.com/luozhiyun/p/14494540.html"><em>https://www.cnblogs.com/luozhiyun/p/14494540.html</em></a><br><em>2.çŒªåƒé±¼ Netpoll è§£æ</em><br>   <a target="_blank" rel="noopener" href="https://www.pefish.club/2020/05/04/Golang/1011Netpoll%E8%A7%A3%E6%9E%90/"><em>https://www.pefish.club/2020/05/04/Golang/1011Netpoll%E8%A7%A3%E6%9E%90/</em></a><br><em>3.issues<br>   <a target="_blank" rel="noopener" href="https://github.com/golang/go/issues/6239"><em>https://github.com/golang/go/issues/6239</em></a><br>4.å³°äº‘å°±å¥¹äº†  go1.14åŸºäºnetpollå®šæ—¶å™¨å®ç°åŸç†</em><br>   <a target="_blank" rel="noopener" href="http://xiaorui.cc/archives/6483"><em>http://xiaorui.cc/archives/6483</em></a></p>
</div><div id="donate"><link rel="stylesheet" type="text/css" href="/css/donate.css?v=1.0.0"><script type="text/javascript" src="/js/donate.js?v=1.0.0" successtext="å¤åˆ¶æˆåŠŸ!"></script><a class="pos-f tr3" id="github" href="https://github.com/clamyang" target="_blank" title="Github"></a><div id="DonateText">Donate</div><ul class="list pos-f" id="donateBox"><li id="AliPay" qr="/img/AliPayQR.jpg"></li><li id="WeChat" qr="/img/WeChatQR.jpg"></li></ul><div class="pos-f left-100" id="QRBox"><div id="MainBox"></div></div></div><div class="post-copyright"><script type="text/javascript" src="/js/copyright.js?v=1.0.0" successtext="å¤åˆ¶æˆåŠŸ!"></script><link rel="stylesheet" type="text/css" href="/css/copyright.css?v=1.0.0"><p><span>æœ¬æ–‡æ ‡é¢˜ï¼š</span>timer ä¼˜åŒ–</p><p><span>æ–‡ç« ä½œè€…ï¼š</span>bqyang</p><p><span>å‘å¸ƒæ—¶é—´ï¼š</span>2021-12-06</p><p><span>æœ€åæ›´æ–°ï¼š</span>2022-07-11</p><p><span>åŸå§‹é“¾æ¥ï¼š</span><a href="/2021/language/golang/timer ä¼˜åŒ–/">https://bqyang.top/2021/language/golang/timer%20%E4%BC%98%E5%8C%96/</a><span class="copy-path"><i class="fa fa-clipboard" data-clipboard-text="https://bqyang.top/2021/language/golang/timer%20%E4%BC%98%E5%8C%96/"></i></span></p><p><span>ç‰ˆæƒå£°æ˜ï¼š</span>The author owns the copyright, please indicate the source reproduced.</p></div><br><div class="tags"></div><div class="post-nav"><a class="pre" href="/2021/os/elf/">elf æ–‡ä»¶æ ¼å¼</a><a class="next" href="/2021/language/golang/timer%20%E6%B5%85%E6%9E%90/">timer æºç åˆ†æ</a></div><script src="https://utteranc.es/client.js" repo="clamyang/blogs" issue-term="title" theme="github-light" crossorigin="anonymous" async> </script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://bqyang.top"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> æœ€è¿‘æ–‡ç« </i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2022/leetcode/backtracking/backtracking/">å›æº¯ç®—æ³•å­¦ä¹ </a></li><li class="post-list-item"><a class="post-list-link" href="/2022/summary/about-221025/">åˆ·é¢˜è¿˜æ˜¯æŒºæœ‰æ„æ€çš„</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/socket/">ä½¿ç”¨ C æ­å»º Server</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/epoll/">epoll æ–‡æ¡£ç¿»è¯‘</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/k8s/k8s/">æ­å»º Kubernetes é›†ç¾¤</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/language/golang/large-alloc/">Go å¤§å¯¹è±¡åˆ†é…æ¢ç´¢</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/language/golang/memory-alloc/">Go å†…å­˜åˆ†é…å™¨</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/os/memory/free-space-manage/">free space management</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/k8s/k8s-storage-source-code/">k8s pv pvc æºç </a></li><li class="post-list-item"><a class="post-list-link" href="/2022/design-pattern/Structural/composite/">ç»„åˆæ¨¡å¼</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> å‹æƒ…é“¾æ¥</i></div><ul></ul><a href="http://www.xargin.com/" title="Xargin" target="_blank">Xargin</a><ul></ul><a href="https://mytechshares.com/" title="è‘£æ³½æ¶¦çš„æŠ€æœ¯ç¬”è®°" target="_blank">è‘£æ³½æ¶¦çš„æŠ€æœ¯ç¬”è®°</a><ul></ul><a href="https://hujingnb.com/" title="çƒŸè‰çš„é¦™å‘³" target="_blank">çƒŸè‰çš„é¦™å‘³</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright Â© 2022 <a href="/." rel="nofollow">æ¨å®å¼ºçš„æŠ€æœ¯ç¬”è®°.</a>Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://beian.miit.gov.cn/"> äº¬ICPå¤‡2021035561å·.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="å¤åˆ¶æˆåŠŸ!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>