<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="一物不知深以为耻"><title>关于 rpc 的那些事（一） | 杨宝强的技术笔记</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><div class="darkmode-toggle">🌓</div><script>var prefersDarkMode = window.matchMedia('(prefers-color-scheme: dark)');
var toggle = document.querySelector('.darkmode-toggle');
var html = document.querySelector('html');

html.dataset.dark = localStorage.dark || prefersDarkMode.matches;

toggle.addEventListener('click', () => {
localStorage.dark = !(html.dataset.dark == 'true');
html.dataset.dark = localStorage.dark;
});</script><meta name="generator" content="Hexo 5.4.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">关于 rpc 的那些事（一）</h1><a id="logo" href="/.">杨宝强的技术笔记</a><p class="description">Gopher Watcher</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">关于 rpc 的那些事（一）</h1><div class="post-meta">2022-06-23</div><div class="post-content"><p>该文是我学习 <code>rpc</code> 过程中的总结，初步了解到一个 <code>rpc </code> 框架是做什么的，以及为什么我们要使用 <code>rpc </code> 框架。结合当前工作中遇到的场景，对比思考。</p>
<p><img src="https://s2.loli.net/2022/06/22/8kZFXOu7yo6nfLJ.png"></p>
<span id="more"></span>

<h2 id="我遇到的"><a href="#我遇到的" class="headerlink" title="我遇到的"></a>我遇到的</h2><p>我们现在的后端服务，跑的是一套开源的云管代码 [<a target="_blank" rel="noopener" href="https://github.com/yunionio/cloudpods">在这里</a>]，据不可靠消息透露，这套框架的源头是美团搞得，一开始貌似用的 Java 代码，后来用 Go 重写了。</p>
<p>八卦了一下，言归正传，这套代码主要由 keystone / apigateway / region / scheduler 组成，简单概述下他们的职责。</p>
<ol>
<li>keystone 负责认证。</li>
<li>apigateway 负责路由转发。</li>
<li>region 负责实际的业务逻辑。</li>
<li>scheduler 负责调度，根据库里数据选择某个最优解。</li>
</ol>
<p><strong>网络请求是怎么进行流转的呢？</strong></p>
<p>认证我们抛开不说，假设以下内容都是认证完成后的。</p>
<p>认证完成后，用户需要创建云主机，从页面点击创建后，请求走到 <code>apigateway</code>，<code>apigateway</code> 分析请求路径，找到对应的 <code>model</code>，进行路由转发，请求 <code>region</code>，<code>region</code> 处理完成后，返回给 <code>apigateway</code>，<code>apigateway</code> 拿到响应后返回给客户结果。</p>
<p><strong>这里是怎么拿到另一个服务的地址呢？</strong></p>
<p>将所有服务信息存储在 endpoint 表中，然后根据请求的相关信息拿到对应的 url，再把 path 拼上。</p>
<p>这个其实不重要，我最好奇的就是，新加了一些路由之后，<code>apigateway</code> 怎么感知呢？</p>
<p>调试代码后发现，<code>region</code> 服务和 <code>apigateway</code> 服务存在着某些程度上的耦合，我们在 <code>region</code> 中添加路由后，必须要“同步”给网关。在网关中添加个文件，如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    Disks modulebase.ResourceManager</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Disks = modules.NewComputeManager(</span><br><span class="line">        <span class="string">&quot;disk&quot;</span>,</span><br><span class="line">        <span class="string">&quot;disks&quot;</span>,</span><br><span class="line">        []<span class="keyword">string</span>&#123;<span class="string">&quot;ID&quot;</span>, <span class="string">&quot;Name&quot;</span>, <span class="string">&quot;Billing_type&quot;</span>,</span><br><span class="line">                 <span class="string">&quot;Guest_id&quot;</span>, <span class="string">&quot;Created_at&quot;</span>&#125;,</span><br><span class="line">        []<span class="keyword">string</span>&#123;<span class="string">&quot;Storage&quot;</span>, <span class="string">&quot;Tenant&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line">    modules.RegisterCompute(&amp;Disks)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过这种方式，注册到全局变量中，后续根据请求的路径查询对应的模块。</p>
<blockquote>
<p>值得一提的是，<code>apigateway</code> 中使用的是正则路由。这样就可以根据请求方法进行抽象，所有的 Get 请求走的都是同一个 handler，其他也类似。</p>
</blockquote>
<p>所以，我们每次写新功能的时候都需要额外重启网关服务，个人感觉不是那么的优雅。</p>
<p>那么问题来了，rpc 能否解决这个问题？我写这篇文章的时候并不知道答案。</p>
<h2 id="rpc-是什么呢？"><a href="#rpc-是什么呢？" class="headerlink" title="rpc 是什么呢？"></a>rpc 是什么呢？</h2><p>虽然没用过微服务，但是听的耳朵都要起茧子了。这玩意应该没那么普及吧..</p>
<p>我认为 rpc 框架主要解决的是服务间调用的问题，如果每个接口都使用注册 handler 的方式实现，这个工作量很大并且很难维护。正如 rpc 名字的意思，调用远程接口和调用本地函数一样，rpc 框架封装了这些细节。</p>
<p>另一方面，grpc 通信摒弃了常规的序列化方式，《DDIA》 中有讲到几种压缩方式的对比。</p>
<p>看一个简单的例子就知道这个调用过程大致长什么样了，例子来自 [<a target="_blank" rel="noopener" href="https://github.com/grpc/grpc-go/tree/master/examples/helloworld">grpc-go</a> ]</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// client</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    flag.Parse()</span><br><span class="line">    <span class="comment">// Set up a connection to the server.</span></span><br><span class="line">    conn, err := grpc.Dial(*addr, grpc.WithTransportCredentials(insecure.NewCredentials()))</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">&quot;did not connect: %v&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> conn.Close()</span><br><span class="line">    c := pb.NewGreeterClient(conn)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Contact the server and print out its response.</span></span><br><span class="line">    ctx, cancel := context.WithTimeout(context.Background(), time.Second)</span><br><span class="line">    <span class="keyword">defer</span> cancel()</span><br><span class="line">    r, err := c.SayHello(ctx, &amp;pb.HelloRequest&#123;Name: *name&#125;)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">&quot;could not greet: %v&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    log.Printf(<span class="string">&quot;Greeting: %s&quot;</span>, r.GetMessage())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// server</span></span><br><span class="line"><span class="comment">// server is used to implement helloworld.GreeterServer.</span></span><br><span class="line"><span class="keyword">type</span> server <span class="keyword">struct</span> &#123;</span><br><span class="line">    pb.UnimplementedGreeterServer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SayHello implements helloworld.GreeterServer</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *server)</span> <span class="title">SayHello</span><span class="params">(ctx context.Context, in *pb.HelloRequest)</span> <span class="params">(*pb.HelloReply, error)</span></span> &#123;</span><br><span class="line">    log.Printf(<span class="string">&quot;Received: %v&quot;</span>, in.GetName())</span><br><span class="line">    <span class="keyword">return</span> &amp;pb.HelloReply&#123;Message: <span class="string">&quot;Hello &quot;</span> + in.GetName()&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    flag.Parse()</span><br><span class="line">    lis, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, fmt.Sprintf(<span class="string">&quot;:%d&quot;</span>, *port))</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">&quot;failed to listen: %v&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    s := grpc.NewServer()</span><br><span class="line">    pb.RegisterGreeterServer(s, &amp;server&#123;&#125;)</span><br><span class="line">    log.Printf(<span class="string">&quot;server listening at %v&quot;</span>, lis.Addr())</span><br><span class="line">    <span class="keyword">if</span> err := s.Serve(lis); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">&quot;failed to serve: %v&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，我们在客户端通过调用函数的方式就实现了对服务端的调用。但是，重点也不是这些，这些内容大部分是通过 <code>.proto</code> 文件生成的，我们只是实现了相应的接口。</p>
<h2 id="proto-文件"><a href="#proto-文件" class="headerlink" title=".proto 文件"></a>.proto 文件</h2><p>生成 <code>.pb.go | _grpc.pb.go</code> 命令：</p>
<p><code> protoc --go_out=. --go_opt=paths=source_relative  --go-grpc_out=.  --go-grpc_opt=paths=source_relative .\forGen.proto</code></p>
<p>Google 官网的解释 [<a target="_blank" rel="noopener" href="https://developers.google.com/protocol-buffers/docs/gotutorial">在这里</a>]，常用的几种数据类型：</p>
<ul>
<li>repeated</li>
<li>map&lt;string, int&gt;</li>
<li>oneof 结构体里面套了一个接口</li>
<li>单个结构体类型，<code>message Foo &#123;&#125;</code> </li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">message FooRepeated &#123;</span><br><span class="line">    <span class="comment">// []string</span></span><br><span class="line">    repeated <span class="keyword">string</span> Address = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message FooMap &#123;</span><br><span class="line">    <span class="comment">// map[string]int32</span></span><br><span class="line">    <span class="keyword">map</span>&lt;<span class="keyword">string</span>, <span class="keyword">int32</span>&gt; info = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message FooOneof &#123;</span><br><span class="line">    <span class="comment">// struct &#123;interface&#123;&#125;&#125;</span></span><br><span class="line">    oneof avatar &#123;</span><br><span class="line">        <span class="keyword">string</span> image_url = <span class="number">1</span>;</span><br><span class="line">        bytes image_data = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="grpc-流"><a href="#grpc-流" class="headerlink" title="grpc 流"></a>grpc 流</h2><p>从文档中不难发现，grpc 支持流式数据传输，流式传输应对的是上传和下载大量数据的场景。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 双向流，stream指定启用流特性</span></span><br><span class="line">service HelloService &#123;</span><br><span class="line">    rpc Channel (stream Foo) returns (stream Foo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和普通的差别也不大，只是从直接接收参数变成了，读取连接里的内容。我们实现的 Channel 方法如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> HelloServiceImpl <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 这就好像，pb 插件给我们提供一个抽象类</span></span><br><span class="line">    <span class="comment">// 我们自己去实现具体的内容</span></span><br><span class="line">    pb.UnimplementedHelloServiceServer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *HelloServiceImpl)</span> <span class="title">Channel</span><span class="params">(stream pb.HelloService_ChannelServer)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// 读取连接中的内容，</span></span><br><span class="line">        <span class="comment">// 读出来的最小单位就是我们在 service 中定义的</span></span><br><span class="line">        args, err := stream.Recv()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 输出从客户端都到的东西</span></span><br><span class="line">        fmt.Println(args.GetName())</span><br><span class="line">        reply := &amp;pb.Foo&#123;Name: args.GetName()&#125;</span><br><span class="line"></span><br><span class="line">        err = stream.Send(reply)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其余 server 端的代码类似，注册函数，启动服务。这里看下 client 实现：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">conn, err := grpc.Dial(<span class="string">&quot;:1234&quot;</span>, grpc.WithTransportCredentials(insecure.NewCredentials()))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br><span class="line"></span><br><span class="line">client := pb.NewHelloServiceClient(conn)</span><br><span class="line">s, err := client.Channel(context.Background())</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="comment">// 每隔一秒给 server 发个消息</span></span><br><span class="line">    err := s.Send(&amp;pb.Foo&#123;Name: <span class="string">&quot;bqyang-test&quot;</span>&#125;)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样既可实现 grpc 以流的方式通信。</p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>那么我们是否可以通过 rpc 的方式重写那个框架中的内容呢？答案是肯定的，可以通过基于HTTP的 rpc 服务，但是貌似仍然解决不了两个服务都重启的问题，而且维护路由的成本更高了。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AServer</span><span class="params">()</span></span> &#123;</span><br><span class="line">    rpc.RegisterName(<span class="string">&quot;HelloService&quot;</span>, <span class="built_in">new</span>(HelloService))</span><br><span class="line">    http.HandleFunc(<span class="string">&quot;/hello&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span>&#123;</span><br><span class="line">        <span class="keyword">var</span> conn io.ReadWriteCloser = <span class="keyword">struct</span> &#123;</span><br><span class="line">            io.Writer</span><br><span class="line">            io.ReadCloser</span><br><span class="line">        &#125; &#123;</span><br><span class="line">            Writer: w, </span><br><span class="line">            ReadCloser: r.Body,</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        rpc.ServeRequest(jsonrpc.NewServerCodec(conn))</span><br><span class="line">    &#125;)</span><br><span class="line">    http.ListenAndServe(<span class="string">&quot;:1234&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>有没有更优解呢？或许可以通过服务发现进行实现，下篇文章的内容有了，了解下服务发现。</p>
</div><div id="donate"><link rel="stylesheet" type="text/css" href="/css/donate.css?v=1.0.0"><script type="text/javascript" src="/js/donate.js?v=1.0.0" successtext="复制成功!"></script><a class="pos-f tr3" id="github" href="https://github.com/clamyang" target="_blank" title="Github"></a><div id="DonateText">Donate</div><ul class="list pos-f" id="donateBox"><li id="AliPay" qr="/img/AliPayQR.jpg"></li><li id="WeChat" qr="/img/WeChatQR.jpg"></li></ul><div class="pos-f left-100" id="QRBox"><div id="MainBox"></div></div></div><div class="post-copyright"><script type="text/javascript" src="/js/copyright.js?v=1.0.0" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copyright.css?v=1.0.0"><p><span>本文标题：</span>关于 rpc 的那些事（一）</p><p><span>文章作者：</span>bqyang</p><p><span>发布时间：</span>2022-06-23</p><p><span>最后更新：</span>2022-06-26</p><p><span>原始链接：</span><a href="/2022/rpc/about-rpc-1/">https://bqyang.top/2022/rpc/about-rpc-1/</a><span class="copy-path"><i class="fa fa-clipboard" data-clipboard-text="https://bqyang.top/2022/rpc/about-rpc-1/"></i></span></p><p><span>版权声明：</span>The author owns the copyright, please indicate the source reproduced.</p></div><br><div class="tags"></div><div class="post-nav"><a class="pre" href="/2022/summary/about-0602/">根管治疗+全瓷冠</a><a class="next" href="/2022/os/RMO/">宽松内存模型</a></div><script src="https://utteranc.es/client.js" repo="clamyang/blogs" issue-term="title" theme="github-light" crossorigin="anonymous" async> </script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://bqyang.top"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2022/os/pstree/">简易版 pstree</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/k8s/k8s-storage/">k8s 存储内容</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/design-pattern/Structural/facade/">门面模式（外观模式）</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/os/memory-api/">内存相关 API</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/language/golang/100-go-mistaks/2-misuse-init/">misuse init func</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/language/golang/go-params-to-goroutine/">参数是怎么传给 goroutine 的</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/language/golang/100-go-mistaks/1-variable-shadowing/">Variable shadowing</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/os/process/process/">操作系统进程</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/os/linker&loader/">linker and loader</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/vcs/git/git-rebase/">git rebase</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.xargin.com/" title="Xargin" target="_blank">Xargin</a><ul></ul><a href="https://mytechshares.com/" title="董泽润的技术笔记" target="_blank">董泽润的技术笔记</a><ul></ul><a href="https://hujingnb.com/" title="烟草的香味" target="_blank">烟草的香味</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2022 <a href="/." rel="nofollow">杨宝强的技术笔记.</a>Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://beian.miit.gov.cn/"> 京ICP备2021035561号.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>