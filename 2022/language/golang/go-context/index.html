<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="一物不知深以为耻"><title>go context | 杨宝强的技术笔记</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><div class="darkmode-toggle">🌓</div><script>var prefersDarkMode = window.matchMedia('(prefers-color-scheme: dark)');
var toggle = document.querySelector('.darkmode-toggle');
var html = document.querySelector('html');

html.dataset.dark = localStorage.dark || prefersDarkMode.matches;

toggle.addEventListener('click', () => {
localStorage.dark = !(html.dataset.dark == 'true');
html.dataset.dark = localStorage.dark;
});</script><meta name="generator" content="Hexo 5.4.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">go context</h1><a id="logo" href="/.">杨宝强的技术笔记</a><p class="description">Gopher Watcher</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">go context</h1><div class="post-meta">2022-06-23</div><div class="post-content"><p><img src="https://s2.loli.net/2022/06/15/4SjfIcJUAtRrigO.png"></p>
<p>这两天在看 Context 的最佳实践，在项目中有用到这个东西，但是又没有实际起作用，只是单纯的作为一个参数传来传去。这篇文章的目的就是学会使用 Context 以及阅读 Context 部分源码实现，还有在使用时需要注意的事项。</p>
<span id="more"></span>

<h2 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h2><h3 id="Background-amp-amp-TODO"><a href="#Background-amp-amp-TODO" class="headerlink" title="Background &amp;&amp; TODO"></a>Background &amp;&amp; TODO</h3><p><strong>Background</strong> 一般都是用来当作树的顶点来使用：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 使用 WithCancel 派生出一个子节点</span></span><br><span class="line">    <span class="comment">// 当前的 Context tree 为：</span></span><br><span class="line">    <span class="comment">// parent --&gt; ctx</span></span><br><span class="line">    ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line">    <span class="keyword">defer</span> cancel</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// use ctx do something..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>需要注意的是，Background 是永远都不会被取消的，这个我们稍后会看到为什么。</p>
</blockquote>
<p><strong>TODO</strong> 一般用在不清楚使用哪个 Context 时：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假设我们有个函数需要 context 作为参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DoSomething</span><span class="params">(ctx context.Context, args Args)</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>如果说这时候我们不知道要传给这个函数哪个具体的实参，可以使用 <code>context.TODO</code> 代替，将来有具体的 Contetxt 可以把这个替换掉。</p>
<h3 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h3><p>在底层这两个其实是同一个东西：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    background = <span class="built_in">new</span>(emptyCtx)</span><br><span class="line">    todo       = <span class="built_in">new</span>(emptyCtx)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>



<p>既然都说到这了，我们看下源码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// context 在底层就是一个 interface</span></span><br><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">    Deadline() (deadline time.Time, ok <span class="keyword">bool</span>)</span><br><span class="line">    <span class="comment">// 采用了 lazy init 的方式进行初始化</span></span><br><span class="line">    Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">    Err() error</span><br><span class="line">    Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>emptyCtx 实现了这个接口，但是与其他 <code>ctx</code> 不同的是，emptyCtx 是不会被 cancel 的，也没有任何的 value 和 deadline。</p>
<p>另一个非常有意思的地方，<code>emptyCtx</code> 其实是 int 的一个别名，官方注释提到不使用 struct 的原因是<strong>需要不同的地址</strong>，可以动手实验一下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printAddr</span><span class="params">()</span></span> &#123;    </span><br><span class="line">    <span class="keyword">type</span> s <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">    a := <span class="built_in">new</span>(s)</span><br><span class="line">    b := <span class="built_in">new</span>(s)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%p, %p\n&quot;</span>, a, b)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">type</span> i <span class="keyword">int</span></span><br><span class="line">    i1 := <span class="built_in">new</span>(i)</span><br><span class="line">    i2 := <span class="built_in">new</span>(i)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%p, %p\n&quot;</span>, i1, i2)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    Output: </span></span><br><span class="line"><span class="comment">    address of a is 0x8cb1d0, address of b is 0x8cb1d0</span></span><br><span class="line"><span class="comment">    address of i1 is 0xc00000a0a8, address of i2 is 0xc00000a0e0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>为什么不能使用相同的地址？</p>
<p>个人认为是为了区分 Background 和 TODO，在源码中我们能看到 emptyCtx 有一个方法叫做 String()</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *emptyCtx)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">   <span class="keyword">switch</span> e &#123;</span><br><span class="line">   <span class="keyword">case</span> background:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;context.Background&quot;</span></span><br><span class="line">   <span class="keyword">case</span> todo:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;context.TODO&quot;</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&quot;unknown empty Context&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果说我们使用 <code>type emptyCtx struct&#123;&#125;</code> 作为 Background 和 TODO 的底层实现，那么在这里打印的时候就会走同一个 case 不能显示正确的输出。</p>
<p>至于其他原因暂时没想到。</p>
</blockquote>
<p>同样的 WithCancel / WithValue 等在底层对应的结构体都实现了这个接口。</p>
<table>
<thead>
<tr>
<th>funcName</th>
<th>structName</th>
</tr>
</thead>
<tbody><tr>
<td>WithValue()</td>
<td><a target="_blank" rel="noopener" href="https://cs.opensource.google/go/go/+/refs/tags/go1.18.3:src/context/context.go;drc=c29be2d41c6c3ed78a76b4d8d8c1c22d7e0ad5b7;l=538">valueCtx</a></td>
</tr>
<tr>
<td>WithDeadline() / WithTimeout()</td>
<td><a target="_blank" rel="noopener" href="https://cs.opensource.google/go/go/+/refs/tags/go1.18.3:src/context/context.go;drc=c29be2d41c6c3ed78a76b4d8d8c1c22d7e0ad5b7;l=465">timerCtx</a></td>
</tr>
<tr>
<td>WithCancel()</td>
<td><a target="_blank" rel="noopener" href="https://cs.opensource.google/go/go/+/refs/tags/go1.18.3:src/context/context.go;drc=c29be2d41c6c3ed78a76b4d8d8c1c22d7e0ad5b7;l=342">cancelCtx</a></td>
</tr>
<tr>
<td>Background() / TODO()</td>
<td><a target="_blank" rel="noopener" href="https://cs.opensource.google/go/go/+/refs/tags/go1.18.3:src/context/context.go;drc=2580d0e08d5e9f979b943758d3c49877fb2324cb;l=171">emptyCtx</a></td>
</tr>
</tbody></table>
<blockquote>
<p>题外话，你看这种方式，像不像之前提到的工厂方法模式，上边表格中的 struct 就是工厂方法子类，如果说我们以后要添加一个新的 ctx 是不影响已存在的内容的，满足了开闭原则。</p>
</blockquote>
<h3 id="WithCancel"><a href="#WithCancel" class="headerlink" title="WithCancel"></a>WithCancel</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A cancelCtx can be canceled. When canceled, it also cancels any children</span></span><br><span class="line"><span class="comment">// that implement canceler.</span></span><br><span class="line"><span class="keyword">type</span> cancelCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">    Context</span><br><span class="line"></span><br><span class="line">    mu       sync.Mutex            <span class="comment">// protects following fields</span></span><br><span class="line">    done     <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;         <span class="comment">// created lazily, closed by first cancel call</span></span><br><span class="line">    children <span class="keyword">map</span>[canceler]<span class="keyword">struct</span>&#123;&#125; <span class="comment">// set to nil by the first cancel call</span></span><br><span class="line">    err      error                 <span class="comment">// set to non-nil by the first cancel call</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>看到这里有一把琐其实就明白为什么 context 可以并发访问</strong>。</p>
<p>cancelCtx 中还有个非常重要的点就是 <code>cancel</code> 取消当前的 ctx 以及对应的 child。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过 channel 告诉要 cancel 掉这个 ctx</span></span><br><span class="line"><span class="comment">// cancel 当前节点的子节点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span> <span class="title">cancel</span><span class="params">(removeFromParent <span class="keyword">bool</span>, err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;context: internal error: missing cancel error&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    c.mu.Lock()</span><br><span class="line">    <span class="keyword">if</span> c.err != <span class="literal">nil</span> &#123;</span><br><span class="line">        c.mu.Unlock()</span><br><span class="line">        <span class="keyword">return</span> <span class="comment">// already canceled</span></span><br><span class="line">    &#125;</span><br><span class="line">    c.err = err</span><br><span class="line">    <span class="keyword">if</span> c.done == <span class="literal">nil</span> &#123;</span><br><span class="line">        c.done = closedchan</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">close</span>(c.done)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> child := <span class="keyword">range</span> c.children &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span> acquiring the child&#x27;s lock while holding parent&#x27;s lock.</span></span><br><span class="line">        child.cancel(<span class="literal">false</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    c.children = <span class="literal">nil</span></span><br><span class="line">    c.mu.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> removeFromParent &#123;</span><br><span class="line">        removeChild(c.Context, c)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>创建 cancelCtx 过程，源码分析</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line"><span class="comment">// use ctx do something</span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可以看到，如果 parent 传递为 nil 时，直接panic</span></span><br><span class="line"><span class="comment">// 所以在不知道传什么的时候，也不要传 nil，传 TODO 即可</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCancel</span><span class="params">(parent Context)</span> <span class="params">(ctx Context, cancel CancelFunc)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> parent == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;cannot create context from nil parent&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    c := newCancelCtx(parent)</span><br><span class="line">    <span class="comment">// 传播这个 ctx，意思为将这个新的 ctx 挂到父节点的下边</span></span><br><span class="line">    propagateCancel(parent, &amp;c)</span><br><span class="line">    <span class="keyword">return</span> &amp;c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">true</span>, Canceled) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// propagateCancel arranges for child to be canceled when parent is.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">propagateCancel</span><span class="params">(parent Context, child canceler)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 父节点的 Done 放在子节点进行初始化操作</span></span><br><span class="line">    done := parent.Done()</span><br><span class="line">    <span class="comment">// 这里就能看到，如果是 emptyCtx， done 直接返回了 nil</span></span><br><span class="line">    <span class="keyword">if</span> done == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="comment">// parent is never canceled</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="comment">// 避免 parent 被取消，额外做一次检查</span></span><br><span class="line">        <span class="keyword">case</span> &lt;-done:</span><br><span class="line">        <span class="comment">// parent is already canceled</span></span><br><span class="line">        child.cancel(<span class="literal">false</span>, parent.Err())</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断parent的类型，如果是 cancelCtx，走下面这个分支</span></span><br><span class="line">    <span class="comment">// 否则单起一个 goroutine 进行监听</span></span><br><span class="line">    <span class="keyword">if</span> p, ok := parentCancelCtx(parent); ok &#123;</span><br><span class="line">        <span class="comment">// 拿到父节点的 cancelCtx 后</span></span><br><span class="line">        <span class="comment">// 将子节点给加入进去就行了。</span></span><br><span class="line">        p.mu.Lock()</span><br><span class="line">        <span class="keyword">if</span> p.err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// parent has already been canceled</span></span><br><span class="line">            child.cancel(<span class="literal">false</span>, p.err)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> p.children == <span class="literal">nil</span> &#123;</span><br><span class="line">                p.children = <span class="built_in">make</span>(<span class="keyword">map</span>[canceler]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">            &#125;</span><br><span class="line">            p.children[child] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        p.mu.Unlock()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 一开始真的想不到什么情况下会走到这个分支</span></span><br><span class="line">        <span class="comment">// 后来想通了，自定义实现的 ctx 就可以走到这里</span></span><br><span class="line">        <span class="comment">// 并且必须实现 Done 方法</span></span><br><span class="line">        atomic.AddInt32(&amp;goroutines, +<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="comment">// select 会直接阻塞住，除非下边两个里边的一个“通了”</span></span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">                <span class="comment">// 如果parent被取消了，取消其子节点</span></span><br><span class="line">                <span class="keyword">case</span> &lt;-parent.Done():</span><br><span class="line">                    child.cancel(<span class="literal">false</span>, parent.Err())</span><br><span class="line">                <span class="comment">// 如果子节点被取消了，不用做额外处理</span></span><br><span class="line">                <span class="keyword">case</span> &lt;-child.Done():</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// parentCancelCtx 将父节点中的 cancelCtx 提取出啦</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parentCancelCtx</span><span class="params">(parent Context)</span> <span class="params">(*cancelCtx, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    done := parent.Done()</span><br><span class="line">    <span class="comment">// 验证 parent 是否已经关闭了</span></span><br><span class="line">    <span class="keyword">if</span> done == closedchan || done == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这个 key 就是专门用来判断是否为 cancelCtx 的</span></span><br><span class="line">    <span class="comment">// 一开始还很好奇是在哪里进行存储的这个 key value 的</span></span><br><span class="line">    <span class="comment">// 其实人家根本没存，就是用两个特定的 key 进行比对的</span></span><br><span class="line">    p, ok := parent.Value(&amp;cancelCtxKey).(*cancelCtx)</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    p.mu.Lock()</span><br><span class="line">    ok = p.done == done</span><br><span class="line">    p.mu.Unlock()</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p, <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>然后另外 <code>timerCtx</code> 的实现其实大差不差，增加了时间限制而已。</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>使用 Context 需要注意什么呢？</p>
<ul>
<li>不要自己内嵌 <code>Context</code>; 取而代之的是显示传递 <code>Context</code> 给需要的函数。</li>
<li>Context 应该作为函数的第一个参数。</li>
<li>不要给函数传递 nil 的 <code>Context</code>，尽管函数没加限制，使用 <code>context.TODO</code> 代替。</li>
<li>使用 context Value 附加参数时，只对那些请求范围内的参数使用。</li>
</ul>
<h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><p>参考链接: <a target="_blank" rel="noopener" href="https://www.sobyte.net/post/2022-03/go-ctx-best-practice/">Go Context Best Practices</a> [1]</p>
<p><strong>使用 context 防止 Goroutine 泄露</strong>，来源于 [<a target="_blank" rel="noopener" href="https://pkg.go.dev/context#example-WithCancel">这里</a>]</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;context&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// gen generates integers in a separate goroutine and</span></span><br><span class="line">    <span class="comment">// sends them to the returned channel.</span></span><br><span class="line">    <span class="comment">// The callers of gen need to cancel the context once</span></span><br><span class="line">    <span class="comment">// they are done consuming generated integers not to leak</span></span><br><span class="line">    <span class="comment">// the internal goroutine started by gen.</span></span><br><span class="line">    gen := <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context)</span> &lt;-<span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        dst := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">        n := <span class="number">1</span></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">for</span> &#123;</span><br><span class="line">                <span class="keyword">select</span> &#123;</span><br><span class="line">                <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">                    <span class="keyword">return</span> <span class="comment">// returning not to leak the goroutine</span></span><br><span class="line">                <span class="keyword">case</span> dst &lt;- n:</span><br><span class="line">                    n++</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line">        <span class="keyword">return</span> dst</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line">    <span class="keyword">defer</span> cancel() <span class="comment">// cancel when we are finished consuming integers</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> n := <span class="keyword">range</span> gen(ctx) &#123;</span><br><span class="line">        fmt.Println(n)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">5</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div><div id="donate"><link rel="stylesheet" type="text/css" href="/css/donate.css?v=1.0.0"><script type="text/javascript" src="/js/donate.js?v=1.0.0" successtext="复制成功!"></script><a class="pos-f tr3" id="github" href="https://github.com/clamyang" target="_blank" title="Github"></a><div id="DonateText">Donate</div><ul class="list pos-f" id="donateBox"><li id="AliPay" qr="/img/AliPayQR.jpg"></li><li id="WeChat" qr="/img/WeChatQR.jpg"></li></ul><div class="pos-f left-100" id="QRBox"><div id="MainBox"></div></div></div><div class="post-copyright"><script type="text/javascript" src="/js/copyright.js?v=1.0.0" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copyright.css?v=1.0.0"><p><span>本文标题：</span>go context</p><p><span>文章作者：</span>bqyang</p><p><span>发布时间：</span>2022-06-23</p><p><span>最后更新：</span>2022-06-24</p><p><span>原始链接：</span><a href="/2022/language/golang/go-context/">https://bqyang.top/2022/language/golang/go-context/</a><span class="copy-path"><i class="fa fa-clipboard" data-clipboard-text="https://bqyang.top/2022/language/golang/go-context/"></i></span></p><p><span>版权声明：</span>The author owns the copyright, please indicate the source reproduced.</p></div><br><div class="tags"></div><div class="post-nav"><a class="pre" href="/2022/language/golang/go-errors/">go error handling</a><a class="next" href="/2022/language/golang/go-ast/">初识 go ast</a></div><script src="https://utteranc.es/client.js" repo="clamyang/blogs" issue-term="title" theme="github-light" crossorigin="anonymous" async> </script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://bqyang.top"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2022/summary/about-221025/">刷题还是挺有意思的</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/socket/">使用 C 搭建 Server</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/epoll/">epoll 文档翻译</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/k8s/k8s/">搭建 Kubernetes 集群</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/language/golang/large-alloc/">Go 大对象分配探索</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/language/golang/memory-alloc/">Go 内存分配器</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/os/memory/free-space-manage/">free space management</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/k8s/k8s-storage-source-code/">k8s pv pvc 源码</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/design-pattern/Structural/composite/">组合模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/os/pstree/">简易版 pstree</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.xargin.com/" title="Xargin" target="_blank">Xargin</a><ul></ul><a href="https://mytechshares.com/" title="董泽润的技术笔记" target="_blank">董泽润的技术笔记</a><ul></ul><a href="https://hujingnb.com/" title="烟草的香味" target="_blank">烟草的香味</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2022 <a href="/." rel="nofollow">杨宝强的技术笔记.</a>Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://beian.miit.gov.cn/"> 京ICP备2021035561号.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>