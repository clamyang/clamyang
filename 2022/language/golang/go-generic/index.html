<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="一物不知深以为耻"><title>go-generic | 杨宝强的技术笔记</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><div class="darkmode-toggle">🌓</div><script>var prefersDarkMode = window.matchMedia('(prefers-color-scheme: dark)');
var toggle = document.querySelector('.darkmode-toggle');
var html = document.querySelector('html');

html.dataset.dark = localStorage.dark || prefersDarkMode.matches;

toggle.addEventListener('click', () => {
localStorage.dark = !(html.dataset.dark == 'true');
html.dataset.dark = localStorage.dark;
});</script><meta name="generator" content="Hexo 5.4.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">go-generic</h1><a id="logo" href="/.">杨宝强的技术笔记</a><p class="description">Coder Gopher Watcher</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">go-generic</h1><div class="post-meta">2022-06-06</div><div class="post-content"><p><img src="https://s2.loli.net/2022/06/06/LNYfsvCZwxeh3l9.png"></p>
<p>go 泛型学习，距离泛型的发布已经有很长一段时间了，之前大概看了下官方文档，说有些东西可能将来都会改变，不保证向前兼容，就没有具体了解，1.18也发了几个版本了，感觉再不努力又要被小伙伴们卷完了。</p>
<span id="more"></span>

<h2 id="困扰"><a href="#困扰" class="headerlink" title="困扰"></a>困扰</h2><p>没有泛型的时候带给我们的困扰（虽然没有亲身体会过，但是感觉很麻烦）</p>
<h3 id="Case-1"><a href="#Case-1" class="headerlink" title="Case 1"></a>Case 1</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Sum returns the sum of the provided arguments.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sum</span><span class="params">(args ...<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> sum <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(args); i++ &#123;</span><br><span class="line">        sum += args[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>要计算 n 数之和，如上述例子，如果这时要计算 int32, float64 类型元素的和呢？</p>
<p>通常情况下，我们需要进行 asserting type，或者为每种类型写不同的函数 <code>sumInt</code> <code>sumInt32</code> <code>sumInt64</code> 等，在源码中就有类似的代码。</p>
<h3 id="Case-2"><a href="#Case-2" class="headerlink" title="Case 2"></a>Case 2</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Declare &quot;host&quot; and &quot;port&quot; in order to create pointers to satisfy the</span></span><br><span class="line">    <span class="comment">// fields in the &quot;request&quot; struct.</span></span><br><span class="line">    host, port := <span class="string">&quot;local&quot;</span>, <span class="number">80</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(request&#123;</span><br><span class="line">        host: &amp;host,</span><br><span class="line">        port: &amp;port,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>This leads to cluttered, hard-to-read code where the only purpose variables serve is for deriving pointers.</p>
</blockquote>
<p>对每个变量进行取址操作，<em>我之前就写过这样的代码</em> ，为了取址不得不声明一个变量。</p>
<p>针对这种情况，可以实现不同的函数进行取址操作。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// PtrInt returns *i.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PtrInt</span><span class="params">(i <span class="keyword">int</span>)</span> *<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PtrStr returns *s.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PtrStr</span><span class="params">(s <span class="keyword">string</span>)</span> *<span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Use the two helper functions that return pointers to their provided</span></span><br><span class="line">    <span class="comment">// values. Remember, this pattern must scale with the number of distinct,</span></span><br><span class="line">    <span class="comment">// defined types that need to be passed by pointer instead of value.</span></span><br><span class="line">    <span class="built_in">print</span>(request&#123;</span><br><span class="line">        host: PtrStr(<span class="string">&quot;local&quot;</span>),</span><br><span class="line">        port: PtrInt(<span class="number">80</span>),</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>看起来可能比上边的优雅了一些，但是还不够，我们看下泛型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Ptr returns *value.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Ptr</span>[<span class="title">T</span> <span class="title">any</span>]<span class="params">(value T)</span> *<span class="title">T</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// No local variables and the typed helper functions can be collapsed into</span></span><br><span class="line">    <span class="comment">// a single, generic function for getting a pointer to a value.</span></span><br><span class="line">    <span class="built_in">print</span>(request&#123;</span><br><span class="line">        host: Ptr(<span class="string">&quot;local&quot;</span>),</span><br><span class="line">        port: Ptr(<span class="number">80</span>),</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>一方面是代码量减少了很多，另一方看是看起来更整洁。</p>
<h2 id="generic-语法"><a href="#generic-语法" class="headerlink" title="generic 语法"></a>generic 语法</h2><p>使用 <em>泛型</em> 重写这段代码</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Sum returns the sum of the provided arguments.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sum</span><span class="params">(args ...<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> sum <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(args); i++ &#123;</span><br><span class="line">        sum += args[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>泛型版本：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sum</span>[<span class="title">T</span> <span class="title">int</span>]<span class="params">(args ...T)</span> <span class="title">T</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> sum T</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(args); i++ &#123;</span><br><span class="line">        sum += args[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><code>[]</code> 是用来定义泛型的，常用的模式为 <code>[&lt;ID&gt; &lt;CONSTRAINT&gt;]</code></p>
<ul>
<li><code>&lt;ID&gt;</code> 是用来表示泛型的符号；</li>
<li><code>&lt;CONSTRAINT&gt;</code> 约束，表明可使用的具体类型，如上，只能使用 int；</li>
</ul>
<p>但是这时候我们想支持 int64 类型的 n 数和应该怎么办？</p>
<h3 id="Constraint"><a href="#Constraint" class="headerlink" title="Constraint"></a>Constraint</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sum</span>[<span class="title">T</span> <span class="title">int</span>|<span class="title">int64</span>]<span class="params">(args ...T)</span> <span class="title">T</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> sum T</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(args); i++ &#123;</span><br><span class="line">        sum += args[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>使用 <code>|</code> 运算符，这时，T 就可以满足 int 或者 int64，至于为什么使用 <code>|</code> 运算符不做过多考究。</p>
<p>但是这时还有一个小问题，如果说要支持更多的类型应该怎么做？难道要 <code>int|int32|int64</code> ? go 也给我们提供了相应的语法。</p>
<h4 id="any-constraint"><a href="#any-constraint" class="headerlink" title="any constraint"></a><code>any</code> constraint</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sum_any.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sum</span>[<span class="title">T</span> <span class="title">any</span>]<span class="params">(args ...T)</span> <span class="title">T</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> sum T</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(args); i++ &#123;</span><br><span class="line">        sum += args[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(Sum([]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;...))</span><br><span class="line">    fmt.Println(Sum([]<span class="keyword">int8</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;...))</span><br><span class="line">    fmt.Println(Sum([]<span class="keyword">uint32</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;...))</span><br><span class="line">    fmt.Println(Sum([]<span class="keyword">float64</span>&#123;<span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>&#125;...))      </span><br><span class="line">    fmt.Println(Sum([]<span class="keyword">complex128</span>&#123;<span class="number">1.1i</span>, <span class="number">2.2i</span>, <span class="number">3.3i</span>&#125;...))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>去执行试下，会意外的发现使用 <code>any</code> 其实行不通，原因是啥呢？</p>
<blockquote>
<p>./sum_any.go:11:3: invalid operation: operator + not defined on sum (variable of type T constrained by any)</p>
</blockquote>
<p> <code>+</code> 运算符并不是对所有的类型都生效。</p>
<p>既然这样，我们是不是可以声明一个东西，限定只能输数字类型的参数呢？</p>
<h4 id="Composite-constraints"><a href="#Composite-constraints" class="headerlink" title="Composite constraints"></a>Composite constraints</h4><p>复合类型</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Numeric expresses a type constraint satisfied by any numeric type.</span></span><br><span class="line"><span class="keyword">type</span> Numeric <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="keyword">uint</span> | <span class="keyword">uint8</span> | <span class="keyword">uint16</span> | <span class="keyword">uint32</span> | <span class="keyword">uint64</span> |</span><br><span class="line">    <span class="keyword">int</span> | <span class="keyword">int8</span> | <span class="keyword">int16</span> | <span class="keyword">int32</span> | <span class="keyword">int64</span> |</span><br><span class="line">    <span class="keyword">float32</span> | <span class="keyword">float64</span> |</span><br><span class="line">    <span class="keyword">complex64</span> | <span class="keyword">complex128</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sum returns the sum of the provided arguments.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sum</span>[<span class="title">T</span> <span class="title">Numeric</span>]<span class="params">(args ...T)</span> <span class="title">T</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> sum T</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(args); i++ &#123;</span><br><span class="line">        sum += args[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>下面这种情况如何处理？</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// id is a new type definition for an int64</span></span><br><span class="line"><span class="keyword">type</span> id <span class="keyword">int64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(Sum([]id&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;...))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>我们给 int64 起了个别名，这时候编译就会报错了，那我们应该怎样去识别别名呢？</p>
<h4 id="Tilde"><a href="#Tilde" class="headerlink" title="Tilde ~"></a>Tilde <code>~</code></h4><p>波浪号就是干这个事情的，举个例子，<code>~int</code> 表示：</p>
<ul>
<li>内置的 int 类型</li>
<li><code>type Integer int </code> 类型，起别名的类型</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Numeric <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="keyword">uint</span> | <span class="keyword">uint8</span> | <span class="keyword">uint16</span> | <span class="keyword">uint32</span> | <span class="keyword">uint64</span> |</span><br><span class="line">    <span class="comment">// 调整如下</span></span><br><span class="line">    <span class="keyword">int</span> | <span class="keyword">int8</span> | <span class="keyword">int16</span> | <span class="keyword">int32</span> | ~<span class="keyword">int64</span> |</span><br><span class="line">    <span class="keyword">float32</span> | <span class="keyword">float64</span> |</span><br><span class="line">    <span class="keyword">complex64</span> | <span class="keyword">complex128</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Type-inference"><a href="#Type-inference" class="headerlink" title="Type inference"></a>Type inference</h3><ul>
<li><input disabled="" type="checkbox"> <a target="_blank" rel="noopener" href="https://go.googlesource.com/proposal/+/refs/heads/master/design/43651-type-parameters.md">Type Parameters Proposal</a> 待阅读</li>
</ul>
<ul>
<li>Type inference is a convenience feature</li>
<li>The Go compiler tries <em>really</em> hard to infer the intended types, but it does not always work when you think it should</li>
<li>If you are not sure why something written generically is not working, try providing the types explicitly</li>
</ul>
<h3 id="Explicit-types"><a href="#Explicit-types" class="headerlink" title="Explicit types"></a>Explicit types</h3><p>显示指定类型</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(Sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line">    fmt.Println(Sum([]id&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;...))</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Generic types can be specified explicitly by invoking a function</span></span><br><span class="line">    <span class="comment">// with the bracket notation and the list of types to use. Because</span></span><br><span class="line">    <span class="comment">// the Sum function only has a single, generic type -- &quot;T&quot; -- the</span></span><br><span class="line">    <span class="comment">// call &quot;Sum[float64]&quot; means that &quot;T&quot; will be replaced by &quot;float64&quot;</span></span><br><span class="line">    <span class="comment">// when compiling the code. Since the values &quot;1&quot; and &quot;2&quot; can both</span></span><br><span class="line">    <span class="comment">// be treated as &quot;float64,&quot; the code is valid.</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// go 类型推断为 int 类型，但是后续出现了浮点数，导致失败。</span></span><br><span class="line">    <span class="comment">// 我们可以明确规定这个为 浮点数类型。</span></span><br><span class="line">    fmt.Println(Sum[<span class="keyword">float64</span>](<span class="number">1</span>, <span class="number">2</span>, <span class="number">3.0</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Multiple-generic-types"><a href="#Multiple-generic-types" class="headerlink" title="Multiple generic types"></a>Multiple generic types</h3><p>到这里为止，接触到的都是接收单一参数的函数，这里学习下怎么接收多个泛型参数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// PrintIDAndSum prints the provided ID and sum of the given values to stdout.</span></span><br><span class="line"><span class="comment">// 应该还记得 ~ 的用法吧，适配类型别名</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PrintIDAndSum</span>[<span class="title">T</span> ~<span class="title">string</span>, <span class="title">K</span> <span class="title">Numeric</span>]<span class="params">(id T, sum SumFn[K], values ...K)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The format string uses &quot;%v&quot; to emit the sum since using &quot;%d&quot; would</span></span><br><span class="line">    <span class="comment">// be invalid if the value type was a float or complex variant.</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%s has a sum of %v\n&quot;</span>, id, sum(values...))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>注意</p>
</blockquote>
<p>在调用这个函数时仍需要显示指定 <code>sum</code> 的类型，<code>PrintIDAndSum(&quot;xx&quot;, Sum[int32], 1, 2, 3)</code> ，如果没有指定类型，就会报错：<code>./mulgen.go:12:22: cannot use generic function Sum without instantiation</code></p>
<h3 id="Declaring-a-new-instance-of-T-with-var"><a href="#Declaring-a-new-instance-of-T-with-var" class="headerlink" title="Declaring a new instance of T with var"></a>Declaring a new instance of <code>T</code> with <code>var</code></h3><p>这里跟在上述 sum 中声明变量没什么区别。</p>
<h3 id="Declaring-a-new-instance-of-T-with-new"><a href="#Declaring-a-new-instance-of-T-with-new" class="headerlink" title="Declaring a new instance of T with new"></a>Declaring a new instance of <code>T</code> with <code>new</code></h3><p>new 之后的变量会被分配地址，不再是 nil。</p>
<h3 id="Structs"><a href="#Structs" class="headerlink" title="Structs"></a>Structs</h3><p>将泛型和结构体结合使用，不难看出语法上和函数定义大差不差。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Ledger[T ~<span class="keyword">string</span>, K Numeric] <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID 		T</span><br><span class="line">    Amounts []k</span><br><span class="line">    SumFn	SumFn[K]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>为泛型结构体添加方法，正因为结构体中有泛型，所以在声明方法时也要导入<strong>相应的符号，约束不需要</strong>，因为是为了类型推断使用。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l Ledger[T, K])</span> <span class="title">PrintIDAndSum</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%s has a sum of %v\n&quot;</span>, l.ID, l.SumFn(l.Amounts...))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>简单示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// generic struct</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Numeric <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> | <span class="keyword">int32</span> | <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Ledger[T ~<span class="keyword">string</span>, K Numeric] <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID T</span><br><span class="line">    Amounts []K</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l Ledger[T, K])</span> <span class="title">PrintA</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(l.ID)</span><br><span class="line">    <span class="built_in">print</span>(l.Amounts)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Ledger[<span class="keyword">string</span>, <span class="keyword">int</span>]&#123;</span><br><span class="line">        ID: <span class="string">&quot;test-qq&quot;</span>,</span><br><span class="line">        Amounts: []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>,<span class="number">3</span>&#125;,</span><br><span class="line">    &#125;.PrintA()</span><br><span class="line"></span><br><span class="line">    Ledger[<span class="keyword">string</span>, <span class="keyword">int32</span>]&#123;</span><br><span class="line">        ID: <span class="string">&quot;test-qq&quot;</span>,</span><br><span class="line">        Amounts: []<span class="keyword">int32</span>&#123;<span class="number">1</span>, <span class="number">2</span>,<span class="number">3</span>&#125;,</span><br><span class="line">    &#125;.PrintA()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Structural-Constraints"><a href="#Structural-Constraints" class="headerlink" title="Structural Constraints"></a>Structural Constraints</h4><p>这个特性还存在一些问题，泛型的结构体暂时禁止访问字段，其实感觉挺一般的，既然更版本了为啥不做好、做完善呢？</p>
<p>…</p>
<p><strong>匿名结构体</strong></p>
<p>如果说要接收任意包含这三个字段的结构体（即 Ledger 的实例），需要像下面这样实现，<strong>所有的结构体都实现了匿名结构体</strong>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SomeFunc</span>[</span></span><br><span class="line">    T ~<span class="keyword">string</span>,</span><br><span class="line">    K Numeric,</span><br><span class="line">    L ~<span class="keyword">struct</span> &#123;</span><br><span class="line">        ID      T</span><br><span class="line">        Amounts []K</span><br><span class="line">        SumFn   SumFn[K]</span><br><span class="line">    &#125;,</span><br><span class="line">](l L) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    SomeFunc[<span class="keyword">string</span>, <span class="keyword">int</span>, Ledger[<span class="keyword">string</span>, <span class="keyword">int</span>]](Ledger[<span class="keyword">string</span>, <span class="keyword">int</span>]&#123;</span><br><span class="line">        ID:      <span class="string">&quot;acct-1&quot;</span>,</span><br><span class="line">        Amounts: []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,</span><br><span class="line">        SumFn:   Sum[<span class="keyword">int</span>],</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>Structural constraints must match the struct <em>exactly</em>, and this means even if all of the fields in the constraint are present, the presence of additional fields in the provided value means the type does not satisfy the constraint.</p>
</blockquote>
<p>这里可以暂时不考虑，后续待官方完善了再学也不迟，毕竟现在工作中用不到这些东西..</p>
<h3 id="Interface-constraints"><a href="#Interface-constraints" class="headerlink" title="Interface constraints"></a>Interface constraints</h3><p>接口约束之前已经见过了， <code>Numeric</code>  限制了类型只能是 <code>int int32 int64</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Numeric <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> | <span class="keyword">int32</span> | <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于结构体来说，想通过接口调用方法，需要在上述那样的基础上再添加上方法。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Ledgerish expresses a constraint that may be satisfied by types that have</span></span><br><span class="line"><span class="comment">// ledger-like qualities.</span></span><br><span class="line"><span class="keyword">type</span> Ledgerish[T ~<span class="keyword">string</span>, K Numeric] <span class="keyword">interface</span> &#123;</span><br><span class="line">    ~<span class="keyword">struct</span> &#123;</span><br><span class="line">        ID      T</span><br><span class="line">        Amounts []K</span><br><span class="line">        SumFn   SumFn[K]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PrintIDAndSum()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Careful-Constructs"><a href="#Careful-Constructs" class="headerlink" title="Careful Constructs"></a>Careful Constructs</h3><h3 id="Internals"><a href="#Internals" class="headerlink" title="Internals"></a>Internals</h3><h4 id="Type-erasure"><a href="#Type-erasure" class="headerlink" title="Type erasure"></a>Type erasure</h4><p>在了解 Go 中泛型是怎么做到运行时安全前，先了解一下类型擦除。</p>
<p>Wiki 上的定义是：<em>the load-time process by which explicit type annotations are removed from a program before it is executed at run-time</em></p>
<p>翻译过来就是，程序在运行时执行前，进程显示的将类型注解从程序中移除掉。（自己翻译的）</p>
<p>伪代码演示如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ints = List&lt;Int32&gt;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">var</span> strs = List&lt;String&gt;&#123;<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;world&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Type erasure</strong> 执行后</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ints = List&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">var</span> strs = List&#123;<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;world&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>这两个的唯一区别就是将类型擦除掉了，这个特性在很多流行的编程语言中都有。</p>
<h5 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h5><p>java 中 type erasure 的体现：<a target="_blank" rel="noopener" href="https://github.com/akutz/go-generics-the-hard-way/blob/main/05-internals/01-type-erasure/02-java.md">java-type-erasure</a></p>
<h5 id="Net"><a href="#Net" class="headerlink" title=".Net"></a>.Net</h5><p>.Net 中 type erasure 的体现：<a target="_blank" rel="noopener" href="https://github.com/akutz/go-generics-the-hard-way/blob/main/05-internals/01-type-erasure/03-dotnet.md">.Net-type-erasure</a></p>
<h5 id="Golang"><a href="#Golang" class="headerlink" title="Golang"></a>Golang</h5><p>Go 中 type erasure 的体现：<a target="_blank" rel="noopener" href="https://github.com/akutz/go-generics-the-hard-way/blob/main/05-internals/01-type-erasure/04-golang.md">Golang-type-erasure</a> ，这里介绍到，Go中没有反省模板，list 中保留的仍是具体类型，不像 JAVA 中翻译成 object。</p>
<h4 id="Runtime-safety"><a href="#Runtime-safety" class="headerlink" title="Runtime-safety"></a>Runtime-safety</h4><p>关于泛型这里我一直有个疑问，比如我们定义了一个泛型数组，使用 Go 代码声明如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> List[T any] []T</span><br></pre></td></tr></table></figure>

<p>假设我们在初始化的时候使用 int，但是后续执行 append 操作的时候加一个 string 能不能行得通？<strong>显然在 Go  中并不行</strong>。那么在其他语言中呢？</p>
<h5 id="JAVA-1"><a href="#JAVA-1" class="headerlink" title="JAVA"></a>JAVA</h5><p><a target="_blank" rel="noopener" href="https://github.com/akutz/go-generics-the-hard-way/blob/main/05-internals/02-runtime-type-safety/01-java.md">java-runtime-safety</a> 从这里不难看出，java 中擦出了初始化泛型的信息，很难保持在 runtime 时安全。</p>
<h5 id="NET"><a href="#NET" class="headerlink" title=".NET"></a>.NET</h5><p><a target="_blank" rel="noopener" href="https://github.com/akutz/go-generics-the-hard-way/blob/main/05-internals/02-runtime-type-safety/02-dotnet.md">.NET-runtime-safety</a> 这里保持了泛型的相关信息，所以在运行时是安全的。</p>
<h5 id="Golang-1"><a href="#Golang-1" class="headerlink" title="Golang"></a>Golang</h5><p><a target="_blank" rel="noopener" href="https://github.com/akutz/go-generics-the-hard-way/blob/main/05-internals/02-runtime-type-safety/03-golang.md">Golang-runtime-safety</a> 通过前面的内容我们知道，Go 中没有进行 type erasure，所以也可以做到 runtime 时安全。</p>
<h4 id="Runtime-instantiation"><a href="#Runtime-instantiation" class="headerlink" title="Runtime-instantiation"></a>Runtime-instantiation</h4><blockquote>
<p>The ability to instantiate new types using generics at runtime，在运行时使用泛型初始化的能力。</p>
</blockquote>
<p>我觉得，如果要支持运行时初始化的能力，需要具备动态推断类型的能力，在运行时检测泛型是哪种类型。</p>
<h5 id="JAVA-2"><a href="#JAVA-2" class="headerlink" title="JAVA"></a>JAVA</h5><p><a target="_blank" rel="noopener" href="https://github.com/akutz/go-generics-the-hard-way/blob/main/05-internals/03-runtime-instantiation/01-java.md">java-runtime-instantiation</a> 不支持，Java中的泛型纯粹是编译时特性。</p>
<h5 id="NET-1"><a href="#NET-1" class="headerlink" title=".NET"></a>.NET</h5><p><a target="_blank" rel="noopener" href="https://github.com/akutz/go-generics-the-hard-way/blob/main/05-internals/03-runtime-instantiation/02-dotnet.md">.NET-runtime-instantiation</a> 支持.. 这么一看.. .NET 还是牛逼..我有个大学同学人家都是 JAVA，Python，这兄弟学了两年 .NET 哈哈哈哈，后来由于比较冷门，也放弃了哈哈。</p>
<h5 id="Golang-2"><a href="#Golang-2" class="headerlink" title="Golang"></a>Golang</h5><p><a target="_blank" rel="noopener" href="https://github.com/akutz/go-generics-the-hard-way/blob/main/05-internals/03-runtime-instantiation/03-golang.md">golang-runtime-instantiation</a> 不支持，Go 中的泛型同 java 一样都是编译时的特性，在编译时就确定好了类型。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><table>
<thead>
<tr>
<th></th>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td align="center">Compile-time type safety</td>
<td align="center">Type erasure</td>
<td align="center">Runtime type safety</td>
<td align="center">Runtime instantiation</td>
</tr>
<tr>
<td>Java</td>
<td align="center">✓</td>
<td align="center">✓</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td>.NET</td>
<td align="center">✓</td>
<td align="center"></td>
<td align="center">✓</td>
<td align="center">✓</td>
</tr>
<tr>
<td>Go</td>
<td align="center">✓</td>
<td align="center"></td>
<td align="center">✓</td>
<td align="center"></td>
</tr>
</tbody></table>
<p>至此，泛型的学习就告一段落了，学到了语法，如何使用，已经在某些简单的场景下使用泛型带来的便利性。也或多或少的了解到了其他语言的泛型特性。</p>
<p>参考链接：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://github.com/akutz/go-generics-the-hard-way/">go-generics-the-hard-way</a></li>
</ol>
</div><div id="donate"><link rel="stylesheet" type="text/css" href="/css/donate.css?v=1.0.0"><script type="text/javascript" src="/js/donate.js?v=1.0.0" successtext="复制成功!"></script><a class="pos-f tr3" id="github" href="https://github.com/clamyang" target="_blank" title="Github"></a><div id="DonateText">Donate</div><ul class="list pos-f" id="donateBox"><li id="AliPay" qr="/img/AliPayQR.jpg"></li><li id="WeChat" qr="/img/WeChatQR.jpg"></li></ul><div class="pos-f left-100" id="QRBox"><div id="MainBox"></div></div></div><div class="post-copyright"><script type="text/javascript" src="/js/copyright.js?v=1.0.0" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copyright.css?v=1.0.0"><p><span>本文标题：</span>go-generic</p><p><span>文章作者：</span>bqyang</p><p><span>发布时间：</span>2022-06-06</p><p><span>最后更新：</span>2022-06-07</p><p><span>原始链接：</span><a href="/2022/language/golang/go-generic/">https://bqyang.top/2022/language/golang/go-generic/</a><span class="copy-path"><i class="fa fa-clipboard" data-clipboard-text="https://bqyang.top/2022/language/golang/go-generic/"></i></span></p><p><span>版权声明：</span>The author owns the copyright, please indicate the source reproduced.</p></div><br><div class="tags"></div><div class="post-nav"><a class="pre" href="/2022/design-pattern/UML/first-uml/">UML 类图</a><a class="next" href="/2022/language/golang/go-ast/">初识 go-ast</a></div><script src="https://utteranc.es/client.js" repo="clamyang/blog_comments" issue-term="title" theme="github-light" crossorigin="anonymous" async> </script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://bqyang.top"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2022/design-pattern/Behavioral/templete-method/">模板方法</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/language/golang/go-context/">go-context</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/design-pattern/factory-method/">工厂方法模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/design-pattern/proxyAndDecorator/">代理模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/language/golang/go-errors/">go-error-handling</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/design-pattern/principle/">面向对象五大原则</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/design-pattern/strategy/">策略模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/design-pattern/easy-factory/">简单工厂模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/design-pattern/UML/first-uml/">UML 类图</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/language/golang/go-generic/">go-generic</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.xargin.com/" title="Xargin" target="_blank">Xargin</a><ul></ul><a href="https://mytechshares.com/" title="董泽润的技术笔记" target="_blank">董泽润的技术笔记</a><ul></ul><a href="https://hujingnb.com/" title="烟草的香味" target="_blank">烟草的香味</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2022 <a href="/." rel="nofollow">杨宝强的技术笔记.</a>Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://beian.miit.gov.cn/"> 京ICP备2021035561号.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>