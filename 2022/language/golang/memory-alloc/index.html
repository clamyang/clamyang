<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="一物不知深以为耻"><title>Go 内存分配器 | 杨宝强的技术笔记</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><div class="darkmode-toggle">🌓</div><script>var prefersDarkMode = window.matchMedia('(prefers-color-scheme: dark)');
var toggle = document.querySelector('.darkmode-toggle');
var html = document.querySelector('html');

html.dataset.dark = localStorage.dark || prefersDarkMode.matches;

toggle.addEventListener('click', () => {
localStorage.dark = !(html.dataset.dark == 'true');
html.dataset.dark = localStorage.dark;
});</script><meta name="generator" content="Hexo 5.4.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Go 内存分配器</h1><a id="logo" href="/.">杨宝强的技术笔记</a><p class="description">Gopher Watcher</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Go 内存分配器</h1><div class="post-meta">2022-07-22</div><div class="post-content"><p><img src="https://s2.loli.net/2022/07/24/SYqz9rCngZNVdAp.png"></p>
<p>梳理 Golang 内存分配器，以前通过代码调试过，有了一个初步的认识，这次把一些细节性的东西都梳理出来了，发现自己对内存分配的过程有了更清晰的认识，很多内容靠脑子想还是太费事了，就咱这个“处理器”差一点就烧坏了.. 把图画出来能够有效的缓解大脑负载..</p>
<span id="more"></span>

<h2 id="Unmanaged-memory（堆外内存）"><a href="#Unmanaged-memory（堆外内存）" class="headerlink" title="Unmanaged memory（堆外内存）"></a>Unmanaged memory（堆外内存）</h2><p>在看 Go 内存源码部分的时候，涉及到管理内存的相关数据结构时，总能看到这样一行 comment， <code>go:notinheap</code> 就感觉挺奇怪的，内存地址空间除了堆就是栈，那要存储在哪里呢？</p>
<p>GC 扫描的时候是不需要对堆外内存进行扫描的，官方给出了堆外内存存在的两个必要性：</p>
<ul>
<li>当这块内存是 memory manager 本身时。</li>
<li>在调用者没有 P 的情况下分配，调度器初始化之前是不存在 P 的。</li>
</ul>
<p>同时，官方也给出了声明 unmanaged memory 的三种方式</p>
<ol>
<li>sysAlloc</li>
<li>persistentalloc</li>
<li>fixalloc</li>
</ol>
<h3 id="go-notinheap"><a href="#go-notinheap" class="headerlink" title="go:notinheap"></a>go:notinheap</h3><p>类型声明的时候使用，表示这个对象禁止在 gc 扫描的堆上或者栈上分配。尤其是，指向这个对象的指针在 <code>runtime.inheap</code> 检查时总是返回假。</p>
<blockquote>
<p>go:notinheap 真正的意义：runtime 在某些底层数据结构上使用，避免了内存屏障，提高了性能。</p>
</blockquote>
<h2 id="basic-concept"><a href="#basic-concept" class="headerlink" title="basic concept"></a>basic concept</h2><p>Go 语言中的内存管理同 tcmalloc 类似，将从操作系统那里得到的内存按照大小不同的块进行管理，形如<code>segregated list</code>，<code>mspan</code> 是 Go 语言中最基本的内存管理单元。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//go:notinheap</span></span><br><span class="line"><span class="keyword">type</span> mspan <span class="keyword">struct</span> &#123;</span><br><span class="line">    next *mspan     <span class="comment">// next span in list, or nil if none</span></span><br><span class="line">    prev *mspan     <span class="comment">// previous span in list, or nil if none</span></span><br><span class="line">    <span class="comment">// ... 省略了大量字段</span></span><br><span class="line">    <span class="comment">// 指向了实际的 chunk</span></span><br><span class="line">    tiny       <span class="keyword">uintptr</span></span><br><span class="line">    <span class="comment">// 表明这个 chunk 用了多少</span></span><br><span class="line">    tinyoffset <span class="keyword">uintptr</span></span><br><span class="line">    <span class="comment">// 表明 tiny allocation 执行的次数</span></span><br><span class="line">    tinyAllocs <span class="keyword">uintptr</span></span><br><span class="line">    alloc [numSpanClasses]*mspan <span class="comment">// spans to allocate from, indexed by spanClass</span></span><br><span class="line">    startAddr <span class="keyword">uintptr</span> <span class="comment">// address of first byte of span aka s.base()</span></span><br><span class="line">    npages    <span class="keyword">uintptr</span> <span class="comment">// number of pages in span</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每一次分配，都会从 freeindex 开始扫描 allocbits</span></span><br><span class="line">    <span class="comment">// 直到遇到 0，说明这是一个空闲块。</span></span><br><span class="line">    <span class="comment">// 当 freeindex == nelemes 时，说明该 mspan 满了</span></span><br><span class="line">    <span class="comment">// 当 n &gt;= freeindex and allocBits[n/8] &amp; (1&lt;&lt;(n%8)) is 0</span></span><br><span class="line">    <span class="comment">// 说明 object n 是空闲的</span></span><br><span class="line">    freeindex <span class="keyword">uintptr</span></span><br><span class="line"></span><br><span class="line">    nelems <span class="keyword">uintptr</span> <span class="comment">// number of object in the span.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// allocBits 的补码</span></span><br><span class="line">    allocCache <span class="keyword">uint64</span></span><br><span class="line"></span><br><span class="line">    allocBits  *gcBits</span><br><span class="line">    gcmarkBits *gcBits</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已经分配的对象数量</span></span><br><span class="line">    allocCount  <span class="keyword">uint16</span></span><br><span class="line">    spanclass   spanClass     <span class="comment">// size class and noscan (uint8)</span></span><br><span class="line"></span><br><span class="line">    elemsize    <span class="keyword">uintptr</span>       <span class="comment">// computed from sizeclass or from npages</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里把该数据结构中有关内存分配相关的字段截取出来，不难看出，该结构体通过 <code>next</code> <code>prev</code> 构成了一个双向链表的数据结构。在整个内存分配过程中，是没有用到这两个字段的，他们的具体作用还有待考究。</p>
<p><code>mspan</code> 中包含了很多个 chunk，更像是一个数组，正如数组的定义一样，内部的元素是 size 相同的 chunk，如下图：</p>
<p><img src="https://s2.loli.net/2022/07/23/IGgUj3sm2NnwpKb.png"></p>
<p>Go 中的 pages 是 OS page 的整数倍，通常每个页面为 8KB。图中的 <code>mspan</code> 由 5 个 page 组成，5 * 8 = 40 KB，我们申请一个 10KB 的切片 <code>slice := make([]byte, 10240)</code> </p>
<p><img src="https://s2.loli.net/2022/07/23/DRVmvIzYd9jJGOL.png"></p>
<p>详细的步骤我们一步步展开，你可能已经注意到了，图中标识了当前 <code>mspan</code> 的 <code>spanclass = 109</code>，我这里的 go 版本为：<code>1.16</code> 有 136 种 spanclass，更进一步，spanclass 分为了：</p>
<ul>
<li><p>scan class</p>
<p>需要扫描的类别，那什么情况下需要使用 scan class 呢？当 chunk 中有指针时，就需要使用 scan class。</p>
</li>
<li><p>noscan class</p>
<p>通常来讲标量类型都是不需要扫描的。</p>
</li>
</ul>
<p>spanclass 其实就是 uint8 的一个别名，通过最后一个 bit 进行判断：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sc spanClass)</span> <span class="title">noscan</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> sc&amp;<span class="number">1</span> != <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 <code>sc&amp;1 != 0</code> 就可以判断出：</p>
<ul>
<li>spanclass为偶数时，需要</li>
<li>spanclass为奇数时，不需要</li>
</ul>
<h3 id="Tiny-Small-Large"><a href="#Tiny-Small-Large" class="headerlink" title="Tiny Small Large"></a>Tiny Small Large</h3><p>Go 把内存对象分成三类</p>
<table>
<thead>
<tr>
<th>对象</th>
<th>范围</th>
</tr>
</thead>
<tbody><tr>
<td>Tiny</td>
<td>(0, 16 B)</td>
</tr>
<tr>
<td>Small</td>
<td>[16 B, 32 KB]</td>
</tr>
<tr>
<td>Large</td>
<td>(32 KB, +∞)</td>
</tr>
</tbody></table>
<p>在上边的例子中，我们创建了一个 small object，那么为什么要根据对象大小进行区分呢？为了 alloc performance。</p>
<h3 id="Mcache-Mcentral-Mheap"><a href="#Mcache-Mcentral-Mheap" class="headerlink" title="Mcache Mcentral Mheap"></a>Mcache Mcentral Mheap</h3><p>这里就是它借鉴了 tcmalloc 中的一点，实现了线程缓存，这样在每个线程上分配时就不需要加锁。当本地处理不了时就需要向上一层一层尝试，当 mheap 都分配不出来了，说明内存用光了。</p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">mcache</td>
<td>线程缓存<br />用于 tiny,small 对象的分配</td>
</tr>
<tr>
<td align="left">mcentral</td>
<td>中心缓存<br />当 mcache 中没有足够空间时会用到 mcentral</td>
</tr>
<tr>
<td align="left">mheap</td>
<td>堆上内存<br />当 mcentral 中没有足够空间时会用到 mheap<br /></td>
</tr>
</tbody></table>
<ul>
<li><p>mcache 中比较重要的字段</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//go:notinheap</span></span><br><span class="line"><span class="keyword">type</span> mcache <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// ... 省略了大量字段</span></span><br><span class="line">    <span class="comment">// 指向了实际的 chunk，负责 tiny 对象的分配</span></span><br><span class="line">    tiny       <span class="keyword">uintptr</span></span><br><span class="line">    <span class="comment">// 表明这个 chunk 用了多少</span></span><br><span class="line">    tinyoffset <span class="keyword">uintptr</span></span><br><span class="line">    <span class="comment">// 表明 tiny allocation 执行的次数</span></span><br><span class="line">    tinyAllocs <span class="keyword">uintptr</span></span><br><span class="line">    <span class="comment">// 负责 small 对象的分配</span></span><br><span class="line">    alloc [numSpanClasses]*mspan <span class="comment">// spans to allocate from, indexed by spanClass</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>当我们学习 large 对象分配的时候再深入研究 mcentral mheap 也不迟</p>
</li>
</ul>
<h2 id="Allocator"><a href="#Allocator" class="headerlink" title="Allocator"></a>Allocator</h2><p>有了基本的概念，我们就可以更深入的了解内存分配器是如何工作的，首先我们要探索的是 <code>tiny allocator</code> ，如果你写不出合适的单元测试，那么官方的 test 就是你的最佳选择。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestTinyAlloc</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    <span class="keyword">const</span> N = <span class="number">16</span></span><br><span class="line">    <span class="keyword">var</span> v [N]unsafe.Pointer</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> v &#123;</span><br><span class="line">        v[i] = unsafe.Pointer(<span class="built_in">new</span>(<span class="keyword">byte</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    chunks := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">uintptr</span>]<span class="keyword">bool</span>, N)</span><br><span class="line">    <span class="keyword">for</span> _, p := <span class="keyword">range</span> v &#123;</span><br><span class="line">        <span class="comment">// a &amp;^ b 的意思就是 清零a中，ab都为1的位</span></span><br><span class="line">        <span class="comment">// 0110 &amp;^ 1011 -&gt; 0100</span></span><br><span class="line">        <span class="comment">// 按照 8 字节进行对齐</span></span><br><span class="line">        chunks[<span class="keyword">uintptr</span>(p)&amp;^<span class="number">7</span>] = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(chunks) == N &#123;</span><br><span class="line">        t.Fatal(<span class="string">&quot;no bytes allocated within the same 8-byte chunk&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>tiny allocator</code> 在分配前需要根据 size 计算字节对齐，然后移动 tinyoff 的位置，如果 size 是 8 的倍数，就按照 8 字节对齐，4 的倍数就按照 4 字节对齐，2 的倍数就按照 2 字节对齐。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// alignUp rounds n up to a multiple of a. a must be a power of 2.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">alignUp</span><span class="params">(n, a <span class="keyword">uintptr</span>)</span> <span class="title">uintptr</span></span> &#123;</span><br><span class="line">    <span class="comment">// &amp;^ bit clear</span></span><br><span class="line">    <span class="keyword">return</span> (n + a - <span class="number">1</span>) &amp;^ (a - <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于 Allocator 来说，最重要的特性就是<strong>性能</strong>，<code>mallocgc</code> 中会通过位图来提升分配器的性能。</p>
<p>需要注意的一点是，我们虽然可以通过 allocCache 加速在 <code>mspan</code> 查找空闲内存块的速度，但是<strong>一个 allocCache</strong>最多只能表示 64 个内存块的使用情况，像前面的 tiny  对象，一个 page （8K） 中有 512 个 16 Byte 的对象，这时该怎么办呢？</p>
<p>我们应该去研究具体的查找过程，即 <code>nextFreeFast nextFree nextFreeIndex</code>:</p>
<ul>
<li><p>nextFreeFast (fastPath)</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fastPath </span></span><br><span class="line"><span class="comment">// 假设 allocCache 为 0001 1111 1....1 （共 64 位） 这是一个已经分配了三次的 allocCache</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nextFreeFast</span><span class="params">(s *mspan)</span> <span class="title">gclinkptr</span></span> &#123;</span><br><span class="line">    <span class="comment">// 计算当前 allocCache 第一个未被使用的内存块位置</span></span><br><span class="line">    <span class="comment">// 0 使用，1 未使用</span></span><br><span class="line">    theBit := sys.Ctz64(s.allocCache)</span><br><span class="line">    <span class="comment">// 64 的原因上边有提到，uint64 只能表示 64 个内存块</span></span><br><span class="line">    <span class="comment">// 如果 theBit == 64 说明该位图对应的所有内存块都被使用了</span></span><br><span class="line">    <span class="comment">// 如果 theBit &lt; 64 说明还有内存块未被使用</span></span><br><span class="line">    <span class="keyword">if</span> theBit &lt; <span class="number">64</span> &#123;</span><br><span class="line">        <span class="comment">// result 代表的是空闲内存块的索引</span></span><br><span class="line">        result := s.freeindex + <span class="keyword">uintptr</span>(theBit)</span><br><span class="line">        <span class="keyword">if</span> result &lt; s.nelems &#123;</span><br><span class="line">            <span class="comment">// 下一次 alloc 开始查找的位置</span></span><br><span class="line">            freeidx := result + <span class="number">1</span></span><br><span class="line">            <span class="comment">// 解释请见下面内容</span></span><br><span class="line">            <span class="keyword">if</span> freeidx%<span class="number">64</span> == <span class="number">0</span> &amp;&amp; freeidx != s.nelems &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">            s.allocCache &gt;&gt;= <span class="keyword">uint</span>(theBit + <span class="number">1</span>)</span><br><span class="line">            s.freeindex = freeidx</span><br><span class="line">            s.allocCount++</span><br><span class="line">            <span class="keyword">return</span> gclinkptr(result*s.elemsize + s.base())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以 spancalss=5 的 mspan 举例：</p>
<p><img src="https://s2.loli.net/2022/07/24/jLlNhRDOP6us3Yd.png"></p>
<p>还是挺清晰的吧，fastPath 就是检查当前这 64 个内存块有没有空闲的，没找到就走 slowPath，找到了则更新allocCache 对应的 bit，将 freeIndex 指向下一个位置，方便下一次分配的查找，更新当前 mspan 已经分配的次数。</p>
<p><code>freeidx%64 == 0 &amp;&amp; freeidx != s.nelems</code> 的意思是：当 freeIndex 指向 allocCache 之外且不是最后一个对象时，fastPath 也是走不通的。 这里主要就是理解 freeIndex 的起始编号为 0，表示这 64 个比特位只需要 0-63，如果对 64 取模为 0 说明已经超过当前 allocCache 的管辖范围了，且当前 allocCache 对应的内存块都被用光了。</p>
<p>那我们就需要更新 allocCache 中的内容，使其指向下一个 64 位的 cache bit。以 tinyAllocator 为例，每次分配  1 字节，我们需要分配 1024 次才能达到这个阈值（前提是这个 mspan是空的）。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">*runtime.mspan &#123;</span><br><span class="line">    startAddr: <span class="number">824633810944</span>,</span><br><span class="line">    npages: <span class="number">1</span>,</span><br><span class="line">    manualFreeList: <span class="number">0</span>,</span><br><span class="line">    freeindex: <span class="number">63</span>,</span><br><span class="line">    nelems: <span class="number">512</span>,</span><br><span class="line">    allocCache: <span class="number">1</span>,</span><br><span class="line">    allocCount: <span class="number">63</span>,</span><br><span class="line">    spanclass: tinySpanClass (<span class="number">5</span>),</span><br><span class="line">    elemsize: <span class="number">16</span>,</span><br><span class="line">    limit: <span class="number">824633819136</span>&#125;</span><br></pre></td></tr></table></figure>

<p>如上 mspan，我们已经使用它分配了 63 个对象（0-62），本次分配的空闲块索引为 63，下一次内存分配的索引为 64，即 <code>freeidx%64 == 0 &amp;&amp; freeidx != s.nelems</code> 条件成立，只能走 slowPath 了。</p>
</li>
<li><p>nextFree (slowPath)</p>
<p>nextFree 中处理 allocCache 的主要逻辑在 <code>s.nextFreeIndex</code> 中</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *mcache)</span> <span class="title">nextFree</span><span class="params">(spc spanClass)</span> <span class="params">(v gclinkptr, s *mspan, shouldhelpgc <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    s = c.alloc[spc]</span><br><span class="line">    shouldhelpgc = <span class="literal">false</span></span><br><span class="line">    freeIndex := s.nextFreeIndex()</span><br><span class="line">    <span class="keyword">if</span> freeIndex == s.nelems &#123;</span><br><span class="line">        <span class="comment">// The span is full.</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">uintptr</span>(s.allocCount) != s.nelems &#123;</span><br><span class="line">            <span class="built_in">println</span>(<span class="string">&quot;runtime: s.allocCount=&quot;</span>, s.allocCount, <span class="string">&quot;s.nelems=&quot;</span>, s.nelems)</span><br><span class="line">            throw(<span class="string">&quot;s.allocCount != s.nelems &amp;&amp; freeIndex == s.nelems&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        c.refill(spc)</span><br><span class="line">        shouldhelpgc = <span class="literal">true</span></span><br><span class="line">        s = c.alloc[spc]</span><br><span class="line"></span><br><span class="line">        freeIndex = s.nextFreeIndex()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> freeIndex &gt;= s.nelems &#123;</span><br><span class="line">        throw(<span class="string">&quot;freeIndex is not valid&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    v = gclinkptr(freeIndex*s.elemsize + s.base())</span><br><span class="line">    s.allocCount++</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">uintptr</span>(s.allocCount) &gt; s.nelems &#123;</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">&quot;s.allocCount=&quot;</span>, s.allocCount, <span class="string">&quot;s.nelems=&quot;</span>, s.nelems)</span><br><span class="line">        throw(<span class="string">&quot;s.allocCount &gt; s.nelems&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>nextFreeIndex (find freeindex)</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *mspan)</span> <span class="title">nextFreeIndex</span><span class="params">()</span> <span class="title">uintptr</span></span> &#123;</span><br><span class="line">    <span class="comment">// 当前空闲块的位置</span></span><br><span class="line">    sfreeindex := s.freeindex</span><br><span class="line">    snelems := s.nelems</span><br><span class="line">    <span class="comment">// 如果是该 mspan 中最后一个内存块，则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> sfreeindex == snelems &#123;</span><br><span class="line">        <span class="keyword">return</span> sfreeindex</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> sfreeindex &gt; snelems &#123;				</span><br><span class="line">        throw(<span class="string">&quot;s.freeindex &gt; s.nelems&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    aCache := s.allocCache</span><br><span class="line"></span><br><span class="line">    bitIndex := sys.Ctz64(aCache)</span><br><span class="line">    <span class="keyword">for</span> bitIndex == <span class="number">64</span> &#123;</span><br><span class="line">        <span class="comment">// Move index to start of next cached bits.</span></span><br><span class="line">        sfreeindex = (sfreeindex + <span class="number">64</span>) &amp;^ (<span class="number">64</span> - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> sfreeindex &gt;= snelems &#123;</span><br><span class="line">            s.freeindex = snelems</span><br><span class="line">            <span class="keyword">return</span> snelems</span><br><span class="line">        &#125;</span><br><span class="line">        whichByte := sfreeindex / <span class="number">8</span></span><br><span class="line">        <span class="comment">// Refill s.allocCache with the next 64 alloc bits.</span></span><br><span class="line">        s.refillAllocCache(whichByte)</span><br><span class="line">        aCache = s.allocCache</span><br><span class="line">        bitIndex = sys.Ctz64(aCache)</span><br><span class="line">        <span class="comment">// nothing available in cached bits</span></span><br><span class="line">        <span class="comment">// grab the next 8 bytes and try again.</span></span><br><span class="line">    &#125;</span><br><span class="line">    result := sfreeindex + <span class="keyword">uintptr</span>(bitIndex)</span><br><span class="line">    <span class="keyword">if</span> result &gt;= snelems &#123;</span><br><span class="line">        s.freeindex = snelems</span><br><span class="line">        <span class="keyword">return</span> snelems</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s.allocCache &gt;&gt;= <span class="keyword">uint</span>(bitIndex + <span class="number">1</span>)</span><br><span class="line">    sfreeindex = result + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> sfreeindex%<span class="number">64</span> == <span class="number">0</span> &amp;&amp; sfreeindex != snelems &#123;</span><br><span class="line">        <span class="comment">// We just incremented s.freeindex so it isn&#x27;t 0.</span></span><br><span class="line">        <span class="comment">// As each 1 in s.allocCache was encountered and used for allocation</span></span><br><span class="line">        <span class="comment">// it was shifted away. At this point s.allocCache contains all 0s.</span></span><br><span class="line">        <span class="comment">// Refill s.allocCache so that it corresponds</span></span><br><span class="line">        <span class="comment">// to the bits at s.allocBits starting at s.freeindex.</span></span><br><span class="line">        whichByte := sfreeindex / <span class="number">8</span></span><br><span class="line">        s.refillAllocCache(whichByte)</span><br><span class="line">    &#125;</span><br><span class="line">    s.freeindex = sfreeindex</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>查看上述源码得知，负责重新分配 allocCache 的是 <code>refilllAllocCache()</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *mspan)</span> <span class="title">refillAllocCache</span><span class="params">(whichByte <span class="keyword">uintptr</span>)</span></span> &#123;</span><br><span class="line">    bytes := (*[<span class="number">8</span>]<span class="keyword">uint8</span>)(unsafe.Pointer(s.allocBits.bytep(whichByte)))</span><br><span class="line">    aCache := <span class="keyword">uint64</span>(<span class="number">0</span>)</span><br><span class="line">    aCache |= <span class="keyword">uint64</span>(bytes[<span class="number">0</span>])</span><br><span class="line">    aCache |= <span class="keyword">uint64</span>(bytes[<span class="number">1</span>]) &lt;&lt; (<span class="number">1</span> * <span class="number">8</span>)</span><br><span class="line">    aCache |= <span class="keyword">uint64</span>(bytes[<span class="number">2</span>]) &lt;&lt; (<span class="number">2</span> * <span class="number">8</span>)</span><br><span class="line">    aCache |= <span class="keyword">uint64</span>(bytes[<span class="number">3</span>]) &lt;&lt; (<span class="number">3</span> * <span class="number">8</span>)</span><br><span class="line">    aCache |= <span class="keyword">uint64</span>(bytes[<span class="number">4</span>]) &lt;&lt; (<span class="number">4</span> * <span class="number">8</span>)</span><br><span class="line">    aCache |= <span class="keyword">uint64</span>(bytes[<span class="number">5</span>]) &lt;&lt; (<span class="number">5</span> * <span class="number">8</span>)</span><br><span class="line">    aCache |= <span class="keyword">uint64</span>(bytes[<span class="number">6</span>]) &lt;&lt; (<span class="number">6</span> * <span class="number">8</span>)</span><br><span class="line">    aCache |= <span class="keyword">uint64</span>(bytes[<span class="number">7</span>]) &lt;&lt; (<span class="number">7</span> * <span class="number">8</span>)</span><br><span class="line">    s.allocCache = ^aCache</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从 allocBits 中获取对应的内存块使用信息，最后以补码的方式保存到 allocCache 中，方便 Ctz 函数的使用。</p>
<p>然后这里我观察了一下 allocBits 它是一个 <code>*gcBits</code> 类型，底层实际上是一个 uint8 的别名，这里最初也挺让我好奇的，一个 uint8 类型就 8 个 bit 是怎么标记 mspan 中那么多对象的。</p>
<p>然后又一头扎进源码中，发现这是一个指向 allocBits 的指针，实际 allocBits 大小是根据 nelems 计算得出的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// allocBit 的初始化函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newMarkBits</span><span class="params">(nelems <span class="keyword">uintptr</span>)</span> *<span class="title">gcBits</span></span> &#123;</span><br><span class="line">    <span class="comment">// 以 64 为步长，计算表达 nelemes 个对象需要多少块</span></span><br><span class="line">    blocksNeeded := <span class="keyword">uintptr</span>((nelems + <span class="number">63</span>) / <span class="number">64</span>)</span><br><span class="line">    bytesNeeded := blocksNeeded * <span class="number">8</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Try directly allocating from the current head arena.</span></span><br><span class="line">    head := (*gcBitsArena)(atomic.Loadp(unsafe.Pointer(&amp;gcBitsArenas.next)))</span><br><span class="line">    <span class="keyword">if</span> p := head.tryAlloc(bytesNeeded); p != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> p</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// There&#x27;s not enough room in the head arena. We may need to</span></span><br><span class="line">    <span class="comment">// allocate a new arena.</span></span><br><span class="line">    lock(&amp;gcBitsArenas.lock)</span><br><span class="line">    <span class="comment">// Try the head arena again, since it may have changed. Now</span></span><br><span class="line">    <span class="comment">// that we hold the lock, the list head can&#x27;t change, but its</span></span><br><span class="line">    <span class="comment">// free position still can.</span></span><br><span class="line">    <span class="keyword">if</span> p := gcBitsArenas.next.tryAlloc(bytesNeeded); p != <span class="literal">nil</span> &#123;</span><br><span class="line">        unlock(&amp;gcBitsArenas.lock)</span><br><span class="line">        <span class="keyword">return</span> p</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allocate a new arena. This may temporarily drop the lock.</span></span><br><span class="line">    fresh := newArenaMayUnlock()</span><br><span class="line">    <span class="comment">// If newArenaMayUnlock dropped the lock, another thread may</span></span><br><span class="line">    <span class="comment">// have put a fresh arena on the &quot;next&quot; list. Try allocating</span></span><br><span class="line">    <span class="comment">// from next again.</span></span><br><span class="line">    <span class="keyword">if</span> p := gcBitsArenas.next.tryAlloc(bytesNeeded); p != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// Put fresh back on the free list.</span></span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Mark it &quot;already zeroed&quot;</span></span><br><span class="line">        fresh.next = gcBitsArenas.free</span><br><span class="line">        gcBitsArenas.free = fresh</span><br><span class="line">        unlock(&amp;gcBitsArenas.lock)</span><br><span class="line">        <span class="keyword">return</span> p</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allocate from the fresh arena. We haven&#x27;t linked it in yet, so</span></span><br><span class="line">    <span class="comment">// this cannot race and is guaranteed to succeed.</span></span><br><span class="line">    p := fresh.tryAlloc(bytesNeeded)</span><br><span class="line">    <span class="keyword">if</span> p == <span class="literal">nil</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;markBits overflow&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add the fresh arena to the &quot;next&quot; list.</span></span><br><span class="line">    fresh.next = gcBitsArenas.next</span><br><span class="line">    atomic.StorepNoWB(unsafe.Pointer(&amp;gcBitsArenas.next), unsafe.Pointer(fresh))</span><br><span class="line"></span><br><span class="line">    unlock(&amp;gcBitsArenas.lock)</span><br><span class="line">    <span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p><code>(nelems + 63) / 64</code> 涉及到一个向上取整的通用算法，感兴趣可以自行  Google</p>
</blockquote>
<p><code>gcBitsArenas</code> 是用来管理这些 Bitmap 的数据结构：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//go:notinheap</span></span><br><span class="line"><span class="keyword">type</span> gcBitsArena <span class="keyword">struct</span> &#123;</span><br><span class="line">    free <span class="keyword">uintptr</span> <span class="comment">// free is the index into bits of the next free byte; read/write atomically</span></span><br><span class="line">    next *gcBitsArena</span><br><span class="line">    bits [gcBitsChunkBytes - gcBitsHeaderBytes]gcBits</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gcBitsArenas <span class="keyword">struct</span> &#123;</span><br><span class="line">    lock     mutex</span><br><span class="line">    free     *gcBitsArena</span><br><span class="line">    next     *gcBitsArena <span class="comment">// Read atomically. Write atomically under lock.</span></span><br><span class="line">    current  *gcBitsArena</span><br><span class="line">    previous *gcBitsArena</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>allocBit 的初始化过程还是比较简单的，这里不再赘述，我们继续回到 <code>allocCache</code>  的替换上，即 <code>refillAllocCache</code> 函数。理解这个函数最关键的一点在于如何理解他的参数 whichByte。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当 sfreeindex % 64 == 0 时，才会执行这个计算</span></span><br><span class="line"><span class="comment">// 所以 whichByte 肯定总是 8 的倍数</span></span><br><span class="line"><span class="comment">// 用来定位 freeindex 在 allocBits 哪个位置</span></span><br><span class="line"><span class="comment">// 相对于 allocBit 开始位置的偏移量，最初偏移量为 0 然后依次偏移 8 的整数倍，8， 16，24..</span></span><br><span class="line"><span class="comment">// 便宜的是字节数，如果换算成 bit 是 8*8，16*8， 24*8</span></span><br><span class="line">whichByte := sfreeindex / <span class="number">8</span></span><br></pre></td></tr></table></figure>

<p>然后将这个偏移量加到 <code>s.allocBits.bytep(whichByte)</code> 就获取到了下一个 8字节的起始地址。再依次获取这8字节中的每个字节表示的内存块的占用信息，以补码的形式保存在 allocCache 中即可。</p>
<p>至此，<code>tiny allocator</code> 涉及到的内容就结束了。<code>small allocator</code> 查找内存块的过程同 tiny allocator 类似，这里就不再继续展开。</p>
<p>额外提一点，你应该能够发现当我们通过 <code>fastPaht</code> 或 <code>nextFree</code> 找到 tiny 内存块的起始地址后，将这个指针转换成了 <code>*[2]uint64</code>，然后执行了两个赋值操作：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">(*[<span class="number">2</span>]<span class="keyword">uint64</span>)(x)[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">(*[<span class="number">2</span>]<span class="keyword">uint64</span>)(x)[<span class="number">1</span>] = <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>这是在干什么？内存清零。tiny allocator 中，每个内存块都是 16 字节，两个 uint64 真好对应 16字节，然后将其中存储的内容置为0。</p>
<p>拓展：</p>
<p>德布鲁因序列 （Ctz 的实现原理）</p>
<p><a target="_blank" rel="noopener" href="http://supertech.csail.mit.edu/papers/debruijn.pdf">http://supertech.csail.mit.edu/papers/debruijn.pdf</a></p>
<p><a target="_blank" rel="noopener" href="https://halfrost.com/go_s2_de_bruijn/#toc-0">https://halfrost.com/go_s2_de_bruijn/#toc-0</a></p>
</div><div id="donate"><link rel="stylesheet" type="text/css" href="/css/donate.css?v=1.0.0"><script type="text/javascript" src="/js/donate.js?v=1.0.0" successtext="复制成功!"></script><a class="pos-f tr3" id="github" href="https://github.com/clamyang" target="_blank" title="Github"></a><div id="DonateText">Donate</div><ul class="list pos-f" id="donateBox"><li id="AliPay" qr="/img/AliPayQR.jpg"></li><li id="WeChat" qr="/img/WeChatQR.jpg"></li></ul><div class="pos-f left-100" id="QRBox"><div id="MainBox"></div></div></div><div class="post-copyright"><script type="text/javascript" src="/js/copyright.js?v=1.0.0" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copyright.css?v=1.0.0"><p><span>本文标题：</span>Go 内存分配器</p><p><span>文章作者：</span>bqyang</p><p><span>发布时间：</span>2022-07-22</p><p><span>最后更新：</span>2022-07-25</p><p><span>原始链接：</span><a href="/2022/language/golang/memory-alloc/">https://bqyang.top/2022/language/golang/memory-alloc/</a><span class="copy-path"><i class="fa fa-clipboard" data-clipboard-text="https://bqyang.top/2022/language/golang/memory-alloc/"></i></span></p><p><span>版权声明：</span>The author owns the copyright, please indicate the source reproduced.</p></div><br><div class="tags"></div><div class="post-nav"><a class="next" href="/2022/os/memory/free-space-manage/">free space management</a></div><script src="https://utteranc.es/client.js" repo="clamyang/blogs" issue-term="title" theme="github-light" crossorigin="anonymous" async> </script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://bqyang.top"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2022/language/golang/memory-alloc/">Go 内存分配器</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/os/memory/free-space-manage/">free space management</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/k8s/k8s-storage-source-code/">k8s pv pvc 源码</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/design-pattern/Structural/composite/">组合模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/os/pstree/">简易版 pstree</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/k8s/k8s-storage/">k8s 存储内容</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/design-pattern/Structural/facade/">门面模式（外观模式）</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/os/memory-api/">内存相关 API</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/language/golang/100-go-mistaks/2-misuse-init/">misuse init func</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/language/golang/go-params-to-goroutine/">参数是怎么传给 goroutine 的</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.xargin.com/" title="Xargin" target="_blank">Xargin</a><ul></ul><a href="https://mytechshares.com/" title="董泽润的技术笔记" target="_blank">董泽润的技术笔记</a><ul></ul><a href="https://hujingnb.com/" title="烟草的香味" target="_blank">烟草的香味</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2022 <a href="/." rel="nofollow">杨宝强的技术笔记.</a>Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://beian.miit.gov.cn/"> 京ICP备2021035561号.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>